Problem Name,Problem Description,Solution
01 Matrix,###  542\. 01 Matrix\n\nGiven an `m x n` binary matrix `mat` return _the distance of the nearest_`0`\n_for each cell_.\n\nThe distance between two adjacent cells is `1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/01-1-grid.jpg)\n\n    \n    \n    **Input:** mat = [[000][010][000]]\n    **Output:** [[000][010][000]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/01-2-grid.jpg)\n\n    \n    \n    **Input:** mat = [[000][010][111]]\n    **Output:** [[000][010][121]]\n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat[i].length`\n  * `1 <= m n <= 104`\n  * `1 <= m * n <= 104`\n  * `mat[i][j]` is either `0` or `1`.\n  * There is at least one `0` in `mat`.\n\n,// Runtime: 534 ms (Top 69.67%) | Memory: 19.20 MB (Top 71.26%)\n\nclass Solution:\n    def updateMatrix(self mat: List[List[int]]) -> List[List[int]]:\n        if not mat or not mat[0]:\n            return []\n\n        m n = len(mat) len(mat[0])\n        queue = deque()\n        MAX_VALUE = m * n\n        \n        # Initialize the queue with all 0s and set cells with 1s to MAX_VALUE.\n        for i in range(m):\n            for j in range(n):\n                if mat[i][j] == 0:\n                    queue.append((i j))\n                else:\n                    mat[i][j] = MAX_VALUE\n        \n        directions = [(1 0) (-1 0) (0 1) (0 -1)]\n        \n        while queue:\n            row col = queue.popleft()\n            for dr dc in directions:\n                r c = row + dr col + dc\n                if 0 <= r < m and 0 <= c < n and mat[r][c] > mat[row][col] + 1:\n                    queue.append((r c))\n                    mat[r][c] = mat[row][col] + 1\n        \n        return mat\n
1-bit and 2-bit Characters,###  717\. 1-bit and 2-bit Characters\n\nWe have two special characters:\n\n  * The first character can be represented by one bit `0`.\n  * The second character can be represented by two bits (`10` or `11`).\n\nGiven a binary array `bits` that ends with `0` return `true` if the last\ncharacter must be a one-bit character.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** bits = [100]\n    **Output:** true\n    **Explanation:** The only way to decode it is two-bit character and one-bit character.\n    So the last character is one-bit character.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** bits = [1110]\n    **Output:** false\n    **Explanation:** The only way to decode it is two-bit character and two-bit character.\n    So the last character is not one-bit character.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= bits.length <= 1000`\n  * `bits[i]` is either `0` or `1`.\n\n,"# Dev: Chumicat\n# Date: 2019/11/30\n# Submission: https://leetcode.com/submissions/detail/282638543/\n# (Time Space) Complexity : O(n) O(1)\n\nclass Solution:\n    def isOneBitCharacter(self bits: List[int]) -> bool:\n        """"""\n        :type bits: List[int]\n        :rtype: bool\n        """"""\n        # Important Rules:\n        # 1. If bit n is 0 bit n+1 must be a new char\n        # 2. If bits end with 1 last bit must be a two bit char\n        #    However this case had been rejected by question\n        # 3. If 1s in row and end with 0 \n        #    we can use count or 1s to check last char\n        #    If count is even last char is ""0""\n        #    If count is odd  last char is ""10""\n        # Strategy:\n        # 1. We don't care last element since it must be 0.\n        # 2. We check from reversed and count 1s in a row\n        # 3. Once 0 occur or list end We stop counting\n        # 4. We use count to determin result\n        # 5. Since we will mod count by 2 we simplify it to bool\n        ret = True\n        for bit in bits[-2::-1]:\n            if bit: ret = not ret\n            else: break\n        return ret\n"
132 Pattern,###  456\. 132 Pattern\n\nGiven an array of `n` integers `nums` a **132 pattern** is a subsequence of\nthree integers `nums[i]` `nums[j]` and `nums[k]` such that `i < j < k` and\n`nums[i] < nums[k] < nums[j]`.\n\nReturn `true` _if there is a**132 pattern** in _`nums` _ otherwise\nreturn_`false` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** false\n    **Explanation:** There is no 132 pattern in the sequence.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [3142]\n    **Output:** true\n    **Explanation:** There is a 132 pattern in the sequence: [1 4 2].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [-1320]\n    **Output:** true\n    **Explanation:** There are three 132 patterns in the sequence: [-1 3 2] [-1 3 0] and [-1 2 0].\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 2 * 105`\n  * `-109 <= nums[i] <= 109`\n\n,// Runtime: 476 ms (Top 99.36%) | Memory: 36.40 MB (Top 85.77%)\n\nclass Solution:\n    def find132pattern(self nums: List[int]) -> bool:\n        stack third = [] float('-inf')\n        \n        for num in reversed(nums):\n            if num < third:\n                return True\n            while stack and stack[-1] < num:\n                third = stack.pop()\n            stack.append(num)\n        return False\n
2 Keys Keyboard,###  650\. 2 Keys Keyboard\n\nThere is only one character `'A'` on the screen of a notepad. You can perform\none of two operations on this notepad for each step:\n\n  * Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).\n  * Paste: You can paste the characters which are copied last time.\n\nGiven an integer `n` return _the minimum number of operations to get the\ncharacter_ `'A'` _exactly_ `n` _times on the screen_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** 3\n    **Explanation:** Initially we have one character 'A'.\n    In step 1 we use Copy All operation.\n    In step 2 we use Paste operation to get 'AA'.\n    In step 3 we use Paste operation to get 'AAA'.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n\n,class Solution:\n    def minSteps(self n: int) -> int:      \n        # at every step we can copy or paste\n        # paste -> we need to know the current clipboard content (count)\n        # copy -> set clipboard count to current screen count (we should consider it if the last operation was paste)\n        \n        memo = {}\n        \n        def dfs(clipboard_count screen_count):\n            if (clipboard_count screen_count) in memo:                   \n                return memo[(clipboard_count screen_count)]\n            \n            # we reached n this is a valid option\n            if screen_count == n: return 0\n            \n            # we passed n not a valid option\n            if screen_count > n: return float('inf')                \n            \n            # paste or copy\n            copy_opt = paste_opt = float('inf')\n            \n            # we should only paste if clipboard is not empty\n            if clipboard_count > 0:\n                paste_opt = dfs(clipboard_count screen_count + clipboard_count)             \n            \n            # we should consider copy only if the last operation was paste\n            if screen_count > clipboard_count:\n                copy_opt = dfs(screen_count screen_count) \n            \n            # save to memo\n            memo[(clipboard_count screen_count)] = 1 + min(paste_opt copy_opt)            \n            return memo[(clipboard_count screen_count)]\n            \n        return dfs(0 1)\n            \n
24 Game,"###  679\. 24 Game\n\nYou are given an integer array `cards` of length `4`. You have four cards\neach containing a number in the range `[1 9]`. You should arrange the numbers\non these cards in a mathematical expression using the operators `['+' '-'\n'*' '/']` and the parentheses `'('` and `')'` to get the value 24.\n\nYou are restricted with the following rules:\n\n  * The division operator `'/'` represents real division not integer division. \n    * For example `4 / (1 - 2 / 3) = 4 / (1 / 3) = 12`.\n  * Every operation done is between two numbers. In particular we cannot use `'-'` as a unary operator. \n    * For example if `cards = [1 1 1 1]` the expression `""-1 - 1 - 1 - 1""` is **not allowed**.\n  * You cannot concatenate numbers together \n    * For example if `cards = [1 2 1 2]` the expression `""12 + 12""` is not valid.\n\nReturn `true` if you can get such expression that evaluates to `24` and\n`false` otherwise.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** cards = [4187]\n    **Output:** true\n    **Explanation:** (8-4) * (7-1) = 24\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cards = [1212]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `cards.length == 4`\n  * `1 <= cards[i] <= 9`\n\n",class Solution:\n    def judgePoint24(self cards: List[int]) -> bool:\n        return self.allComputeWays(cards 4 24)\n        \n    def allComputeWays(self nums l target):\n        if l == 1:\n            if abs(nums[0] - target) <= 1e-6:\n                return True\n            return False\n        for first in range(l):\n            for second in range(first + 1 l):\n                tmp1 tmp2 = nums[first] nums[second]\n                nums[second] = nums[l - 1]\n                \n                nums[first] = tmp1 + tmp2\n                if self.allComputeWays(nums l - 1 target):\n                    return True\n                nums[first] = tmp1 - tmp2\n                if self.allComputeWays(nums l - 1 target):\n                    return True\n                nums[first] = tmp2 - tmp1\n                if self.allComputeWays(nums l - 1 target):\n                    return True\n                nums[first] = tmp1 * tmp2\n                if self.allComputeWays(nums l - 1 target):\n                    return True\n                if tmp2:\n                    nums[first] = tmp1 / tmp2\n                    if self.allComputeWays(nums l - 1 target):\n                        return True\n                if tmp1:\n                    nums[first] = tmp2 / tmp1\n                    if self.allComputeWays(nums l - 1 target):\n                        return True\n                nums[first] nums[second] = tmp1 tmp2\n        return False
3Sum,###  15\. 3Sum\n\nGiven an integer array nums return all the triplets `[nums[i] nums[j]\nnums[k]]` such that `i != j` `i != k` and `j != k` and `nums[i] + nums[j] +\nnums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [-1012-1-4]\n    **Output:** [[-1-12][-101]]\n    **Explanation:** \n    nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\n    nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\n    nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\n    The distinct triplets are [-101] and [-1-12].\n    Notice that the order of the output and the order of the triplets does not matter.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [011]\n    **Output:** []\n    **Explanation:** The only possible triplet does not sum up to 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [000]\n    **Output:** [[000]]\n    **Explanation:** The only possible triplet sums up to 0.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= nums.length <= 3000`\n  * `-105 <= nums[i] <= 105`\n\n,"class Solution(object):\n    def threeSum(self nums):\n        ans = []\n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] > 0: break  # after sorting if the min > 0 we couldn't find such three values\n            if i > 0 and nums[i] == nums[i - 1]:  # ensure that nums[i] is not duplicated\n                continue               \n            l r = i + 1 len(nums) - 1\n            while l < r:\n                if nums[l] + nums[r] > -nums[i]:\n                    r -= 1\n                elif nums[l] + nums[r] < -nums[i]:\n                    l += 1\n                else:\n                    ans.append([nums[i] nums[l] nums[r]])\n					# update l to get a different sum\n                    l += 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n        return ans\n"
3Sum Closest,###  16\. 3Sum Closest\n\nGiven an integer array `nums` of length `n` and an integer `target` find\nthree integers in `nums` such that the sum is closest to `target`.\n\nReturn _the sum of the three integers_.\n\nYou may assume that each input would have exactly one solution.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [-121-4] target = 1\n    **Output:** 2\n    **Explanation:** The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [000] target = 1\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `3 <= nums.length <= 1000`\n  * `-1000 <= nums[i] <= 1000`\n  * `-104 <= target <= 104`\n\n,# Runtime: 1535 ms (Top 7.9%) | Memory: 16.58 MB (Top 11.9%)\n\nclass Solution:\n    def threeSumClosest(self nums: List[int] target: int) -> int:\n        closet = float('inf')\n        nums.sort()\n        for i in range(len(nums) - 2):\n            l r = i + 1 len(nums) - 1\n            while l < r:\n                sum3 = nums[i] + nums[l] + nums[r]\n                print(sum3)\n                if sum3 < target:\n                    l += 1\n                else:\n                    r -=1\n                if abs(sum3 - target) < abs(closet - target):\n                    closet = sum3\n        return closet\n                
3Sum With Multiplicity,###  923\. 3Sum With Multiplicity\n\nGiven an integer array `arr` and an integer `target` return the number of\ntuples `i j k` such that `i < j < k` and `arr[i] + arr[j] + arr[k] ==\ntarget`.\n\nAs the answer can be very large return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [1122334455] target = 8\n    **Output:** 20\n    **Explanation:**\n    Enumerating by the values (arr[i] arr[j] arr[k]):\n    (1 2 5) occurs 8 times;\n    (1 3 4) occurs 8 times;\n    (2 2 4) occurs 2 times;\n    (2 3 3) occurs 2 times.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [112222] target = 5\n    **Output:** 12\n    **Explanation:**\n    arr[i] = 1 arr[j] = arr[k] = 2 occurs 12 times:\n    We choose one 1 from [11] in 2 ways\n    and two 2s from [2222] in 6 ways.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [213] target = 6\n    **Output:** 1\n    **Explanation:** (1 2 3) occured one time in the array so we return 1.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= arr.length <= 3000`\n  * `0 <= arr[i] <= 100`\n  * `0 <= target <= 300`\n\n,class Solution:\n    def threeSumMulti(self arr: List[int] target: int) -> int:\n        arr.sort()\n        count = 0\n        for i in range(0 len(arr)-2):\n            rem_sum = target - arr[i]\n            hash_map = {}\n            for j in range(i+1 len(arr)):\n                if arr[j] > rem_sum:\n                    break\n                if rem_sum - arr[j] in hash_map:\n                    count = count + hash_map[rem_sum-arr[j]]\n                # update the hash_map\n                hash_map[arr[j]] = hash_map.get(arr[j] 0) + 1\n        return count % 1000000007\n
4Sum,###  18\. 4Sum\n\nGiven an array `nums` of `n` integers return _an array of all the**unique**\nquadruplets_ `[nums[a] nums[b] nums[c] nums[d]]` such that:\n\n  * `0 <= a b c d < n`\n  * `a` `b` `c` and `d` are **distinct**.\n  * `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\nYou may return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [10-10-22] target = 0\n    **Output:** [[-2-112][-2002][-1001]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [22222] target = 8\n    **Output:** [[2222]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 200`\n  * `-109 <= nums[i] <= 109`\n  * `-109 <= target <= 109`\n\n,class Solution:\n    def fourSum(self nums: List[int] target: int) -> List[List[int]]:\n        \n        if len(nums) < 4: return []\n        \n        nums.sort()\n        res = []\n        \n        for i in range(len(nums)):\n            for j in range(i + 1 len(nums)):\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n\n                    sum_ = nums[i]+nums[j]+nums[l]+nums[r]\n                    a = [nums[i] nums[j] nums[l] nums[r]]\n                \n                    if sum_ == target and a not in res:\n                        res.append(a)\n                  \n                    if sum_ > target:\n                        r -= 1\n                    \n                    else:\n                        l += 1\n                        while l < r and nums[l-1] == nums[l]:\n                            l += 1\n                  \n        return res\n        \n        # An Upvote will be encouraging\n                    \n        \n
4Sum II,###  454\. 4Sum II\n\nGiven four integer arrays `nums1` `nums2` `nums3` and `nums4` all of length\n`n` return the number of tuples `(i j k l)` such that:\n\n  * `0 <= i j k l < n`\n  * `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [12] nums2 = [-2-1] nums3 = [-12] nums4 = [02]\n    **Output:** 2\n    **Explanation:**\n    The two tuples are:\n    1. (0 0 0 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n    2. (1 1 0 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [0] nums2 = [0] nums3 = [0] nums4 = [0]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `n == nums1.length`\n  * `n == nums2.length`\n  * `n == nums3.length`\n  * `n == nums4.length`\n  * `1 <= n <= 200`\n  * `-228 <= nums1[i] nums2[i] nums3[i] nums4[i] <= 228`\n\n,# Runtime: 1360 ms (Top 29.95%) | Memory: 14.2 MB (Top 70.39%)\nclass Solution:\n    def fourSumCount(self nums1: List[int] nums2: List[int] nums3: List[int] nums4: List[int]) -> int:\n        n1n2 = defaultdict(int)\n        for n1 in nums1:\n            for n2 in nums2:\n                n1n2[n1+n2] += 1\n        n3n4 = defaultdict(int)\n        for n3 in nums3:\n            for n4 in nums4:\n                n3n4[n3+n4] += 1\n        ans = 0\n        for s in n1n2:\n            ans += n1n2[s] * n3n4[-s]\n        return ans
A Number After a Double Reversal,###  2119\. A Number After a Double Reversal\n\n**Reversing** an integer means to reverse all its digits.\n\n  * For example reversing `2021` gives `1202`. Reversing `12300` gives `321` as the **leading zeros are not retained**.\n\nGiven an integer `num` **reverse** `num` to get `reversed1` **then reverse**\n`reversed1` to get `reversed2`. Return `true` _if_ `reversed2` _equals_ `num`.\nOtherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 526\n    **Output:** true\n    **Explanation:** Reverse num to get 625 then reverse 625 to get 526 which equals num.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 1800\n    **Output:** false\n    **Explanation:** Reverse num to get 81 then reverse 81 to get 18 which does not equal num.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = 0\n    **Output:** true\n    **Explanation:** Reverse num to get 0 then reverse 0 to get 0 which equals num.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= num <= 106`\n\n,"class Solution(object):\n    def isSameAfterReversals(self num):\n		# All you have to do is check the Trailing zeros\n        return num == 0 or num % 10  # num % 10 means num % 10 != 0\n"
Abbreviating the Product of a Range,"###  2117\. Abbreviating the Product of a Range\n\nYou are given two positive integers `left` and `right` with `left <= right`.\nCalculate the **product** of all integers in the **inclusive** range `[left\nright]`.\n\nSince the product may be very large you will **abbreviate** it following\nthese steps:\n\n  1. Count all **trailing** zeros in the product and **remove** them. Let us denote this count as `C`. \n     * For example there are `3` trailing zeros in `1000` and there are `0` trailing zeros in `546`.\n  2. Denote the remaining number of digits in the product as `d`. If `d > 10` then express the product as `<pre>...<suf>` where `<pre>` denotes the **first** `5` digits of the product and `<suf>` denotes the **last** `5` digits of the product **after** removing all trailing zeros. If `d <= 10` we keep it unchanged. \n     * For example we express `1234567654321` as `12345...54321` but `1234567` is represented as `1234567`.\n  3. Finally represent the product as a **string** `""<pre>...<suf>eC""`. \n     * For example `12345678987600000` will be represented as `""12345...89876e5""`.\n\nReturn _a string denoting the**abbreviated product** of all integers in the\n**inclusive** range_ `[left right]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** left = 1 right = 4\n    **Output:** ""24e0""\n    **Explanation:** The product is 1 × 2 × 3 × 4 = 24.\n    There are no trailing zeros so 24 remains the same. The abbreviation will end with ""e0"".\n    Since the number of digits is 2 which is less than 10 we do not have to abbreviate it further.\n    Thus the final representation is ""24e0"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** left = 2 right = 11\n    **Output:** ""399168e2""\n    **Explanation:** The product is 39916800.\n    There are 2 trailing zeros which we remove to get 399168. The abbreviation will end with ""e2"".\n    The number of digits after removing the trailing zeros is 6 so we do not abbreviate it further.\n    Hence the abbreviated product is ""399168e2"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** left = 371 right = 375\n    **Output:** ""7219856259e3""\n    **Explanation:** The product is 7219856259000.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= left <= right <= 104`\n\n",class Solution:\n    def abbreviateProduct(self left: int right: int) -> str:\n        c2 = c5 = 0\n        top12 = tail5 = 1\n\n        for i in range(left right+1):\n            # count and remove all 2 and 5\n            while i % 2 == 0:\n                i //= 2\n                c2 += 1\n            while i % 5 == 0:\n                i //= 5\n                c5 += 1\n\n            # track top 12 and last 5\n            top12 = int(str(top12 * i)[:12])\n            tail5 = tail5 * i % 100000\n        \n        # multiply the remained 2 or 5\n        if c2 > c5:\n            for _ in range(c2 - c5):\n                top12 = int(str(top12 * 2)[:12])\n                tail5 = tail5 * 2 % 100000\n        elif c2 < c5:\n            for _ in range(c5 - c2):\n                top12 = int(str(top12 * 5)[:12])\n                tail5 = tail5 * 5 % 100000\n\n        zero = min(c2 c5)\n\n        # as is included in top 12 it's easy to tell when d<=10\n        if len(str(top12))<=10:\n            return str(top12)+'e'+str(zero)\n        \n        return str(top12)[:5] + '.'*3 + '0'*(5-len(str(tail5)))+str(tail5)+'e'+str(zero)\n
Accounts Merge,"###  721\. Accounts Merge\n\nGiven a list of `accounts` where each element `accounts[i]` is a list of\nstrings where the first element `accounts[i][0]` is a name and the rest of\nthe elements are **emails** representing emails of the account.\n\nNow we would like to merge these accounts. Two accounts definitely belong to\nthe same person if there is some common email to both accounts. Note that even\nif two accounts have the same name they may belong to different people as\npeople could have the same name. A person can have any number of accounts\ninitially but all of their accounts definitely have the same name.\n\nAfter merging the accounts return the accounts in the following format: the\nfirst element of each account is the name and the rest of the elements are\nemails **in sorted order**. The accounts themselves can be returned in **any\norder**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** accounts = [[""John""""johnsmith@mail.com""""john_newyork@mail.com""][""John""""johnsmith@mail.com""""john00@mail.com""][""Mary""""mary@mail.com""][""John""""johnnybravo@mail.com""]]\n    **Output:** [[""John""""john00@mail.com""""john_newyork@mail.com""""johnsmith@mail.com""][""Mary""""mary@mail.com""][""John""""johnnybravo@mail.com""]]\n    **Explanation:**\n    The first and second John's are the same person as they have the common email ""johnsmith@mail.com"".\n    The third John and Mary are different people as none of their email addresses are used by other accounts.\n    We could return these lists in any order for example the answer [['Mary' 'mary@mail.com'] ['John' 'johnnybravo@mail.com'] \n    ['John' 'john00@mail.com' 'john_newyork@mail.com' 'johnsmith@mail.com']] would still be accepted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** accounts = [[""Gabe""""Gabe0@m.co""""Gabe3@m.co""""Gabe1@m.co""][""Kevin""""Kevin3@m.co""""Kevin5@m.co""""Kevin0@m.co""][""Ethan""""Ethan5@m.co""""Ethan4@m.co""""Ethan0@m.co""][""Hanzo""""Hanzo3@m.co""""Hanzo1@m.co""""Hanzo0@m.co""][""Fern""""Fern5@m.co""""Fern1@m.co""""Fern0@m.co""]]\n    **Output:** [[""Ethan""""Ethan0@m.co""""Ethan4@m.co""""Ethan5@m.co""][""Gabe""""Gabe0@m.co""""Gabe1@m.co""""Gabe3@m.co""][""Hanzo""""Hanzo0@m.co""""Hanzo1@m.co""""Hanzo3@m.co""][""Kevin""""Kevin0@m.co""""Kevin3@m.co""""Kevin5@m.co""][""Fern""""Fern0@m.co""""Fern1@m.co""""Fern5@m.co""]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= accounts.length <= 1000`\n  * `2 <= accounts[i].length <= 10`\n  * `1 <= accounts[i][j].length <= 30`\n  * `accounts[i][0]` consists of English letters.\n  * `accounts[i][j] (for j > 0)` is a valid email.\n\n",class Solution:\n    def accountsMerge(self accounts: List[List[str]]) -> List[List[str]]:\n        def merge(accounts):\n            res = []\n            ls = []\n            for i in range(len(accounts)):\n                temp = list(set(accounts[i][1:]))\n                temp.sort()\n                temp = [accounts[i][0]] + temp\n                if i in ls:\n                    continue\n                for j in range(len(accounts[i:])):\n                    s = i+j\n                    if i == s:\n                        continue\n                    if accounts[i][0] != accounts[s][0]:\n                        continue\n                    temp3 = list(set(accounts[s][1:]))\n                    uni = list(set(temp[1:]) | set(temp3))\n                    if len(uni) < len(temp[1:]) + len(temp3):\n                        temp1 = list(set(temp[1:]) | set(temp3))\n                        temp = [temp[0]] + temp1 \n                        ls.append(s)\n                temp0 = temp[1:]\n                temp0.sort()\n                temp = [temp[0]]+temp0\n                res.append(temp)\n            return res\n        merged = merge(accounts)\n        while merge(merged) != merged:\n            merged = merge(merged)\n\n        return merged\n
Add Binary,"###  67\. Add Binary\n\nGiven two binary strings `a` and `b` return _their sum as a binary string_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** a = ""11"" b = ""1""\n    **Output:** ""100""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** a = ""1010"" b = ""1011""\n    **Output:** ""10101""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= a.length b.length <= 104`\n  * `a` and `b` consist only of `'0'` or `'1'` characters.\n  * Each string does not contain leading zeros except for the zero itself.\n\n","class Solution(object):\n    def addBinary(self a b):\n        """"""\n        :type a: str\n        :type b: str\n        :rtype: str\n        """"""\n\n        return str(bin(int(a base = 2)+int(b base = 2)))[2:]\n"
Add Digits,###  258\. Add Digits\n\nGiven an integer `num` repeatedly add all its digits until the result has\nonly one digit and return it.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 38\n    **Output:** 2\n    **Explanation:** The process is\n    38 --> 3 + 8 --> 11\n    11 --> 1 + 1 --> 2 \n    Since 2 has only one digit return it.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 0\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `0 <= num <= 231 - 1`\n\n\n\n**Follow up:** Could you do it without any loop/recursion in `O(1)` runtime?\n\n,// Runtime: 45 ms (Top 20.34%) | Memory: 16.40 MB (Top 13.14%)\n\nclass Solution:\n    def addDigits(self num: int) -> int:\n        while num > 9:\n            num = num % 10 + num // 10\n        return num\n
Add Minimum Number of Rungs,###  1936\. Add Minimum Number of Rungs\n\nYou are given a **strictly increasing** integer array `rungs` that represents\nthe **height** of rungs on a ladder. You are currently on the **floor** at\nheight `0` and you want to reach the last rung.\n\nYou are also given an integer `dist`. You can only climb to the next highest\nrung if the distance between where you are currently at (the floor or on a\nrung) and the next rung is **at most** `dist`. You are able to insert rungs at\nany positive **integer** height if a rung is not already there.\n\nReturn _the**minimum** number of rungs that must be added to the ladder in\norder for you to climb to the last rung._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rungs = [13510] dist = 2\n    **Output:** 2\n    **Explanation:** You currently cannot reach the last rung.\n    Add rungs at heights 7 and 8 to climb this ladder. \n    The ladder will now have rungs at [135_7_ _8_ 10].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rungs = [36810] dist = 3\n    **Output:** 0\n    **Explanation:**\n    This ladder can be climbed without adding additional rungs.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** rungs = [3467] dist = 2\n    **Output:** 1\n    **Explanation:**\n    You currently cannot reach the first rung from the ground.\n    Add a rung at height 1 to climb this ladder.\n    The ladder will now have rungs at [_1_ 3467].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rungs.length <= 105`\n  * `1 <= rungs[i] <= 109`\n  * `1 <= dist <= 109`\n  * `rungs` is **strictly increasing**.\n\n,class Solution:\n    def addRungs(self rungs: List[int] dist: int) -> int:\n        rungs=[0]+rungs\n        ians=10\n        while i<len(rungs): \n            if rungs[i]-rungs[i-1] > dist:\n                ans+=ceil((rungs[i]-rungs[i-1])/dist)-1\n            i+=1\n        return ans\n\n\n\n            
Add One Row to Tree,###  623\. Add One Row to Tree\n\nGiven the `root` of a binary tree and two integers `val` and `depth` add a\nrow of nodes with value `val` at the given depth `depth`.\n\nNote that the `root` node is at depth `1`.\n\nThe adding rule is:\n\n  * Given the integer `depth` for each not null tree node `cur` at the depth `depth - 1` create two tree nodes with value `val` as `cur`'s left subtree root and right subtree root.\n  * `cur`'s original left subtree should be the left subtree of the new left subtree root.\n  * `cur`'s original right subtree should be the right subtree of the new right subtree root.\n  * If `depth == 1` that means there is no depth `depth - 1` at all then create a tree node with value `val` as the new root of the whole original tree and the original tree is the new root's left subtree.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg)\n\n    \n    \n    **Input:** root = [426315] val = 1 depth = 2\n    **Output:** [4112nullnull6315]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg)\n\n    \n    \n    **Input:** root = [42null31] val = 1 depth = 3\n    **Output:** [42null113nullnull1]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * The depth of the tree is in the range `[1 104]`.\n  * `-100 <= Node.val <= 100`\n  * `-105 <= val <= 105`\n  * `1 <= depth <= the depth of tree + 1`\n\n,// Runtime: 77 ms (Top 6.3%) | Memory: 18.50 MB (Top 98.9%)\n\nclass Solution:\n    def addOneRow(self root: TreeNode v: int d: int) -> TreeNode:\n        if d == 1: return TreeNode(v root None)\n        elif d == 2:\n            root.left = TreeNode(v root.left None)\n            root.right = TreeNode(v None root.right)\n        else:\n            if root.left: self.addOneRow(root.left v d-1)\n            if root.right: self.addOneRow(root.right v d-1)\n        return root\n
Add Strings,"###  415\. Add Strings\n\nGiven two non-negative integers `num1` and `num2` represented as string\nreturn _the sum of_ `num1` _and_ `num2` _as a string_.\n\nYou must solve the problem without using any built-in library for handling\nlarge integers (such as `BigInteger`). You must also not convert the inputs to\nintegers directly.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num1 = ""11"" num2 = ""123""\n    **Output:** ""134""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num1 = ""456"" num2 = ""77""\n    **Output:** ""533""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num1 = ""0"" num2 = ""0""\n    **Output:** ""0""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num1.length num2.length <= 104`\n  * `num1` and `num2` consist of only digits.\n  * `num1` and `num2` don't have any leading zeros except for the zero itself.\n\n",class Solution:\n    def addStrings(self num1: str num2: str) -> str:\n        def func(n):\n            value = {'0':0 '1':1 '2':2 '3':3 '4':4 '5':5 '6':6 '7':7 '8':8 '9':9}\n            result = 0\n            for digit in n:\n                result = 10 * result + value[digit]\n\n            return result\n\n        ans = func(num1) + func(num2)\n        return str(ans)
Add to Array-Form of Integer,###  989\. Add to Array-Form of Integer\n\nThe **array-form** of an integer `num` is an array representing its digits in\nleft to right order.\n\n  * For example for `num = 1321` the array form is `[1321]`.\n\nGiven `num` the **array-form** of an integer and an integer `k` return\n_the**array-form** of the integer_ `num + k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = [1200] k = 34\n    **Output:** [1234]\n    **Explanation:** 1200 + 34 = 1234\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = [274] k = 181\n    **Output:** [455]\n    **Explanation:** 274 + 181 = 455\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = [215] k = 806\n    **Output:** [1021]\n    **Explanation:** 215 + 806 = 1021\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num.length <= 104`\n  * `0 <= num[i] <= 9`\n  * `num` does not contain any leading zeros except for the zero itself.\n  * `1 <= k <= 104`\n\n,"// Runtime: 384 ms (Top 73.70%) | Memory: 15 MB (Top 73.95%)\nclass Solution:\n    def addToArrayForm(self num: List[int] k: int) -> List[int]:\n        return list(str(int("""".join(map(strnum)))+k))"
Add Two Numbers,###  2\. Add Two Numbers\n\nYou are given two **non-empty** linked lists representing two non-negative\nintegers. The digits are stored in **reverse order**  and each of their nodes\ncontains a single digit. Add the two numbers and return the sum as a linked\nlist.\n\nYou may assume the two numbers do not contain any leading zero except the\nnumber 0 itself.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg)\n\n    \n    \n    **Input:** l1 = [243] l2 = [564]\n    **Output:** [708]\n    **Explanation:** 342 + 465 = 807.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** l1 = [0] l2 = [0]\n    **Output:** [0]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** l1 = [9999999] l2 = [9999]\n    **Output:** [89990001]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in each linked list is in the range `[1 100]`.\n  * `0 <= Node.val <= 9`\n  * It is guaranteed that the list represents a number that does not have leading zeros.\n\n,// Runtime: 74 ms (Top 13.64%) | Memory: 16.40 MB (Top 51.59%)\n\nclass Solution:\n    def addTwoNumbers(self l1: ListNode l2: ListNode) -> ListNode:\n        dummyHead = ListNode(0)\n        tail = dummyHead\n        carry = 0\n\n        while l1 is not None or l2 is not None or carry != 0:\n            digit1 = l1.val if l1 is not None else 0\n            digit2 = l2.val if l2 is not None else 0\n\n            sum = digit1 + digit2 + carry\n            digit = sum % 10\n            carry = sum // 10\n\n            newNode = ListNode(digit)\n            tail.next = newNode\n            tail = tail.next\n\n            l1 = l1.next if l1 is not None else None\n            l2 = l2.next if l2 is not None else None\n\n        result = dummyHead.next\n        dummyHead.next = None\n        return result\n
Add Two Numbers II,###  445\. Add Two Numbers II\n\nYou are given two **non-empty** linked lists representing two non-negative\nintegers. The most significant digit comes first and each of their nodes\ncontains a single digit. Add the two numbers and return the sum as a linked\nlist.\n\nYou may assume the two numbers do not contain any leading zero except the\nnumber 0 itself.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg)\n\n    \n    \n    **Input:** l1 = [7243] l2 = [564]\n    **Output:** [7807]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** l1 = [243] l2 = [564]\n    **Output:** [807]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** l1 = [0] l2 = [0]\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in each linked list is in the range `[1 100]`.\n  * `0 <= Node.val <= 9`\n  * It is guaranteed that the list represents a number that does not have leading zeros.\n\n\n\n**Follow up:**  Could you solve it without reversing the input lists?\n\n,class Solution:\n    def addTwoNumbers(self l1: Optional[ListNode] l2: Optional[ListNode]) -> Optional[ListNode]:\n        def number(head):\n            ans = ''\n            while head:\n                ans+=str(head.val)\n                head = head.next\n            return int(ans) \n        temp = dummy = ListNode(0)\n        for i in str(number(l1) + number(l2)):\n            temp.next = ListNode(i)\n            temp = temp.next\n        return dummy.next\n      \n\n
Adding Spaces to a String,"###  2109\. Adding Spaces to a String\n\nYou are given a **0-indexed** string `s` and a **0-indexed** integer array\n`spaces` that describes the indices in the original string where spaces will\nbe added. Each space should be inserted **before** the character at the given\nindex.\n\n  * For example given `s = ""EnjoyYourCoffee""` and `spaces = [5 9]` we place spaces before `'Y'` and `'C'` which are at indices `5` and `9` respectively. Thus we obtain `""Enjoy **_Y_** our _**C**_ offee""`.\n\nReturn****_the modified string**after** the spaces have been added._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""LeetcodeHelpsMeLearn"" spaces = [81315]\n    **Output:** ""Leetcode Helps Me Learn""\n    **Explanation:** \n    The indices 8 13 and 15 correspond to the underlined characters in ""Leetcode _**H**_ elps _**M**_ e _**L**_ earn"".\n    We then place spaces before those characters.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""icodeinpython"" spaces = [1579]\n    **Output:** ""i code in py thon""\n    **Explanation:**\n    The indices 1 5 7 and 9 correspond to the underlined characters in ""i _**c**_ ode _**i**_ n _**p**_ y _**t**_ hon"".\n    We then place spaces before those characters.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""spacing"" spaces = [0123456]\n    **Output:** "" s p a c i n g""\n    **Explanation:**\n    We are also able to place spaces before the first character of the string.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 3 * 105`\n  * `s` consists only of lowercase and uppercase English letters.\n  * `1 <= spaces.length <= 3 * 105`\n  * `0 <= spaces[i] <= s.length - 1`\n  * All the values of `spaces` are **strictly increasing**.\n\n","// Runtime: 460 ms (Top 99.07%) | Memory: 53.10 MB (Top 90.93%)\n\nclass Solution:\n    def addSpaces(self s: str spaces: List[int]) -> str:\n        \n        arr = []\n        prev = 0\n        for space in spaces:\n            arr.append(s[prev:space])\n            prev = space\n        arr.append(s[space:])\n       \n        return "" "".join(arr)\n"
Adding Two Negabinary Numbers,###  1073\. Adding Two Negabinary Numbers\n\nGiven two numbers `arr1` and `arr2` in base **-2**  return the result of\nadding them together.\n\nEach number is given in _array format_ :  as an array of 0s and 1s from most\nsignificant bit to least significant bit.  For example `arr = [1101]`\nrepresents the number `(-2)^3 + (-2)^2 + (-2)^0 = -3`.  A number `arr` in\n_array format_ is also guaranteed to have no leading zeros: either `arr ==\n[0]` or `arr[0] == 1`.\n\nReturn the result of adding `arr1` and `arr2` in the same format: as an array\nof 0s and 1s with no leading zeros.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr1 = [11111] arr2 = [101]\n    **Output:** [10000]\n    **Explanation:** arr1 represents 11 arr2 represents 5 the output represents 16.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr1 = [0] arr2 = [0]\n    **Output:** [0]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr1 = [0] arr2 = [1]\n    **Output:** [1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr1.length arr2.length <= 1000`\n  * `arr1[i]` and `arr2[i]` are `0` or `1`\n  * `arr1` and `arr2` have no leading zeros\n\n,"class Solution:\n    def addNegabinary(self arr1: List[int] arr2: List[int]) -> List[int]:\n        \n        //final answer\n        new = []\n        carry = 0\n        \n		//make arrays length equal \n        if len(arr1) < len(arr2):\n            diff = len(arr2) - len(arr1)\n            arr1 = ([0] * diff) + arr1\n        \n        if len(arr1) > len(arr2):\n            diff = len(arr1) - len(arr2)\n            arr2 = ([0] * diff) + arr2\n            \n            \n        \n        //add values at every index and set carry and new value appropriately\n        while arr1 and arr2:\n            \n            top = arr1.pop()\n            down = arr2.pop()\n            \n            add = top + down + carry\n            \n            if add == -1:\n                new = [1] + new\n                carry = 1\n            \n            elif add == 1 or add == 0:\n                new =  [add] + new\n                carry = 0\n                \n            elif add == 2:\n                new = [0] + new\n                carry = -1\n            \n            else:\n                new = [1] + new\n                carry = -1\n                \n         // if carry -1 add 1 1 since -1 is 11 in negabinary\n        if carry == -1:\n            new = [11] + new\n            \n		//remove any leading zeros\n        while new[0] == 0 and len(new) >1:\n            new = new[1:]\n            \n        return new\n"
Additive Number,"###  306\. Additive Number\n\nAn **additive number** is a string whose digits can form an **additive\nsequence**.\n\nA valid **additive sequence** should contain **at least** three numbers.\nExcept for the first two numbers each subsequent number in the sequence must\nbe the sum of the preceding two.\n\nGiven a string containing only digits return `true` if it is an **additive\nnumber** or `false` otherwise.\n\n**Note:** Numbers in the additive sequence **cannot** have leading zeros so\nsequence `1 2 03` or `1 02 3` is invalid.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** ""112358""\n    **Output:** true\n    **Explanation:** \n    The digits can form an additive sequence: 1 1 2 3 5 8. \n    1 + 1 = 2 1 + 2 = 3 2 + 3 = 5 3 + 5 = 8\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** ""199100199""\n    **Output:** true\n    **Explanation:** \n    The additive sequence is: 1 99 100 199. \n    1 + 99 = 100 99 + 100 = 199\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num.length <= 35`\n  * `num` consists only of digits.\n\n\n\n**Follow up:** How would you handle overflow for very large input integers?\n\n","class Solution:\ndef isAdditiveNumber(self num: str) -> bool:\n    \n    def isadditive(num1num2st):\n        if len(st) == 0:\n            return True\n        num3 = str(num1+num2)\n        l = len(num3)\n        return num3 == st[:l] and isadditive(num2int(num3)st[l:])\n    \n    for i in range(1len(num)-1):\n        for j in range(i+1len(num)):\n            if num [0] == ""0"" and i != 1:\n                break\n            if num[i] == ""0"" and i+1 != j:\n                break\n           \n            if isadditive(int(num[:i])int(num[i:j])num[j:]):\n                \n                return True\n    return False\n"
Advantage Shuffle,###  870\. Advantage Shuffle\n\nYou are given two integer arrays `nums1` and `nums2` both of the same length.\nThe **advantage** of `nums1` with respect to `nums2` is the number of indices\n`i` for which `nums1[i] > nums2[i]`.\n\nReturn _any permutation of_`nums1` _that maximizes its**advantage** with\nrespect to _`nums2`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [271115] nums2 = [110411]\n    **Output:** [211715]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [1224832] nums2 = [13253211]\n    **Output:** [2432812]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length <= 105`\n  * `nums2.length == nums1.length`\n  * `0 <= nums1[i] nums2[i] <= 109`\n\n,class Solution:\n    def advantageCount(self nums1: List[int] nums2: List[int]) -> List[int]:\n        # sort by ascend order\n        nums1.sort()\n\n        # heapq in python is a minimal heap so if we need to use a maximal heap the element in the queue should be like: (-num index)\n        q = []\n        for i n in enumerate(nums2):\n            heapq.heappush(q (-n i))\n\n        n = len(nums1)\n        l = 0\n        r = n - 1\n        ans = [0] * n\n\n        while q:\n            # pop out the maximum number from nums2\n            num i = heapq.heappop(q)\n            num = -num\n\n            # no number in nums1 > max number in nums2 so grap the minimum numer from nums1\n            if nums1[r] <= num:\n                ans[i] = nums1[l]\n                l += 1\n            else:\n                ans[i] = nums1[r]\n                r -= 1\n\n        return ans
Airplane Seat Assignment Probability,###  1227\. Airplane Seat Assignment Probability\n\n`n` passengers board an airplane with exactly `n` seats. The first passenger\nhas lost the ticket and picks a seat randomly. But after that the rest of the\npassengers will:\n\n  * Take their own seat if it is still available and\n  * Pick other seats randomly when they find their seat occupied\n\nReturn _the probability that the_`nth` _person gets his own seat_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1.00000\n    **Explanation:** The first person can only get the first seat.\n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 0.50000\n    **Explanation:** The second person has a probability of 0.5 to get the second seat (when first person gets the first seat).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n\n,class Solution:\n    def nthPersonGetsNthSeat(self n: int) -> float:\n\n        return 0.5 if n > 1 else 1\n
Alert Using Same Key-Card Three or More Times in a One Hour Period,"###  1604\. Alert Using Same Key-Card Three or More Times in a One Hour Period\n\nLeetCode company workers use key-cards to unlock office doors. Each time a\nworker uses their key-card the security system saves the worker's name and\nthe time when it was used. The system emits an **alert** if any worker uses\nthe key-card **three or more times** in a one-hour period.\n\nYou are given a list of strings `keyName` and `keyTime` where `[keyName[i]\nkeyTime[i]]` corresponds to a person's name and the time when their key-card\nwas used **in a** **single day**.\n\nAccess times are given in the **24-hour time format ""HH:MM""**  such as\n`""23:51""` and `""09:49""`.\n\nReturn a _list of unique worker names who received an alert for frequent\nkeycard use_. Sort the names in **ascending order alphabetically**.\n\nNotice that `""10:00""` \- `""11:00""` is considered to be within a one-hour\nperiod while `""22:51""` \- `""23:52""` is not considered to be within a one-hour\nperiod.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** keyName = [""daniel""""daniel""""daniel""""luis""""luis""""luis""""luis""] keyTime = [""10:00""""10:40""""11:00""""09:00""""11:00""""13:00""""15:00""]\n    **Output:** [""daniel""]\n    **Explanation:** ""daniel"" used the keycard 3 times in a one-hour period (""10:00""""10:40"" ""11:00"").\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** keyName = [""alice""""alice""""alice""""bob""""bob""""bob""""bob""] keyTime = [""12:01""""12:00""""18:00""""21:00""""21:20""""21:30""""23:00""]\n    **Output:** [""bob""]\n    **Explanation:** ""bob"" used the keycard 3 times in a one-hour period (""21:00""""21:20"" ""21:30"").\n    \n\n\n\n**Constraints:**\n\n  * `1 <= keyName.length keyTime.length <= 105`\n  * `keyName.length == keyTime.length`\n  * `keyTime[i]` is in the format **""HH:MM""**.\n  * `[keyName[i] keyTime[i]]` is **unique**.\n  * `1 <= keyName[i].length <= 10`\n  * `keyName[i] contains only lowercase English letters.`\n\n","class Solution:\n    # 668 ms 99.52%. Time: O(NlogN). Space: O(N)\n    def alertNames(self keyName: List[str] keyTime: List[str]) -> List[str]:\n        \n        def is_within_1hr(t1 t2):\n            h1 m1 = t1.split("":"")\n            h2 m2 = t2.split("":"")\n            if int(h1) + 1 < int(h2): return False\n            if h1 == h2: return True\n            return m1 >= m2\n        \n        records = collections.defaultdict(list)\n        for name time in zip(keyName keyTime):\n            records[name].append(time)\n        \n        rv = []\n        for person record in records.items():\n            record.sort()\n			# Loop through 2 values at a time and check if they are within 1 hour.\n            if any(is_within_1hr(t1 t2) for t1 t2 in zip(record record[2:])):\n                rv.append(person)\n        return sorted(rv)\n                  \n"
All Ancestors of a Node in a Directed Acyclic Graph,###  2192\. All Ancestors of a Node in a Directed Acyclic Graph\n\nYou are given a positive integer `n` representing the number of nodes of a\n**Directed Acyclic Graph** (DAG). The nodes are numbered from `0` to `n - 1`\n(**inclusive**).\n\nYou are also given a 2D integer array `edges` where `edges[i] = [fromi toi]`\ndenotes that there is a **unidirectional** edge from `fromi` to `toi` in the\ngraph.\n\nReturn _a list_ `answer` _ where_`answer[i]`_is the**list of ancestors** of\nthe_ `ith` _node sorted in**ascending order**_.\n\nA node `u` is an **ancestor** of another node `v` if `u` can reach `v` via a\nset of edges.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/12/12/e1.png)\n\n    \n    \n    **Input:** n = 8 edgeList = [[03][04][13][24][27][35][36][37][46]]\n    **Output:** [[][][][01][02][013][01234][0123]]\n    **Explanation:**\n    The above diagram represents the input graph.\n    - Nodes 0 1 and 2 do not have any ancestors.\n    - Node 3 has two ancestors 0 and 1.\n    - Node 4 has two ancestors 0 and 2.\n    - Node 5 has three ancestors 0 1 and 3.\n    - Node 6 has five ancestors 0 1 2 3 and 4.\n    - Node 7 has four ancestors 0 1 2 and 3.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/12/12/e2.png)\n\n    \n    \n    **Input:** n = 5 edgeList = [[01][02][03][04][12][13][14][23][24][34]]\n    **Output:** [[][0][01][012][0123]]\n    **Explanation:**\n    The above diagram represents the input graph.\n    - Node 0 does not have any ancestor.\n    - Node 1 has one ancestor 0.\n    - Node 2 has two ancestors 0 and 1.\n    - Node 3 has three ancestors 0 1 and 2.\n    - Node 4 has four ancestors 0 1 2 and 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n  * `0 <= edges.length <= min(2000 n * (n - 1) / 2)`\n  * `edges[i].length == 2`\n  * `0 <= fromi toi <= n - 1`\n  * `fromi != toi`\n  * There are no duplicate edges.\n  * The graph is **directed** and **acyclic**.\n\n,# Runtime: 2132 ms (Top 14.62%) | Memory: 30.4 MB (Top 89.89%)\nclass Solution:\n    def getAncestors(self n: int edges: List[List[int]]) -> List[List[int]]:\n        graph = {}\n        for a b in edges:\n            graph[b] = graph.get(b []) + [a]\n        op = [[] for i in range(n)]\n        for a in graph:\n            visited = set()\n            paths = [a]\n            while len(paths) > 0:\n                curr = paths.pop()\n                for b in graph.get(curr []):\n                    if b not in visited:\n                        visited.add(b)\n                        paths.append(b)\n            op[a] = sorted(visited)\n        return op
All Divisions With the Highest Score of a Binary Array,###  2155\. All Divisions With the Highest Score of a Binary Array\n\nYou are given a **0-indexed** binary array `nums` of length `n`. `nums` can be\ndivided at index `i` (where `0 <= i <= n)` into two arrays (possibly empty)\n`numsleft` and `numsright`:\n\n  * `numsleft` has all the elements of `nums` between index `0` and `i - 1` **(inclusive)**  while `numsright` has all the elements of nums between index `i` and `n - 1` **(inclusive)**.\n  * If `i == 0` `numsleft` is **empty**  while `numsright` has all the elements of `nums`.\n  * If `i == n` `numsleft` has all the elements of nums while `numsright` is **empty**.\n\nThe **division score** of an index `i` is the **sum** of the number of `0`'s\nin `numsleft` and the number of `1`'s in `numsright`.\n\nReturn _**all distinct indices** that have the **highest** possible **division\nscore**_. You may return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [0010]\n    **Output:** [24]\n    **Explanation:** Division at index\n    - 0: numsleft is []. numsright is [00_**1**_ 0]. The score is 0 + 1 = 1.\n    - 1: numsleft is [_**0**_]. numsright is [0_**1**_ 0]. The score is 1 + 1 = 2.\n    - 2: numsleft is [_**0**_ _**0**_]. numsright is [_**1**_ 0]. The score is 2 + 1 = 3.\n    - 3: numsleft is [_**0**_ _**0**_ 1]. numsright is [0]. The score is 2 + 0 = 2.\n    - 4: numsleft is [_**0**_ _**0**_ 1_**0**_]. numsright is []. The score is 3 + 0 = 3.\n    Indices 2 and 4 both have the highest possible division score 3.\n    Note the answer [42] would also be accepted.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [000]\n    **Output:** [3]\n    **Explanation:** Division at index\n    - 0: numsleft is []. numsright is [000]. The score is 0 + 0 = 0.\n    - 1: numsleft is [_**0**_]. numsright is [00]. The score is 1 + 0 = 1.\n    - 2: numsleft is [_**0**_ _**0**_]. numsright is [0]. The score is 2 + 0 = 2.\n    - 3: numsleft is [_**0**_ _**0**_ _**0**_]. numsright is []. The score is 3 + 0 = 3.\n    Only index 3 has the highest possible division score 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [11]\n    **Output:** [0]\n    **Explanation:** Division at index\n    - 0: numsleft is []. numsright is [_**1**_ _**1**_]. The score is 0 + 2 = 2.\n    - 1: numsleft is [1]. numsright is [_**1**_]. The score is 0 + 1 = 1.\n    - 2: numsleft is [11]. numsright is []. The score is 0 + 0 = 0.\n    Only index 0 has the highest possible division score 2.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 105`\n  * `nums[i]` is either `0` or `1`.\n\n,# Runtime: 5049 ms (Top 67.40%) | Memory: 29.4 MB (Top 23.35%)\nclass Solution:\n    def maxScoreIndices(self nums: List[int]) -> List[int]:\n        zeroFromLeft = [0] * (len(nums) + 1)\n        oneFromRight = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                zeroFromLeft[i + 1] = zeroFromLeft[i] + 1\n            else:\n                zeroFromLeft[i + 1] = zeroFromLeft[i]\n\n        for i in range(len(nums))[::-1]:\n            if nums[i] == 1:\n                oneFromRight[i] = oneFromRight[i + 1] + 1\n            else:\n                oneFromRight[i] = oneFromRight[i + 1]\n\n        allSum = [0] * (len(nums) + 1)\n        currentMax = 0\n        res = []\n        for i in range(len(nums) + 1):\n            allSum[i] = oneFromRight[i] + zeroFromLeft[i]\n            if allSum[i] > currentMax:\n                res = []\n                currentMax = allSum[i]\n            if allSum[i] == currentMax:\n                res.append(i)\n        return res\n
All Elements in Two Binary Search Trees,###  1305\. All Elements in Two Binary Search Trees\n\nGiven two binary search trees `root1` and `root2` return _a list containing\nall the integers from both trees sorted in**ascending** order_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/12/18/q2-e1.png)\n\n    \n    \n    **Input:** root1 = [214] root2 = [103]\n    **Output:** [011234]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/12/18/q2-e5-.png)\n\n    \n    \n    **Input:** root1 = [1null8] root2 = [81]\n    **Output:** [1188]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in each tree is in the range `[0 5000]`.\n  * `-105 <= Node.val <= 105`\n\n,\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getAllElements(self root1: TreeNode root2: TreeNode) -> List[int]:\n        \n        \n        l1l2=[][]\n        def preorder(rootl):\n            if root is None:\n                return \n            preorder(root.leftl)\n            l.append(root.val)\n            preorder(root.rightl)\n        preorder(root1l1)\n        preorder(root2l2)\n        return sorted(l1+l2)\n
All Nodes Distance K in Binary Tree,###  863\. All Nodes Distance K in Binary Tree\n\nGiven the `root` of a binary tree the value of a target node `target` and an\ninteger `k` return _an array of the values of all nodes that have a\ndistance_`k` _from the target node._\n\nYou can return the answer in **any order**.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png)\n\n    \n    \n    **Input:** root = [3516208nullnull74] target = 5 k = 2\n    **Output:** [741]\n    Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7 4 and 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [1] target = 1 k = 3\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 500]`.\n  * `0 <= Node.val <= 500`\n  * All the values `Node.val` are **unique**.\n  * `target` is the value of one of the nodes in the tree.\n  * `0 <= k <= 1000`\n\n,// Runtime: 38 ms (Top 85.62%) | Memory: 17.70 MB (Top 14.33%)\n\nclass Solution:\n    def distanceK(self root target K):\n        # Step 1: Build adjacency list graph\n        graph = {}\n        self.buildGraph(root None graph)\n\n        # Step 2: Perform BFS from the target node\n        queue = [(target 0)]\n        visited = set([target])\n        result = []\n        \n        while queue:\n            node distance = queue.pop(0)\n            \n            if distance == K:\n                result.append(node.val)\n                \n            if distance > K:\n                break\n            \n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor distance + 1))\n        \n        return result\n    \n    def buildGraph(self node parent graph):\n        if not node:\n            return\n        \n        if node not in graph:\n            graph[node] = []\n            \n        if parent:\n            graph[node].append(parent)\n            graph[parent].append(node)\n            \n        self.buildGraph(node.left node graph)\n        self.buildGraph(node.right node graph)\n\n
All Paths From Source to Target,###  797\. All Paths From Source to Target\n\nGiven a directed acyclic graph (**DAG**) of `n` nodes labeled from `0` to `n -\n1` find all possible paths from node `0` to node `n - 1` and return them in\n**any order**.\n\nThe graph is given as follows: `graph[i]` is a list of all nodes you can visit\nfrom node `i` (i.e. there is a directed edge from node `i` to node\n`graph[i][j]`).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)\n\n    \n    \n    **Input:** graph = [[12][3][3][]]\n    **Output:** [[013][023]]\n    **Explanation:** There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)\n\n    \n    \n    **Input:** graph = [[431][324][3][4][]]\n    **Output:** [[04][034][0134][01234][014]]\n    \n\n\n\n**Constraints:**\n\n  * `n == graph.length`\n  * `2 <= n <= 15`\n  * `0 <= graph[i][j] < n`\n  * `graph[i][j] != i` (i.e. there will be no self-loops).\n  * All the elements of `graph[i]` are **unique**.\n  * The input graph is **guaranteed** to be a **DAG**.\n\n,class Solution:\n    def allPathsSourceTarget(self graph: List[List[int]]) -> List[List[int]]:\n        res = []\n        self.explore(graph graph[0] [0] res)\n        return res\n    \n    def explore(self graph candidates step res):\n        if step[-1] == len(graph)-1:\n            res.append(list(step))\n        else:\n            for i in range(len(candidates)):\n                step.append(candidates[i])\n                self.explore(graph graph[candidates[i]] step res)\n                step.pop()\n
All Possible Full Binary Trees,###  894\. All Possible Full Binary Trees\n\nGiven an integer `n` return _a list of all possible**full binary trees**\nwith_ `n` _nodes_. Each node of each tree in the answer must have `Node.val ==\n0`.\n\nEach element of the answer is the root node of one possible tree. You may\nreturn the final list of trees in **any order**.\n\nA **full binary tree** is a binary tree where each node has exactly `0` or `2`\nchildren.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png)\n\n    \n    \n    **Input:** n = 7\n    **Output:** [[000nullnull00nullnull00][000nullnull0000][0000000][00000nullnullnullnull00][00000nullnull00]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** [[000]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 20`\n\n,"We can't create Full Binary tree with even number of nodes. e.g n = 2/4/6/8...\nstart with cache having n = 1\n	cache = {1:TreeNode()}\n	\n	n = 3\n							0 (root)\n						 1     1\n	n = 5       \n	                        0 (root1)                  0 (root2) \n						 1     3                     3    1\n	n = 7  \n	                         0                    0                   0\n						 1      5              3    3              5     1\n\n\nclass Solution:\n    def allPossibleFBT(self n: int) -> List[Optional[TreeNode]]:\n        def helper(n):\n            if n in cache:\n                return cache[n]\n            # We use result array to store all possible binary tree of size n\n            result = [] \n            leftNodes rightNodes = 1n-2\n            # if n = 7 then (leftNodesrightNodes) should be : (15)(33)(51) \n            while rightNodes >0:\n                root = TreeNode()\n                if leftNodes not in cache:\n                    helper(leftNodes)\n                if rightNodes not in cache:\n                    helper(rightNodes)\n                leftTree = cache[leftNodes]\n                rightTree = cache[rightNodes]\n                # Using two for loops we generate all possible binary tree.\n                # Always remember root of each binary tree is diffrent So create new root every time\n                for i in range(len(leftTree)):\n                    for j in range(len(rightTree)):\n                        root.left = leftTree[i]\n                        root.right = rightTree[j]\n                        result.append(root)\n                        root = TreeNode()\n                leftNodes += 2\n                rightNodes -= 2\n            cache[n] = result\n            return result\n            \n        if n % 2 == 0:\n            return \n        else:\n            cache = {1:[TreeNode()]}\n            return helper(n)\n			\nThank You 😊\n\n"
Allocate Mailboxes,###  1478\. Allocate Mailboxes\n\nGiven the array `houses` where `houses[i]` is the location of the `ith` house\nalong a street and an integer `k` allocate `k` mailboxes in the street.\n\nReturn _the**minimum** total distance between each house and its nearest\nmailbox_.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/05/07/sample_11_1816.png)\n\n    \n    \n    **Input:** houses = [1481020] k = 3\n    **Output:** 5\n    **Explanation:** Allocate mailboxes in position 3 9 and 20.\n    Minimum total distance from each houses to nearest mailboxes is |3-1| + |4-3| + |9-8| + |10-9| + |20-20| = 5 \n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/05/07/sample_2_1816.png)\n\n    \n    \n    **Input:** houses = [2351218] k = 2\n    **Output:** 9\n    **Explanation:** Allocate mailboxes in position 3 and 14.\n    Minimum total distance from each houses to nearest mailboxes is |2-3| + |3-3| + |5-3| + |12-14| + |18-14| = 9.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= houses.length <= 100`\n  * `1 <= houses[i] <= 104`\n  * All the integers of `houses` are **unique**.\n\n,class Solution:\n    def minDistance(self houses: List[int] k: int) -> int:\n        houses.sort()\n\n        @lru_cache(None)\n        def dp(left right k):\n            if k == 1:                                          # <-- 1.\n                mid = houses[(left+right) // 2]\n                return sum(abs(houses[i] - mid) for i in range(left right + 1))\n\n            return min(dp(left i 1) + dp(i+1 right k - 1) \n                       for i in range(left right - k + 2))     # <-- 2.\n\n        return dp(0 len(houses)-1 k)
Alphabet Board Path,"###  1138\. Alphabet Board Path\n\nOn an alphabet board we start at position `(0 0)` corresponding to\ncharacter `board[0][0]`.\n\nHere `board = [""abcde"" ""fghij"" ""klmno"" ""pqrst"" ""uvwxy"" ""z""]` as shown\nin the diagram below.\n\n![](https://assets.leetcode.com/uploads/2019/07/28/azboard.png)\n\nWe may make the following moves:\n\n  * `'U'` moves our position up one row if the position exists on the board;\n  * `'D'` moves our position down one row if the position exists on the board;\n  * `'L'` moves our position left one column if the position exists on the board;\n  * `'R'` moves our position right one column if the position exists on the board;\n  * `'!'` adds the character `board[r][c]` at our current position `(r c)` to the answer.\n\n(Here the only positions that exist on the board are positions with letters\non them.)\n\nReturn a sequence of moves that makes our answer equal to `target` in the\nminimum number of moves.  You may return any path that does so.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = ""leet""\n    **Output:** ""DDR!UURRR!!DDD!""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = ""code""\n    **Output:** ""RR!DDRR!UUL!R!""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= target.length <= 100`\n  * `target` consists only of English lowercase letters.\n\n","# Runtime: 68 ms (Top 16.25%) | Memory: 14 MB (Top 13.50%)\nclass Solution:\n    def alphabetBoardPath(self target: str) -> str:\n        def shortestPath(rctrtc):\n            path = """"\n            pr = r\n            while r > tr:\n                path += 'U'\n                r -= 1\n            while r < tr:\n                path += 'D'\n                r += 1\n            if tr == 5 and pr != tr: path = path[:len(path) - 1]\n            while c > tc:\n                path += 'L'\n                c -= 1\n            while c < tc:\n                path += 'R'\n                c += 1\n            if tr == 5 and pr != tr: path = path + 'D'\n            return path\n\n        table = ['abcde''fghij''klmno''pqrst''uvwxy''z']\n        rc = 00\n        ans = """"\n        for character in target:\n            t_row = None\n            for iword in enumerate(table):\n                if character in word:\n                    t_row = i\n                    break\n            t_col = table[i].index(character)\n            ans += shortestPath(rct_rowt_col) + '!'\n            rc = t_rowt_col\n        return ans"
Ambiguous Coordinates,"###  816\. Ambiguous Coordinates\n\nWe had some 2-dimensional coordinates like `""(1 3)""` or `""(2 0.5)""`. Then\nwe removed all commas decimal points and spaces and ended up with the string\ns.\n\n  * For example `""(1 3)""` becomes `s = ""(13)""` and `""(2 0.5)""` becomes `s = ""(205)""`.\n\nReturn _a list of strings representing all possibilities for what our original\ncoordinates could have been_.\n\nOur original representation never had extraneous zeroes so we never started\nwith numbers like `""00""` `""0.0""` `""0.00""` `""1.0""` `""001""` `""00.01""` or\nany other number that can be represented with fewer digits. Also a decimal\npoint within a number never occurs without at least one digit occurring before\nit so we never started with numbers like `"".1""`.\n\nThe final answer list can be returned in any order. All coordinates in the\nfinal answer have exactly one space between them (occurring after the comma.)\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""(123)""\n    **Output:** [""(1 2.3)""""(1 23)""""(1.2 3)""""(12 3)""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""(0123)""\n    **Output:** [""(0 1.23)""""(0 12.3)""""(0 123)""""(0.1 2.3)""""(0.1 23)""""(0.12 3)""]\n    **Explanation:** 0.0 00 0001 or 00.01 are not allowed.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""(00011)""\n    **Output:** [""(0 0.011)""""(0.001 1)""]\n    \n\n\n\n**Constraints:**\n\n  * `4 <= s.length <= 12`\n  * `s[0] == '('` and `s[s.length - 1] == ')'`.\n  * The rest of `s` are digits.\n\n","# Runtime: 129 ms (Top 6.42%) | Memory: 13.9 MB (Top 92.66%)\nclass Solution(object):\n    def ambiguousCoordinates(self s):\n        """"""\n        :type s: str\n        :rtype: List[str]\n        """"""\n        def _isValidSplit(s):\n            return False if len(s)>1 and re.match('/^[0]+$/'s) else True\n\n        def _isValidNum(ipartfpart):\n            return False if (len(ipart)>1 and ipart[0]=='0') or (fpart and fpart[-1]=='0') else True\n\n        def _splitToNums(s):\n            rets=[]\n            if len(s)==1:return [s]\n            for i in range(1len(s)+1):\n                ab=s[:i]s[i:]\n                if _isValidNum(ab):rets.append(""%s.%s""%(ab) if b else ""%s""%(a))\n            return rets\n\n        anss=[]s[1:-1]\n        for i in range(1len(s)):\n            ab=s[:i]s[i:]\n            if not _isValidSplit(a) or not _isValidSplit(b):continue\n            for c1c2 in itertools.product(_splitToNums(a)_splitToNums(b)):ans.append(""(%s %s)""%(c1c2))\n        return ans"
Apply Discount to Prices,"###  2288\. Apply Discount to Prices\n\nA **sentence** is a string of single-space separated words where each word can\ncontain digits lowercase letters and the dollar sign `'$'`. A word\nrepresents a **price** if it is a sequence of digits preceded by a dollar\nsign.\n\n  * For example `""$100""` `""$23""` and `""$6""` represent prices while `""100""` `""$""` and `""$1e5""` do not.\n\nYou are given a string `sentence` representing a sentence and an integer\n`discount`. For each word representing a price apply a discount of\n`discount%` on the price and **update** the word in the sentence. All updated\nprices should be represented with **exactly two** decimal places.\n\nReturn _a string representing the modified sentence_.\n\nNote that all prices will contain **at most** `10` digits.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** sentence = ""there are $1 $2 and 5$ candies in the shop"" discount = 50\n    **Output:** ""there are $0.50 $1.00 and 5$ candies in the shop""\n    **Explanation:** \n    The words which represent prices are ""$1"" and ""$2"". \n    - A 50% discount on ""$1"" yields ""$0.50"" so ""$1"" is replaced by ""$0.50"".\n    - A 50% discount on ""$2"" yields ""$1"". Since we need to have exactly 2 decimal places after a price we replace ""$2"" with ""$1.00"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** sentence = ""1 2 $3 4 $5 $6 7 8$ $9 $10$"" discount = 100\n    **Output:** ""1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$""\n    **Explanation:** \n    Applying a 100% discount on any price will result in 0.\n    The words representing prices are ""$3"" ""$5"" ""$6"" and ""$9"".\n    Each of them is replaced by ""$0.00"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= sentence.length <= 105`\n  * `sentence` consists of lowercase English letters digits `' '` and `'$'`.\n  * `sentence` does not have leading or trailing spaces.\n  * All words in `sentence` are separated by a single space.\n  * All prices will be **positive** numbers without leading zeros.\n  * All prices will have **at most** `10` digits.\n  * `0 <= discount <= 100`\n\n","class Solution:\n    def discountPrices(self sentence: str discount: int) -> str:\n        s = sentence.split() # convert to List to easily update\n        m = discount / 100 \n        for iword in enumerate(s):\n            if word[0] == ""$"" and word[1:].isdigit(): # Check whether it is in correct format\n                num = int(word[1:]) * (1-m) # discounted price\n                w = ""$"" + ""{:.2f}"".format(num) #correctly format\n                s[i] = w #Change inside the list\n        \n        return "" "".join(s) #Combine the updated list\n		```"
Arithmetic Subarrays,###  1630\. Arithmetic Subarrays\n\nA sequence of numbers is called **arithmetic** if it consists of at least two\nelements and the difference between every two consecutive elements is the\nsame. More formally a sequence `s` is arithmetic if and only if `s[i+1] -\ns[i] == s[1] - s[0] `for all valid `i`.\n\nFor example these are **arithmetic** sequences:\n\n    \n    \n    1 3 5 7 9\n    7 7 7 7\n    3 -1 -5 -9\n\nThe following sequence is not **arithmetic** :\n\n    \n    \n    1 1 2 5 7\n\nYou are given an array of `n` integers `nums` and two arrays of `m` integers\neach `l` and `r` representing the `m` range queries where the `ith` query\nis the range `[l[i] r[i]]`. All the arrays are **0-indexed**.\n\nReturn _a list of_`boolean` _elements_ `answer` _ where_ `answer[i]` _is_\n`true` _if the subarray_ `nums[l[i]] nums[l[i]+1] ...  nums[r[i]]`_can\nbe**rearranged** to form an **arithmetic** sequence and_ `false` _otherwise._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [465937] l = [002] r = [235]\n    **Output:** [truefalsetrue]\n    **Explanation:**\n    In the 0th query the subarray is [465]. This can be rearranged as [654] which is an arithmetic sequence.\n    In the 1st query the subarray is [4659]. This cannot be rearranged as an arithmetic sequence.\n    In the 2nd query the subarray is [5937]. This can be rearranged as [3579] which is an arithmetic sequence.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-12-9-3-12-61520-25-20-15-10] l = [016487] r = [4497910]\n    **Output:** [falsetruefalsefalsetruetrue]\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `m == l.length`\n  * `m == r.length`\n  * `2 <= n <= 500`\n  * `1 <= m <= 500`\n  * `0 <= l[i] < r[i] < n`\n  * `-105 <= nums[i] <= 105`\n\n,// Runtime: 194 ms (Top 22.81%) | Memory: 17.70 MB (Top 6.09%)\n\nclass Solution:\n    def checkArithmeticSubarrays(self nums: List[int] l: List[int] r: List[int]) -> List[bool]:\n        ans = []\n        \n        def find_diffs(arr):\n            \n            arr.sort()\n\n            dif = []\n            \n            for i in range(len(arr) - 1):\n                dif.append(arr[i] - arr[i + 1])\n            \n            return len(set(dif)) == 1\n        \n        for i  j in zip(l  r):\n            ans.append(find_diffs(nums[i:j + 1]))\n        \n        return ans\n
Arranging Coins,###  441\. Arranging Coins\n\nYou have `n` coins and you want to build a staircase with these coins. The\nstaircase consists of `k` rows where the `ith` row has exactly `i` coins. The\nlast row of the staircase **may be** incomplete.\n\nGiven the integer `n` return _the number of**complete rows** of the staircase\nyou will build_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/09/arrangecoins1-grid.jpg)\n\n    \n    \n    **Input:** n = 5\n    **Output:** 2\n    **Explanation:** Because the 3rd row is incomplete we return 2.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/09/arrangecoins2-grid.jpg)\n\n    \n    \n    **Input:** n = 8\n    **Output:** 3\n    **Explanation:** Because the 4th row is incomplete we return 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 231 - 1`\n\n,# Runtime: 6683 ms (Top 5.01%) | Memory: 13.8 MB (Top 57.45%)\nclass Solution:\n    def arrangeCoins(self n: int) -> int:\n        for i in range(12**31):\n            val=i*(i+1)//2\n            if val>n:\n                a=i\n                break\n            elif val==n:\n                return i\n        return a-1
Array Nesting,###  565\. Array Nesting\n\nYou are given an integer array `nums` of length `n` where `nums` is a\npermutation of the numbers in the range `[0 n - 1]`.\n\nYou should build a set `s[k] = {nums[k] nums[nums[k]] nums[nums[nums[k]]]\n... }` subjected to the following rule:\n\n  * The first element in `s[k]` starts with the selection of the element `nums[k]` of `index = k`.\n  * The next element in `s[k]` should be `nums[nums[k]]` and then `nums[nums[nums[k]]]` and so on.\n  * We stop adding right before a duplicate element occurs in `s[k]`.\n\nReturn _the longest length of a set_ `s[k]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [5403162]\n    **Output:** 4\n    **Explanation:** \n    nums[0] = 5 nums[1] = 4 nums[2] = 0 nums[3] = 3 nums[4] = 1 nums[5] = 6 nums[6] = 2.\n    One of the longest sets s[k]:\n    s[0] = {nums[0] nums[5] nums[6] nums[2]} = {5 6 2 0}\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [012]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] < nums.length`\n  * All the values of `nums` are **unique**.\n\n,class Solution:\n    def arrayNesting(self nums: List[int]) -> int:\n        max_len = 0\n        visited = set()\n        def dfs(nums index dfs_visited):\n            if index in dfs_visited:\n                return len(dfs_visited)\n            \n            # add the index to dfs_visited and visited\n            visited.add(index)\n            dfs_visited.add(index)\n            return dfs(nums nums[index] dfs_visited)\n            \n        for i in range(len(nums)):\n            if i not in visited:\n                max_len = max(max_len dfs(nums i set()))\n        return max_len\n
Array of Doubled Pairs,###  954\. Array of Doubled Pairs\n\nGiven an integer array of even length `arr` return `true` _if it is possible\nto reorder_`arr` _such that_`arr[2 * i + 1] = 2 * arr[2 * i]`_for every_`0 <=\ni < len(arr) / 2` _ or_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [3136]\n    **Output:** false\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [2126]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [4-22-4]\n    **Output:** true\n    **Explanation:** We can take two groups [-2-4] and [24] to form [-2-424] or [24-2-4].\n    \n\n\n\n**Constraints:**\n\n  * `2 <= arr.length <= 3 * 104`\n  * `arr.length` is even.\n  * `-105 <= arr[i] <= 105`\n\n,# Runtime: 1769 ms (Top 5.17%) | Memory: 16.6 MB (Top 56.95%)\nclass Solution:\n    def canReorderDoubled(self arr: List[int]) -> bool:\n        n = len(arr)\n        arr.sort()\n        times = n//2\n        count = {}\n        for i in arr :\n            if i in count:count[i] += 1\n            else: count[i] = 1\n        for i in count:\n            if i == 0:\n                tmp = count[0]//2\n                times -= tmp\n                if times <=0 : return True\n            else:\n                if i*2 in count:\n                    ct1 = count[i]\n                    ct2 = count[i*2]\n                    while ct1 > 0 and ct2 > 0 and times > 0:\n                        ct1 -= 1\n                        ct2 -= 1\n                        times -= 1\n                    count[i] = ct1\n                    count[i*2] = ct2\n                    if times == 0:return True\n        return False
Array Partition,###  561\. Array Partition\n\nGiven an integer array `nums` of `2n` integers group these integers into `n`\npairs `(a1 b1) (a2 b2) ... (an bn)` such that the sum of `min(ai bi)`\nfor all `i` is **maximized**. Return _the maximized sum_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1432]\n    **Output:** 4\n    **Explanation:** All possible pairings (ignoring the ordering of elements) are:\n    1. (1 4) (2 3) -> min(1 4) + min(2 3) = 1 + 2 = 3\n    2. (1 3) (2 4) -> min(1 3) + min(2 4) = 1 + 2 = 3\n    3. (1 2) (3 4) -> min(1 2) + min(3 4) = 1 + 3 = 4\n    So the maximum possible sum is 4.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [626512]\n    **Output:** 9\n    **Explanation:** The optimal pairing is (2 1) (2 5) (6 6). min(2 1) + min(2 5) + min(6 6) = 1 + 2 + 6 = 9.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n  * `nums.length == 2 * n`\n  * `-104 <= nums[i] <= 104`\n\n,"class Solution(object):\n    def arrayPairSum(self nums):\n        """"""\n        :type nums: List[int]\n        :rtype: int\n        """"""\n        \n        \n        nums = sorted(nums)\n        \n        summ = 0\n        for i in range(0len(nums)2):\n            summ += min(nums[i]nums[i+1])\n        return summ"
Array With Elements Not Equal to Average of Neighbors,###  1968\. Array With Elements Not Equal to Average of Neighbors\n\nYou are given a **0-indexed** array `nums` of **distinct** integers. You want\nto rearrange the elements in the array such that every element in the\nrearranged array is **not** equal to the **average** of its neighbors.\n\nMore formally the rearranged array should have the property such that for\nevery `i` in the range `1 <= i < nums.length - 1` `(nums[i-1] + nums[i+1]) /\n2` is **not** equal to `nums[i]`.\n\nReturn _**any** rearrangement of _`nums` _that meets the requirements_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12345]\n    **Output:** [12453]\n    **Explanation:**\n    When i=1 nums[i] = 2 and the average of its neighbors is (1+4) / 2 = 2.5.\n    When i=2 nums[i] = 4 and the average of its neighbors is (2+5) / 2 = 3.5.\n    When i=3 nums[i] = 5 and the average of its neighbors is (4+3) / 2 = 3.5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [62097]\n    **Output:** [97620]\n    **Explanation:**\n    When i=1 nums[i] = 7 and the average of its neighbors is (9+6) / 2 = 7.5.\n    When i=2 nums[i] = 6 and the average of its neighbors is (7+2) / 2 = 4.5.\n    When i=3 nums[i] = 2 and the average of its neighbors is (6+0) / 2 = 3.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= nums.length <= 105`\n  * `0 <= nums[i] <= 105`\n\n,class Solution:\n    def rearrangeArray(self nums: List[int]) -> List[int]:\n        for i in range(1 len(nums) -1):\n            pre = nums[i-1]\n            current = nums[i]\n            next = nums[i+1]\n            \n            # If block will run when we meet 1 2 3 or 6 4 2\n            if (pre < current < next) or (pre > current > next):\n                # Swap next and current\n                # For example: \n                # 1 2 3 -> 1 3 2\n                # 6 4 2 -> 6 2 4\n                nums[i+1] nums[i] = nums[i] nums[i+1]\n                \n        return nums\n
As Far from Land as Possible,###  1162\. As Far from Land as Possible\n\nGiven an `n x n` `grid` containing only values `0` and `1` where `0`\nrepresents water and `1` represents land find a water cell such that its\ndistance to the nearest land cell is maximized and return the distance. If no\nland or water exists in the grid return `-1`.\n\nThe distance used in this problem is the Manhattan distance: the distance\nbetween two cells `(x0 y0)` and `(x1 y1)` is `|x0 - x1| + |y0 - y1|`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/05/03/1336_ex1.JPG)\n\n    \n    \n    **Input:** grid = [[101][000][101]]\n    **Output:** 2\n    **Explanation:** The cell (1 1) is as far as possible from all the land with distance 2.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/05/03/1336_ex2.JPG)\n\n    \n    \n    **Input:** grid = [[100][000][000]]\n    **Output:** 4\n    **Explanation:** The cell (2 2) is as far as possible from all the land with distance 4.\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length`\n  * `n == grid[i].length`\n  * `1 <= n <= 100`\n  * `grid[i][j]` is `0` or `1`\n\n,from collections import *\nclass Solution:\n    def maxDistance(self grid) -> int:\n        mn=len(grid)len(grid[0])\n        queue=deque([])\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==1:\n                    queue.append((ij))\n        c=-1\n        while queue:\n            # print(queue)\n            temp=len(queue)\n            for _ in range(temp):\n                (ij)=queue.popleft()\n                for (xy) in ((i-1j)(i+1j)(ij-1)(ij+1)):\n                    if x < 0 or x >= m or y < 0 or y >= n or grid[x][y]==1:\n                        continue\n                    grid[x][y]=1\n                    queue.append((xy))\n            c+=1\n        return c if c!=0 else -1\n
Assign Cookies,###  455\. Assign Cookies\n\nAssume you are an awesome parent and want to give your children some cookies.\nBut you should give each child at most one cookie.\n\nEach child `i` has a greed factor `g[i]` which is the minimum size of a\ncookie that the child will be content with; and each cookie `j` has a size\n`s[j]`. If `s[j] >= g[i]` we can assign the cookie `j` to the child `i` and\nthe child `i` will be content. Your goal is to maximize the number of your\ncontent children and output the maximum number.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** g = [123] s = [11]\n    **Output:** 1\n    **Explanation:** You have 3 children and 2 cookies. The greed factors of 3 children are 1 2 3. \n    And even though you have 2 cookies since their size is both 1 you could only make the child whose greed factor is 1 content.\n    You need to output 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** g = [12] s = [123]\n    **Output:** 2\n    **Explanation:** You have 2 children and 3 cookies. The greed factors of 2 children are 1 2. \n    You have 3 cookies and their sizes are big enough to gratify all of the children \n    You need to output 2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= g.length <= 3 * 104`\n  * `0 <= s.length <= 3 * 104`\n  * `1 <= g[i] s[j] <= 231 - 1`\n\n,# Runtime: 437 ms (Top 8.80%) | Memory: 15.9 MB (Top 13.77%)\nclass Solution:\n    def findContentChildren(self g: List[int] s: List[int]) -> int:\n        g.sort()\n        s.sort()\n        cont = 0\n        c = 0\n        k = 0\n        while k< len(s) and c < len(g):\n            if s[k] >= g[c]:\n                c+=1\n                k+=1\n                cont+=1\n            else:\n                k+=1\n        return cont
Asteroid Collision,###  735\. Asteroid Collision\n\nWe are given an array `asteroids` of integers representing asteroids in a row.\n\nFor each asteroid the absolute value represents its size and the sign\nrepresents its direction (positive meaning right negative meaning left). Each\nasteroid moves at the same speed.\n\nFind out the state of the asteroids after all collisions. If two asteroids\nmeet the smaller one will explode. If both are the same size both will\nexplode. Two asteroids moving in the same direction will never meet.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** asteroids = [510-5]\n    **Output:** [510]\n    **Explanation:** The 10 and -5 collide resulting in 10. The 5 and 10 never collide.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** asteroids = [8-8]\n    **Output:** []\n    **Explanation:** The 8 and -8 collide exploding each other.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** asteroids = [102-5]\n    **Output:** [10]\n    **Explanation:** The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= asteroids.length <= 104`\n  * `-1000 <= asteroids[i] <= 1000`\n  * `asteroids[i] != 0`\n\n,# Runtime: 103 ms (Top 70.1%) | Memory: 17.56 MB (Top 44.2%)\n\nclass Solution:\n    def asteroidCollision(self asteroids: List[int]) -> List[int]:\n        stack = []\n        for a in asteroids:\n            while stack and stack[-1] > 0 > a:\n                if stack[-1] < abs(a):\n                    stack.pop()\n                    continue\n                elif stack[-1] == abs(a):\n                    stack.pop()\n                break # this means asteroid must be destroyed (not add to stack in else statement below)\n            else:\n                stack.append(a)\n        \n        return stack
Available Captures for Rook,"###  999\. Available Captures for Rook\n\nOn an `8 x 8` chessboard there is **exactly one** white rook `'R'` and some\nnumber of white bishops `'B'` black pawns `'p'` and empty squares `'.'`.\n\nWhen the rook moves it chooses one of four cardinal directions (north east\nsouth or west) then moves in that direction until it chooses to stop\nreaches the edge of the board captures a black pawn or is blocked by a white\nbishop. A rook is considered **attacking** a pawn if the rook can capture the\npawn on the rook's turn. The **number of available captures** for the white\nrook is the number of pawns that the rook is **attacking**.\n\nReturn _the**number of available captures** for the white rook_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/02/20/1253_example_1_improved.PNG)\n\n    \n    \n    **Input:** board = [[""."""".""""."""".""""."""".""""."""".""]["".""""."""".""""p""""."""".""""."""".""]["".""""."""".""""R"""".""""."""".""""p""][""."""".""""."""".""""."""".""""."""".""][""."""".""""."""".""""."""".""""."""".""]["".""""."""".""""p""""."""".""""."""".""][""."""".""""."""".""""."""".""""."""".""][""."""".""""."""".""""."""".""""."""".""]]\n    **Output:** 3\n    **Explanation:** In this example the rook is attacking all the pawns.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/02/19/1253_example_2_improved.PNG)\n\n    \n    \n    **Input:** board = [[""."""".""""."""".""""."""".""""."""".""]["".""""p""""p""""p""""p""""p""""."""".""]["".""""p""""p""""B""""p""""p""""."""".""]["".""""p""""B""""R""""B""""p""""."""".""]["".""""p""""p""""B""""p""""p""""."""".""]["".""""p""""p""""p""""p""""p""""."""".""][""."""".""""."""".""""."""".""""."""".""][""."""".""""."""".""""."""".""""."""".""]]\n    **Output:** 0\n    **Explanation:** The bishops are blocking the rook from attacking any of the pawns.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/02/20/1253_example_3_improved.PNG)\n\n    \n    \n    **Input:** board = [[""."""".""""."""".""""."""".""""."""".""]["".""""."""".""""p""""."""".""""."""".""]["".""""."""".""""p""""."""".""""."""".""][""p""""p"""".""""R"""".""""p""""B"""".""][""."""".""""."""".""""."""".""""."""".""]["".""""."""".""""B""""."""".""""."""".""]["".""""."""".""""p""""."""".""""."""".""][""."""".""""."""".""""."""".""""."""".""]]\n    **Output:** 3\n    **Explanation:** The rook is attacking the pawns at positions b5 d6 and f5.\n    \n\n\n\n**Constraints:**\n\n  * `board.length == 8`\n  * `board[i].length == 8`\n  * `board[i][j]` is either `'R'` `'.'` `'B'` or `'p'`\n  * There is exactly one cell with `board[i][j] == 'R'`\n\n","class Solution:\n    def numRookCaptures(self board: List[List[str]]) -> int:\n		# Checking for possible case to the right of Rook\n        def right_position(ni):\n            List = i[0:n][::-1] # taking list to the right of rook\n            pIndexbIndex = -1-1\n            if 'p' in List: # Checking if  'p' in list   \n                pIndex = List.index('p')\n            if 'B' in List: # Checking if 'B' in list\n                bIndex = List.index('B')\n            print(bIndexpIndexList)\n            if bIndex == -1 and pIndex >-1: # if list does not have 'B' and have 'p'\n                return True\n            if pIndex == -1: # if list does not have 'p'\n                return False\n            return bIndex>pIndex \n        def left_position(ni):\n            List = i[n+1:]# taking list to the right of rook\n            pIndexbIndex = -1-1\n            if 'p' in List:\n                pIndex = List.index('p')\n            if 'B' in List:\n                bIndex = List.index('B')\n            print(bIndexpIndexList)\n            if bIndex == -1 and pIndex >-1:\n                return True\n            if pIndex == -1:\n                return False\n            return bIndex>pIndex\n        Count = 0\n		# Checking for possibilites in row\n        for i in board:\n            if 'R' in i:\n                print(i)\n                n = i.index('R')\n                if left_position(ni):\n                    Count += 1\n                if right_position(ni):\n                    Count += 1\n        Col = []\n		# checking for possibilites in col\n        for i in range(0len(board)):\n            Col.append(board[i][n]) # taking the elements from the same col of Rook\n        n = Col.index('R')\n        if left_position(nCol):\n            Count += 1\n        if right_position(nCol):\n            Count += 1\n        return Count\n"
Average of Levels in Binary Tree,###  637\. Average of Levels in Binary Tree\n\nGiven the `root` of a binary tree return _the average value of the nodes on\neach level in the form of an array_. Answers within `10-5` of the actual\nanswer will be accepted.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/09/avg1-tree.jpg)\n\n    \n    \n    **Input:** root = [3920nullnull157]\n    **Output:** [3.0000014.5000011.00000]\n    Explanation: The average value of nodes on level 0 is 3 on level 1 is 14.5 and on level 2 is 11.\n    Hence return [3 14.5 11].\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/09/avg2-tree.jpg)\n\n    \n    \n    **Input:** root = [3920157]\n    **Output:** [3.0000014.5000011.00000]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `-231 <= Node.val <= 231 - 1`\n\n,// Runtime: 40 ms (Top 94.14%) | Memory: 19.30 MB (Top 21.03%)\n\nclass Solution:\n    def averageOfLevels(self root: TreeNode) -> List[float]:\n        \n        if not root:\n            \n            # Quick response for empty tree\n            return []\n        \n        traversal_q = [root]\n        \n        average = []\n        \n        while traversal_q:\n            \n            # compute current level average\n            cur_avg = sum( (node.val for node in traversal_q if node) ) / len(traversal_q)\n            \n            # add to result\n            average.append( cur_avg )\n            \n            # update next level queue\n            next_level_q = [ child for node in traversal_q for child in (node.left node.right) if child ]\n            \n            # update traversal queue as next level's\n            traversal_q = next_level_q\n            \n        return average\n
Average Salary Excluding the Minimum and Maximum Salary,###  1491\. Average Salary Excluding the Minimum and Maximum Salary\n\nYou are given an array of **unique** integers `salary` where `salary[i]` is\nthe salary of the `ith` employee.\n\nReturn _the average salary of employees excluding the minimum and maximum\nsalary_. Answers within `10-5` of the actual answer will be accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** salary = [4000300010002000]\n    **Output:** 2500.00000\n    **Explanation:** Minimum salary and maximum salary are 1000 and 4000 respectively.\n    Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** salary = [100020003000]\n    **Output:** 2000.00000\n    **Explanation:** Minimum salary and maximum salary are 1000 and 3000 respectively.\n    Average salary excluding minimum and maximum salary is (2000) / 1 = 2000\n    \n\n\n\n**Constraints:**\n\n  * `3 <= salary.length <= 100`\n  * `1000 <= salary[i] <= 106`\n  * All the integers of `salary` are **unique**.\n\n,class Solution:\n    def average(self salary: List[int]) -> float:       \n\n        return (sum(salary)-min(salary)-max(salary))/(len(salary)-2)\n
Average Waiting Time,###  1701\. Average Waiting Time\n\nThere is a restaurant with a single chef. You are given an array `customers`\nwhere `customers[i] = [arrivali timei]:`\n\n  * `arrivali` is the arrival time of the `ith` customer. The arrival times are sorted in **non-decreasing** order.\n  * `timei` is the time needed to prepare the order of the `ith` customer.\n\nWhen a customer arrives he gives the chef his order and the chef starts\npreparing it once he is idle. The customer waits till the chef finishes\npreparing his order. The chef does not prepare food for more than one customer\nat a time. The chef prepares food for customers **in the order they were given\nin the input**.\n\nReturn _the**average** waiting time of all customers_. Solutions within `10-5`\nfrom the actual answer are considered accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** customers = [[12][25][43]]\n    **Output:** 5.00000\n    **Explanation:** 1) The first customer arrives at time 1 the chef takes his order and starts preparing it immediately at time 1 and finishes at time 3 so the waiting time of the first customer is 3 - 1 = 2.\n    2) The second customer arrives at time 2 the chef takes his order and starts preparing it at time 3 and finishes at time 8 so the waiting time of the second customer is 8 - 2 = 6.\n    3) The third customer arrives at time 4 the chef takes his order and starts preparing it at time 8 and finishes at time 11 so the waiting time of the third customer is 11 - 4 = 7.\n    So the average waiting time = (2 + 6 + 7) / 3 = 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** customers = [[52][54][103][201]]\n    **Output:** 3.25000\n    **Explanation:** 1) The first customer arrives at time 5 the chef takes his order and starts preparing it immediately at time 5 and finishes at time 7 so the waiting time of the first customer is 7 - 5 = 2.\n    2) The second customer arrives at time 5 the chef takes his order and starts preparing it at time 7 and finishes at time 11 so the waiting time of the second customer is 11 - 5 = 6.\n    3) The third customer arrives at time 10 the chef takes his order and starts preparing it at time 11 and finishes at time 14 so the waiting time of the third customer is 14 - 10 = 4.\n    4) The fourth customer arrives at time 20 the chef takes his order and starts preparing it immediately at time 20 and finishes at time 21 so the waiting time of the fourth customer is 21 - 20 = 1.\n    So the average waiting time = (2 + 6 + 4 + 1) / 4 = 3.25.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= customers.length <= 105`\n  * `1 <= arrivali timei <= 104`\n  * `arrivali <= arrivali+1`\n\n,class Solution:\n    def averageWaitingTime(self customers: List[List[int]]) -> float:\n        start = customers[0][0]\n        end = start + customers[0][1]\n        total_wait = end - start\n        for c in customers[1:]:\n            start = c[0]\n            if start <= end:\n                end += c[1]\n                total_wait = total_wait + end - start\n            else:\n                end = c[0]+c[1]\n                total_wait += c[1]\n        return total_wait/len(customers)\n            \n    \n    \n    \n
Avoid Flood in The City,###  1488\. Avoid Flood in The City\n\nYour country has an infinite number of lakes. Initially all the lakes are\nempty but when it rains over the `nth` lake the `nth` lake becomes full of\nwater. If it rains over a lake that is **full of water**  there will be a\n**flood**. Your goal is to avoid floods in any lake.\n\nGiven an integer array `rains` where:\n\n  * `rains[i] > 0` means there will be rains over the `rains[i]` lake.\n  * `rains[i] == 0` means there are no rains this day and you can choose **one lake** this day and **dry it**.\n\nReturn _an array`ans`_ where:\n\n  * `ans.length == rains.length`\n  * `ans[i] == -1` if `rains[i] > 0`.\n  * `ans[i]` is the lake you choose to dry in the `ith` day if `rains[i] == 0`.\n\nIf there are multiple valid answers return **any** of them. If it is\nimpossible to avoid flood return **an empty array**.\n\nNotice that if you chose to dry a full lake it becomes empty but if you\nchose to dry an empty lake nothing changes.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rains = [1234]\n    **Output:** [-1-1-1-1]\n    **Explanation:** After the first day full lakes are [1]\n    After the second day full lakes are [12]\n    After the third day full lakes are [123]\n    After the fourth day full lakes are [1234]\n    There's no day to dry any lake and there is no flood in any lake.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rains = [120021]\n    **Output:** [-1-121-1-1]\n    **Explanation:** After the first day full lakes are [1]\n    After the second day full lakes are [12]\n    After the third day we dry lake 2. Full lakes are [1]\n    After the fourth day we dry lake 1. There is no full lakes.\n    After the fifth day full lakes are [2].\n    After the sixth day full lakes are [12].\n    It is easy that this scenario is flood-free. [-1-112-1-1] is another acceptable scenario.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** rains = [12012]\n    **Output:** []\n    **Explanation:** After the second day full lakes are  [12]. We have to dry one lake in the third day.\n    After that it will rain over lakes [12]. It's easy to prove that no matter which lake you choose to dry in the 3rd day the other one will flood.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rains.length <= 105`\n  * `0 <= rains[i] <= 109`\n\n,from bisect import bisect_left\n\nclass Solution:\n    def avoidFlood(self rains):\n        full_lakes dry_dates = {} []\n        ans = [-1] * len(rains)\n\n        for date rain_lake in enumerate(rains):\n            if rain_lake == 0:  # no rain we can dry one lake\n                dry_dates.append(date)  # keep dry date we'll decide later\n                continue\n\n            if rain_lake in full_lakes:  # the lake is already full\n                # BS find out earliest day we can use to dry that lake | greedy\n                dry_day = bisect_left(dry_dates full_lakes[rain_lake])\n\n                if dry_day >= len(dry_dates): return []  # can not find a date to dry this lake\n\n                ans[dry_dates.pop(dry_day)] = rain_lake  # dry this lake at the date we choose\n\n            # remember latest rain on this lake\n            full_lakes[rain_lake] = date\n\n        # we may have dry dates remain on these days rain > 0 we can not use -1 just choose day 1 to dry (maybe nothing happend)\n        for dry_day in dry_dates:\n            ans[dry_day] = 1\n\n        return ans\n
Backspace String Compare,"###  844\. Backspace String Compare\n\nGiven two strings `s` and `t` return `true` _if they are equal when both are\ntyped into empty text editors_. `'#'` means a backspace character.\n\nNote that after backspacing an empty text the text will continue empty.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ab#c"" t = ""ad#c""\n    **Output:** true\n    **Explanation:** Both s and t become ""ac"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""ab##"" t = ""c#d#""\n    **Output:** true\n    **Explanation:** Both s and t become """".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""a#c"" t = ""b""\n    **Output:** false\n    **Explanation:** s becomes ""c"" while t becomes ""b"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length t.length <= 200`\n  * `s` and `t` only contain lowercase letters and `'#'` characters.\n\n\n\n**Follow up:** Can you solve it in `O(n)` time and `O(1)` space?\n\n",class Solution:\n    def backspaceCompare(self s: str t: str) -> bool:\n        def backwardResult(string):\n            debt = 0\n            \n            for c in reversed(string):\n                if c == '#':\n                    debt += 1\n                \n                elif debt > 0:\n                    debt -= 1\n                \n                else:\n                    yield c\n        \n        return all(a == b for (a b) in zip_longest(backwardResult(s) backwardResult(t)))
Bag of Tokens,###  948\. Bag of Tokens\n\nYou have an initial **power** of `power` an initial **score** of `0` and a\nbag of `tokens` where `tokens[i]` is the value of the `ith` token (0-indexed).\n\nYour goal is to maximize your total **score** by potentially playing each\ntoken in one of two ways:\n\n  * If your current **power** is at least `tokens[i]` you may play the `ith` token face up losing `tokens[i]` **power** and gaining `1` **score**.\n  * If your current **score** is at least `1` you may play the `ith` token face down gaining `tokens[i]` **power** and losing `1` **score**.\n\nEach token may be played **at most** once and **in any order**. You do **not**\nhave to play all the tokens.\n\nReturn _the largest possible**score** you can achieve after playing any number\nof tokens_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** tokens = [100] power = 50\n    **Output:** 0\n    **Explanation****:** Playing the only token in the bag is impossible because you either have too little power or too little score.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** tokens = [100200] power = 150\n    **Output:** 1\n    **Explanation:** Play the 0th token (100) face up your power becomes 50 and score becomes 1.\n    There is no need to play the 1st token since you cannot play it face up to add to your score.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** tokens = [100200300400] power = 200\n    **Output:** 2\n    **Explanation:** Play the tokens in this order to get a score of 2:\n    1. Play the 0th token (100) face up your power becomes 100 and score becomes 1.\n    2. Play the 3rd token (400) face down your power becomes 500 and score becomes 0.\n    3. Play the 1st token (200) face up your power becomes 300 and score becomes 1.\n    4. Play the 2nd token (300) face up your power becomes 0 and score becomes 2.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= tokens.length <= 1000`\n  * `0 <= tokens[i] power < 104`\n\n,// Runtime: 51 ms (Top 88.07%) | Memory: 17.40 MB (Top 31.65%)\n\nclass Solution:\n    def bagOfTokensScore(self tokens: List[int] power: int) -> int:\n        tokens.sort()\n        ij=0len(tokens)-1\n        m=score=0\n        while i<j:\n            if tokens[i]>power and score==0:\n                break  \n            if tokens[i]<=power:\n                score+=1\n                power-=tokens[i]\n                m=max(mscore)\n                i+=1\n            else:\n                if score>0:\n                    score-=1\n                    power+=tokens[j]\n                    j-=1\n        if i<len(tokens) and tokens[i]<=power:\n            score+=1\n            m=max(mscore)\n        return m\n
Balance a Binary Search Tree,###  1382\. Balance a Binary Search Tree\n\nGiven the `root` of a binary search tree return _a**balanced** binary search\ntree with the same node values_. If there is more than one answer return\n**any of them**.\n\nA binary search tree is **balanced** if the depth of the two subtrees of every\nnode never differs by more than `1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg)\n\n    \n    \n    **Input:** root = [1null2null3null4nullnull]\n    **Output:** [213nullnullnull4]\n    **Explanation:** This is not the only correct answer [314null2] is also correct.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/08/10/balanced2-tree.jpg)\n\n    \n    \n    **Input:** root = [213]\n    **Output:** [213]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `1 <= Node.val <= 105`\n\n,"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def balanceBST(self root):\n        """"""\n        :type root: TreeNode\n        :rtype: TreeNode\n        """"""\n        arr = []\n        self.flatTree(root arr)\n        return self.createTree(arr 0 len(arr))\n    \n    def flatTree(self root arr):\n        if not root:\n            return\n        self.flatTree(root.left arr)\n        arr.append(root)\n        self.flatTree(root.right arr)\n    \n    def createTree(self arr start length):\n        if length == 0:\n            return None\n        root = arr[start + length / 2]\n        root.left = self.createTree(arr start length / 2)\n        root.right = self.createTree(arr start + length / 2 + 1 length - length / 2 - 1)\n        return root\n"
Balanced Binary Tree,###  110\. Balanced Binary Tree\n\nGiven a binary tree determine if it is height-balanced.\n\nFor this problem a height-balanced binary tree is defined as:\n\n> a binary tree in which the left and right subtrees of _every_ node differ in\n> height by no more than 1.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\n\n    \n    \n    **Input:** root = [3920nullnull157]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)\n\n    \n    \n    **Input:** root = [12233nullnull44]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = []\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 5000]`.\n  * `-104 <= Node.val <= 104`\n\n,# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self val=0 left=None right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nclass Solution:\n    def isBalanced(self root: TreeNode) -> bool:\n\n        # Initialize the result to True\n        res = True\n\n        # DFS through the tree\n        def dfs(node i):\n            nonlocal res\n\n            # If there isn't a node return previous depth\n            if not node:\n                return i - 1\n\n            # Check depths of the left and right subtrees\n            left right = dfs(node.left i + 1) dfs(node.right i + 1)\n\n            # If they are more than 1 difference save False to the result\n            if abs(right - left) > 1:\n                res = False\n\n            # Return the max depth of both subtrees\n            return max(left right)\n\n        dfs(root 0)\n\n        return res\n
Basic Calculator,"###  224\. Basic Calculator\n\nGiven a string `s` representing a valid expression implement a basic\ncalculator to evaluate it and return _the result of the evaluation_.\n\n**Note:** You are **not** allowed to use any built-in function which evaluates\nstrings as mathematical expressions such as `eval()`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""1 + 1""\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = "" 2-1 + 2 ""\n    **Output:** 3\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""(1+(4+5+2)-3)+(6+8)""\n    **Output:** 23\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 3 * 105`\n  * `s` consists of digits `'+'` `'-'` `'('` `')'` and `' '`.\n  * `s` represents a valid expression.\n  * `'+'` is **not** used as a unary operation (i.e. `""+1""` and `""+(2 + 3)""` is invalid).\n  * `'-'` could be used as a unary operation (i.e. `""-1""` and `""-(2 + 3)""` is valid).\n  * There will be no two consecutive operators in the input.\n  * Every number and running calculation will fit in a signed 32-bit integer.\n\n",# Runtime: 137 ms (Top 57.95%) | Memory: 15.5 MB (Top 50.78%)\n\n```class Solution:\n    def calculate(self s: str) -> int:\n        curroutputsignstack = 001[]\n\n        for ch in s:\n            if ch.isdigit():\n                curr = curr * 10 + int(ch)\n\n            elif ch == '+':\n                output += sign * curr\n                sign = 1\n                curr = 0\n\n            elif ch == '-':\n                output += sign * curr\n                sign = -1\n                curr = 0\n\n            elif ch == '(':\n                #push the result and then the sign\n                stack.append(output)\n                stack.append(sign)\n                sign = 1\n                output = 0\n\n            elif ch == ')':\n                output += sign * curr\n                output *= stack.pop()\n                output += stack.pop()\n                curr = 0\n        return output + sign*curr``
Basic Calculator II,"###  227\. Basic Calculator II\n\nGiven a string `s` which represents an expression _evaluate this expression\nand return its value_.\n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate\nresults will be in the range of `[-231 231 - 1]`.\n\n**Note:** You are not allowed to use any built-in function which evaluates\nstrings as mathematical expressions such as `eval()`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""3+2*2""\n    **Output:** 7\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = "" 3/2 ""\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = "" 3+5 / 2 ""\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 3 * 105`\n  * `s` consists of integers and operators `('+' '-' '*' '/')` separated by some number of spaces.\n  * `s` represents **a valid expression**.\n  * All the integers in the expression are non-negative integers in the range `[0 231 - 1]`.\n  * The answer is **guaranteed** to fit in a **32-bit integer**.\n\n",# Runtime: 201 ms (Top 18.42%) | Memory: 15.8 MB (Top 36.40%)\nclass Solution:\n    def calculate(self s: str) -> int:\n        stack = []\n        currentNumber = 0\n        operator = '+'\n        operations = '+-/*'\n        for i in range(len(s)):\n            ch = s[i]\n            if ch.isdigit():\n                currentNumber = currentNumber * 10 + int(ch)\n\n            if ch in operations or i == len(s) - 1:\n                if operator == '+':\n                    stack.append(currentNumber)\n\n                elif operator == '-':\n                    stack.append(-currentNumber)\n\n                elif operator == '*':\n                    stack.append(stack.pop() * currentNumber)\n\n                elif operator == '/':\n                    stack.append(int(stack.pop()/currentNumber))\n\n                currentNumber =0\n                operator = ch\n\n        return sum(stack)\n
Basic Calculator IV,"###  770\. Basic Calculator IV\n\nGiven an expression such as `expression = ""e + 8 - a + 5""` and an evaluation\nmap such as `{""e"": 1}` (given in terms of `evalvars = [""e""]` and `evalints =\n[1]`) return a list of tokens representing the simplified expression such as\n`[""-1*a""""14""]`\n\n  * An expression alternates chunks and symbols with a space separating each chunk and symbol.\n  * A chunk is either an expression in parentheses a variable or a non-negative integer.\n  * A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters and note that variables never have a leading coefficient or unary operator like `""2x""` or `""-x""`.\n\nExpressions are evaluated in the usual order: brackets first then\nmultiplication then addition and subtraction.\n\n  * For example `expression = ""1 + 2 * 3""` has an answer of `[""7""]`.\n\nThe format of the output is as follows:\n\n  * For each term of free variables with a non-zero coefficient we write the free variables within a term in sorted order lexicographically. \n    * For example we would never write a term like `""b*a*c""` only `""a*b*c""`.\n  * Terms have degrees equal to the number of free variables being multiplied counting multiplicity. We write the largest degree terms of our answer first breaking ties by lexicographic order ignoring the leading coefficient of the term. \n    * For example `""a*a*b*c""` has degree `4`.\n  * The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.\n  * An example of a well-formatted answer is `[""-2*a*a*a"" ""3*a*a*b"" ""3*b*b"" ""4*a"" ""5*c"" ""-6""]`.\n  * Terms (including constant terms) with coefficient `0` are not included. \n    * For example an expression of `""0""` has an output of `[]`.\n\n**Note:** You may assume that the given expression is always valid. All\nintermediate results will be in the range of `[-231 231 - 1]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** expression = ""e + 8 - a + 5"" evalvars = [""e""] evalints = [1]\n    **Output:** [""-1*a""""14""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** expression = ""e - 8 + temperature - pressure"" evalvars = [""e"" ""temperature""] evalints = [1 12]\n    **Output:** [""-1*pressure""""5""]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** expression = ""(e + 8) * (e - 8)"" evalvars = [] evalints = []\n    **Output:** [""1*e*e""""-64""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= expression.length <= 250`\n  * `expression` consists of lowercase English letters digits `'+'` `'-'` `'*'` `'('` `')'` `' '`.\n  * `expression` does not contain any leading or trailing spaces.\n  * All the tokens in `expression` are separated by a single space.\n  * `0 <= evalvars.length <= 100`\n  * `1 <= evalvars[i].length <= 20`\n  * `evalvars[i]` consists of lowercase English letters.\n  * `evalints.length == evalvars.length`\n  * `-100 <= evalints[i] <= 100`\n\n","# Runtime: 62 ms (Top 83.61%) | Memory: 14.1 MB (Top 62.30%)\nclass Term:\n    def __init__(self exp: Optional[str]='' * term: Optional[Mapping[str int]]={}) -> None:\n        self.d = defaultdict(int **term)\n        if re.match(r'^\-?\d+$' exp):\n            self.d[''] += int(exp)\n        elif exp:\n            self.d[exp] += 1\n\n    def __add__(self other: 'Term') -> 'Term':\n        return self._pm(other add=True)\n\n    def __mul__(self other: 'Term') -> 'Term':\n        res = defaultdict(int)\n        for (l_var l_coef) (r_var r_coef) in product(self.d.items() other.d.items()):\n            res['*'.join(sorted(self._exp(l_var)+self._exp(r_var)))] += l_coef*r_coef\n        return Term(term=res)\n\n    def __sub__(self other: 'Term') -> 'Term':\n        return self._pm(other add=False)\n\n    def get(self) -> List[str]:\n        return [str(coef)+'*'*bool(var)+var \\n                for var coef in sorted(self.d.items() key=lambda t: (-len(self._exp(t[0])) t[0])) if coef]\n\n    def _exp(self var: str) -> List[str]:\n        return list(filter(bool var.split('*')))\n\n    def _pm(self other: 'Term' * add: bool) -> 'Term':\n        res = copy.copy(self.d)\n        for var coef in other.d.items():\n            res[var] += coef*(-1)**(1-add)\n        return Term(term=res)\n\nclass Solution:\n    def basicCalculatorIV(self expression: str evalvars: List[str] evalints: List[int]) -> List[str]:\n        vals = dict(zip(evalvars evalints))\n        return eval(re.sub(r'[a-z0-9]+' lambda m: ""Term('""+str(vals.get(m.group() m.group()))+""')"" expression)).get()"
Battleships in a Board,"###  419\. Battleships in a Board\n\nGiven an `m x n` matrix `board` where each cell is a battleship `'X'` or empty\n`'.'` return _the number of the**battleships** on_ `board`.\n\n**Battleships** can only be placed horizontally or vertically on `board`. In\nother words they can only be made of the shape `1 x k` (`1` row `k` columns)\nor `k x 1` (`k` rows `1` column) where `k` can be of any size. At least one\nhorizontal or vertical cell separates between two battleships (i.e. there are\nno adjacent battleships).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/10/battelship-grid.jpg)\n\n    \n    \n    **Input:** board = [[""X""""."""".""""X""]["".""""."""".""""X""]["".""""."""".""""X""]]\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** board = [["".""]]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `m == board.length`\n  * `n == board[i].length`\n  * `1 <= m n <= 200`\n  * `board[i][j]` is either `'.'` or `'X'`.\n\n\n\n**Follow up:** Could you do it in one-pass using only `O(1)` extra memory and\nwithout modifying the values `board`?\n\n",class Solution:\n    def countBattleships(self board: List[List[str]]) -> int:\n        \n        m = len(board)\n        n = len(board[0])\n        res = 0\n        \n        pole = [ [True for i in range(n)] for j in range(m) ]\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'X' and pole[i][j]:\n                    for z in range(i+1 m):\n                        if board[z][j] == 'X':\n                            pole[z][j] = False\n                        else:\n                            break\n                            \n                    for z in range(j+1 n):\n                        if board[i][z] == 'X':\n                            pole[i][z] = False\n                        else:\n                            break\n                    \n                    \n                    res += 1\n                \n\n        \n        return res\n
Beautiful Arrangement,###  526\. Beautiful Arrangement\n\nSuppose you have `n` integers labeled `1` through `n`. A permutation of those\n`n` integers `perm` (**1-indexed**) is considered a **beautiful arrangement**\nif for every `i` (`1 <= i <= n`) **either** of the following is true:\n\n  * `perm[i]` is divisible by `i`.\n  * `i` is divisible by `perm[i]`.\n\nGiven an integer `n` return _the**number** of the **beautiful arrangements**\nthat you can construct_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 2\n    **Explanation:** \n    The first beautiful arrangement is [12]:\n        - perm[1] = 1 is divisible by i = 1\n        - perm[2] = 2 is divisible by i = 2\n    The second beautiful arrangement is [21]:\n        - perm[1] = 2 is divisible by i = 1\n        - i = 2 is divisible by perm[2] = 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 15`\n\n,class Solution:\n    def countArrangement(self n: int) -> int:\n        self.count = 0\n        self.backtrack(n 1 [])\n        return self.count\n        \n    def backtrack(self N idx temp):\n        if len(temp) == N:\n            self.count += 1\n            return\n        \n        for i in range(1 N+1):\n            if i not in temp and (i % idx == 0 or idx % i == 0):\n                temp.append(i)\n                self.backtrack(N idx+1 temp)\n                temp.pop()
Beautiful Arrangement II,###  667\. Beautiful Arrangement II\n\nGiven two integers `n` and `k` construct a list `answer` that contains `n`\ndifferent positive integers ranging from `1` to `n` and obeys the following\nrequirement:\n\n  * Suppose this list is `answer = [a1 a2 a3 ...  an]` then the list `[|a1 - a2| |a2 - a3| |a3 - a4| ...  |an-1 - an|]` has exactly `k` distinct integers.\n\nReturn _the list_ `answer`. If there multiple valid answers return **any of\nthem**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 k = 1\n    **Output:** [123]\n    Explanation: The [123] has three different positive integers ranging from 1 to 3 and the [11] has exactly 1 distinct integer: 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3 k = 2\n    **Output:** [132]\n    Explanation: The [132] has three different positive integers ranging from 1 to 3 and the [21] has exactly 2 distinct integers: 1 and 2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k < n <= 104`\n\n,class Solution:\n    def constructArray(self n: int k: int) -> List[int]:\n        # n = 8 k = 5\n        # 1 2 3 8 4 7 5 6\n        # 1 1 5 4 3 2 1\n        res = list(range(1n-k+1))\n        sign val = 1 k\n        for i in range(k):\n            res.append(res[-1]+sign*val)\n            sign *= -1\n            val -= 1\n        return res\n
Beautiful Array,###  932\. Beautiful Array\n\nAn array `nums` of length `n` is **beautiful** if:\n\n  * `nums` is a permutation of the integers in the range `[1 n]`.\n  * For every `0 <= i < j < n` there is no index `k` with `i < k < j` where `2 * nums[k] == nums[i] + nums[j]`.\n\nGiven the integer `n` return _any**beautiful** array _`nums` _of length_`n`.\nThere will be at least one valid answer for the given `n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** [2143]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** [31254]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n\n,from itertools import permutations\nclass Solution:\n    def invalid(self x):\n        n = len(x)\n        flag = False\n        for i in range(n):\n            if flag: break\n            for j in range(i+2 n):\n                if flag: break\n                for k in range(i+1 j):\n                    if 2*x[k] == x[i]+x[j]: flag = True; break\n        return flag\n        \n    def beautifulArray(self n: int) -> List[int]:\n        for perm in permutations(range(1 n+1)):\n            if not self.invalid(perm):\n                return perm\n
Best Poker Hand,"###  2347\. Best Poker Hand\n\nYou are given an integer array `ranks` and a character array `suits`. You have\n`5` cards where the `ith` card has a rank of `ranks[i]` and a suit of\n`suits[i]`.\n\nThe following are the types of **poker hands** you can make from best to\nworst:\n\n  1. `""Flush""`: Five cards of the same suit.\n  2. `""Three of a Kind""`: Three cards of the same rank.\n  3. `""Pair""`: Two cards of the same rank.\n  4. `""High Card""`: Any single card.\n\nReturn _a string representing the**best** type of **poker hand** you can make\nwith the given cards._\n\n**Note** that the return values are **case-sensitive**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** ranks = [132319] suits = [""a""""a""""a""""a""""a""]\n    **Output:** ""Flush""\n    **Explanation:** The hand with all the cards consists of 5 cards with the same suit so we have a ""Flush"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** ranks = [44244] suits = [""d""""a""""a""""b""""c""]\n    **Output:** ""Three of a Kind""\n    **Explanation:** The hand with the first second and fourth card consists of 3 cards with the same rank so we have a ""Three of a Kind"".\n    Note that we could also make a ""Pair"" hand but ""Three of a Kind"" is a better hand.\n    Also note that other cards could be used to make the ""Three of a Kind"" hand.\n\n**Example 3:**\n\n    \n    \n    **Input:** ranks = [10102129] suits = [""a""""b""""c""""a""""d""]\n    **Output:** ""Pair""\n    **Explanation:** The hand with the first and second card consists of 2 cards with the same rank so we have a ""Pair"".\n    Note that we cannot make a ""Flush"" or a ""Three of a Kind"".\n    \n\n\n\n**Constraints:**\n\n  * `ranks.length == suits.length == 5`\n  * `1 <= ranks[i] <= 13`\n  * `'a' <= suits[i] <= 'd'`\n  * No two cards have the same rank and suit.\n\n","# Runtime: 38 ms (Top 59.18%) | Memory: 13.9 MB (Top 14.06%)\nclass Solution:\n    def bestHand(self ranks: List[int] suits: List[str]) -> str:\n        s={}\n        for i in suits:\n            if i in s:\n                s[i]+=1\n                if s[i]==5:\n                    return 'Flush'\n            else:\n                s[i]=1\n        r={}\n        max_ = 0\n        for i in ranks:\n            if i in r:\n                r[i]+=1\n                max_=max(max_r[i])\n            else:\n                r[i]=1\n        if max_>=3:\n            return ""Three of a Kind""\n        elif max_==2:\n            return ""Pair""\n        else:\n            return ""High Card"""
Best Position for a Service Centre,###  1515\. Best Position for a Service Centre\n\nA delivery company wants to build a new service center in a new city. The\ncompany knows the positions of all the customers in this city on a 2D-Map and\nwants to build the new center in a position such that **the sum of the\neuclidean distances to all customers is minimum**.\n\nGiven an array `positions` where `positions[i] = [xi yi]` is the position of\nthe `ith` customer on the map return _the minimum sum of the euclidean\ndistances_ to all customers.\n\nIn other words you need to choose the position of the service center\n`[xcentre ycentre]` such that the following formula is minimized:\n\n![](https://assets.leetcode.com/uploads/2020/06/25/q4_edited.jpg)\n\nAnswers within `10-5` of the actual value will be accepted.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/06/25/q4_e1.jpg)\n\n    \n    \n    **Input:** positions = [[01][10][12][21]]\n    **Output:** 4.00000\n    **Explanation:** As shown you can see that choosing [xcentre ycentre] = [1 1] will make the distance to each customer = 1 the sum of all distances is 4 which is the minimum possible we can achieve.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/06/25/q4_e3.jpg)\n\n    \n    \n    **Input:** positions = [[11][33]]\n    **Output:** 2.82843\n    **Explanation:** The minimum possible sum of distances = sqrt(2) + sqrt(2) = 2.82843\n    \n\n\n\n**Constraints:**\n\n  * `1 <= positions.length <= 50`\n  * `positions[i].length == 2`\n  * `0 <= xi yi <= 100`\n\n,class Solution:\n    def getMinDistSum(self positions: List[List[int]]) -> float:\n        n = len(positions)\n        if n == 1: return 0\n        def gradient(xy):\n            ans = [00]\n            for i in range(n):\n                denom = math.sqrt(pow(x-positions[i][0]2)+pow(y-positions[i][1]2))\n                ans[0] += (x-positions[i][0])/denom if denom else 0\n                ans[1] += (y-positions[i][1])/denom if denom else 0\n            return ans\n        def fn(x y):\n            res = 0\n            for i in range(n):\n                res += math.sqrt(pow(x-positions[i][0]2)+pow(y-positions[i][1]2))\n            return res\n        x = sum(x for x_ in positions)/n\n        y = sum(y for _y in positions)/n\n        lr = 1\n        while lr > 1e-7:\n            dx dy = gradient(xy)\n            x -= lr*dx\n            y -= lr*dy\n            lr *= 0.997\n            if not dx and not dy:\n                lr /= 2\n        return fn(xy)
Best Sightseeing Pair,###  1014\. Best Sightseeing Pair\n\nYou are given an integer array `values` where values[i] represents the value\nof the `ith` sightseeing spot. Two sightseeing spots `i` and `j` have a\n**distance** `j - i` between them.\n\nThe score of a pair (`i < j`) of sightseeing spots is `values[i] + values[j] +\ni - j`: the sum of the values of the sightseeing spots minus the distance\nbetween them.\n\nReturn _the maximum score of a pair of sightseeing spots_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** values = [81526]\n    **Output:** 11\n    **Explanation:** i = 0 j = 2 values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** values = [12]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `2 <= values.length <= 5 * 104`\n  * `1 <= values[i] <= 1000`\n\n,"class Solution:\n    """"""\n    Approach: \n    O(n^2) is very straight forward\n    For all the possible pairs\n    for i in range(n)\n      for j in range(i+1 n)\n         value[i] = max(value[i] value[i] + value[j] + i - j`)\n    \n    we can do this problem in O(n) as well\n    values = [8 1 5 2 6]\n    max_val = [0 0 0 0 0]\n    max_val[i] = max(max_val[i-1]-1 values[i-1]-1)\n    we have to do it once from left side and then from right side\n    """"""\n    def maxScoreSightseeingPair(self values: List[int]) -> int:\n        left_max_vals = [float('-inf') for _ in range(len(values))]\n        right_max_vals = [float('-inf') for _ in range(len(values))]\n        \n        for i in range(1 len(values)):\n            left_max_vals[i] = max(left_max_vals[i-1]-1 values[i-1]-1)\n            \n        for i in range(len(values)-2 -1 -1):\n            right_max_vals[i] = max(right_max_vals[i+1]-1 values[i+1]-1)\n        \n        max_pair = float('-inf')\n        for i in range(len(values)):\n            max_pair = max(max_pair values[i] + max(left_max_vals[i] right_max_vals[i]))\n        return max_pair\n"
Best Team With No Conflicts,###  1626\. Best Team With No Conflicts\n\nYou are the manager of a basketball team. For the upcoming tournament you\nwant to choose the team with the highest overall score. The score of the team\nis the **sum** of scores of all the players in the team.\n\nHowever the basketball team is not allowed to have **conflicts**. A\n**conflict** exists if a younger player has a **strictly higher** score than\nan older player. A conflict does **not** occur between players of the same\nage.\n\nGiven two lists `scores` and `ages` where each `scores[i]` and `ages[i]`\nrepresents the score and age of the `ith` player respectively return _the\nhighest overall score of all possible basketball teams_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** scores = [1351015] ages = [12345]\n    **Output:** 34\n    **Explanation:**  You can choose all the players.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** scores = [4565] ages = [2121]\n    **Output:** 16\n    **Explanation:**  It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** scores = [1235] ages = [89101]\n    **Output:** 6\n    **Explanation:**  It is best to choose the first 3 players. \n    \n\n\n\n**Constraints:**\n\n  * `1 <= scores.length ages.length <= 1000`\n  * `scores.length == ages.length`\n  * `1 <= scores[i] <= 106`\n  * `1 <= ages[i] <= 1000`\n\n,"# Runtime: 5727 ms (Top 5.11%) | Memory: 14.3 MB (Top 62.50%)\nclass Solution(object):\n    def bestTeamScore(self scores ages):\n        """"""\n        :type scores: List[int]\n        :type ages: List[int]\n        :rtype: int\n        """"""\n        l = len(scores)\n        mapped = [[ages[i] scores[i]] for i in range(l)]\n        mapped = sorted(mapped key = lambda x : (x[0] x[1]))\n        dp = [i[1] for i in mapped]\n\n        for i in range(l):\n            for j in range(0 i):\n                if mapped[j][1] <= mapped[i][1]:\n                    dp[i] = max(dp[i] mapped[i][1] + dp[j])\n                elif mapped[i][0] == mapped[j][0]:\n                    dp[i] = max(dp[i] mapped[i][1] + dp[j])\n\n        return max(dp)"
Best Time to Buy and Sell Stock,###  121\. Best Time to Buy and Sell Stock\n\nYou are given an array `prices` where `prices[i]` is the price of a given\nstock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock\nand choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you\ncannot achieve any profit return `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** prices = [715364]\n    **Output:** 5\n    **Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6) profit = 6-1 = 5.\n    Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** prices = [76431]\n    **Output:** 0\n    **Explanation:** In this case no transactions are done and the max profit = 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= prices.length <= 105`\n  * `0 <= prices[i] <= 104`\n\n,# Runtime: 2509 ms (Top 5.01%) | Memory: 25 MB (Top 86.17%)\n\nclass Solution:\n    def maxProfit(selfprices):\n        left = 0 #Buy\n        right = 1 #Sell\n        max_profit = 0\n        while right < len(prices):\n            currentProfit = prices[right] - prices[left] #our current Profit\n            if prices[left] < prices[right]:\n                max_profit =max(currentProfitmax_profit)\n            else:\n                left = right\n            right += 1\n        return max_profit
Best Time to Buy and Sell Stock II,###  122\. Best Time to Buy and Sell Stock II\n\nYou are given an integer array `prices` where `prices[i]` is the price of a\ngiven stock on the `ith` day.\n\nOn each day you may decide to buy and/or sell the stock. You can only hold\n**at most one** share of the stock at any time. However you can buy it then\nimmediately sell it on the **same day**.\n\nFind and return _the**maximum** profit you can achieve_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** prices = [715364]\n    **Output:** 7\n    **Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5) profit = 5-1 = 4.\n    Then buy on day 4 (price = 3) and sell on day 5 (price = 6) profit = 6-3 = 3.\n    Total profit is 4 + 3 = 7.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** prices = [12345]\n    **Output:** 4\n    **Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5) profit = 5-1 = 4.\n    Total profit is 4.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** prices = [76431]\n    **Output:** 0\n    **Explanation:** There is no way to make a positive profit so we never buy the stock to achieve the maximum profit of 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= prices.length <= 3 * 104`\n  * `0 <= prices[i] <= 104`\n\n,"\nclass Solution:\n    def maxProfit(self prices: List[int]) -> int:\n        n=len(prices)\n        ans=0\n        want=""valley""\n        for i in range(n-1):\n            if want==""valley"" and prices[i]<prices[i+1]:\n                ans-=prices[i]\n                want=""hill""\n            elif want==""hill"" and prices[i]>prices[i+1]:\n                ans+=prices[i]\n                want=""valley""\n        if want==""hill"":\n            ans+=prices[-1]\n        return ans\n"
Best Time to Buy and Sell Stock III,###  123\. Best Time to Buy and Sell Stock III\n\nYou are given an array `prices` where `prices[i]` is the price of a given\nstock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete **at most two\ntransactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e.\nyou must sell the stock before you buy again).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** prices = [33500314]\n    **Output:** 6\n    **Explanation:** Buy on day 4 (price = 0) and sell on day 6 (price = 3) profit = 3-0 = 3.\n    Then buy on day 7 (price = 1) and sell on day 8 (price = 4) profit = 4-1 = 3.\n\n**Example 2:**\n\n    \n    \n    **Input:** prices = [12345]\n    **Output:** 4\n    **Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5) profit = 5-1 = 4.\n    Note that you cannot buy on day 1 buy on day 2 and sell them later as you are engaging multiple transactions at the same time. You must sell before buying again.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** prices = [76431]\n    **Output:** 0\n    **Explanation:** In this case no transaction is done i.e. max profit = 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= prices.length <= 105`\n  * `0 <= prices[i] <= 105`\n\n,class Solution:\n    def maxProfit(self prices: List[int]) -> int:\n        buy1 sell1 buy2 sell2 = -inf0-inf0\n        for price in prices:\n            buy1 = max(buy1-price)\n            sell1 = max(sell1price+buy1)\n            \n            buy2 = max(buy2sell1-price)\n            sell2 = max(sell2price+buy2)\n        return sell2\n
Best Time to Buy and Sell Stock IV,###  188\. Best Time to Buy and Sell Stock IV\n\nYou are given an integer array `prices` where `prices[i]` is the price of a\ngiven stock on the `ith` day and an integer `k`.\n\nFind the maximum profit you can achieve. You may complete at most `k`\ntransactions.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e.\nyou must sell the stock before you buy again).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** k = 2 prices = [241]\n    **Output:** 2\n    **Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4) profit = 4-2 = 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** k = 2 prices = [326503]\n    **Output:** 7\n    **Explanation:** Buy on day 2 (price = 2) and sell on day 3 (price = 6) profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3) profit = 3-0 = 3.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= k <= 100`\n  * `0 <= prices.length <= 1000`\n  * `0 <= prices[i] <= 1000`\n\n,class Solution:\n    def maxProfit(self k: int prices: List[int]) -> int:\n        buy = [-inf] * (k+1)\n        sell = [0] * (k+1)\n        for price in prices:\n            for i in range(1k+1):\n                    buy[i] = max(buy[i]sell[i-1]-price)\n                    sell[i] = max(sell[i]buy[i]+price)\n        return sell[-1]\n
Best Time to Buy and Sell Stock with Cooldown,###  309\. Best Time to Buy and Sell Stock with Cooldown\n\nYou are given an array `prices` where `prices[i]` is the price of a given\nstock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete as many transactions\nas you like (i.e. buy one and sell one share of the stock multiple times)\nwith the following restrictions:\n\n  * After you sell your stock you cannot buy stock on the next day (i.e. cooldown one day).\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e.\nyou must sell the stock before you buy again).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** prices = [12302]\n    **Output:** 3\n    **Explanation:** transactions = [buy sell cooldown buy sell]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** prices = [1]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= prices.length <= 5000`\n  * `0 <= prices[i] <= 1000`\n\n,class Solution:\n    def maxProfit(self prices: List[int]) -> int:\n        \n        \n        cache = {}\n        def dfs(i buying):\n            \n            if i >= len(prices):\n                return 0\n            \n            if (i buying) in cache:\n                return cache[(i buying)]\n            \n            if buying:\n                # if have sell the share in previous step\n                # then currently we have two options\n                # either buy or not buy(cooldown)\n                \n                # we have bought so increment the index and set buying flag to not buying\n                # and don't forget that we bought so we have to reduce that share amount from profit\n                buy = dfs(i+1 not buying) - prices[i] \n                \n                cooldown = dfs(i+1 buying)\n                \n                profit = max( buy cooldown )\n                cache[(i buying)] = profit\n                \n            else:\n                # we have sell the share so \n                # we cannot buy next share we have to skip the next price(cooldown for one day)\n                # set (not buying) flag to buying\n                # we also have to add that share price to profit\n                sell = dfs(i+2 not buying) + prices[i] \n                \n                cooldown = dfs(i+1 buying)\n                \n                profit = max( sell cooldown )\n                cache[(i buying)] = profit\n                \n            return cache[(i  buying)]\n        \n        return dfs(0 True)\n\n
Best Time to Buy and Sell Stock with Transaction Fee,###  714\. Best Time to Buy and Sell Stock with Transaction Fee\n\nYou are given an array `prices` where `prices[i]` is the price of a given\nstock on the `ith` day and an integer `fee` representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions\nas you like but you need to pay the transaction fee for each transaction.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e.\nyou must sell the stock before you buy again).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** prices = [132849] fee = 2\n    **Output:** 8\n    **Explanation:** The maximum profit can be achieved by:\n    - Buying at prices[0] = 1\n    - Selling at prices[3] = 8\n    - Buying at prices[4] = 4\n    - Selling at prices[5] = 9\n    The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** prices = [1375103] fee = 3\n    **Output:** 6\n    \n\n\n\n**Constraints:**\n\n  * `1 <= prices.length <= 5 * 104`\n  * `1 <= prices[i] < 5 * 104`\n  * `0 <= fee < 5 * 104`\n\n,class Solution:\n    def maxProfit(self prices: List[int] fee: int) -> int:\n        n = len(prices)\n        lookup = {}\n        def f(ind buy lookup):\n            \n            if ind == n: return 0\n            \n            if (ind buy) in lookup: return lookup[(ind buy)]\n            profit = 0\n            if buy:\n                profit = max(-prices[ind] + f(ind+10lookup) f(ind+1 1lookup))\n            else:\n                profit = max(prices[ind] + f(ind+11lookup) - fee f(ind+1 0lookup))\n                \n            lookup[(indbuy)] = profit\n            return lookup[(indbuy)]\n        \n        return f(0 1lookup)\n\n
Binary Gap,"###  868\. Binary Gap\n\nGiven a positive integer `n` find and return _the**longest distance** between\nany two **adjacent** _`1` _'s in the binary representation of_`n` _. If there\nare no two adjacent_`1` _'s return_`0` _._\n\nTwo `1`'s are **adjacent** if there are only `0`'s separating them (possibly\nno `0`'s). The **distance** between two `1`'s is the absolute difference\nbetween their bit positions. For example the two `1`'s in `""1001""` have a\ndistance of 3.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 22\n    **Output:** 2\n    **Explanation:** 22 in binary is ""10110"".\n    The first adjacent pair of 1's is ""_1_ 0 _1_ 10"" with a distance of 2.\n    The second adjacent pair of 1's is ""10 _11_ 0"" with a distance of 1.\n    The answer is the largest of these two distances which is 2.\n    Note that ""_1_ 01 _1_ 0"" is not a valid pair since there is a 1 separating the two 1's underlined.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 8\n    **Output:** 0\n    **Explanation:** 8 in binary is ""1000"".\n    There are not any adjacent pairs of 1's in the binary representation of 8 so we return 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** 2\n    **Explanation:** 5 in binary is ""101"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n\n","class Solution:\n    def binaryGap(self n: int) -> int:\n        prev = 0\n        res = 0\n        for i d in enumerate(bin(n)[3:]):\n            if d == ""1"":\n                res = max(res i-prev+1)\n                prev = i + 1\n        return res\n"
Binary Number with Alternating Bits,###  693\. Binary Number with Alternating Bits\n\nGiven a positive integer check whether it has alternating bits: namely if\ntwo adjacent bits will always have different values.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** true\n    **Explanation:** The binary representation of 5 is: 101\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 7\n    **Output:** false\n    **Explanation:** The binary representation of 7 is: 111.\n\n**Example 3:**\n\n    \n    \n    **Input:** n = 11\n    **Output:** false\n    **Explanation:** The binary representation of 11 is: 1011.\n\n\n\n**Constraints:**\n\n  * `1 <= n <= 231 - 1`\n\n,class Solution:\n    def hasAlternatingBits(self n: int) -> bool:\n        bin_n = bin(n)[2:]\n        for i in range(len(bin_n)-1):\n            if bin_n[i] == '0' and bin_n[i+1] == '0':\n                return False\n            \n            if bin_n[i] == '1' and bin_n[i+1] == '1':\n                return False\n            \n        return True\n\n
Binary Search Tree Iterator,"###  173\. Binary Search Tree Iterator\n\nImplement the `BSTIterator` class that represents an iterator over the **[in-\norder traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-\norder_\(LNR\))** of a binary search tree (BST):\n\n  * `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\n  * `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer otherwise returns `false`.\n  * `int next()` Moves the pointer to the right then returns the number at the pointer.\n\nNotice that by initializing the pointer to a non-existent smallest number the\nfirst call to `next()` will return the smallest element in the BST.\n\nYou may assume that `next()` calls will always be valid. That is there will\nbe at least a next number in the in-order traversal when `next()` is called.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)\n\n    \n    \n    **Input**\n    [""BSTIterator"" ""next"" ""next"" ""hasNext"" ""next"" ""hasNext"" ""next"" ""hasNext"" ""next"" ""hasNext""]\n    [[[7 3 15 null null 9 20]] [] [] [] [] [] [] [] [] []]\n    **Output**\n    [null 3 7 true 9 true 15 true 20 false]\n    \n    **Explanation**\n    BSTIterator bSTIterator = new BSTIterator([7 3 15 null null 9 20]);\n    bSTIterator.next();    // return 3\n    bSTIterator.next();    // return 7\n    bSTIterator.hasNext(); // return True\n    bSTIterator.next();    // return 9\n    bSTIterator.hasNext(); // return True\n    bSTIterator.next();    // return 15\n    bSTIterator.hasNext(); // return True\n    bSTIterator.next();    // return 20\n    bSTIterator.hasNext(); // return False\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 105]`.\n  * `0 <= Node.val <= 106`\n  * At most `105` calls will be made to `hasNext` and `next`.\n\n\n\n**Follow up:**\n\n  * Could you implement `next()` and `hasNext()` to run in average `O(1)` time and use `O(h)` memory where `h` is the height of the tree?\n\n",# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass BSTIterator:\n\n    def __init__(self root: Optional[TreeNode]):\n        self.root=root\n        self.tree=[]#list to store the inorder traversal\n        def inorder(node):\n            if not node:\n                return\n            inorder(node.left)\n            self.tree.append(node.val)\n            inorder(node.right)\n            return\n        inorder(self.root)\n        self.i=0\n        \n\n    def next(self) -> int:\n        self.i+=1\n        return self.tree[self.i-1]\n\n    def hasNext(self) -> bool:\n        return self.i-1<len(self.tree)-1\n\n\n# Your BSTIterator object will be instantiated and called as such:\n# obj = BSTIterator(root)\n# param_1 = obj.next()\n# param_2 = obj.hasNext()\n
Binary Search Tree to Greater Sum Tree,###  1038\. Binary Search Tree to Greater Sum Tree\n\nGiven the `root` of a Binary Search Tree (BST) convert it to a Greater Tree\nsuch that every key of the original BST is changed to the original key plus\nthe sum of all keys greater than the original key in BST.\n\nAs a reminder a _binary search tree_ is a tree that satisfies these\nconstraints:\n\n  * The left subtree of a node contains only nodes with keys **less than** the node's key.\n  * The right subtree of a node contains only nodes with keys **greater than** the node's key.\n  * Both the left and right subtrees must also be binary search trees.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/05/02/tree.png)\n\n    \n    \n    **Input:** root = [4160257nullnullnull3nullnullnull8]\n    **Output:** [30362136352615nullnullnull33nullnullnull8]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [0null1]\n    **Output:** [1null1]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 100]`.\n  * `0 <= Node.val <= 100`\n  * All the values in the tree are **unique**.\n\n\n\n**Note:** This question is the same as 538:\n<https://leetcode.com/problems/convert-bst-to-greater-tree/>\n\n,# Runtime: 36 ms (Top 83.6%) | Memory: 16.39 MB (Top 54.5%)\n\nclass Solution:\n    def bstToGst(self root):\n        self.total = 0\n        def dfs(n):\n            if n:\n                dfs(n.right)\n                self.total +=  n.val\n                n.val       =  self.total\n                dfs(n.left)\n        dfs(root)\n        return root
Binary String With Substrings Representing 1 To N,"###  1016\. Binary String With Substrings Representing 1 To N\n\nGiven a binary string `s` and a positive integer `n` return `true` _if the\nbinary representation of all the integers in the range_`[1\nn]`_are**substrings** of _`s` _ or_`false` _otherwise_.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""0110"" n = 3\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""0110"" n = 4\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s[i]` is either `'0'` or `'1'`.\n  * `1 <= n <= 109`\n\n",// Runtime: 34 ms (Top 84.96%) | Memory: 16.60 MB (Top 62.78%)\n\nclass Solution:\n    def queryString(self S: str N: int) -> bool:\n        ans = set()\n        for i in range(len(S)):\n            for ii in range(i i + N.bit_length()): \n                x = int(S[i:ii+1] 2)\n                if 1 <= x <= N: ans.add(x)\n        return len(ans) == N\n
Binary Subarrays With Sum,###  930\. Binary Subarrays With Sum\n\nGiven a binary array `nums` and an integer `goal` return _the number of non-\nempty**subarrays** with a sum_ `goal`.\n\nA **subarray** is a contiguous part of the array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [10101] goal = 2\n    **Output:** 4\n    **Explanation:** The 4 subarrays are bolded and underlined below:\n    [_**101**_ 01]\n    [_**1010**_ 1]\n    [1_**0101**_]\n    [10_**101**_]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [00000] goal = 0\n    **Output:** 15\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 3 * 104`\n  * `nums[i]` is either `0` or `1`.\n  * `0 <= goal <= nums.length`\n\n,# Runtime: 680 ms (Top 7.52%) | Memory: 17.5 MB (Top 60.81%)\nclass Solution:\n    def numSubarraysWithSum(self nums: List[int] goal: int) -> int:\n        my_dict = {0:1}\n        accum res = 0 0\n        for n in nums:\n            accum += n\n            diff = accum-goal\n            if diff in my_dict:\n                res += my_dict[diff]\n            if accum in my_dict:\n                my_dict[accum] +=1\n            else:\n                my_dict[accum] =1\n        return res
Binary Tree Cameras,###  968\. Binary Tree Cameras\n\nYou are given the `root` of a binary tree. We install cameras on the tree\nnodes where each camera at a node can monitor its parent itself and its\nimmediate children.\n\nReturn _the minimum number of cameras needed to monitor all nodes of the\ntree_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png)\n\n    \n    \n    **Input:** root = [00null00]\n    **Output:** 1\n    **Explanation:** One camera is enough to monitor all nodes if placed as shown.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_02.png)\n\n    \n    \n    **Input:** root = [00null0null0nullnull0]\n    **Output:** 2\n    **Explanation:** At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 1000]`.\n  * `Node.val == 0`\n\n,"\nimport itertools\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minCameraHelper(self root: Optional[TreeNode]) -> (int int):\n        # Return 3 things:\n        # cam uncam uncov\n        # cam(era) is best score for valid tree with camera at root\n        # uncam(era) is best score for valid tree without camera at root\n        # uncov(ered) is best score for invalid tree where the only invalidity (i.e. the only uncovered node) is the root node\n        \n        # Note: maxint (float(""inf"")) is used to signify situations that don't make sense or can't happen.\n        # Anywhere there is a float(""inf"") you can safely replace that with a 1 as 1 is as bad or worse than worst practical\n        # but I stick with maxint to highlight the nonsensical cases for the reader!\n        \n        if not root.left and not root.right:\n            # base case: leaf\n            # Note: ""Uncam"" setting doesn't make much sense (a leaf with no parents can either have a camera or be uncovered\n            #       but not covered with no camera)\n            return 1 float(""inf"") 0\n        \n        if root.left:\n            left_cam left_uncam left_uncov = self.minCameraHelper(root.left)\n        else:\n            # base case: empty child\n            # Need to prevent null nodes from providing coverage to parent so set that cost to inf\n            left_cam left_uncam left_uncov = float(""inf"") 0 0\n            \n        if root.right:\n            right_cam right_uncam right_uncov = self.minCameraHelper(root.right)\n        else:\n            # base case: empty child\n            # Need to prevent null nodes from providing coverage to parent so set that cost to inf\n            right_cam right_uncam right_uncov = float(""inf"") 0 0\n            \n        # Get the possible combinations for each setting    \n        cam_poss = itertools.product([left_cam left_uncam left_uncov] [right_cam right_uncam right_uncov])\n        uncam_poss = [(left_cam right_cam) (left_uncam right_cam) (left_cam right_uncam)]\n        uncov_poss = [(left_uncam right_uncam)]\n        \n        # Compute costs for each setting\n        cam = min([x + y for x y in cam_poss]) + 1\n        uncam = min([x + y for x y in uncam_poss])\n        uncov = min([x + y for x y in uncov_poss])\n        \n        return cam uncam uncov\n                    \n    def minCameraCover(self root: Optional[TreeNode]) -> int:\n        cam uncam _ = self.minCameraHelper(root)\n        return min(cam uncam)\n\n"
Binary Tree Coloring Game,###  1145\. Binary Tree Coloring Game\n\nTwo players play a turn based game on a binary tree. We are given the `root`\nof this binary tree and the number of nodes `n` in the tree. `n` is odd and\neach node has a distinct value from `1` to `n`.\n\nInitially the first player names a value `x` with `1 <= x <= n` and the\nsecond player names a value `y` with `1 <= y <= n` and `y != x`. The first\nplayer colors the node with value `x` red and the second player colors the\nnode with value `y` blue.\n\nThen the players take turns starting with the first player. In each turn\nthat player chooses a node of their color (red if player 1 blue if player 2)\nand colors an **uncolored** neighbor of the chosen node (either the left\nchild right child or parent of the chosen node.)\n\nIf (and only if) a player cannot choose such a node in this way they must\npass their turn. If both players pass their turn the game ends and the\nwinner is the player that colored more nodes.\n\nYou are the second player. If it is possible to choose such a `y` to ensure\nyou win the game return `true`. If it is not possible return `false`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/08/01/1480-binary-tree-coloring-\ngame.png)\n\n    \n    \n    **Input:** root = [1234567891011] n = 11 x = 3\n    **Output:** true\n    **Explanation:** The second player can choose the node with value 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [123] n = 3 x = 1\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is `n`.\n  * `1 <= x <= n <= 100`\n  * `n` is odd.\n  * 1 <= Node.val <= n\n  * All the values of the tree are **unique**.\n\n,# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findParent(selfnodepar = None):\n        if node:\n            self.parent[node.val] = par\n            self.findParent(node.leftnode)\n            self.findParent(node.rightnode)\n    \n    def traverse(selfnodedone):\n        if node:\n            if node in done: return 0\n            done[node] = True\n            a = self.traverse(self.parent[node.val]done)\n            b = self.traverse(node.leftdone)\n            c = self.traverse(node.rightdone)\n            return a + b + c + 1\n        return 0\n    \n    def btreeGameWinningMove(self root: Optional[TreeNode] n: int x: int) -> bool:\n        self.parent = {}\n        self.findParent(root)\n        parent = self.parent[x]\n        node = root if root.val == x else parent.left if parent and parent.left and parent.left.val == x else parent.right\n        up = self.traverse(parent{node:True})\n        left = self.traverse(node.left{node:True})\n        right = self.traverse(node.right{node:True})\n        return (up > left + right) or (left > up + right) or (right > up + left)\n
Binary Tree Inorder Traversal,###  94\. Binary Tree Inorder Traversal\n\nGiven the `root` of a binary tree return _the inorder traversal of its nodes'\nvalues_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n\n    \n    \n    **Input:** root = [1null23]\n    **Output:** [132]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** [1]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 100]`.\n  * `-100 <= Node.val <= 100`\n\n\n\n**Follow up:** Recursive solution is trivial could you do it iteratively?\n\n,"from typing import List Optional\n\n\nclass Solution:\n	""""""\n	Time:   O(n)\n	Memory: O(n)\n	""""""\n\n	def inorderTraversal(self root: Optional[TreeNode]) -> List[int]:\n		inorder = []\n		stack = []\n\n		while stack or root is not None:\n			if root:\n				stack.append(root)\n				root = root.left\n			else:\n				node = stack.pop()\n				inorder.append(node.val)\n				root = node.right\n\n		return inorder\n\n\nclass Solution:\n	""""""\n	Time:   O(n)\n	Memory: O(n)\n	""""""\n\n	def inorderTraversal(self root: Optional[TreeNode]) -> List[int]:\n		return list(self.inorder_generator(root))\n\n	@classmethod\n	def inorder_generator(cls tree: Optional[TreeNode]):\n		if tree is not None:\n			yield from cls.inorder_generator(tree.left)\n			yield tree.val\n			yield from cls.inorder_generator(tree.right)\n"
Binary Tree Level Order Traversal,###  102\. Binary Tree Level Order Traversal\n\nGiven the `root` of a binary tree return _the level order traversal of its\nnodes' values_. (i.e. from left to right level by level).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n\n    \n    \n    **Input:** root = [3920nullnull157]\n    **Output:** [[3][920][157]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** [[1]]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 2000]`.\n  * `-1000 <= Node.val <= 1000`\n\n,# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n        \n    def levelOrder(self root: Optional[TreeNode]) -> List[List[int]]:\n        \n        ret = []\n        next_levels = [[root]]\n        \n        for level in next_levels:\n            curr_lv = []\n            next_lv = []\n            for node in level:\n                if not node: \n                    continue\n                curr_lv.append(node.val)\n                next_lv.append(node.left)\n                next_lv.append(node.right)\n            \n            if curr_lv: \n                ret.append(curr_lv)\n            if next_lv: \n                next_levels.append(next_lv)\n        \n        return ret\n
Binary Tree Level Order Traversal II,###  107\. Binary Tree Level Order Traversal II\n\nGiven the `root` of a binary tree return _the bottom-up level order traversal\nof its nodes' values_. (i.e. from left to right level by level from leaf to\nroot).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n\n    \n    \n    **Input:** root = [3920nullnull157]\n    **Output:** [[157][920][3]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** [[1]]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 2000]`.\n  * `-1000 <= Node.val <= 1000`\n\n,class Solution:\n    def levelOrderBottom(self root: Optional[TreeNode]) -> List[List[int]]:\n        def dfs(node level result):\n            if not node:\n                return\n            if level >= len(result):\n                result.append([])\n            result[level].append(node.val)\n            dfs(node.left level+1 result)\n            dfs(node.right level+1 result)\n        result = []\n        dfs(root 0 result)\n        return result[::-1]
Binary Tree Maximum Path Sum,###  124\. Binary Tree Maximum Path Sum\n\nA **path** in a binary tree is a sequence of nodes where each pair of adjacent\nnodes in the sequence has an edge connecting them. A node can only appear in\nthe sequence **at most once**. Note that the path does not need to pass\nthrough the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree return _the maximum**path sum** of any\n**non-empty** path_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)\n\n    \n    \n    **Input:** root = [123]\n    **Output:** 6\n    **Explanation:** The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)\n\n    \n    \n    **Input:** root = [-10920nullnull157]\n    **Output:** 42\n    **Explanation:** The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 3 * 104]`.\n  * `-1000 <= Node.val <= 1000`\n\n,class Solution:\n    def maxPathSum(self root: Optional[TreeNode]) -> int:\n        self.res=root.val\n        def solving(root):\n            if not root:\n                return 0\n            current=root.val\n            sleftsright=float('-inf')float('-inf')\n            if root.left:\n                sleft=solving(root.left)\n                if(sleft>=0):\n                    current+=sleft\n            if root.right:\n                sright=solving(root.right)\n                if(sright>=0):\n                    current+=sright\n            if(current>self.res):\n                self.res=current\n            return max(root.val root.val+sleft root.val+sright)\n        solving(root)\n        return self.res\n
Binary Tree Paths,"###  257\. Binary Tree Paths\n\nGiven the `root` of a binary tree return _all root-to-leaf paths in**any\norder**_.\n\nA **leaf** is a node with no children.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)\n\n    \n    \n    **Input:** root = [123null5]\n    **Output:** [""1->2->5""""1->3""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** [""1""]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 100]`.\n  * `-100 <= Node.val <= 100`\n\n",class Solution:\n    def binaryTreePaths(self root: Optional[TreeNode]) -> List[str]:\n        \n        # DFS solution\n        output = []\n        stack = [(root '')]\n        \n        while stack:\n            node path = stack.pop()\n            path += str(node.val)\n            \n            if not node.left and not node.right:\n                output.append(path)\n                \n            path += '->'\n            if node.left:\n                stack.append((node.left path))\n            if node.right:\n                stack.append((node.right path))\n                \n        return output\n
Binary Tree Postorder Traversal,###  145\. Binary Tree Postorder Traversal\n\nGiven the `root` of a binary tree return _the postorder traversal of its\nnodes' values_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/pre1.jpg)\n\n    \n    \n    **Input:** root = [1null23]\n    **Output:** [321]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** [1]\n    \n\n\n\n**Constraints:**\n\n  * The number of the nodes in the tree is in the range `[0 100]`.\n  * `-100 <= Node.val <= 100`\n\n\n\n**Follow up:** Recursive solution is trivial could you do it iteratively?\n\n,"from typing import List Optional\n\n\nclass Solution:\n	""""""\n	Time:   O(n)\n	Memory: O(n)\n	""""""\n\n	def postorderTraversal(self root: Optional[TreeNode]) -> List[int]:\n		if root is None:\n			return []\n\n		postorder = []\n		stack = [root]\n\n		while stack:\n			node = stack.pop()\n			postorder.append(node.val)\n			if node.left is not None:\n				stack.append(node.left)\n			if node.right is not None:\n				stack.append(node.right)\n\n		return postorder[::-1]\n\n\nclass Solution:\n	""""""\n	Time:   O(n)\n	Memory: O(n)\n	""""""\n\n	def postorderTraversal(self root: Optional[TreeNode]) -> List[int]:\n		return list(self.postorder_generator(root))\n\n	@classmethod\n	def postorder_generator(cls tree: Optional[TreeNode]):\n		if tree is not None:\n			yield from cls.postorder_generator(tree.left)\n			yield from cls.postorder_generator(tree.right)\n			yield tree.val"
Binary Tree Preorder Traversal,###  144\. Binary Tree Preorder Traversal\n\nGiven the `root` of a binary tree return _the preorder traversal of its\nnodes' values_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)\n\n    \n    \n    **Input:** root = [1null23]\n    **Output:** [123]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** [1]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 100]`.\n  * `-100 <= Node.val <= 100`\n\n\n\n**Follow up:** Recursive solution is trivial could you do it iteratively?\n\n,"# Runtime: 58 ms (Top 23.56%) | Memory: 13.9 MB (Top 60.28%)\nfrom collections import deque\nfrom typing import List Optional\n\nclass Solution:\n    """"""\n    Time: O(n)\n    Memory: O(n)\n    """"""\n\n    def preorderTraversal(self root: Optional[TreeNode]) -> List[int]:\n        if root is None:\n            return []\n\n        queue = deque([root])\n        preorder = []\n\n        while queue:\n            node = queue.pop()\n            preorder.append(node.val)\n\n            if node.right is not None:\n                queue.append(node.right)\n            if node.left is not None:\n                queue.append(node.left)\n\n        return preorder\n\nclass Solution:\n    """"""\n    Time: O(n)\n    Memory: O(n)\n    """"""\n\n    def preorderTraversal(self root: Optional[TreeNode]) -> List[int]:\n        return list(self.preorder_generator(root))\n\n    @classmethod\n    def preorder_generator(cls tree: Optional[TreeNode]):\n        if tree is not None:\n            yield tree.val\n            yield from cls.preorder_generator(tree.left)\n            yield from cls.preorder_generator(tree.right)"
Binary Tree Pruning,"###  814\. Binary Tree Pruning\n\nGiven the `root` of a binary tree return _the same tree where every subtree\n(of the given tree) not containing a_`1` _has been removed_.\n\nA subtree of a node `node` is `node` plus every node that is a descendant of\n`node`.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_2.png)\n\n    \n    \n    **Input:** root = [1null001]\n    **Output:** [1null0null1]\n    **Explanation:** \n    Only the red nodes satisfy the property ""every subtree not containing a 1"".\n    The diagram on the right represents the answer.\n    \n\n**Example 2:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/06/1028_1.png)\n\n    \n    \n    **Input:** root = [1010001]\n    **Output:** [1null1null1]\n    \n\n**Example 3:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/05/1028.png)\n\n    \n    \n    **Input:** root = [11011010]\n    **Output:** [11011null1]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 200]`.\n  * `Node.val` is either `0` or `1`.\n\n","// Runtime: 35 ms (Top 80.71%) | Memory: 17.30 MB (Top 5.56%)\n\nclass Solution:\n    def pruneTree(self root):\n        """"""\n        :type root: TreeNode\n        :rtype: TreeNode\n        """"""\n        if not root: return root\n        root.left root.right = self.pruneTree(root.left) self.pruneTree(root.right)\n        return None if not root.val and not root.left and not root.right else root\n"
Binary Tree Right Side View,###  199\. Binary Tree Right Side View\n\nGiven the `root` of a binary tree imagine yourself standing on the **right\nside** of it return _the values of the nodes you can see ordered from top to\nbottom_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)\n\n    \n    \n    **Input:** root = [123null5null4]\n    **Output:** [134]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [1null3]\n    **Output:** [13]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 100]`.\n  * `-100 <= Node.val <= 100`\n\n,# Runtime: 54 ms (Top 45.43%) | Memory: 13.9 MB (Top 70.59%)\n# Definition for a binary tree node.\n# class TreeNode:\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass Solution:\n    def rightSideView(self root: Optional[TreeNode]) -> List[int]:\n\n        def dfs(root d):\n\n            if not root: return\n\n            if self.maxi < d:\n                self.res.append(root.val)\n                self.maxi = d\n\n            dfs(root.right d+1)\n            dfs(root.left d+1)\n\n        self.res self.maxi = [] 0\n        dfs(root 1)\n        return self.res\n\n        # An Upvote will be encouraging\n
Binary Tree Tilt,###  563\. Binary Tree Tilt\n\nGiven the `root` of a binary tree return _the sum of every tree\nnode's**tilt**._\n\nThe **tilt** of a tree node is the **absolute difference** between the sum of\nall left subtree node **values** and all right subtree node **values**. If a\nnode does not have a left child then the sum of the left subtree node\n**values** is treated as `0`. The rule is similar if the node does not have a\nright child.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/20/tilt1.jpg)\n\n    \n    \n    **Input:** root = [123]\n    **Output:** 1\n    **Explanation:** \n    Tilt of node 2 : |0-0| = 0 (no children)\n    Tilt of node 3 : |0-0| = 0 (no children)\n    Tilt of node 1 : |2-3| = 1 (left subtree is just left child so sum is 2; right subtree is just right child so sum is 3)\n    Sum of every tilt : 0 + 0 + 1 = 1\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/20/tilt2.jpg)\n\n    \n    \n    **Input:** root = [42935null7]\n    **Output:** 15\n    **Explanation:** \n    Tilt of node 3 : |0-0| = 0 (no children)\n    Tilt of node 5 : |0-0| = 0 (no children)\n    Tilt of node 7 : |0-0| = 0 (no children)\n    Tilt of node 2 : |3-5| = 2 (left subtree is just left child so sum is 3; right subtree is just right child so sum is 5)\n    Tilt of node 9 : |0-7| = 7 (no left child so sum is 0; right subtree is just right child so sum is 7)\n    Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3 5 and 2 which sums to 10; right subtree values are 9 and 7 which sums to 16)\n    Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/10/20/tilt3.jpg)\n\n    \n    \n    **Input:** root = [21714112233]\n    **Output:** 9\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 104]`.\n  * `-1000 <= Node.val <= 1000`\n\n,# Runtime: 66 ms (Top 84.95%) | Memory: 16.4 MB (Top 43.30%)\n# Definition for a binary tree node.\n# class TreeNode:\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass Solution:\n    def findTilt(self root: Optional[TreeNode]) -> int:\n        res = [0]\n        def tilt_helper(rootres):\n            if not root:\n                return 0\n\n            left = tilt_helper(root.leftres)\n            right = tilt_helper(root.rightres)\n\n            res[0] += abs(left-right)\n\n            return left + right + root.val\n\n        tilt_helper(rootres)\n        return res[0]
Binary Tree Zigzag Level Order Traversal,###  103\. Binary Tree Zigzag Level Order Traversal\n\nGiven the `root` of a binary tree return _the zigzag level order traversal of\nits nodes' values_. (i.e. from left to right then right to left for the next\nlevel and alternate between).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)\n\n    \n    \n    **Input:** root = [3920nullnull157]\n    **Output:** [[3][209][157]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** [[1]]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 2000]`.\n  * `-100 <= Node.val <= 100`\n\n,"class Solution(object):\n    def zigzagLevelOrder(self root):\n        """"""\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        """"""\n        if not root: return []\n        \n        ans = []\n        \n        node = root \n        \n        q = collections.deque([node])\n        \n        order = -1 \n        \n        while q:\n            order = -order\n            level = []\n            for _ in range(len(q)):\n                node = q.popleft()\n                \n                level.append(node.val)\n                \n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n                    \n            ans.append(level[::order])\n                \n        return ans\n"
Binary Trees With Factors,###  823\. Binary Trees With Factors\n\nGiven an array of unique integers `arr` where each integer `arr[i]` is\nstrictly greater than `1`.\n\nWe make a binary tree using these integers and each number may be used for\nany number of times. Each non-leaf node's value should be equal to the product\nof the values of its children.\n\nReturn _the number of binary trees we can make_. The answer may be too large\nso return the answer **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [24]\n    **Output:** 3\n    **Explanation:** We can make these trees: [2] [4] [4 2 2]\n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [24510]\n    **Output:** 7\n    **Explanation:** We can make these trees: [2] [4] [5] [10] [4 2 2] [10 2 5] [10 5 2].\n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 1000`\n  * `2 <= arr[i] <= 109`\n  * All the values of `arr` are **unique**.\n\n,class Solution:\n    def numFactoredBinaryTrees(self nums: List[int]) -> int:\n        nums = set(nums)\n        n = len(nums)\n        \n        @lru_cache(None)\n        def helper(num):\n            trees = 1\n            for factor in nums:\n                if not num % factor and num // factor in nums:\n                    trees += helper(factor) * helper(num // factor)\n\n            return trees\n        \n        return sum(helper(num) for num in nums) % (10 ** 9 + 7)
Binary Watch,"###  401\. Binary Watch\n\nA binary watch has 4 LEDs on the top to represent the hours (0-11) and 6 LEDs\non the bottom to represent the minutes (0-59). Each LED represents a zero or\none with the least significant bit on the right.\n\n  * For example the below binary watch reads `""4:51""`.\n\n![](https://assets.leetcode.com/uploads/2021/04/08/binarywatch.jpg)\n\nGiven an integer `turnedOn` which represents the number of LEDs that are\ncurrently on (ignoring the PM) return _all possible times the watch could\nrepresent_. You may return the answer in **any order**.\n\nThe hour must not contain a leading zero.\n\n  * For example `""01:00""` is not valid. It should be `""1:00""`.\n\nThe minute must be consist of two digits and may contain a leading zero.\n\n  * For example `""10:2""` is not valid. It should be `""10:02""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** turnedOn = 1\n    **Output:** [""0:01""""0:02""""0:04""""0:08""""0:16""""0:32""""1:00""""2:00""""4:00""""8:00""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** turnedOn = 9\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * `0 <= turnedOn <= 10`\n\n","# Runtime: 44 ms (Top 50.1%) | Memory: 16.36 MB (Top 42.0%)\n\nclass Solution:\n    def readBinaryWatch(self turnedOn: int) -> List[str]:\n        output = []\n        # Loop through all possible combinations of hours and minutes and count the number of set bits\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count('1') + bin(m).count('1') == turnedOn:  # Check if the number of set bits in hours and minutes equals the target number\n                    output.append(f""{h}:{m:02d}"")  # Add the valid combination of hours and minutes to the output list\n        return output\n"
Bitwise AND of Numbers Range,###  201\. Bitwise AND of Numbers Range\n\nGiven two integers `left` and `right` that represent the range `[left\nright]` return _the bitwise AND of all numbers in this range inclusive_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** left = 5 right = 7\n    **Output:** 4\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** left = 0 right = 0\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** left = 1 right = 2147483647\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `0 <= left <= right <= 231 - 1`\n\n,// Runtime: 125 ms (Top 17.27%) | Memory: 13.9 MB (Top 25.09%)\nclass Solution:\n    def rangeBitwiseAnd(self left: int right: int) -> int:\n        if not left: return 0\n        i = 0\n        cur = left\n        while cur + (cur & -cur) <= right:\n            cur += cur & -cur\n            left &= cur\n        return left
Bitwise ORs of Subarrays,###  898\. Bitwise ORs of Subarrays\n\nWe have an array `arr` of non-negative integers.\n\nFor every (contiguous) subarray `sub = [arr[i] arr[i + 1] ... arr[j]]` (with `i <= j`) we take the bitwise OR of all the elements in `sub` obtaining a result `arr[i] | arr[i + 1] | ... | arr[j]`.\n\nReturn the number of possible results. Results that occur more than once are\nonly counted once in the final answer\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [0]\n    **Output:** 1\n    **Explanation:** There is only one possible result: 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [112]\n    **Output:** 3\n    **Explanation:** The possible subarrays are [1] [1] [2] [1 1] [1 2] [1 1 2].\n    These yield the results 1 1 2 1 3 3.\n    There are 3 unique values so the answer is 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [124]\n    **Output:** 6\n    **Explanation:** The possible results are 1 2 3 4 6 and 7.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5 * 104`\n  * `0 <= nums[i] <= 109`\n\n,class Solution:\n    def subarrayBitwiseORs(self arr: List[int]) -> int:\n        \n        \n        ans=set(arr)\n        \n        # each element is a subarry\n        \n        \n        one = set()\n        \n        # to get the ans for the subarray of  size >1\n        # starting from 0th element to the ending element\n        \n        \n        one.add(arr[0])\n        \n        for i in  range(1len(arr)):\n            \n            two=set()\n            \n            for j in one:\n                \n                two.add(j |  arr[i])\n                \n                # subarray from the element in one set to the current ele(i th one)\n                \n                ans.add(j| arr[i])\n                \n            \n            two.add(arr[i])\n            \n            # adding curr element to set two so that from next iteration we can take sub array starting from curr element \n            \n            one = two\n            \n        return len(ans)\n        \n
Booking Concert Tickets in Groups,"###  2286\. Booking Concert Tickets in Groups\n\nA concert hall has `n` rows numbered from `0` to `n - 1` each with `m` seats\nnumbered from `0` to `m - 1`. You need to design a ticketing system that can\nallocate seats in the following cases:\n\n  * If a group of `k` spectators can sit **together** in a row.\n  * If **every** member of a group of `k` spectators can get a seat. They may or **may not** sit together.\n\nNote that the spectators are very picky. Hence:\n\n  * They will book seats only if each member of their group can get a seat with row number **less than or equal** to `maxRow`. `maxRow` can **vary** from group to group.\n  * In case there are multiple rows to choose from the row with the **smallest** number is chosen. If there are multiple seats to choose in the same row the seat with the **smallest** number is chosen.\n\nImplement the `BookMyShow` class:\n\n  * `BookMyShow(int n int m)` Initializes the object with `n` as number of rows and `m` as number of seats per row.\n  * `int[] gather(int k int maxRow)` Returns an array of length `2` denoting the row and seat number (respectively) of the **first seat** being allocated to the `k` members of the group who must sit **together**. In other words it returns the smallest possible `r` and `c` such that all `[c c + k - 1]` seats are valid and empty in row `r` and `r <= maxRow`. Returns `[]` in case it is **not possible** to allocate seats to the group.\n  * `boolean scatter(int k int maxRow)` Returns `true` if all `k` members of the group can be allocated seats in rows `0` to `maxRow` who may or **may not** sit together. If the seats can be allocated it allocates `k` seats to the group with the **smallest** row numbers and the smallest possible seat numbers in each row. Otherwise returns `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""BookMyShow"" ""gather"" ""gather"" ""scatter"" ""scatter""]\n    [[2 5] [4 0] [2 0] [5 1] [5 1]]\n    **Output**\n    [null [0 0] [] true false]\n    \n    **Explanation**\n    BookMyShow bms = new BookMyShow(2 5); // There are 2 rows with 5 seats each \n    bms.gather(4 0); // return [0 0]\n                      // The group books seats [0 3] of row 0. \n    bms.gather(2 0); // return []\n                      // There is only 1 seat left in row 0\n                      // so it is not possible to book 2 consecutive seats. \n    bms.scatter(5 1); // return True\n                       // The group books seat 4 of row 0 and seats [0 3] of row 1. \n    bms.scatter(5 1); // return False\n                       // There is only one seat left in the hall.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 5 * 104`\n  * `1 <= m k <= 109`\n  * `0 <= maxRow <= n - 1`\n  * At most `5 * 104` calls **in total** will be made to `gather` and `scatter`.\n\n","class Node:\n    def __init__(self start end):\n        self.s = start\n        self.e = end\n        self.left = None\n        self.right = None\n        self.total = 0 # for range sum query\n        self.mx = 0 # for range max query\n        \nclass SegTree:\n    def __init__(self start end val):\n        \n        def build(l r):\n            if l > r:\n                return None\n            if l == r:\n                node = Node(l r)\n                node.total = val\n                node.mx = val\n                return node\n            node = Node(l r)\n            m = (l + r) // 2\n            node.left = build(l m)\n            node.right = build(m+1 r)\n            node.mx = max(node.left.mx node.right.mx)\n            node.total = node.left.total + node.right.total\n            return node\n        \n        self.root = build(start end)\n    \n	# update the total remain seats and the max remain seats for each node (range) in the segment tree\n    def update(self index val):\n        \n        def updateHelper(node):\n            if node.s == node.e == index:\n                node.total -= val\n                node.mx -= val\n                return\n            m = (node.s + node.e) // 2\n            if index <= m:\n                updateHelper(node.left)\n            elif index > m:\n                updateHelper(node.right)\n            node.mx = max(node.left.mx node.right.mx)\n            node.total = node.left.total + node.right.total\n            return\n            \n        updateHelper(self.root)\n        \n    def maxQuery(self k maxRow seats):\n        \n        def queryHelper(node):\n            if node.s == node.e:\n				# check if the row number is less than maxRow and the number of remains seats is greater or equal than k\n                if node.e > maxRow or node.total < k:\n                    return []\n                if node.e <= maxRow and node.total >= k:\n                    return [node.e seats - node.total]\n			# we want to greedily search the left subtree to get the smallest row which has enough remain seats\n            if node.left.mx >= k:\n                return queryHelper(node.left)\n            return queryHelper(node.right)\n        \n        return queryHelper(self.root)\n                \n    def sumQuery(self endRow):\n        \n        def queryHelper(node left right):\n            if left <= node.s and node.e <= right:\n                return node.total\n            m = (node.s + node.e) // 2\n            if right <= m:\n                return queryHelper(node.left left right)\n            elif left > m:\n                return queryHelper(node.right left right)\n            return queryHelper(node.left left m) + queryHelper(node.right m+1 right)\n        \n        return queryHelper(self.root 0 endRow)\n    \nclass BookMyShow:\n\n    def __init__(self n: int m: int):\n        self.m = m\n        self.seg = SegTree(0 n-1 m)\n		# record the remain seats at each row\n        self.seats = [m] * n\n		# record the index of the smallest row that has remain seats > 0\n        self.startRow = 0\n        \n    def gather(self k: int maxRow: int) -> List[int]:\n        res = self.seg.maxQuery(k maxRow self.m)\n        if res:\n            row = res[0]\n            self.seg.update(row k)\n            self.seats[row] -= k\n        return res\n\n    def scatter(self k: int maxRow: int) -> bool:\n        if self.seg.sumQuery(maxRow) < k:\n            return False\n        else:\n            i = self.startRow\n            total = 0\n            while total < k:\n                prevTotal = total\n                total += self.seats[i]\n                if total < k:\n					# use up all the seats at ith row\n                    self.seg.update(i self.seats[i])\n                    self.seats[i] = 0\n                    i += 1\n                    self.startRow = i\n                elif total >= k:\n					# occupy (k - prevTotal) seats at ith row\n                    self.seg.update(i k - prevTotal)\n                    self.seats[i] -= k - prevTotal\n            return True\n"
Brace Expansion II,"###  1096\. Brace Expansion II\n\nUnder the grammar given below strings can represent a set of lowercase words.\nLet `R(expr)` denote the set of words the expression represents.\n\nThe grammar can best be understood through simple examples:\n\n  * Single letters represent a singleton set containing that word. \n    * `R(""a"") = {""a""}`\n    * `R(""w"") = {""w""}`\n  * When we take a comma-delimited list of two or more expressions we take the union of possibilities. \n    * `R(""{abc}"") = {""a""""b""""c""}`\n    * `R(""{{ab}{bc}}"") = {""a""""b""""c""}` (notice the final set only contains each word at most once)\n  * When we concatenate two expressions we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression. \n    * `R(""{ab}{cd}"") = {""ac""""ad""""bc""""bd""}`\n    * `R(""a{bc}{de}f{gh}"") = {""abdfg"" ""abdfh"" ""abefg"" ""abefh"" ""acdfg"" ""acdfh"" ""acefg"" ""acefh""}`\n\nFormally the three rules for our grammar:\n\n  * For every lowercase letter `x` we have `R(x) = {x}`.\n  * For expressions `e1 e2 ...  ek` with `k >= 2` we have `R({e1 e2 ...}) = R(e1) ∪ R(e2) ∪ ...`\n  * For expressions `e1` and `e2` we have `R(e1 + e2) = {a + b for (a b) in R(e1) × R(e2)}` where `+` denotes concatenation and `×` denotes the cartesian product.\n\nGiven an expression representing a set of words under the given grammar\nreturn _the sorted list of words that the expression represents_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** expression = ""{ab}{c{de}}""\n    **Output:** [""ac""""ad""""ae""""bc""""bd""""be""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** expression = ""{{az}a{bc}{abz}}""\n    **Output:** [""a""""ab""""ac""""z""]\n    **Explanation:** Each distinct word is written only once in the final answer.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= expression.length <= 60`\n  * `expression[i]` consists of `'{'` `'}'` `''`or lowercase English letters.\n  * The given `expression` represents a set of words based on the grammar given in the description.\n\n","class Solution:\n    def braceExpansionII(self expression: str) -> List[str]:\n        s = list(reversed(""{"" + expression + ""}""))\n        \n        def full_word(): \n            cur = [] \n            while s and s[-1].isalpha():    \n                cur.append(s.pop())            \n            return """".join(cur)\n        \n        def _expr(): \n            res = set()    \n            if s[-1].isalpha(): \n                res.add(full_word())    \n            elif s[-1] == ""{"":   \n                s.pop() # remove open brace\n                res.update(_expr()) \n                while s and s[-1] == """": \n                    s.pop() # remove comma \n                    res.update(_expr())    \n                s.pop() # remove close brace \n            while s and s[-1] not in ""}"": \n                res = {e + o for o in _expr() for e in res}\n            return res    \n        \n        return sorted(_expr()) \n"
Break a Palindrome,"###  1328\. Break a Palindrome\n\nGiven a palindromic string of lowercase English letters `palindrome` replace\n**exactly one** character with any lowercase English letter so that the\nresulting string is **not** a palindrome and that it is the\n**lexicographically smallest** one possible.\n\nReturn _the resulting string. If there is no way to replace a character to\nmake it not a palindrome return an**empty string**._\n\nA string `a` is lexicographically smaller than a string `b` (of the same\nlength) if in the first position where `a` and `b` differ `a` has a character\nstrictly smaller than the corresponding character in `b`. For example\n`""abcc""` is lexicographically smaller than `""abcd""` because the first position\nthey differ is at the fourth character and `'c'` is smaller than `'d'`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** palindrome = ""abccba""\n    **Output:** ""aaccba""\n    **Explanation:** There are many ways to make ""abccba"" not a palindrome such as ""_z_ bccba"" ""a _a_ ccba"" and ""ab _a_ cba"".\n    Of all the ways ""aaccba"" is the lexicographically smallest.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** palindrome = ""a""\n    **Output:** """"\n    **Explanation:** There is no way to replace a single character to make ""a"" not a palindrome so return an empty string.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= palindrome.length <= 1000`\n  * `palindrome` consists of only lowercase English letters.\n\n","class Solution(object):\n    def breakPalindrome(self palindrome):\n        """"""\n        :type palindrome: str\n        :rtype: str\n        """"""\n        s = palindrome\n        palindrome = [ch for ch in s]\n        if len(palindrome) == 1:\n            return """"\n        \n        for i in range(len(palindrome)//2):\n            if palindrome[i] != 'a':\n                palindrome[i] = 'a'\n                return """".join(palindrome)\n        palindrome[-1] = 'b'\n        return """".join(palindrome)\n        \n        \n                \n                \n"
Brick Wall,###  554\. Brick Wall\n\nThere is a rectangular brick wall in front of you with `n` rows of bricks. The\n`ith` row has some number of bricks each of the same height (i.e. one unit)\nbut they can be of different widths. The total width of each row is the same.\n\nDraw a vertical line from the top to the bottom and cross the least bricks. If\nyour line goes through the edge of a brick then the brick is not considered\nas crossed. You cannot draw a line just along one of the two vertical edges of\nthe wall in which case the line will obviously cross no bricks.\n\nGiven the 2D array `wall` that contains the information about the wall return\n_the minimum number of crossed bricks after drawing such a vertical line_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg)\n\n    \n    \n    **Input:** wall = [[1221][312][132][24][312][1311]]\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** wall = [[1][1][1]]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `n == wall.length`\n  * `1 <= n <= 104`\n  * `1 <= wall[i].length <= 104`\n  * `1 <= sum(wall[i].length) <= 2 * 104`\n  * `sum(wall[i])` is the same for each row `i`.\n  * `1 <= wall[i][j] <= 231 - 1`\n\n,class Solution:\n    def leastBricks(self wall: List[List[int]]) -> int:\n        m = len(wall)\n        ctr = {}\n        res = m\n        for i in range(m):\n            n = len(wall[i])\n            curr = 0\n            for j in range(n - 1):\n                curr += wall[i][j]\n                x = ctr.get(curr m) - 1\n                ctr[curr] = x\n                res = min(res x)\n        return res\n
Bricks Falling When Hit,###  803\. Bricks Falling When Hit\n\nYou are given an `m x n` binary `grid` where each `1` represents a brick and\n`0` represents an empty space. A brick is **stable** if:\n\n  * It is directly connected to the top of the grid or\n  * At least one other brick in its four adjacent cells is **stable**.\n\nYou are also given an array `hits` which is a sequence of erasures we want to\napply. Each time we want to erase the brick at the location `hits[i] = (rowi\ncoli)`. The brick on that location (if it exists) will disappear. Some other\nbricks may no longer be stable because of that erasure and will **fall**. Once\na brick falls it is **immediately** erased from the `grid` (i.e. it does not\nland on other stable bricks).\n\nReturn _an array_`result` _ where each_`result[i]`_is the number of bricks\nthat will**fall** after the _`ith` _erasure is applied._\n\n**Note** that an erasure may refer to a location with no brick and if it\ndoes no bricks drop.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** grid = [[1000][1110]] hits = [[10]]\n    **Output:** [2]\n    **Explanation:** Starting with the grid:\n    [[1000]\n     [_1_ 110]]\n    We erase the underlined brick at (10) resulting in the grid:\n    [[1000]\n     [0_1_ _1_ 0]]\n    The two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick so they will fall. The resulting grid is:\n    [[1000]\n     [0000]]\n    Hence the result is [2].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[1000][1100]] hits = [[11][10]]\n    **Output:** [00]\n    **Explanation:** Starting with the grid:\n    [[1000]\n     [1_1_ 00]]\n    We erase the underlined brick at (11) resulting in the grid:\n    [[1000]\n     [1000]]\n    All remaining bricks are still stable so no bricks fall. The grid remains the same:\n    [[1000]\n     [_1_ 000]]\n    Next we erase the underlined brick at (10) resulting in the grid:\n    [[1000]\n     [0000]]\n    Once again all remaining bricks are still stable so no bricks fall.\n    Hence the result is [00].\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 200`\n  * `grid[i][j]` is `0` or `1`.\n  * `1 <= hits.length <= 4 * 104`\n  * `hits[i].length == 2`\n  * `0 <= xi <= m - 1`\n  * `0 <= yi <= n - 1`\n  * All `(xi yi)` are unique.\n\n,# Runtime: 7285 ms (Top 5.13%) | Memory: 29.8 MB (Top 5.13%)\nfrom collections import defaultdict\n\nclass Solution:\n    def hitBricks(self grid: List[List[int]] hits: List[List[int]]) -> List[int]:\n        parent = defaultdict()\n        sz = defaultdict(lambda:1)\n        empty = set()\n        def find(i):\n            if parent[i] != i:\n                parent[i] = find(parent[i])\n            return parent[i]\n        def union(ij):\n            pi = find(i)\n            pj = find(j)\n            if pi != pj:\n                parent[pi] = pj\n                sz[pj] += sz[pi]\n        row = len(grid)\n        col = len(grid[0])\n        for r in range(row):\n            for c in range(col):\n                parent[(rc)] = (rc)\n        parent[(rowcol)] = (rowcol)\n        for r c in hits:\n            if grid[r][c]:\n                grid[r][c] = 0\n            else:\n                empty.add((rc))\n        for r in range(row):\n            for c in range(col):\n                if not grid[r][c]:\n                    continue\n                for dr dc in [[-10][10][01][0-1]]:\n                    if 0 <= r + dr < row and 0 <= c + dc < col and grid[r+dr][c+dc]:\n                        union((r c)(r+dr c+dc))\n                if r == 0:\n                    union((rc)(rowcol))\n        res = [0]*len(hits)\n        for i in range(len(hits)-1-1-1):\n            r c = hits[i]\n            if (rc) in empty:\n                continue\n            grid[r][c] = 1\n            curbricks = sz[find((rowcol))]\n            for dr dc in [[-10][10][01][0-1]]:\n                if 0 <= r + dr < row and 0 <= c + dc < col and grid[r+dr][c+dc]:\n                    union((rc)(r+drc+dc))\n            if r == 0:\n                union((rc)(rowcol))\n            nextbricks = sz[find((rowcol))]\n            if nextbricks > curbricks:\n                res[i] = nextbricks - curbricks - 1\n        return res
Broken Calculator,###  991\. Broken Calculator\n\nThere is a broken calculator that has the integer `startValue` on its display\ninitially. In one operation you can:\n\n  * multiply the number on display by `2` or\n  * subtract `1` from the number on display.\n\nGiven two integers `startValue` and `target` return _the minimum number of\noperations needed to display_`target` _on the calculator_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** startValue = 2 target = 3\n    **Output:** 2\n    **Explanation:** Use double operation and then decrement operation {2 -> 4 -> 3}.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** startValue = 5 target = 8\n    **Output:** 2\n    **Explanation:** Use decrement and then double {5 -> 4 -> 8}.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** startValue = 3 target = 10\n    **Output:** 3\n    **Explanation:** Use double decrement and double {3 -> 6 -> 5 -> 10}.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= startValue target <= 109`\n\n,"class Solution(object):\n    def brokenCalc(self startValue target):\n        """"""\n        :type startValue: int\n        :type target: int\n        :rtype: int\n        """"""\n        res = 0\n        while target > startValue:\n            res += 1\n            if target % 2:\n                target += 1\n            else:\n                target //= 2\n        return res + startValue - target\n"
Buddy Strings,"###  859\. Buddy Strings\n\nGiven two strings `s` and `goal` return `true` _if you can swap two letters\nin_`s` _so the result is equal to_`goal` _ otherwise return_`false` _._\n\nSwapping letters is defined as taking two indices `i` and `j` (0-indexed) such\nthat `i != j` and swapping the characters at `s[i]` and `s[j]`.\n\n  * For example swapping at indices `0` and `2` in `""abcd""` results in `""cbad""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ab"" goal = ""ba""\n    **Output:** true\n    **Explanation:** You can swap s[0] = 'a' and s[1] = 'b' to get ""ba"" which is equal to goal.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""ab"" goal = ""ab""\n    **Output:** false\n    **Explanation:** The only letters you can swap are s[0] = 'a' and s[1] = 'b' which results in ""ba"" != goal.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""aa"" goal = ""aa""\n    **Output:** true\n    **Explanation:** You can swap s[0] = 'a' and s[1] = 'a' to get ""aa"" which is equal to goal.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length goal.length <= 2 * 104`\n  * `s` and `goal` consist of lowercase letters.\n\n",# Runtime: 54 ms (Top 48.33%) | Memory: 14.1 MB (Top 96.59%)\n\nfrom collections import Counter\n\nclass Solution:\n    def buddyStrings(self s: str goal: str) -> bool:\n        if len(s) != len(goal):\n            return False\n        diffCharactersCount = 0\n        diffCharactersInS = []\n        diffCharactersInGoal = []\n        for i in range(len(s)):\n            if s[i] != goal[i]:\n                diffCharactersCount += 1\n                diffCharactersInS.append(s[i])\n                diffCharactersInGoal.append(goal[i])\n        if diffCharactersCount == 2:\n            # if there are only 2 different characters then they should be swappable\n            if ((diffCharactersInS[0] == diffCharactersInGoal[1]) and (diffCharactersInS[1] == diffCharactersInGoal[0])):\n                return True\n            return False\n        elif diffCharactersCount == 0:\n            # if there is atleast one repeating character in the string then its possible for swap\n            counts = Counter(s)\n            for kv in counts.items():\n                if v > 1:\n                    return True\n        # if different characters count is not 2 or 0 then it's not possible for the strings to be buddy strings\n        return False\n
Build an Array With Stack Operations,"###  1441\. Build an Array With Stack Operations\n\nYou are given an integer array `target` and an integer `n`.\n\nYou have an empty stack with the two following operations:\n\n  * **`""Push""`** : pushes an integer to the top of the stack.\n  * **`""Pop""`** : removes the integer on the top of the stack.\n\nYou also have a stream of the integers in the range `[1 n]`.\n\nUse the two stack operations to make the numbers in the stack (from the bottom\nto the top) equal to `target`. You should follow the following rules:\n\n  * If the stream of the integers is not empty pick the next integer from the stream and push it to the top of the stack.\n  * If the stack is not empty pop the integer at the top of the stack.\n  * If at any moment the elements in the stack (from the bottom to the top) are equal to `target` do not read new integers from the stream and do not do more operations on the stack.\n\nReturn _the stack operations needed to build_`target` following the mentioned\nrules. If there are multiple valid answers return **any of them**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = [13] n = 3\n    **Output:** [""Push""""Push""""Pop""""Push""]\n    **Explanation:** Initially the stack s is empty. The last element is the top of the stack.\n    Read 1 from the stream and push it to the stack. s = [1].\n    Read 2 from the stream and push it to the stack. s = [12].\n    Pop the integer on the top of the stack. s = [1].\n    Read 3 from the stream and push it to the stack. s = [13].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = [123] n = 3\n    **Output:** [""Push""""Push""""Push""]\n    **Explanation:** Initially the stack s is empty. The last element is the top of the stack.\n    Read 1 from the stream and push it to the stack. s = [1].\n    Read 2 from the stream and push it to the stack. s = [12].\n    Read 3 from the stream and push it to the stack. s = [123].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** target = [12] n = 4\n    **Output:** [""Push""""Push""]\n    **Explanation:** Initially the stack s is empty. The last element is the top of the stack.\n    Read 1 from the stream and push it to the stack. s = [1].\n    Read 2 from the stream and push it to the stack. s = [12].\n    Since the stack (from the bottom to the top) is equal to target we stop the stack operations.\n    The answers that read integer 3 from the stream are not accepted.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= target.length <= 100`\n  * `1 <= n <= 100`\n  * `1 <= target[i] <= n`\n  * `target` is strictly increasing.\n\n","class Solution:\n    def buildArray(self target: List[int] n: int) -> List[str]:\n        temp = []\n        result = []\n        x = target[-1]\n        for i in range(1x+1):\n            temp.append(i)\n        for i in range(len(temp)):\n            if temp[i] in target:\n                result.append(""Push"")\n            elif temp[i] not in target:\n                result.append(""Push"")\n                result.append(""Pop"")\n        return result\n"
Build Array from Permutation,###  1920\. Build Array from Permutation\n\nGiven a **zero-based permutation** `nums` (**0-indexed**) build an array\n`ans` of the **same length** where `ans[i] = nums[nums[i]]` for each `0 <= i <\nnums.length` and return it.\n\nA **zero-based permutation** `nums` is an array of **distinct** integers from\n`0` to `nums.length - 1` (**inclusive**).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [021534]\n    **Output:** [012453]**Explanation:** The array ans is built as follows: \n    ans = [nums[nums[0]] nums[nums[1]] nums[nums[2]] nums[nums[3]] nums[nums[4]] nums[nums[5]]]\n        = [nums[0] nums[2] nums[1] nums[5] nums[3] nums[4]]\n        = [012453]\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [501234]\n    **Output:** [450123]\n    **Explanation:** The array ans is built as follows:\n    ans = [nums[nums[0]] nums[nums[1]] nums[nums[2]] nums[nums[3]] nums[nums[4]] nums[nums[5]]]\n        = [nums[5] nums[0] nums[1] nums[2] nums[3] nums[4]]\n        = [450123]\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `0 <= nums[i] < nums.length`\n  * The elements in `nums` are **distinct**.\n\n\n\n**Follow-up:** Can you solve it without using an extra space (i.e. `O(1)`\nmemory)?\n\n,"class Solution:\n	#As maximum value of the array element is 1000 this solution would work\n    def buildArray(self nums: List[int]) -> List[int]:\n        for i in range(len(nums)):            \n            if nums[nums[i]] <= len(nums):\n                nums[i] = nums[nums[i]] * 1000 + nums[i]\n            else:\n                nums[i] = mod(nums[nums[i]]1000) * 1000 + nums[i]\n            \n        for i in range(len(nums)):\n            nums[i]  = nums[i] // 1000\n            \n        return nums\n"
Build Array Where You Can Find The Maximum Exactly K Comparisons,###  1420\. Build Array Where You Can Find The Maximum Exactly K Comparisons\n\nYou are given three integers `n` `m` and `k`. Consider the following\nalgorithm to find the maximum element of an array of positive integers:\n\n![](https://assets.leetcode.com/uploads/2020/04/02/e.png)\n\nYou should build the array arr which has the following properties:\n\n  * `arr` has exactly `n` integers.\n  * `1 <= arr[i] <= m` where `(0 <= i < n)`.\n  * After applying the mentioned algorithm to `arr` the value `search_cost` is equal to `k`.\n\nReturn _the number of ways_ to build the array `arr` under the mentioned\nconditions. As the answer may grow large the answer **must be** computed\nmodulo `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2 m = 3 k = 1\n    **Output:** 6\n    **Explanation:** The possible arrays are [1 1] [2 1] [2 2] [3 1] [3 2] [3 3]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 5 m = 2 k = 3\n    **Output:** 0\n    **Explanation:** There are no possible arrays that satisify the mentioned conditions.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 9 m = 1 k = 1\n    **Output:** 1\n    **Explanation:** The only possible array is [1 1 1 1 1 1 1 1 1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 50`\n  * `1 <= m <= 100`\n  * `0 <= k <= n`\n\n,class Solution:\n    def numOfArrays(self n: int m: int k: int) -> int:\n        @cache\n        def dp(abc):\n            if a==n: return c==k\n            return (b*dp(a+1bc) if b>=1 else 0) + sum(dp(a+1ic+1) for i in range(b+1m+1))\n        return dp(000)%(10**9+7)\n
Building Boxes,###  1739\. Building Boxes\n\nYou have a cubic storeroom where the width length and height of the room are\nall equal to `n` units. You are asked to place `n` boxes in this room where\neach box is a cube of unit side length. There are however some rules to\nplacing the boxes:\n\n  * You can place the boxes anywhere on the floor.\n  * If box `x` is placed on top of the box `y` then each side of the four vertical sides of the box `y` **must** either be adjacent to another box or to a wall.\n\nGiven an integer `n` return _the**minimum** possible number of boxes touching\nthe floor._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/3-boxes.png)\n\n    \n    \n    **Input:** n = 3\n    **Output:** 3\n    **Explanation:** The figure above is for the placement of the three boxes.\n    These boxes are placed in the corner of the room where the corner is on the left side.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/4-boxes.png)\n\n    \n    \n    **Input:** n = 4\n    **Output:** 3\n    **Explanation:** The figure above is for the placement of the four boxes.\n    These boxes are placed in the corner of the room where the corner is on the left side.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/10-boxes.png)\n\n    \n    \n    **Input:** n = 10\n    **Output:** 6\n    **Explanation:** The figure above is for the placement of the ten boxes.\n    These boxes are placed in the corner of the room where the corner is on the back side.\n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n\n,# Runtime: 68 ms (Top 24.24%) | Memory: 13.9 MB (Top 54.55%)\nclass Solution:\n    def minimumBoxes(self n: int) -> int:\n        r = 0\n        while (n_upper := r*(r+1)*(r+2)//6) < n:\n            r += 1\n        m = r*(r+1)//2\n        for i in range(r 0 -1):\n            if (n_upper - i) < n:\n                break\n            n_upper -= i\n            m -= 1\n        return m
Bulb Switcher,###  319\. Bulb Switcher\n\nThere are `n` bulbs that are initially off. You first turn on all the bulbs\nthen you turn off every second bulb.\n\nOn the third round you toggle every third bulb (turning on if it's off or\nturning off if it's on). For the `ith` round you toggle every `i` bulb. For\nthe `nth` round you only toggle the last bulb.\n\nReturn _the number of bulbs that are on after`n` rounds_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg)\n\n    \n    \n    **Input:** n = 3\n    **Output:** 1\n    **Explanation:** At first the three bulbs are [off off off].\n    After the first round the three bulbs are [on on on].\n    After the second round the three bulbs are [on off on].\n    After the third round the three bulbs are [on off off]. \n    So you should return 1 because there is only one bulb is on.\n\n**Example 2:**\n\n    \n    \n    **Input:** n = 0\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 109`\n\n,class Solution:\n    def bulbSwitch(self n: int) -> int:\n        return int(sqrt(n))\n
Bulb Switcher II,###  672\. Bulb Switcher II\n\nThere is a room with `n` bulbs labeled from `1` to `n` that all are turned on\ninitially and **four buttons** on the wall. Each of the four buttons has a\ndifferent functionality where:\n\n  * **Button 1:** Flips the status of all the bulbs.\n  * **Button 2:** Flips the status of all the bulbs with even labels (i.e. `2 4 ...`).\n  * **Button 3:** Flips the status of all the bulbs with odd labels (i.e. `1 3 ...`).\n  * **Button 4:** Flips the status of all the bulbs with a label `j = 3k + 1` where `k = 0 1 2 ...` (i.e. `1 4 7 10 ...`).\n\nYou must make **exactly** `presses` button presses in total. For each press\nyou may pick **any** of the four buttons to press.\n\nGiven the two integers `n` and `presses` return _the number of**different\npossible statuses** after performing all _`presses` _button presses_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1 presses = 1\n    **Output:** 2\n    **Explanation:** Status can be:\n    - [off] by pressing button 1\n    - [on] by pressing button 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 presses = 1\n    **Output:** 3\n    **Explanation:** Status can be:\n    - [off off] by pressing button 1\n    - [on off] by pressing button 2\n    - [off on] by pressing button 3\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3 presses = 1\n    **Output:** 4\n    **Explanation:** Status can be:\n    - [off off off] by pressing button 1\n    - [off on off] by pressing button 2\n    - [on off on] by pressing button 3\n    - [off on on] by pressing button 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n  * `0 <= presses <= 1000`\n\n,# Runtime: 30 ms (Top 97.1%) | Memory: 16.43 MB (Top 14.4%)\n\nclass Solution:\n    def flipLights(self n: int m: int) -> int:\n        # Reduce n to at most 3 since any action performed more than 3 times\n        # will result in a pattern that has already been counted\n        n = min(n 3)\n        if m == 0:\n            return 1\n        elif m == 1:\n            # For m=1 there are only 2 outcomes for n=1 3 outcomes for n=2 and 4 outcomes for n=3\n            return [2 3 4][n - 1]\n        elif m == 2:\n            # For m=2 there are only 2 outcomes for n=1 4 outcomes for n=2 and 7 outcomes for n=3\n            return [2 4 7][n - 1]\n        else:\n            # For m>=3 there are only 2 outcomes for n=1 4 outcomes for n=2 and 8 outcomes for n=3\n            return [2 4 8][n - 1]\n
Bulls and Cows,"###  299\. Bulls and Cows\n\nYou are playing the **[Bulls and\nCows](https://en.wikipedia.org/wiki/Bulls_and_Cows)** game with your friend.\n\nYou write down a secret number and ask your friend to guess what the number\nis. When your friend makes a guess you provide a hint with the following\ninfo:\n\n  * The number of ""bulls"" which are digits in the guess that are in the correct position.\n  * The number of ""cows"" which are digits in the guess that are in your secret number but are located in the wrong position. Specifically the non-bull digits in the guess that could be rearranged such that they become bulls.\n\nGiven the secret number `secret` and your friend's guess `guess` return _the\nhint for your friend's guess_.\n\nThe hint should be formatted as `""xAyB""` where `x` is the number of bulls and\n`y` is the number of cows. Note that both `secret` and `guess` may contain\nduplicate digits.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** secret = ""1807"" guess = ""7810""\n    **Output:** ""1A3B""\n    **Explanation:** Bulls are connected with a '|' and cows are underlined:\n    ""1807""\n      |\n    ""_7_ 8 _10_ ""\n\n**Example 2:**\n\n    \n    \n    **Input:** secret = ""1123"" guess = ""0111""\n    **Output:** ""1A1B""\n    **Explanation:** Bulls are connected with a '|' and cows are underlined:\n    ""1123""        ""1123""\n      |      or     |\n    ""01 _1_ 1""        ""011 _1_ ""\n    Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= secret.length guess.length <= 1000`\n  * `secret.length == guess.length`\n  * `secret` and `guess` consist of digits only.\n\n",class Solution:\n    def getHint(self secret: str guess: str) -> str:\n        \n        # Setup counts for bulls and cows\n        bulls = cows = 0\n        \n        # Copy secret and guess into lists that are easier to work with\n        secretCopy = list(secret)\n        guessCopy = list(guess)\n        \n        # In a for loop check every pair of letters at the same index in both guess and secret for matching letters AKA bulls\n        for i in range(len(secret)):\n            \n            # If they match bulls += 1 and pop() the letters from the copy lists via their .index()\n            if secret[i] == guess[i]:\n                bulls += 1\n                secretCopy.pop(secretCopy.index(secret[i]))\n                guessCopy.pop(guessCopy.index(guess[i]))\n                \n                \n        # Count() the letters remaining in secret and guess lists\n        secretCounter = Counter(secretCopy)\n        guessCounter = Counter(guessCopy)\n        \n        # Counter1 - Counter2 gives us Counter1 with any matching values of Counter1 and Counter2 removed; leftover Counter2 values are trashed\n        # secretCounter - guessCounter gives us the secretCounter except for any correctly guessed letters\n        # Therefore subtract this difference from the OG secretCounter to be left with a counter of only correctly guessed letters\n        dif = secretCounter - (secretCounter - guessCounter)\n        \n        # The .total() of the dif Counter is the number of cows\n        cows = dif.total()\n\n        # return the formatted string with req. info\n        return f'{bulls}A{cows}B'\n
Burst Balloons,###  312\. Burst Balloons\n\nYou are given `n` balloons indexed from `0` to `n - 1`. Each balloon is\npainted with a number on it represented by an array `nums`. You are asked to\nburst all the balloons.\n\nIf you burst the `ith` balloon you will get `nums[i - 1] * nums[i] * nums[i +\n1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array then treat\nit as if there is a balloon with a `1` painted on it.\n\nReturn _the maximum coins you can collect by bursting the balloons wisely_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3158]\n    **Output:** 167\n    **Explanation:**\n    nums = [3158] --> [358] --> [38] --> [8] --> []\n    coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [15]\n    **Output:** 10\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 300`\n  * `0 <= nums[i] <= 100`\n\n,// Runtime: 3739 ms (Top 77.47%) | Memory: 34.10 MB (Top 46.9%)\n\nclass Solution:\n    def maxCoins(self nums):\n        A = [1] + nums + [1]\n        \n        @lru_cache(None)\n        def dfs(i j):\n            return max([A[i]*A[k]*A[j] + dfs(ik) + dfs(kj) for k in range(i+1 j)] or [0])\n        \n        return dfs(0 len(A) - 1)\n
Bus Routes,###  815\. Bus Routes\n\nYou are given an array `routes` representing bus routes where `routes[i]` is a\nbus route that the `ith` bus repeats forever.\n\n  * For example if `routes[0] = [1 5 7]` this means that the `0th` bus travels in the sequence `1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ...` forever.\n\nYou will start at the bus stop `source` (You are not on any bus initially)\nand you want to go to the bus stop `target`. You can travel between bus stops\nby buses only.\n\nReturn _the least number of buses you must take to travel from_`source`\n_to_`target`. Return `-1` if it is not possible.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** routes = [[127][367]] source = 1 target = 6\n    **Output:** 2\n    **Explanation:** The best strategy is take the first bus to the bus stop 7 then take the second bus to the bus stop 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** routes = [[712][4515][6][1519][91213]] source = 15 target = 12\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= routes.length <= 500`.\n  * `1 <= routes[i].length <= 105`\n  * All the values of `routes[i]` are **unique**.\n  * `sum(routes[i].length) <= 105`\n  * `0 <= routes[i][j] < 106`\n  * `0 <= source target < 106`\n\n,// Runtime: 990 ms (Top 43.31%) | Memory: 53.60 MB (Top 12.36%)\n\nclass Solution:\n    from collections import defaultdict deque\n    def numBusesToDestination(self routes: List[List[int]] source: int target: int) -> int:\n        # Base case\n        if source == target:\n            return 0\n        # Creating graph or routes\n        graph = defaultdict(set)\n        \n        # Since index represents bus_number on a route\n        # suppose i is bus number and stops are the values present at that index\n        for bus_number stops in enumerate(routes):\n            # for each stop adding buses going to that stop\n            for stop in stops:\n                graph[stop].add(bus_number)\n        \n        # Using bfs\n        bfs = deque([(source 0)])\n        \n        # visited stops \n        seen_stops = set()\n        # visited buses\n        seen_buses = set()\n        \n        while bfs:\n            stop count = bfs.popleft()\n            # Resulting case\n            if stop == target:\n                    return count\n                \n            # Since our graph stores all buses going to a stop\n            # We will iterate for every bus\n            for bus_number in graph[stop]:\n                # We dont want to travel in same bus as we might stuck into loop and reach nowhere\n                if bus_number not in seen_buses:\n                    seen_buses.add(bus_number)\n                    \n                    # Now we are in a bus so we will travel all the stops that bus goes to but again we only want to go to stops we haven't visited\n                    for stop in routes[bus_number]:\n                        if stop not in seen_stops:\n                            seen_stops.add(stop)\n                            bfs.append((stop count + 1))\n        return -1\n
Calculate Money in Leetcode Bank,###  1716\. Calculate Money in Leetcode Bank\n\nHercy wants to save money for his first car. He puts money in the Leetcode\nbank **every day**.\n\nHe starts by putting in `$1` on Monday the first day. Every day from Tuesday\nto Sunday he will put in `$1` more than the day before. On every subsequent\nMonday he will put in `$1` more than the **previous Monday**.\n\nGiven `n` return _the total amount of money he will have in the Leetcode bank\nat the end of the_`nth` _day._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** 10\n    **Explanation:**  After the 4th day the total is 1 + 2 + 3 + 4 = 10.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 37\n    **Explanation:**  After the 10th day the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday Hercy only puts in $2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 20\n    **Output:** 96\n    **Explanation:**  After the 20th day the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n\n,from itertools import cycle \\n                      repeat \\n                      starmap\nfrom operator import floordiv\n\n\nclass Solution:\n    def totalMoney(self n: int) -> int:\n        return sum(starmap(addzip(\n            starmap(floordiv zip(range(n) repeat(7 n)))\n            cycle((1234567))\n        )))\n\n
Camelcase Matching,"###  1023\. Camelcase Matching\n\nGiven an array of strings `queries` and a string `pattern` return a boolean\narray `answer` where `answer[i]` is `true` if `queries[i]` matches `pattern`\nand `false` otherwise.\n\nA query word `queries[i]` matches `pattern` if you can insert lowercase\nEnglish letters pattern so that it equals the query. You may insert each\ncharacter at any position and you may not insert any characters.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** queries = [""FooBar""""FooBarTest""""FootBall""""FrameBuffer""""ForceFeedBack""] pattern = ""FB""\n    **Output:** [truefalsetruetruefalse]\n    **Explanation:** ""FooBar"" can be generated like this ""F"" + ""oo"" + ""B"" + ""ar"".\n    ""FootBall"" can be generated like this ""F"" + ""oot"" + ""B"" + ""all"".\n    ""FrameBuffer"" can be generated like this ""F"" + ""rame"" + ""B"" + ""uffer"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** queries = [""FooBar""""FooBarTest""""FootBall""""FrameBuffer""""ForceFeedBack""] pattern = ""FoBa""\n    **Output:** [truefalsetruefalsefalse]\n    **Explanation:** ""FooBar"" can be generated like this ""Fo"" + ""o"" + ""Ba"" + ""r"".\n    ""FootBall"" can be generated like this ""Fo"" + ""ot"" + ""Ba"" + ""ll"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** queries = [""FooBar""""FooBarTest""""FootBall""""FrameBuffer""""ForceFeedBack""] pattern = ""FoBaT""\n    **Output:** [falsetruefalsefalsefalse]\n    **Explanation:** ""FooBarTest"" can be generated like this ""Fo"" + ""o"" + ""Ba"" + ""r"" + ""T"" + ""est"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= pattern.length queries.length <= 100`\n  * `1 <= queries[i].length <= 100`\n  * `queries[i]` and `pattern` consist of English letters.\n\n","class Solution:\n    def camelMatch(self queries: List[str] pattern: str) -> List[bool]:\n        res N = [] len(pattern)\n		\n        for query in queries:\n		\n            if self.upLetter(query) != self.upLetter(pattern) or self.LCS(query pattern) != N:\n                res.append(False)\n            \n            else:\n                res.append(True)\n				\n        return res\n                \n        \n		\n    def LCS(self A B):\n        N M = len(A) len(B)\n        d = [[0 for _ in range(M+1)] for _ in range(N+1)]\n\n        for i in range(1 N+1):\n            for j in range(1 M+1):\n			\n                if A[i - 1] == B[j - 1]:\n                    d[i][j] = 1 + d[i-1][j-1]\n\n                else:\n                    d[i][j] = max(d[i-1][j] d[i][j-1])\n        return d[-1][-1]\n\n\n    \n    def upLetter(self w):\n        count = 0\n        for c in w:\n            if c.isupper():\n                count += 1\n        return count\n\n"
Can Convert String in K Moves,"###  1540\. Can Convert String in K Moves\n\nGiven two strings `s` and `t` your goal is to convert `s` into `t` in `k`**\n** moves or less.\n\nDuring the `ith` (`1 <= i <= k`) move you can:\n\n  * Choose any index `j` (1-indexed) from `s` such that `1 <= j <= s.length` and `j` has not been chosen in any previous move and shift the character at that index `i` times.\n  * Do nothing.\n\nShifting a character means replacing it by the next letter in the alphabet\n(wrapping around so that `'z'` becomes `'a'`). Shifting a character by `i`\nmeans applying the shift operations `i` times.\n\nRemember that any index `j` can be picked at most once.\n\nReturn `true` if it's possible to convert `s` into `t` in no more than `k`\nmoves otherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""input"" t = ""ouput"" k = 9\n    **Output:** true\n    **Explanation:** In the 6th move we shift 'i' 6 times to get 'o'. And in the 7th move we shift 'n' to get 'u'.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abc"" t = ""bcd"" k = 10\n    **Output:** false\n    **Explanation:** We need to shift each character in s one time to convert it into t. We can shift 'a' to 'b' during the 1st move. However there is no way to shift the other characters in the remaining moves to obtain t from s.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""aab"" t = ""bbb"" k = 27\n    **Output:** true\n    **Explanation:** In the 1st move we shift the first 'a' 1 time to get 'b'. In the 27th move we shift the second 'a' 27 times to get 'b'.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length t.length <= 10^5`\n  * `0 <= k <= 10^9`\n  * `s` `t` contain only lowercase English letters.\n\n",# Runtime: 285 ms (Top 92.79%) | Memory: 15.1 MB (Top 75.68%)\nclass Solution:\n    def canConvertString(self s: str t: str k: int) -> bool:\n        if len(s) != len(t):\n            return False\n\n        cycles extra = divmod(k 26)\n        shifts = [cycles + (shift <= extra) for shift in range(26)]\n\n        for cs ct in zip(s t):\n            shift = (ord(ct) - ord(cs)) % 26\n            if shift == 0:\n                continue\n            if not shifts[shift]:\n                return False\n            shifts[shift] -= 1\n\n        return True
Can I Win,"###  464\. Can I Win\n\nIn the ""100 game"" two players take turns adding to a running total any\ninteger from `1` to `10`. The player who first causes the running total to\n**reach or exceed** 100 wins.\n\nWhat if we change the game so that players **cannot** re-use integers?\n\nFor example two players might take turns drawing from a common pool of\nnumbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers `maxChoosableInteger` and `desiredTotal` return `true` if\nthe first player to move can force a win otherwise return `false`. Assume\nboth players play **optimally**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** maxChoosableInteger = 10 desiredTotal = 11\n    **Output:** false\n    **Explanation:**\n    No matter which integer the first player choose the first player will lose.\n    The first player can choose an integer from 1 up to 10.\n    If the first player choose 1 the second player can only choose integers from 2 up to 10.\n    The second player will win by choosing 10 and get a total = 11 which is >= desiredTotal.\n    Same with other integers chosen by the first player the second player will always win.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** maxChoosableInteger = 10 desiredTotal = 0\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** maxChoosableInteger = 10 desiredTotal = 1\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= maxChoosableInteger <= 20`\n  * `0 <= desiredTotal <= 300`\n\n",class Solution:\n    def canIWin(self maxChoosableInteger: int desiredTotal: int) -> bool:\n        remainder = [i+1 for i in range(maxChoosableInteger)] # numbers\n        @cache\n        def can_win(total remainder):\n            if total >= desiredTotal:\n                return False # total is already exceed the desiredTotal. Opponent won. \n            \n            for num in remainder:\n                if can_win(total + num tuple([n for n in remainder if n != num])) == False: # if opponent lose I win(return True)\n                    return True\n            return False \n        \n        if desiredTotal == 0: \n            return True \n        if sum(remainder) < desiredTotal: # Both of two cannot win.\n            return False \n        return can_win(0 tuple(remainder))\n
Can Make Arithmetic Progression From Sequence,###  1502\. Can Make Arithmetic Progression From Sequence\n\nA sequence of numbers is called an **arithmetic progression** if the\ndifference between any two consecutive elements is the same.\n\nGiven an array of numbers `arr` return `true` _if the array can be rearranged\nto form an**arithmetic progression**. Otherwise return_ `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [351]\n    **Output:** true\n    **Explanation:** We can reorder the elements as [135] or [531] with differences 2 and -2 respectively between each consecutive elements.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [124]\n    **Output:** false\n    **Explanation:** There is no way to reorder the elements to obtain an arithmetic progression.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= arr.length <= 1000`\n  * `-106 <= arr[i] <= 106`\n\n,class Solution:\n    def canMakeArithmeticProgression(self arr: List[int]) -> bool:\n        arr.sort()\n        check = arr[0] - arr[1]\n        for i in range(len(arr)-1):\n            if arr[i] - arr[i+1] != check:\n                return False\n        return True\n
Can Make Palindrome from Substring,"###  1177\. Can Make Palindrome from Substring\n\nYou are given a string `s` and array `queries` where `queries[i] = [lefti\nrighti ki]`. We may rearrange the substring `s[lefti...righti]` for each\nquery and then choose up to `ki` of them to replace with any lowercase English\nletter.\n\nIf the substring is possible to be a palindrome string after the operations\nabove the result of the query is `true`. Otherwise the result is `false`.\n\nReturn a boolean array `answer` where `answer[i]` is the result of the `ith`\nquery `queries[i]`.\n\nNote that each letter is counted individually for replacement so if for\nexample `s[lefti...righti] = ""aaa""` and `ki = 2` we can only replace two of\nthe letters. Also note that no query modifies the initial string `s`.\n\n\n\n**Example :**\n\n    \n    \n    **Input:** s = ""abcda"" queries = [[330][120][031][032][041]]\n    **Output:** [truefalsefalsetruetrue]\n    **Explanation:**\n    queries[0]: substring = ""d"" is palidrome.\n    queries[1]: substring = ""bc"" is not palidrome.\n    queries[2]: substring = ""abcd"" is not palidrome after replacing only 1 character.\n    queries[3]: substring = ""abcd"" could be changed to ""abba"" which is palidrome. Also this can be changed to ""baab"" first rearrange it ""bacd"" then replace ""cd"" with ""ab"".\n    queries[4]: substring = ""abcda"" could be changed to ""abcba"" which is palidrome.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""lyb"" queries = [[010][221]]\n    **Output:** [falsetrue]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length queries.length <= 105`\n  * `0 <= lefti <= righti < s.length`\n  * `0 <= ki <= s.length`\n  * `s` consists of lowercase English letters.\n\n",class Solution:\n    def canMakePaliQueries(self s: str queries: List[List[int]]) -> List[bool]:\n        hash_map = {s[0]: 1}\n        x = hash_map\n        prefix = [hash_map]\n        for i in range(1 len(s)):\n            x = x.copy()\n            x[s[i]] = x.get(s[i] 0) + 1\n            prefix.append(x)\n            \n        result = []\n        for query in queries:\n            cnt = 0\n            for key value in prefix[query[1]].items():\n                if query[0] > 0:\n                    x = value - prefix[query[0]-1].get(key 0)\n                else:\n                    x = value\n                if x % 2:\n                    cnt+=1\n            if cnt - 2 * query[2] > 1:\n                result.append(False)\n            else:\n                result.append(True)\n        return result\n
Can Place Flowers,###  605\. Can Place Flowers\n\nYou have a long flowerbed in which some of the plots are planted and some are\nnot. However flowers cannot be planted in **adjacent** plots.\n\nGiven an integer array `flowerbed` containing `0`'s and `1`'s where `0` means\nempty and `1` means not empty and an integer `n` return _if_ `n` new flowers\ncan be planted in the `flowerbed` without violating the no-adjacent-flowers\nrule.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** flowerbed = [10001] n = 1\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** flowerbed = [10001] n = 2\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= flowerbed.length <= 2 * 104`\n  * `flowerbed[i]` is `0` or `1`.\n  * There are no two adjacent flowers in `flowerbed`.\n  * `0 <= n <= flowerbed.length`\n\n,class Solution:\n    def canPlaceFlowers(self flowerbed: List[int] n: int) -> bool:\n        f = [0] + flowerbed + [0]\n\n        i could_plant = 1 0\n        while could_plant < n and i < len(f) - 1:\n            if f[i + 1]:\n                # 0 0 1 -> skip 3\n                i += 3\n            elif f[i]:\n                # 0 1 0 -> skip 2\n                i += 2\n            elif f[i - 1]:\n                # 1 0 0 -> skip 1\n                i += 1\n            else:\n                # 0 0 0 -> plant becomes 0 1 0 -> skip 2\n                could_plant += 1\n                i += 2\n\n        return n <= could_plant\n
Capacity To Ship Packages Within D Days,###  1011\. Capacity To Ship Packages Within D Days\n\nA conveyor belt has packages that must be shipped from one port to another\nwithin `days` days.\n\nThe `ith` package on the conveyor belt has a weight of `weights[i]`. Each day\nwe load the ship with packages on the conveyor belt (in the order given by\n`weights`). We may not load more weight than the maximum weight capacity of\nthe ship.\n\nReturn the least weight capacity of the ship that will result in all the\npackages on the conveyor belt being shipped within `days` days.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** weights = [12345678910] days = 5\n    **Output:** 15\n    **Explanation:** A ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\n    1st day: 1 2 3 4 5\n    2nd day: 6 7\n    3rd day: 8\n    4th day: 9\n    5th day: 10\n    \n    Note that the cargo must be shipped in the order given so using a ship of capacity 14 and splitting the packages into parts like (2 3 4 5) (1 6 7) (8) (9) (10) is not allowed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** weights = [322414] days = 3\n    **Output:** 6\n    **Explanation:** A ship capacity of 6 is the minimum to ship all the packages in 3 days like this:\n    1st day: 3 2\n    2nd day: 2 4\n    3rd day: 1 4\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** weights = [12311] days = 4\n    **Output:** 3\n    **Explanation:**\n    1st day: 1\n    2nd day: 2\n    3rd day: 3\n    4th day: 1 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= days <= weights.length <= 5 * 104`\n  * `1 <= weights[i] <= 500`\n\n,# Runtime: 1388 ms (Top 11.51%) | Memory: 17.1 MB (Top 35.27%)\nclass Solution:\n    def shipWithinDays(self weights: List[int] days: int) -> int:\n        def calc(m):#function calculate no of days for given weight\n            cs=00\n            for i in weights:\n                if i+s>m:\n                    c+=1\n                    s=0\n                s+=i\n            if s>0:\n                c+=1\n            return c\n        leftright=max(weights)sum(weights)\n        while left <=right:\n            mid = (left+right)//2\n            if calc(mid) > days:\n                left = mid+1\n            else :\n                right = mid -1\n        return left
Capitalize the Title,"###  2129\. Capitalize the Title\n\nYou are given a string `title` consisting of one or more words separated by a\nsingle space where each word consists of English letters. **Capitalize** the\nstring by changing the capitalization of each word such that:\n\n  * If the length of the word is `1` or `2` letters change all letters to lowercase.\n  * Otherwise change the first letter to uppercase and the remaining letters to lowercase.\n\nReturn _the**capitalized** _`title`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** title = ""capiTalIze tHe titLe""\n    **Output:** ""Capitalize The Title""\n    **Explanation:**\n    Since all the words have a length of at least 3 the first letter of each word is uppercase and the remaining letters are lowercase.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** title = ""First leTTeR of EACH Word""\n    **Output:** ""First Letter of Each Word""\n    **Explanation:**\n    The word ""of"" has length 2 so it is all lowercase.\n    The remaining words have a length of at least 3 so the first letter of each remaining word is uppercase and the remaining letters are lowercase.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** title = ""i lOve leetcode""\n    **Output:** ""i Love Leetcode""\n    **Explanation:**\n    The word ""i"" has length 1 so it is lowercase.\n    The remaining words have a length of at least 3 so the first letter of each remaining word is uppercase and the remaining letters are lowercase.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= title.length <= 100`\n  * `title` consists of words separated by a single space without any leading or trailing spaces.\n  * Each word consists of uppercase and lowercase English letters and is **non-empty**.\n\n",class Solution:\n    def capitalizeTitle(self title: str) -> str:\n        li = title.split()\n        for il in enumerate(li):\n            if len(l) <= 2:\n                li[i] = l.lower()\n            else:\n                li[i] = l[0].upper() + l[1:].lower()\n        return ' '.join(li)
Car Fleet,###  853\. Car Fleet\n\nThere are `n` cars going to the same destination along a one-lane road. The\ndestination is `target` miles away.\n\nYou are given two integer array `position` and `speed` both of length `n`\nwhere `position[i]` is the position of the `ith` car and `speed[i]` is the\nspeed of the `ith` car (in miles per hour).\n\nA car can never pass another car ahead of it but it can catch up to it and\ndrive bumper to bumper **at the same speed**. The faster car will **slow\ndown** to match the slower car's speed. The distance between these two cars is\nignored (i.e. they are assumed to have the same position).\n\nA **car fleet** is some non-empty set of cars driving at the same position and\nsame speed. Note that a single car is also a car fleet.\n\nIf a car catches up to a car fleet right at the destination point it will\nstill be considered as one car fleet.\n\nReturn _the**number of car fleets** that will arrive at the destination_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = 12 position = [108053] speed = [24113]\n    **Output:** 3\n    **Explanation:**\n    The cars starting at 10 (speed 2) and 8 (speed 4) become a fleet meeting each other at 12.\n    The car starting at 0 does not catch up to any other car so it is a fleet by itself.\n    The cars starting at 5 (speed 1) and 3 (speed 3) become a fleet meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n    Note that no other cars meet these fleets before the destination so the answer is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = 10 position = [3] speed = [3]\n    **Output:** 1\n    **Explanation:** There is only one car hence there is only one fleet.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** target = 100 position = [024] speed = [421]\n    **Output:** 1\n    **Explanation:**\n    The cars starting at 0 (speed 4) and 2 (speed 2) become a fleet meeting each other at 4. The fleet moves at speed 2.\n    Then the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n    \n\n\n\n**Constraints:**\n\n  * `n == position.length == speed.length`\n  * `1 <= n <= 105`\n  * `0 < target <= 106`\n  * `0 <= position[i] < target`\n  * All the values of `position` are **unique**.\n  * `0 < speed[i] <= 106`\n\n,# Runtime: 1570 ms (Top 45.22%) | Memory: 36.4 MB (Top 42.14%)\nclass Solution:\n    def carFleet(self target: int position: List[int] speed: List[int]) -> int:\n        def computeArrivalTime(curr_pos curr_speed):\n            nonlocal target\n            return (target - curr_pos) / curr_speed\n            # avoid integer division as a car may arrive at 5.2s and another at 5.6s\n\n        cars = list(zip(position speed))\n        cars.sort(key=lambda x: x[0] reverse=True)\n        arrival_bound = None # time upper bound\n        fleet = 0\n        for pos sp in cars:\n            curr_arrival = computeArrivalTime(pos sp)\n            if not arrival_bound or curr_arrival > arrival_bound:\n                arrival_bound = curr_arrival\n                fleet += 1\n        return fleet\n    # time O(n logn): sort = (nlogn); loop = (n)\n    # space O(n): depend on sort
Car Fleet II,###  1776\. Car Fleet II\n\nThere are `n` cars traveling at different speeds in the same direction along a\none-lane road. You are given an array `cars` of length `n` where `cars[i] =\n[positioni speedi]` represents:\n\n  * `positioni` is the distance between the `ith` car and the beginning of the road in meters. It is guaranteed that `positioni < positioni+1`.\n  * `speedi` is the initial speed of the `ith` car in meters per second.\n\nFor simplicity cars can be considered as points moving along the number line.\nTwo cars collide when they occupy the same position. Once a car collides with\nanother car they unite and form a single car fleet. The cars in the formed\nfleet will have the same position and the same speed which is the initial\nspeed of the **slowest** car in the fleet.\n\nReturn an array `answer` where `answer[i]` is the time in seconds at which\nthe `ith` car collides with the next car or `-1` if the car does not collide\nwith the next car. Answers within `10-5` of the actual answers are accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** cars = [[12][21][43][72]]\n    **Output:** [1.00000-1.000003.00000-1.00000]\n    **Explanation:** After exactly one second the first car will collide with the second car and form a car fleet with speed 1 m/s. After exactly 3 seconds the third car will collide with the fourth car and form a car fleet with speed 2 m/s.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cars = [[34][54][63][91]]\n    **Output:** [2.000001.000001.50000-1.00000]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= cars.length <= 105`\n  * `1 <= positioni speedi <= 106`\n  * `positioni < positioni+1`\n\n,class Car:\n    def __init__(self pos speed idx prev=None next=None):\n        self.pos = pos\n        self.speed = speed\n        self.idx = idx\n        self.prev = prev\n        self.next = next\n\nclass Solution:\n    def getCollisionTimes(self cars: List[List[int]]) -> List[float]:\n        colis_times = [-1] * len(cars)\n        cars = [Car(pos sp i) for i (pos sp) in enumerate(cars)]\n        for i in range(len(cars)-1): cars[i].next = cars[i+1]\n        for i in range(1 len(cars)): cars[i].prev = cars[i-1]\n        \n        catchup_order = [((b.pos-a.pos)/(a.speed-b.speed) a.idx a)\n                        for i (a b) \n                        in enumerate(zip(cars cars[1:])) if a.speed > b.speed]\n        heapify(catchup_order)\n        \n        while catchup_order:\n            catchup_time idx car = heappop(catchup_order)\n            if colis_times[idx] > -1: continue # ith car has already caught up\n            colis_times[idx] = catchup_time\n            if not car.prev: continue # no car is following us\n            car.prev.next car.next.prev = car.next car.prev\n            if car.next.speed >= car.prev.speed: continue # the follower is too slow to catch up\n            new_catchup_time = (car.next.pos-car.prev.pos)/(car.prev.speed-car.next.speed)\n            heappush(catchup_order (new_catchup_time car.prev.idx car.prev))\n        \n        return colis_times\n
Car Pooling,###  1094\. Car Pooling\n\nThere is a car with `capacity` empty seats. The vehicle only drives east\n(i.e. it cannot turn around and drive west).\n\nYou are given the integer `capacity` and an array `trips` where `trips[i] =\n[numPassengersi fromi toi]` indicates that the `ith` trip has\n`numPassengersi` passengers and the locations to pick them up and drop them\noff are `fromi` and `toi` respectively. The locations are given as the number\nof kilometers due east from the car's initial location.\n\nReturn `true` _if it is possible to pick up and drop off all passengers for\nall the given trips or_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** trips = [[215][337]] capacity = 4\n    **Output:** false\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** trips = [[215][337]] capacity = 5\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= trips.length <= 1000`\n  * `trips[i].length == 3`\n  * `1 <= numPassengersi <= 100`\n  * `0 <= fromi < toi <= 1000`\n  * `1 <= capacity <= 105`\n\n,class Solution:\n    def carPooling(self trips: List[List[int]] capacity: int) -> bool:\n        endheap = []\n        startheap = []\n        \n        for i in range(len(trips)):\n            endheap.append((trips[i][2]trips[i][0]trips[i][1]))\n            startheap.append((trips[i][1]trips[i][0]trips[i][2]))\n        heapify(endheap)\n        heapify(startheap)\n        cur = 0\n        while startheap:\n            startnumend = heappop(startheap)\n            while start >= endheap[0][0]:\n                newendnewnumnewstart = heappop(endheap)\n                cur -= newnum\n            cur += num\n            print(cur)\n            if cur >capacity:\n                return False\n        return True\n                \n                \n            \n        \n
Card Flipping Game,###  822\. Card Flipping Game\n\nYou are given two **0-indexed** integer arrays `fronts` and `backs` of length\n`n` where the `ith` card has the positive integer `fronts[i]` printed on the\nfront and `backs[i]` printed on the back. Initially each card is placed on a\ntable such that the front number is facing up and the other is facing down.\nYou may flip over any number of cards (possibly zero).\n\nAfter flipping the cards an integer is considered **good** if it is facing\ndown on some card and **not** facing up on any card.\n\nReturn _the minimum possible good integer after flipping the cards_. If there\nare no good integers return `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** fronts = [12447] backs = [13413]\n    **Output:** 2\n    **Explanation:**\n    If we flip the second card the face up numbers are [13447] and the face down are [12413].\n    2 is the minimum good integer as it appears facing down but not facing up.\n    It can be shown that 2 is the minimum possible good integer obtainable after flipping some cards.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** fronts = [1] backs = [1]\n    **Output:** 0\n    **Explanation:**\n    There are no good integers no matter how we flip the cards so we return 0.\n    \n\n\n\n**Constraints:**\n\n  * `n == fronts.length == backs.length`\n  * `1 <= n <= 1000`\n  * `1 <= fronts[i] backs[i] <= 2000`\n\n,# Runtime: 7624 ms (Top 5.13%) | Memory: 14.1 MB (Top 95.38%)\nclass Solution:\n    def flipgame(self fronts: List[int] backs: List[int]) -> int:\n        return min([v for v in fronts + backs if v not in set([i for i j in zip(fronts backs) if i == j])] or [0])
Cat and Mouse,###  913\. Cat and Mouse\n\nA game on an **undirected** graph is played by two players Mouse and Cat who\nalternate turns.\n\nThe graph is given as follows: `graph[a]` is a list of all nodes `b` such that\n`ab` is an edge of the graph.\n\nThe mouse starts at node `1` and goes first the cat starts at node `2` and\ngoes second and there is a hole at node `0`.\n\nDuring each player's turn they **must** travel along one edge of the graph\nthat meets where they are.  For example if the Mouse is at node 1 it\n**must** travel to any node in `graph[1]`.\n\nAdditionally it is not allowed for the Cat to travel to the Hole (node 0.)\n\nThen the game can end in three ways:\n\n  * If ever the Cat occupies the same node as the Mouse the Cat wins.\n  * If ever the Mouse reaches the Hole the Mouse wins.\n  * If ever a position is repeated (i.e. the players are in the same position as a previous turn and it is the same player's turn to move) the game is a draw.\n\nGiven a `graph` and assuming both players play optimally return\n\n  * `1` if the mouse wins the game\n  * `2` if the cat wins the game or\n  * `0` if the game is a draw.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg)\n\n    \n    \n    **Input:** graph = [[25][3][045][145][23][023]]\n    **Output:** 0\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg)\n\n    \n    \n    **Input:** graph = [[13][0][3][02]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `3 <= graph.length <= 50`\n  * `1 <= graph[i].length < graph.length`\n  * `0 <= graph[i][j] < graph.length`\n  * `graph[i][j] != i`\n  * `graph[i]` is unique.\n  * The mouse and the cat can always move. \n\n,class Solution:\n    def catMouseGame(self graph: List[List[int]]) -> int:\n        def getPreStates(mct):\n            ans = []\n            if t == 1:\n                for c2 in graph[c]:\n                    if c2 == 0:continue\n                    ans.append((mc22))\n            else:\n                for m2 in graph[m]:\n                    ans.append((m2c1))\n            return ans\n        \n        def ifAllNextMovesFailed(mct):\n            if t == 1:\n                for m2 in graph[m]:\n                    if result[(m2c2)] != 2:return False\n            else:\n                for c2 in graph[c]:\n                    if c2 == 0:continue\n                    if result[(mc21)] != 1:return False\n            return True\n        \n        result = defaultdict(lambda:0) \n        # key = (mcturn) value = (0/1/2)\n        n = len(graph)\n        queue = deque()\n        \n        for t in range(13):\n            for i in range(1n):\n                # mouse win \n                result[(0it)] = 1\n                queue.append((0it))\n                # cat win\n                result[(iit)] = 2\n                queue.append((iit))\n        \n        while queue:\n            mct = queue.popleft()\n            r = result[(mct)]\n            for m2c2t2 in getPreStates(mct):\n                r2 = result[(m2c2t2)]\n                if r2 > 0:continue\n                # populate prestate\n                if r == 3-t: # can always win\n                    result[(m2c2t2)] = r\n                    queue.append((m2c2t2))\n                elif ifAllNextMovesFailed(m2c2t2):\n                    result[(m2c2t2)] =3-t2\n                    queue.append((m2c2t2))\n        return result[(121)]\n                    \n
Cat and Mouse II,"###  1728\. Cat and Mouse II\n\nA game is played by a cat and a mouse named Cat and Mouse.\n\nThe environment is represented by a `grid` of size `rows x cols` where each\nelement is a wall floor player (Cat Mouse) or food.\n\n  * Players are represented by the characters `'C'`(Cat)`'M'`(Mouse).\n  * Floors are represented by the character `'.'` and can be walked on.\n  * Walls are represented by the character `'#'` and cannot be walked on.\n  * Food is represented by the character `'F'` and can be walked on.\n  * There is only one of each character `'C'` `'M'` and `'F'` in `grid`.\n\nMouse and Cat play according to the following rules:\n\n  * Mouse **moves first**  then they take turns to move.\n  * During each turn Cat and Mouse can jump in one of the four directions (left right up down). They cannot jump over the wall nor outside of the `grid`.\n  * `catJump mouseJump` are the maximum lengths Cat and Mouse can jump at a time respectively. Cat and Mouse can jump less than the maximum length.\n  * Staying in the same position is allowed.\n  * Mouse can jump over Cat.\n\nThe game can end in 4 ways:\n\n  * If Cat occupies the same position as Mouse Cat wins.\n  * If Cat reaches the food first Cat wins.\n  * If Mouse reaches the food first Mouse wins.\n  * If Mouse cannot get to the food within 1000 turns Cat wins.\n\nGiven a `rows x cols` matrix `grid` and two integers `catJump` and\n`mouseJump` return `true` _if Mouse can win the game if both Cat and Mouse\nplay optimally otherwise return_`false`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/12/sample_111_1955.png)\n\n    \n    \n    **Input:** grid = [""####F""""#C...""""M....""] catJump = 1 mouseJump = 2\n    **Output:** true\n    **Explanation:** Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/12/sample_2_1955.png)\n\n    \n    \n    **Input:** grid = [""M.C...F""] catJump = 1 mouseJump = 4\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [""M.C...F""] catJump = 1 mouseJump = 3\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `rows == grid.length`\n  * `cols = grid[i].length`\n  * `1 <= rows cols <= 8`\n  * `grid[i][j]` consist only of characters `'C'` `'M'` `'F'` `'.'` and `'#'`.\n  * There is only one of each character `'C'` `'M'` and `'F'` in `grid`.\n  * `1 <= catJump mouseJump <= 8`\n\n","class Solution:\n    def canMouseWin(self A: List[str] cj: int mj: int) -> bool:\n        # some helper functions:\n        xy2i = lambda x y: x * n + y\n        i2xy = lambda i: (i // n i % n)\n        def adj_grid(x0 y0 jump=1):\n            for dx dy in ((-1 0) (1 0) (0 -1) (0 1)):\n                for step in range(jump):\n                    x y = x0 + (step+1) * dx y0 + (step+1) * dy\n                    if not(0<=x<m and 0<=y<n) or A[x][y]==""#"": break\n                    yield x y\n        \n        m n jps = len(A) len(A[0]) (mj cj)\n        fi = mi = ci = 0  # location of food mouse cat\n        for i in range(m):\n            for j in range(n):\n                if A[i][j] == ""C"": ci = xy2i(i j)\n                elif A[i][j] == ""M"": mi = xy2i(i j)\n                elif A[i][j] == ""F"": fi = xy2i(i j)\n		\n		# BFS for unreachable food cases\n        def reach_food(x y):\n            B = [list(row) for row in A]\n            B[x][y] = ""#""\n            que = collections.deque([(x y)])\n            while que:\n                for x y in adj_grid(*que.popleft()):\n                    if B[x][y] == ""#"": continue\n                    if B[x][y] == ""F"": return True\n                    B[x][y] = ""#""\n                    que.append((x y))\n            return False\n        \n        if not reach_food(*i2xy(mi)): return False\n        elif not reach_food(*i2xy(ci)): return True\n        \n        # adjacent states counter\n        adj = [[[0] * (m*n) for _ in range(m*n)] for _ in range(2)]\n        for i0 in range(m*n):\n            for k in (0 1):\n                i = [0 0]\n                i[k] = i0\n                for x y in adj_grid(*i2xy(i0) jps[k]):\n                    adj[k][i[0]][i[1]] += 1\n                i2 = i.copy()\n                for i2[1-k] in range(m*n):\n                    adj[k][i2[0]][i2[1]] = adj[k][i[0]][i[1]]\n        \n        dp = [[[None] * (m*n) for _ in range(m*n)] for _ in range(2)]\n        que1 que2 = collections.deque() collections.deque()  # que1 for decisive states que2 for indecisive ones\n        for i in range(m*n):\n            x y = i2xy(i)\n            if A[x][y] == ""#"": continue\n            if i != fi:\n                dp[0][fi][i] = dp[1][fi][i] = True\n                que1.append((1 fi i))\n                que2.append((0 fi i))\n            dp[0][i][fi] = dp[1][i][fi] = dp[0][i][i] = dp[1][i][i] = False\n            que1.append((0ifi))\n            que2.append((1ifi))\n            que1.append((0ii))\n            que2.append((1ii))\n            \n        while que1 or que2:\n            while que1:\n                k2 mi2 ci2 = que1.popleft()\n                t = dp[k2][mi2][ci2]\n                k = 1 - k2\n                i = [mi2 ci2]\n                for x y in adj_grid(*i2xy(i[k]) jps[k]):\n                    i[k] = xy2i(x y)\n                    if dp[k][i[0]][i[1]] is None:\n                        dp[k][i[0]][i[1]] = t  # directly determine the value\n                        if (k i[0] i[1]) == (0 mi ci): return t\n                        que2.append((k i[0] i[1]))\n            while que2:\n                k2 mi2 ci2 = que2.popleft()\n                t = dp[k2][mi2][ci2]\n                k = 1 - k2\n                i = [mi2 ci2]\n                for x y in adj_grid(*i2xy(i[k]) jps[k]):\n                    i[k] = xy2i(x y)\n                    if dp[k][i[0]][i[1]] is None:\n                        adj[k][i[0]][i[1]] -= 1  # only change the counter\n                        if adj[k][i[0]][i[1]] == 0:\n                            dp[k][i[0]][i[1]] = t\n                            if (k i[0] i[1]) == (0 mi ci): return t\n                            que1.append((k i[0] i[1]))\n        \n        return dp[0][mi][ci]\n"
Cells with Odd Values in a Matrix,###  1252\. Cells with Odd Values in a Matrix\n\nThere is an `m x n` matrix that is initialized to all `0`'s. There is also a\n2D array `indices` where each `indices[i] = [ri ci]` represents a **0-indexed\nlocation** to perform some increment operations on the matrix.\n\nFor each location `indices[i]` do **both** of the following:\n\n  1. Increment **all** the cells on row `ri`.\n  2. Increment **all** the cells on column `ci`.\n\nGiven `m` `n` and `indices` return _the**number of odd-valued cells** in\nthe matrix after applying the increment to all locations in _`indices`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/10/30/e1.png)\n\n    \n    \n    **Input:** m = 2 n = 3 indices = [[01][11]]\n    **Output:** 6\n    **Explanation:** Initial matrix = [[000][000]].\n    After applying first increment it becomes [[121][010]].\n    The final matrix is [[131][131]] which contains 6 odd numbers.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/10/30/e2.png)\n\n    \n    \n    **Input:** m = 2 n = 2 indices = [[11][00]]\n    **Output:** 0\n    **Explanation:** Final matrix = [[22][22]]. There are no odd numbers in the final matrix.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m n <= 50`\n  * `1 <= indices.length <= 100`\n  * `0 <= ri < m`\n  * `0 <= ci < n`\n\n\n\n**Follow up:** Could you solve this in `O(n + m + indices.length)` time with\nonly `O(n + m)` extra space?\n\n,// Runtime: 81 ms (Top 40.72%) | Memory: 13.9 MB (Top 91.29%)\nclass Solution:\n    def oddCells(self row: int col: int indices: List[List[int]]) -> int:\n        rows cols = [False] * row [False] * col\n\n        for index in indices:\n            rows[index[0]] = not rows[index[0]]\n            cols[index[1]] = not cols[index[1]]\n\n        count = 0\n        for i in rows:\n            for j in cols:\n                count += i ^ j\n\n        return count
Chalkboard XOR Game,###  810\. Chalkboard XOR Game\n\nYou are given an array of integers `nums` represents the numbers written on a\nchalkboard.\n\nAlice and Bob take turns erasing exactly one number from the chalkboard with\nAlice starting first. If erasing a number causes the bitwise XOR of all the\nelements of the chalkboard to become `0` then that player loses. The bitwise\nXOR of one element is that element itself and the bitwise XOR of no elements\nis `0`.\n\nAlso if any player starts their turn with the bitwise XOR of all the elements\nof the chalkboard equal to `0` then that player wins.\n\nReturn `true` _if and only if Alice wins the game assuming both players play\noptimally_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [112]\n    **Output:** false\n    **Explanation:** \n    Alice has two choices: erase 1 or erase 2. \n    If she erases 1 the nums array becomes [1 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants because Alice will be the one to erase the last element and she will lose. \n    If Alice erases 2 first now nums become [1 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [01]\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `0 <= nums[i] < 216`\n\n,# Runtime: 84 ms (Top 36.7%) | Memory: 16.24 MB (Top 100.0%)\n\n\n\n\n\n\n\n\n\n\nclass Solution:\n  def xorGame(self nums: List[int]) -> bool:\n    return functools.reduce(operator.xor nums) == 0 or len(nums) % 2 == 0\n
Champagne Tower,###  799\. Champagne Tower\n\nWe stack glasses in a pyramid where the **first** row has `1` glass the\n**second** row has `2` glasses and so on until the 100th row.  Each glass\nholds one cup of champagne.\n\nThen some champagne is poured into the first glass at the top.  When the\ntopmost glass is full any excess liquid poured will fall equally to the glass\nimmediately to the left and right of it.  When those glasses become full any\nexcess champagne will fall equally to the left and right of those glasses and\nso on.  (A glass at the bottom row has its excess champagne fall on the\nfloor.)\n\nFor example after one cup of champagne is poured the top most glass is full.\nAfter two cups of champagne are poured the two glasses on the second row are\nhalf full.  After three cups of champagne are poured those two cups become\nfull - there are 3 full glasses total now.  After four cups of champagne are\npoured the third row has the middle glass half full and the two outside\nglasses are a quarter full as pictured below.\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png)\n\nNow after pouring some non-negative integer cups of champagne return how full\nthe `jth` glass in the `ith` row is (both `i` and `j` are 0-indexed.)\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** poured = 1 query_row = 1 query_glass = 1\n    **Output:** 0.00000\n    **Explanation:** We poured 1 cup of champange to the top glass of the tower (which is indexed as (0 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** poured = 2 query_row = 1 query_glass = 1\n    **Output:** 0.50000\n    **Explanation:** We poured 2 cups of champange to the top glass of the tower (which is indexed as (0 0)). There is one cup of excess liquid. The glass indexed as (1 0) and the glass indexed as (1 1) will share the excess liquid equally and each will get half cup of champange.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** poured = 100000009 query_row = 33 query_glass = 17\n    **Output:** 1.00000\n    \n\n\n\n**Constraints:**\n\n  * `0 <= poured <= 109`\n  * `0 <= query_glass <= query_row < 100`\n\n,# Runtime: 392 ms (Top 9.30%) | Memory: 14.4 MB (Top 11.38%)\nclass Solution:\n    def champagneTower(self poured: int r: int c: int) -> float:\n        quantity=defaultdict(int)\n        quantity[(00)]=poured\n        for i in range(r+1):\n            flag=False\n            for j in range(i+1):\n                prev_flow=quantity[(ij)]-1\n                if prev_flow<=0:\n                    continue\n                flag=True\n                quantity[(ij)]=1\n                quantity[(i+1j)]+=prev_flow/2\n                quantity[(i+1j+1)]+=prev_flow/2\n            if not flag: break\n        return quantity[(rc)]\n
Change Minimum Characters to Satisfy One of Three Conditions,"###  1737\. Change Minimum Characters to Satisfy One of Three Conditions\n\nYou are given two strings `a` and `b` that consist of lowercase letters. In\none operation you can change any character in `a` or `b` to **any lowercase\nletter**.\n\nYour goal is to satisfy **one** of the following three conditions:\n\n  * **Every** letter in `a` is **strictly less** than **every** letter in `b` in the alphabet.\n  * **Every** letter in `b` is **strictly less** than **every** letter in `a` in the alphabet.\n  * **Both** `a` and `b` consist of **only one** distinct letter.\n\nReturn _the**minimum** number of operations needed to achieve your goal._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** a = ""aba"" b = ""caa""\n    **Output:** 2\n    **Explanation:** Consider the best way to make each condition true:\n    1) Change b to ""ccc"" in 2 operations then every letter in a is less than every letter in b.\n    2) Change a to ""bbb"" and b to ""aaa"" in 3 operations then every letter in b is less than every letter in a.\n    3) Change a to ""aaa"" and b to ""aaa"" in 2 operations then a and b consist of one distinct letter.\n    The best way was done in 2 operations (either condition 1 or condition 3).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** a = ""dabadd"" b = ""cda""\n    **Output:** 3\n    **Explanation:** The best way is to make condition 1 true by changing b to ""eee"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= a.length b.length <= 105`\n  * `a` and `b` consist only of lowercase letters.\n\n",// Runtime: 115 ms (Top 83.64%) | Memory: 17.50 MB (Top 38.79%)\n\nclass Solution:\n    def minCharacters(self a: str b: str) -> int:\n        pa pb = [0]*26 [0]*26\n        for x in a: pa[ord(x)-97] += 1\n        for x in b: pb[ord(x)-97] += 1\n        \n        ans = len(a) - max(pa) + len(b) - max(pb) # condition 3\n        for i in range(25): \n            pa[i+1] += pa[i]\n            pb[i+1] += pb[i]\n            ans = min(ans pa[i] + len(b) - pb[i]) # condition 2\n            ans = min(ans len(a) - pa[i] + pb[i]) # condition 1\n        return ans \n
Cheapest Flights Within K Stops,###  787\. Cheapest Flights Within K Stops\n\nThere are `n` cities connected by some number of flights. You are given an\narray `flights` where `flights[i] = [fromi toi pricei]` indicates that there\nis a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src` `dst` and `k` return _**the\ncheapest price** from _`src` _to_`dst` _with at most_`k` _stops._ If there is\nno such route return __`-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-\nstops-3drawio.png)\n\n    \n    \n    **Input:** n = 4 flights = [[01100][12100][20100][13600][23200]] src = 0 dst = 3 k = 1\n    **Output:** 700\n    **Explanation:**\n    The graph is shown above.\n    The optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\n    Note that the path through cities [0123] is cheaper but is invalid because it uses 2 stops.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-\nstops-1drawio.png)\n\n    \n    \n    **Input:** n = 3 flights = [[01100][12100][02500]] src = 0 dst = 2 k = 1\n    **Output:** 200\n    **Explanation:**\n    The graph is shown above.\n    The optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2022/03/18/cheapest-flights-within-k-\nstops-2drawio.png)\n\n    \n    \n    **Input:** n = 3 flights = [[01100][12100][02500]] src = 0 dst = 2 k = 0\n    **Output:** 500\n    **Explanation:**\n    The graph is shown above.\n    The optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 100`\n  * `0 <= flights.length <= (n * (n - 1) / 2)`\n  * `flights[i].length == 3`\n  * `0 <= fromi toi < n`\n  * `fromi != toi`\n  * `1 <= pricei <= 104`\n  * There will not be any multiple flights between two cities.\n  * `0 <= src dst k < n`\n  * `src != dst`\n\n,"class Solution:\n	def findCheapestPrice(self n: int flights: List[List[int]] src: int dst: int k: int) -> int:\n		graph = defaultdict(list)\n		for uvw in flights: graph[u].append((vw))\n\n		pq = [(0src0)]\n		dis = [float('inf')]*n\n\n		while pq:\n			cnl = heappop(pq)\n			if n==dst: return c\n			if l > k or l>= dis[n]: continue\n			dis[n] = l\n			for vw in graph[n]:\n				heappush(pq(c+wvl+1))\n		return -1\n"
Check Array Formation Through Concatenation,###  1640\. Check Array Formation Through Concatenation\n\nYou are given an array of **distinct** integers `arr` and an array of integer\narrays `pieces` where the integers in `pieces` are **distinct**. Your goal is\nto form `arr` by concatenating the arrays in `pieces` **in any order**.\nHowever you are **not** allowed to reorder the integers in each array\n`pieces[i]`.\n\nReturn `true` _if it is possible_ _to form the array_`arr` _from_`pieces`.\nOtherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [1588] pieces = [[88][15]]\n    **Output:** true\n    **Explanation:** Concatenate [15] then [88]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [491816] pieces = [[161849]]\n    **Output:** false\n    **Explanation:** Even though the numbers match we cannot reorder pieces[0].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [9146478] pieces = [[78][464][91]]\n    **Output:** true\n    **Explanation:** Concatenate [91] then [464] then [78]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= pieces.length <= arr.length <= 100`\n  * `sum(pieces[i].length) == arr.length`\n  * `1 <= pieces[i].length <= arr.length`\n  * `1 <= arr[i] pieces[i][j] <= 100`\n  * The integers in `arr` are **distinct**.\n  * The integers in `pieces` are **distinct** (i.e. If we flatten pieces in a 1D array all the integers in this array are distinct).\n\n,class Solution:\n    def canFormArray(self arr: List[int] pieces: List[List[int]]) -> bool:\n        keys ans = {} []\n        for piece in pieces:\n            keys[piece[0]] = piece\n        for a in arr:\n            if a in keys:\n                ans.extend(keys[a])\n        return ''.join(map(str arr)) == ''.join(map(str ans))\n
Check Completeness of a Binary Tree,###  958\. Check Completeness of a Binary Tree\n\nGiven the `root` of a binary tree determine if it is a _complete binary\ntree_.\n\nIn a **[complete binary\ntree](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)** \nevery level except possibly the last is completely filled and all nodes in\nthe last level are as far left as possible. It can have between `1` and `2h`\nnodes inclusive at the last level `h`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png)\n\n    \n    \n    **Input:** root = [123456]\n    **Output:** true\n    **Explanation:** Every level before the last is full (ie. levels with node-values {1} and {2 3}) and all nodes in the last level ({4 5 6}) are as far left as possible.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png)\n\n    \n    \n    **Input:** root = [12345null7]\n    **Output:** false\n    **Explanation:** The node with value 7 isn't as far left as possible.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 100]`.\n  * `1 <= Node.val <= 1000`\n\n,"class Solution:\n	def isCompleteTree(self root: Optional[TreeNode]) -> bool:\n		# if not root: return True\n		def node_count(root):\n			if not root: return 0\n			return 1 + node_count(root.left) + node_count(root.right)\n\n		def isCBT(rooticount):\n			if not root: return True\n			if i>=count: return False\n			return isCBT(root.left2*i+1count) and isCBT(root.right2*i+2count)\n\n\n		return isCBT(root0node_count(root))"
Check If a String Can Break Another String,"###  1433\. Check If a String Can Break Another String\n\nGiven two strings: `s1` and `s2` with the same size check if some permutation\nof string `s1` can break some permutation of string `s2` or vice-versa. In\nother words `s2` can break `s1` or vice-versa.\n\nA string `x` can break string `y` (both of size `n`) if `x[i] >= y[i]` (in\nalphabetical order) for all `i` between `0` and `n-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s1 = ""abc"" s2 = ""xya""\n    **Output:** true\n    **Explanation:** ""ayx"" is a permutation of s2=""xya"" which can break to string ""abc"" which is a permutation of s1=""abc"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""abe"" s2 = ""acd""\n    **Output:** false \n    **Explanation:** All permutations for s1=""abe"" are: ""abe"" ""aeb"" ""bae"" ""bea"" ""eab"" and ""eba"" and all permutation for s2=""acd"" are: ""acd"" ""adc"" ""cad"" ""cda"" ""dac"" and ""dca"". However there is not any permutation from s1 which can break some permutation from s2 and vice-versa.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s1 = ""leetcodee"" s2 = ""interview""\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `s1.length == n`\n  * `s2.length == n`\n  * `1 <= n <= 10^5`\n  * All strings consist of lowercase English letters.\n\n",class Solution:\n    def checkIfCanBreak(self s1: str s2: str) -> bool:\n        s1 s2 = sorted(s1) sorted(s2)\n        return all(a1 >= a2 for a1 a2 in zip(s1 s2)) or all(a1 <= a2 for a1 a2 in zip(s1 s2))\n
Check If a String Contains All Binary Codes of Size K,"###  1461\. Check If a String Contains All Binary Codes of Size K\n\nGiven a binary string `s` and an integer `k` return `true` _if every binary\ncode of length_ `k` _is a substring of_ `s`. Otherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""00110110"" k = 2\n    **Output:** true\n    **Explanation:** The binary codes of length 2 are ""00"" ""01"" ""10"" and ""11"". They can be all found as substrings at indices 0 1 3 and 2 respectively.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""0110"" k = 1\n    **Output:** true\n    **Explanation:** The binary codes of length 1 are ""0"" and ""1"" it is clear that both exist as a substring. \n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""0110"" k = 2\n    **Output:** false\n    **Explanation:** The binary code ""00"" is of length 2 and does not exist in the array.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 5 * 105`\n  * `s[i]` is either `'0'` or `'1'`.\n  * `1 <= k <= 20`\n\n",class Solution:\n    def hasAllCodes(self s: str k: int) -> bool:\n        \n        Z = set()\n\n        for i in range(len(s)-k+1):\n            Z.add(s[i:i+k])\n            \n        if len(Z) == 2**k:\n            return True\n\n        return False
Check If a Word Occurs As a Prefix of Any Word in a Sentence,"###  1455\. Check If a Word Occurs As a Prefix of Any Word in a Sentence\n\nGiven a `sentence` that consists of some words separated by a **single space**\n and a `searchWord` check if `searchWord` is a prefix of any word in\n`sentence`.\n\nReturn _the index of the word in_`sentence` _(**1-indexed**) where\n_`searchWord` _is a prefix of this word_. If `searchWord` is a prefix of more\nthan one word return the index of the first word **(minimum index)**. If\nthere is no such word return `-1`.\n\nA **prefix** of a string `s` is any leading contiguous substring of `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** sentence = ""i love eating burger"" searchWord = ""burg""\n    **Output:** 4\n    **Explanation:** ""burg"" is prefix of ""burger"" which is the 4th word in the sentence.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** sentence = ""this problem is an easy problem"" searchWord = ""pro""\n    **Output:** 2\n    **Explanation:** ""pro"" is prefix of ""problem"" which is the 2nd and the 6th word in the sentence but we return 2 as it's the minimal index.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** sentence = ""i am tired"" searchWord = ""you""\n    **Output:** -1\n    **Explanation:** ""you"" is not a prefix of any word in the sentence.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= sentence.length <= 100`\n  * `1 <= searchWord.length <= 10`\n  * `sentence` consists of lowercase English letters and spaces.\n  * `searchWord` consists of lowercase English letters.\n\n","class Solution(object):\n    def isPrefixOfWord(self sentence searchWord):\n        """"""\n        :type sentence: str\n        :type searchWord: str\n        :rtype: int\n        """"""\n        word_list = sentence.split()\n        counter = 0\n        for word in sentence.split():\n            counter+=1\n            if searchWord == word[0:len(searchWord)]:\n                return counter\n        return -1\n"
Check If All 1's Are at Least Length K Places Away,###  1437\. Check If All 1's Are at Least Length K Places Away\n\nGiven an binary array `nums` and an integer `k` return `true` _if all_`1` _'s\nare at least_`k` _places away from each other otherwise return_`false`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/04/15/sample_1_1791.png)\n\n    \n    \n    **Input:** nums = [10001001] k = 2\n    **Output:** true\n    **Explanation:** Each of the 1s are at least 2 places away from each other.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/04/15/sample_2_1791.png)\n\n    \n    \n    **Input:** nums = [100101] k = 2\n    **Output:** false\n    **Explanation:** The second 1 and third 1 are only one apart from each other.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= k <= nums.length`\n  * `nums[i]` is `0` or `1`\n\n,class Solution:\n    def kLengthApart(self nums: List[int] k: int) -> bool:\n        pre = -k - 1\n        for i v in enumerate(nums):\n            if v:\n                if i - pre < k + 1:\n                    return False\n                else:\n                    pre = i\n        return True\n        \n
Check if All A's Appears Before All B's,"###  2124\. Check if All A's Appears Before All B's\n\nGiven a string `s` consisting of **only** the characters `'a'` and `'b'`\nreturn `true` _if**every** _`'a'` _appears before**every** _`'b'`_in the\nstring_. Otherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aaabbb""\n    **Output:** true\n    **Explanation:**\n    The 'a's are at indices 0 1 and 2 while the 'b's are at indices 3 4 and 5.\n    Hence every 'a' appears before every 'b' and we return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abab""\n    **Output:** false\n    **Explanation:**\n    There is an 'a' at index 2 and a 'b' at index 1.\n    Hence not every 'a' appears before every 'b' and we return false.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""bbb""\n    **Output:** true\n    **Explanation:**\n    There are no 'a's hence every 'a' appears before every 'b' and we return true.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s[i]` is either `'a'` or `'b'`.\n\n","class Solution:\n    def checkString(self s: str) -> bool:\n        if ""ba"" in s:\n            return False\n        else:\n            return True\n"
Check if All the Integers in a Range Are Covered,###  1893\. Check if All the Integers in a Range Are Covered\n\nYou are given a 2D integer array `ranges` and two integers `left` and `right`.\nEach `ranges[i] = [starti endi]` represents an **inclusive** interval between\n`starti` and `endi`.\n\nReturn `true` _if each integer in the inclusive range_ `[left right]` _is\ncovered by**at least one** interval in_ `ranges`. Return `false` _otherwise_.\n\nAn integer `x` is covered by an interval `ranges[i] = [starti endi]` if\n`starti <= x <= endi`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** ranges = [[12][34][56]] left = 2 right = 5\n    **Output:** true\n    **Explanation:** Every integer between 2 and 5 is covered:\n    - 2 is covered by the first range.\n    - 3 and 4 are covered by the second range.\n    - 5 is covered by the third range.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** ranges = [[110][1020]] left = 21 right = 21\n    **Output:** false\n    **Explanation:** 21 is not covered by any range.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= ranges.length <= 50`\n  * `1 <= starti <= endi <= 50`\n  * `1 <= left <= right <= 50`\n\n,class Solution:\n    def isCovered(self ranges: List[List[int]] left: int right: int) -> bool:\n        \n        \n        t=[0]*(60)\n        \n        for i in ranges:\n            \n            t[i[0]]+=1\n            t[i[1]+1]-=1\n            \n        for i in range(1len(t)):\n            t[i] += t[i-1]\n            \n        return min(t[left:right+1])>=1\n        \n        \n        \n        \n        \n
Check if an Original String Exists Given Two Encoded Strings,"###  2060\. Check if an Original String Exists Given Two Encoded Strings\n\nAn original string consisting of lowercase English letters can be encoded by\nthe following steps:\n\n  * Arbitrarily **split** it into a **sequence** of some number of **non-empty** substrings.\n  * Arbitrarily choose some elements (possibly none) of the sequence and **replace** each with **its length** (as a numeric string).\n  * **Concatenate** the sequence as the encoded string.\n\nFor example **one way** to encode an original string `""abcdefghijklmnop""`\nmight be:\n\n  * Split it as a sequence: `[""ab"" ""cdefghijklmn"" ""o"" ""p""]`.\n  * Choose the second and third elements to be replaced by their lengths respectively. The sequence becomes `[""ab"" ""12"" ""1"" ""p""]`.\n  * Concatenate the elements of the sequence to get the encoded string: `""ab121p""`.\n\nGiven two encoded strings `s1` and `s2` consisting of lowercase English\nletters and digits `1-9` (inclusive) return `true` _if there exists an\noriginal string that could be encoded as**both** _`s1` _and_`s2` _. Otherwise\nreturn_`false`.\n\n**Note** : The test cases are generated such that the number of consecutive\ndigits in `s1` and `s2` does not exceed `3`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s1 = ""internationalization"" s2 = ""i18n""\n    **Output:** true\n    **Explanation:** It is possible that ""internationalization"" was the original string.\n    - ""internationalization"" \n      -> Split:       [""internationalization""]\n      -> Do not replace any element\n      -> Concatenate:  ""internationalization"" which is s1.\n    - ""internationalization""\n      -> Split:       [""i"" ""nternationalizatio"" ""n""]\n      -> Replace:     [""i"" ""18""                 ""n""]\n      -> Concatenate:  ""i18n"" which is s2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""l123e"" s2 = ""44""\n    **Output:** true\n    **Explanation:** It is possible that ""leetcode"" was the original string.\n    - ""leetcode"" \n      -> Split:      [""l"" ""e"" ""et"" ""cod"" ""e""]\n      -> Replace:    [""l"" ""1"" ""2""  ""3""   ""e""]\n      -> Concatenate: ""l123e"" which is s1.\n    - ""leetcode"" \n      -> Split:      [""leet"" ""code""]\n      -> Replace:    [""4""    ""4""]\n      -> Concatenate: ""44"" which is s2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s1 = ""a5b"" s2 = ""c5b""\n    **Output:** false\n    **Explanation:** It is impossible.\n    - The original string encoded as s1 must start with the letter 'a'.\n    - The original string encoded as s2 must start with the letter 'c'.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s1.length s2.length <= 40`\n  * `s1` and `s2` consist of digits `1-9` (inclusive) and lowercase English letters only.\n  * The number of consecutive digits in `s1` and `s2` does not exceed `3`.\n\n","// Runtime: 1026 ms (Top 83.52%) | Memory: 55.5 MB (Top 82.18%)\nfrom functools import lru_cache\nclass Solution:\n    def possiblyEquals(self s1: str s2: str) -> bool:\n\n        def getValidPrefixLength(sstart):\n            end = start\n            while end < len(s) and s[end].isdigit(): end += 1\n            return end\n\n        @lru_cache(None)\n        def possibleLengths(s):\n            """"""Return all possible lengths represented by numeric string s.""""""\n            ans = {int(s)}\n            for i in range(1 len(s)):\n                # add all lengths by splitting numeric string s at i\n                ans |= {x+y for x in possibleLengths(s[:i]) for y in possibleLengths(s[i:])}\n            return ans\n\n        @lru_cache(None)\n        def dp(i j diff):\n            """"""Return True if s1[i:] matches s2[j:] with given differences.""""""\n\n            # If both have reached end return true if none of them are leading\n            if i == len(s1) and j == len(s2): return diff == 0\n\n            # s1 has not reached end and s1 starts with a digit\n            if i < len(s1) and s1[i].isdigit():\n                i2 = getValidPrefixLength(s1i)\n                for L in possibleLengths(s1[i:i2]):\n                    # substract since lead of s2 decreases by L\n                    if dp(i2 j diff-L): return True\n\n            # s2 has not reached end and s2 starts with a digit\n            elif j < len(s2) and s2[j].isdigit():\n                j2 = getValidPrefixLength(s2j)\n                for L in possibleLengths(s2[j:j2]):\n                    # add since lead of s2 increase by L\n                    if dp(i j2 diff+L): return True\n\n            # if none of them have integer prefix or a lead over the other\n            elif diff == 0:\n                # if only one of them has reached end or current alphabets are not the same\n                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False\n                # skip same alphabets\n                return dp(i+1 j+1 0)\n\n            # if none of them have integer prefix & s2 lead over s1\n            elif diff > 0:\n                # no s1 to balance s2's lead\n                if i == len(s1): return False\n                # move s1 pointer forward and reduce diff\n                return dp(i+1 j diff-1)\n\n            # if none of them have integer prefix & s1 lead over s2\n            else:\n                # no s2 to balance s1's lead\n                if j == len(s2): return False\n                # move s2 pointer forward and increase diff\n                return dp(i j+1 diff+1)\n\n        # start with starts of both s1 and s2 with no lead by any of them\n        return dp(0 0 0)"
Check If Array Pairs Are Divisible by k,###  1497\. Check If Array Pairs Are Divisible by k\n\nGiven an array of integers `arr` of even length `n` and an integer `k`.\n\nWe want to divide the array into exactly `n / 2` pairs such that the sum of\neach pair is divisible by `k`.\n\nReturn `true` _If you can find a way to do that or_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [12345106789] k = 5\n    **Output:** true\n    **Explanation:** Pairs are (19)(28)(37)(46) and (510).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [123456] k = 7\n    **Output:** true\n    **Explanation:** Pairs are (16)(25) and(34).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [123456] k = 10\n    **Output:** false\n    **Explanation:** You can try all possible pairs to see that there is no way to divide arr into 3 pairs each with sum divisible by 10.\n    \n\n\n\n**Constraints:**\n\n  * `arr.length == n`\n  * `1 <= n <= 105`\n  * `n` is even.\n  * `-109 <= arr[i] <= 109`\n  * `1 <= k <= 105`\n\n,# Runtime: 556 ms (Top 81.4%) | Memory: 30.00 MB (Top 97.8%)\n\nclass Solution:\n    def canArrange(self arr: List[int] k: int) -> bool:\n        #The idea is to count the residues\n        \n        #If every residue has the counter residue\n        #such that x+y == kthen we found a pair\n        \n        count = [0]*k\n        for num in arr:\n            count[num%k] +=1\n        \n        #Now since we have 012.....k-1 as residues\n        #If count[1] == count[k-1]pairs+=count[1]\n        #since we have odd number of complimenting residues\n        #we should also care about residue=0 and residue=k//2\n        \n        ij =1k-1\n        pairs  = 0\n        while i<j :\n            if count[i]!=count[j]:\n                return False\n            pairs += count[i]\n            i+=1\n            j-=1\n        if pairs>0 and i==j:\n            pairs+=count[i]/2\n        pairs+= count[0]/2\n        n = len(arr)\n        return pairs == n//2
Check if Binary String Has at Most One Segment of Ones,"###  1784\. Check if Binary String Has at Most One Segment of Ones\n\nGiven a binary string `s` **​​​​​without leading zeros**  return\n`true`​​​ _if_`s` _contains**at most one contiguous segment of ones**_.\nOtherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""1001""\n    **Output:** false\n    **Explanation:** The ones do not form a contiguous segment.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""110""\n    **Output:** true\n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s[i]`​​​​ is either `'0'` or `'1'`.\n  * `s[0]` is `'1'`.\n\n","# Runtime: 42 ms (Top 66.03%) | Memory: 13.8 MB (Top 52.02%)\nclass Solution:\n    def checkOnesSegment(self s: str) -> bool:\n        return ""01"" not in s"
Check if Every Row and Column Contains All Numbers,###  2133\. Check if Every Row and Column Contains All Numbers\n\nAn `n x n` matrix is **valid** if every row and every column contains **all**\nthe integers from `1` to `n` (**inclusive**).\n\nGiven an `n x n` integer matrix `matrix` return `true` _if the matrix\nis**valid**._ Otherwise return `false`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/21/example1drawio.png)\n\n    \n    \n    **Input:** matrix = [[123][312][231]]\n    **Output:** true\n    **Explanation:** In this case n = 3 and every row and column contains the numbers 1 2 and 3.\n    Hence we return true.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/21/example2drawio.png)\n\n    \n    \n    **Input:** matrix = [[111][123][123]]\n    **Output:** false\n    **Explanation:** In this case n = 3 but the first row and the first column do not contain the numbers 2 or 3.\n    Hence we return false.\n    \n\n\n\n**Constraints:**\n\n  * `n == matrix.length == matrix[i].length`\n  * `1 <= n <= 100`\n  * `1 <= matrix[i][j] <= n`\n\n,class Solution:\n    def checkValid(self matrix: List[List[int]]) -> bool:\n        lst = [0]*len(matrix)\n        for i in matrix:\n            if len(set(i)) != len(matrix):\n                return False\n            for j in range(len(i)):\n                lst[j] += i[j]\n        return len(set(lst)) == 1\n
Check If It Is a Good Array,###  1250\. Check If It Is a Good Array\n\nGiven an array `nums` of positive integers. Your task is to select some subset\nof `nums` multiply each element by an integer and add all these numbers. The\narray is said to be **good  **if you can obtain a sum of `1` from the array by\nany possible subset and multiplicand.\n\nReturn `True` if the array is **good  **otherwise return `False`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [125723]\n    **Output:** true\n    **Explanation:** Pick numbers 5 and 7.\n    5*3 + 7*(-2) = 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [29610]\n    **Output:** true\n    **Explanation:** Pick numbers 29 6 and 10.\n    29*1 + 6*(-3) + 10*(-1) = 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [36]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 10^5`\n  * `1 <= nums[i] <= 10^9`\n\n,# Runtime: 527 ms (Top 22.03%) | Memory: 24.7 MB (Top 71.19%)\nclass Solution:\n    def isGoodArray(self nums: List[int]) -> bool:\n        def gcd(ab):\n            while a:\n                a b = b%a a\n            return b\n        return reduce(gcdnums)==1
Check If It Is a Straight Line,###  1232\. Check If It Is a Straight Line\n\nYou are given an array `coordinates` `coordinates[i] = [x y]` where `[x\ny]` represents the coordinate of a point. Check if these points make a\nstraight line in the XY plane.\n\n\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/10/15/untitled-diagram-2.jpg)\n\n    \n    \n    **Input:** coordinates = [[12][23][34][45][56][67]]\n    **Output:** true\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2019/10/09/untitled-diagram-1.jpg)**\n\n    \n    \n    **Input:** coordinates = [[11][22][34][45][56][77]]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `2 <= coordinates.length <= 1000`\n  * `coordinates[i].length == 2`\n  * `-10^4 <= coordinates[i][0] coordinates[i][1] <= 10^4`\n  * `coordinates` contains no duplicate point.\n\n,"class Solution(object):\n    def checkStraightLine(self coordinates):\n        """"""\n        :type coordinates: List[List[int]]\n        :rtype: bool\n        """"""\n        if len(coordinates) == 2:\n            return True\n        \n        num = coordinates[1][1] - coordinates[0][1]\n        den = coordinates[1][0] - coordinates[0][0]\n        \n        for i in range(2 len(coordinates)):\n            if num * (coordinates[i][0] - coordinates[0][0]) != den * (coordinates[i][1] - coordinates[0][1]):\n                return False\n        \n        return True\n"
Check if Number is a Sum of Powers of Three,###  1780\. Check if Number is a Sum of Powers of Three\n\nGiven an integer `n` return `true` _if it is possible to represent_`n` _as\nthe sum of distinct powers of three._ Otherwise return `false`.\n\nAn integer `y` is a power of three if there exists an integer `x` such that `y\n== 3x`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 12\n    **Output:** true\n    **Explanation:** 12 = 31 + 32\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 91\n    **Output:** true\n    **Explanation:** 91 = 30 + 32 + 34\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 21\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 107`\n\n,// Runtime: 79 ms (Top 10.08%) | Memory: 17.20 MB (Top 9.7%)\n\nclass Solution:\n    def checkPowersOfThree(self n: int) -> bool:\n        while n > 1:\n            n r = divmod(n 3)\n            if r == 2: return False\n        return True\n
Check if Numbers Are Ascending in a Sentence,"###  2042\. Check if Numbers Are Ascending in a Sentence\n\nA sentence is a list of **tokens** separated by a **single** space with no\nleading or trailing spaces. Every token is either a **positive number**\nconsisting of digits `0-9` with no leading zeros or a **word** consisting of\nlowercase English letters.\n\n  * For example `""a puppy has 2 eyes 4 legs""` is a sentence with seven tokens: `""2""` and `""4""` are numbers and the other tokens such as `""puppy""` are words.\n\nGiven a string `s` representing a sentence you need to check if **all** the\nnumbers in `s` are **strictly increasing** from left to right (i.e. other\nthan the last number **each** number is **strictly smaller** than the number\non its **right** in `s`).\n\nReturn `true` _if so or_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n![example-1](https://assets.leetcode.com/uploads/2021/09/30/example1.png)\n\n    \n    \n    **Input:** s = ""1 box has 3 blue 4 red 6 green and 12 yellow marbles""\n    **Output:** true\n    **Explanation:** The numbers in s are: 1 3 4 6 12.\n    They are strictly increasing from left to right: 1 < 3 < 4 < 6 < 12.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""hello world 5 x 5""\n    **Output:** false\n    **Explanation:** The numbers in s are: _**5**_  **_5_**. They are not strictly increasing.\n    \n\n**Example 3:**\n\n![example-3](https://assets.leetcode.com/uploads/2021/09/30/example3.png)\n\n    \n    \n    **Input:** s = ""sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s""\n    **Output:** false\n    **Explanation:** The numbers in s are: 7 _**51**_  _**50**_  60. They are not strictly increasing.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= s.length <= 200`\n  * `s` consists of lowercase English letters spaces and digits from `0` to `9` inclusive.\n  * The number of tokens in `s` is between `2` and `100` inclusive.\n  * The tokens in `s` are separated by a single space.\n  * There are at least **two** numbers in `s`.\n  * Each number in `s` is a **positive** number **less** than `100` with no leading zeros.\n  * `s` contains no leading or trailing spaces.\n\n",# Runtime: 52 ms (Top 38.18%) | Memory: 13.8 MB (Top 55.89%)\nclass Solution:\n    def areNumbersAscending(self s):\n        nums = re.findall(r'\d+' s)\n        return nums == sorted(set(nums) key=int)
Check if One String Swap Can Make Strings Equal,"###  1790\. Check if One String Swap Can Make Strings Equal\n\nYou are given two strings `s1` and `s2` of equal length. A **string swap** is\nan operation where you choose two indices in a string (not necessarily\ndifferent) and swap the characters at these indices.\n\nReturn `true` _if it is possible to make both strings equal by performing**at\nmost one string swap** on **exactly one** of the strings. _Otherwise return\n`false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s1 = ""bank"" s2 = ""kanb""\n    **Output:** true\n    **Explanation:** For example swap the first character with the last character of s2 to make ""bank"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""attack"" s2 = ""defend""\n    **Output:** false\n    **Explanation:** It is impossible to make them equal with one string swap.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s1 = ""kelb"" s2 = ""kelb""\n    **Output:** true\n    **Explanation:** The two strings are already equal so no string swap operation is required.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s1.length s2.length <= 100`\n  * `s1.length == s2.length`\n  * `s1` and `s2` consist of only lowercase English letters.\n\n",# Runtime: 36 ms (Top 83.5%) | Memory: 16.25 MB (Top 70.5%)\n\nclass Solution:\n    def areAlmostEqual(self s1: str s2: str) -> bool:\n        diff = [[x y] for x y in zip(s1 s2) if x != y]\n        return not diff or len(diff) == 2 and diff[0][::-1] == diff[1]
Check If String Is a Prefix of Array,"###  1961\. Check If String Is a Prefix of Array\n\nGiven a string `s` and an array of strings `words` determine whether `s` is a\n**prefix string** of `words`.\n\nA string `s` is a **prefix string** of `words` if `s` can be made by\nconcatenating the first `k` strings in `words` for some **positive** `k` no\nlarger than `words.length`.\n\nReturn `true` _if_`s` _is a**prefix string** of _`words` _ or_`false`\n_otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""iloveleetcode"" words = [""i""""love""""leetcode""""apples""]\n    **Output:** true\n    **Explanation:**\n    s can be made by concatenating ""i"" ""love"" and ""leetcode"" together.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""iloveleetcode"" words = [""apples""""i""""love""""leetcode""]\n    **Output:** false\n    **Explanation:**\n    It is impossible to make s using a prefix of arr.\n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 100`\n  * `1 <= words[i].length <= 20`\n  * `1 <= s.length <= 1000`\n  * `words[i]` and `s` consist of only lowercase English letters.\n\n",class Solution:\n    def isPrefixString(self s: str words: List[str]) -> bool:\n        \n        a = ''\n    \n        for i in words:\n            \n            a += i\n            \n            if a == s:\n                return True\n            if not s.startswith(a):\n                break\n                     \n        return False \n
Check If String Is Transformable With Substring Sort Operations,"###  1585\. Check If String Is Transformable With Substring Sort Operations\n\nGiven two strings `s` and `t` transform string `s` into string `t` using the\nfollowing operation any number of times:\n\n  * Choose a **non-empty** substring in `s` and sort it in place so the characters are in **ascending order**. \n    * For example applying the operation on the underlined substring in `""1 _4234_ ""` results in `""1 _2344_ ""`.\n\nReturn `true` if _it is possible to transform`s` into `t`_. Otherwise return\n`false`.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""84532"" t = ""34852""\n    **Output:** true\n    **Explanation:** You can transform s into t using the following sort operations:\n    ""84 _53_ 2"" (from index 2 to 3) -> ""84 _35_ 2""\n    ""_843_ 52"" (from index 0 to 2) -> ""_348_ 52""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""34521"" t = ""23415""\n    **Output:** true\n    **Explanation:** You can transform s into t using the following sort operations:\n    ""_3452_ 1"" -> ""_2345_ 1""\n    ""234 _51_ "" -> ""234 _15_ ""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""12345"" t = ""12435""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `s.length == t.length`\n  * `1 <= s.length <= 105`\n  * `s` and `t` consist of only digits.\n\n",from collections import defaultdict\nclass Solution:\n    def isTransformable(self s: str t: str) -> bool:\n        index = defaultdict(list)\n        for i c in enumerate(s):\n            index[c].append(i)\n        curpos = defaultdict(int)\n        for c in t:\n            if curpos[c] == len(index[c]): return False\n            for i in range(int(c)):\n                i = str(i)\n                if curpos[i] < len(index[i]) and index[i][curpos[i]] < index[c][curpos[c]]:\n                    return False\n            curpos[c] += 1\n        return True
Check if There Is a Valid Parentheses String Path,"###  2267\. Check if There Is a Valid Parentheses String Path\n\nA parentheses string is a **non-empty** string consisting only of `'('` and\n`')'`. It is **valid** if **any** of the following conditions is **true** :\n\n  * It is `()`.\n  * It can be written as `AB` (`A` concatenated with `B`) where `A` and `B` are valid parentheses strings.\n  * It can be written as `(A)` where `A` is a valid parentheses string.\n\nYou are given an `m x n` matrix of parentheses `grid`. A **valid parentheses\nstring path** in the grid is a path satisfying **all** of the following\nconditions:\n\n  * The path starts from the upper left cell `(0 0)`.\n  * The path ends at the bottom-right cell `(m - 1 n - 1)`.\n  * The path only ever moves **down** or **right**.\n  * The resulting parentheses string formed by the path is **valid**.\n\nReturn `true` _if there exists a**valid parentheses string path** in the\ngrid._ Otherwise return `false`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png)\n\n    \n    \n    **Input:** grid = [[""(""""(""""(""]["")""""("""")""][""(""""("""")""][""(""""("""")""]]\n    **Output:** true\n    **Explanation:** The above diagram shows two possible paths that form valid parentheses strings.\n    The first path shown results in the valid parentheses string ""()(())"".\n    The second path shown results in the valid parentheses string ""((()))"".\n    Note that there may be other valid parentheses string paths.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png)\n\n    \n    \n    **Input:** grid = [["")"""")""][""(""""(""]]\n    **Output:** false\n    **Explanation:** The two possible paths form the parentheses strings ""))("" and "")(("". Since neither of them are valid parentheses strings we return false.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 100`\n  * `grid[i][j]` is either `'('` or `')'`.\n\n",// Runtime: 1143 ms (Top 75.31%) | Memory: 238.70 MB (Top 9.88%)\n\nclass Solution:\n    def hasValidPath(self grid: List[List[str]]) -> bool:  \n        m = len(grid)\n        n = len(grid[0])\n        @lru_cache(maxsize=None)\n        def hasValidPathInner(x y cnt):\n            # cnt variable would act as a counter to track \n            # the balance of parantheses sequence\n            if x == m or y == n or cnt < 0:\n                return False\n            \n            # logic to check the balance of sequence\n            cnt += 1 if grid[x][y] == '(' else -1\n            \n            # if balanced and end of grid return True\n            if x == m - 1 and y == n - 1 and not cnt:\n                return True\n            \n            return hasValidPathInner(x + 1 y cnt) or hasValidPathInner(x y + 1 cnt)\n\n        return hasValidPathInner(0 0 0)\n
Check if There is a Valid Partition For The Array,###  2369\. Check if There is a Valid Partition For The Array\n\nYou are given a **0-indexed** integer array `nums`. You have to partition the\narray into one or more **contiguous** subarrays.\n\nWe call a partition of the array **valid** if each of the obtained subarrays\nsatisfies **one** of the following conditions:\n\n  1. The subarray consists of **exactly** `2` equal elements. For example the subarray `[22]` is good.\n  2. The subarray consists of **exactly** `3` equal elements. For example the subarray `[444]` is good.\n  3. The subarray consists of **exactly** `3` consecutive increasing elements that is the difference between adjacent elements is `1`. For example the subarray `[345]` is good but the subarray `[135]` is not.\n\nReturn `true` _if the array has**at least** one valid partition_. Otherwise\nreturn `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [44456]\n    **Output:** true\n    **Explanation:** The array can be partitioned into the subarrays [44] and [456].\n    This partition is valid so we return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1112]\n    **Output:** false\n    **Explanation:** There is no valid partition for this array.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 105`\n  * `1 <= nums[i] <= 106`\n\n,# Runtime: 920 ms (Top 32.4%) | Memory: 30.14 MB (Top 95.0%)\n\nclass Solution:\n    def validPartition(self nums: List[int]) -> bool:\n        n = len(nums)\n        \n        dp = [False] * 3\n        dp[0] = True  # An empty partition is always valid\n\n        for i in range(2 n + 1):\n            ans = False\n\n            if nums[i - 1] == nums[i - 2]:\n                ans = ans or dp[(i - 2) % 3]\n            if i >= 3 and nums[i - 1] == nums[i - 2] == nums[i - 3]:\n                ans = ans or dp[(i - 3) % 3]\n            if i >= 3 and nums[i - 1] == nums[i - 2] + 1 == nums[i - 3] + 2:\n                ans = ans or dp[(i - 3) % 3]\n\n            dp[i % 3] = ans\n\n        return dp[n % 3]
Check if There is a Valid Path in a Grid,###  1391\. Check if There is a Valid Path in a Grid\n\nYou are given an `m x n` `grid`. Each cell of `grid` represents a street. The\nstreet of `grid[i][j]` can be:\n\n  * `1` which means a street connecting the left cell and the right cell.\n  * `2` which means a street connecting the upper cell and the lower cell.\n  * `3` which means a street connecting the left cell and the lower cell.\n  * `4` which means a street connecting the right cell and the lower cell.\n  * `5` which means a street connecting the left cell and the upper cell.\n  * `6` which means a street connecting the right cell and the upper cell.\n\n![](https://assets.leetcode.com/uploads/2020/03/05/main.png)\n\nYou will initially start at the street of the upper-left cell `(0 0)`. A\nvalid path in the grid is a path that starts from the upper left cell `(0 0)`\nand ends at the bottom-right cell `(m - 1 n - 1)`. **The path should only\nfollow the streets**.\n\n**Notice** that you are **not allowed** to change any street.\n\nReturn `true` _if there is a valid path in the grid or_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/03/05/e1.png)\n\n    \n    \n    **Input:** grid = [[243][652]]\n    **Output:** true\n    **Explanation:** As shown you can start at cell (0 0) and visit all the cells of the grid to reach (m - 1 n - 1).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/03/05/e2.png)\n\n    \n    \n    **Input:** grid = [[121][121]]\n    **Output:** false\n    **Explanation:** As shown you the street at cell (0 0) is not connected with any street of any other cell and you will get stuck at cell (0 0)\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[112]]\n    **Output:** false\n    **Explanation:** You will get stuck at cell (0 1) and you cannot reach cell (0 2).\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 300`\n  * `1 <= grid[i][j] <= 6`\n\n,class Solution:\n    def hasValidPath(self grid: List[List[int]]) -> bool:\n        rc=len(grid)len(grid[0])\n        dic={\n            2:[(-10)(10)]\n            1:[(01)(0-1)]\n            5:[(-10)(0-1)]\n            3:[(10)(0-1)]\n            6:[(01)(-10)]\n            4:[(01)(10)]\n            \n        }\n        q=collections.deque([(00)])\n        visit=set()\n        while q:\n            ij=q.popleft()\n            visit.add((ij))\n            if i==r-1 and j==c-1:\n                return True\n            for xy in dic[grid[i][j]]:\n                nx=i+x\n                ny=j+y\n                if nx>=0 and nx<r and ny>=0 and ny<c and (nxny) not in visit:\n                    if (-x-y) in dic[grid[nx][ny]]:\n                        q.append((nxny))\n        return False\n
Check If Two String Arrays are Equivalent,"###  1662\. Check If Two String Arrays are Equivalent\n\nGiven two string arrays `word1` and `word2` return __`true` _if the two\narrays**represent** the same string and _`false` _otherwise._\n\nA string is **represented** by an array if the array elements concatenated\n**in order** forms the string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word1 = [""ab"" ""c""] word2 = [""a"" ""bc""]\n    **Output:** true\n    **Explanation:**\n    word1 represents string ""ab"" + ""c"" -> ""abc""\n    word2 represents string ""a"" + ""bc"" -> ""abc""\n    The strings are the same so return true.\n\n**Example 2:**\n\n    \n    \n    **Input:** word1 = [""a"" ""cb""] word2 = [""ab"" ""c""]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** word1  = [""abc"" ""d"" ""defg""] word2 = [""abcddefg""]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word1.length word2.length <= 103`\n  * `1 <= word1[i].length word2[i].length <= 103`\n  * `1 <= sum(word1[i].length) sum(word2[i].length) <= 103`\n  * `word1[i]` and `word2[i]` consist of lowercase letters.\n\n","class Solution:\n    def arrayStringsAreEqual(self word1: List[str] word2: List[str]) -> bool:\n        return True if """".join(word1) == """".join(word2) else False"
Check if Word Can Be Placed In Crossword,"###  2018\. Check if Word Can Be Placed In Crossword\n\nYou are given an `m x n` matrix `board` representing the**current** state of\na crossword puzzle. The crossword contains lowercase English letters (from\nsolved words) `' '` to represent any **empty** cells and `'#'` to represent\nany **blocked** cells.\n\nA word can be placed**horizontally** (left to right **or** right to left) or\n**vertically** (top to bottom **or** bottom to top) in the board if:\n\n  * It does not occupy a cell containing the character `'#'`.\n  * The cell each letter is placed in must either be `' '` (empty) or **match** the letter already on the `board`.\n  * There must not be any empty cells `' '` or other lowercase letters **directly left or right****** of the word if the word was placed **horizontally**.\n  * There must not be any empty cells `' '` or other lowercase letters **directly above or below** the word if the word was placed **vertically**.\n\nGiven a string `word` return `true` _if_`word` _can be placed in_`board` _\nor_`false` _**otherwise**_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/10/04/crossword-ex1-1.png)\n\n    \n    \n    **Input:** board = [[""#"" "" "" ""#""] ["" "" "" "" ""#""] [""#"" ""c"" "" ""]] word = ""abc""\n    **Output:** true\n    **Explanation:** The word ""abc"" can be placed as shown above (top to bottom).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/10/04/crossword-ex2-1.png)\n\n    \n    \n    **Input:** board = [["" "" ""#"" ""a""] ["" "" ""#"" ""c""] ["" "" ""#"" ""a""]] word = ""ac""\n    **Output:** false\n    **Explanation:** It is impossible to place the word because there will always be a space/letter above or below it.\n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/10/04/crossword-ex3-1.png)\n\n    \n    \n    **Input:** board = [[""#"" "" "" ""#""] ["" "" "" "" ""#""] [""#"" "" "" ""c""]] word = ""ca""\n    **Output:** true\n    **Explanation:** The word ""ca"" can be placed as shown above (right to left). \n    \n\n\n\n**Constraints:**\n\n  * `m == board.length`\n  * `n == board[i].length`\n  * `1 <= m * n <= 2 * 105`\n  * `board[i][j]` will be `' '` `'#'` or a lowercase English letter.\n  * `1 <= word.length <= max(m n)`\n  * `word` will contain only lowercase English letters.\n\n","class Solution:\n    def placeWordInCrossword(self board: List[List[str]] word: str) -> bool:\n        m n = len(board) len(board[0])\n        W = len(word)\n        \n        def valid(x y):\n            return 0 <= x < m and 0 <= y < n\n        \n        def place(x y word direction):\n            dx dy = direction\n            for c in word:\n                if not valid(x y) or board[x][y] == '#' or (board[x][y] != ' ' and board[x][y] != c):\n                    return False\n                x y = x+dx y+dy\n            return True\n            \n        \n        for x in range(m):\n            for y in range(n):\n                if board[x][y] == '#' or (board[x][y] != ' ' and board[x][y] != word[0]):\n                    continue\n                \n                # left to right\n                if (not valid(x y-1) or board[x][y-1] == '#') and (not valid(x y+W) or board[x][y+W] == '#') and place(x y word [0 1]):\n                    return True\n                \n                # right to left\n                if (not valid(x y+1) or board[x][y+1] == '#') and (not valid(x y-W) or board[x][y-W] == '#') and place(x y word [0 -1]):\n                    return True\n                \n                # top to bottom\n                if (not valid(x-1 y) or board[x-1][y] == '#') and (not valid(x+W y) or board[x+W][y] == '#') and place(x y word [1 0]):\n                    return True\n                \n				# bottom to top\n                if (not valid(x+1 y) or board[x+1][y] == '#') and (not valid(x-W y) or board[x-W][y] == '#') and place(x y word [-1 0]):\n                    return True\n                \n        return False\n"
Check if Word Equals Summation of Two Words,"###  1880\. Check if Word Equals Summation of Two Words\n\nThe **letter value** of a letter is its position in the alphabet **starting\nfrom 0** (i.e. `'a' -> 0` `'b' -> 1` `'c' -> 2` etc.).\n\nThe **numerical value** of some string of lowercase English letters `s` is the\n**concatenation** of the **letter values** of each letter in `s` which is\nthen **converted** into an integer.\n\n  * For example if `s = ""acb""` we concatenate each letter's letter value resulting in `""021""`. After converting it we get `21`.\n\nYou are given three strings `firstWord` `secondWord` and `targetWord` each\nconsisting of lowercase English letters `'a'` through `'j'` **inclusive**.\n\nReturn `true` _if the**summation** of the **numerical values** of _`firstWord`\n_and_`secondWord` _equals the**numerical value** of _`targetWord` _\nor_`false` _otherwise._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** firstWord = ""acb"" secondWord = ""cba"" targetWord = ""cdb""\n    **Output:** true\n    **Explanation:**\n    The numerical value of firstWord is ""acb"" -> ""021"" -> 21.\n    The numerical value of secondWord is ""cba"" -> ""210"" -> 210.\n    The numerical value of targetWord is ""cdb"" -> ""231"" -> 231.\n    We return true because 21 + 210 == 231.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** firstWord = ""aaa"" secondWord = ""a"" targetWord = ""aab""\n    **Output:** false\n    **Explanation:** \n    The numerical value of firstWord is ""aaa"" -> ""000"" -> 0.\n    The numerical value of secondWord is ""a"" -> ""0"" -> 0.\n    The numerical value of targetWord is ""aab"" -> ""001"" -> 1.\n    We return false because 0 + 0 != 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** firstWord = ""aaa"" secondWord = ""a"" targetWord = ""aaaa""\n    **Output:** true\n    **Explanation:** \n    The numerical value of firstWord is ""aaa"" -> ""000"" -> 0.\n    The numerical value of secondWord is ""a"" -> ""0"" -> 0.\n    The numerical value of targetWord is ""aaaa"" -> ""0000"" -> 0.\n    We return true because 0 + 0 == 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= firstWord.length ``secondWord.length ``targetWord.length <= 8`\n  * `firstWord` `secondWord` and `targetWord` consist of lowercase English letters from `'a'` to `'j'` **inclusive**.\n\n","# Runtime: 40 ms (Top 58.1%) | Memory: 16.21 MB (Top 73.9%)\n\nclass Solution:\n    def isSumEqual(self firstWord: str secondWord: str targetWord: str) -> bool:\n        x=['a''b''c''d''e''f''g''h''i''j''k''l''m''n''o''p''q''r''s''t''u''v''w''x''y''z']\n        a=""""\n        for i in firstWord:\n            a=a+str(x.index(i))\n        \n        b=""""\n        for i in secondWord:\n            b=b+str(x.index(i))\n\n        c=""""\n        for i in targetWord:\n            c=c+str(x.index(i))\n        if int(a)+int(b)==int(c):\n            return True\n        return False"
Check If Word Is Valid After Substitutions,"###  1003\. Check If Word Is Valid After Substitutions\n\nGiven a string `s` determine if it is **valid**.\n\nA string `s` is **valid** if starting with an empty string `t = """"` you can\n**transform**`t`**into**`s` after performing the following operation **any\nnumber of times** :\n\n  * Insert string `""abc""` into any position in `t`. More formally `t` becomes `tleft + ""abc"" + tright` where `t == tleft + tright`. Note that `tleft` and `tright` may be **empty**.\n\nReturn `true` _if_`s` _is a**valid** string otherwise return_ `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aabcbc""\n    **Output:** true\n    **Explanation:**\n    """" -> ""_abc_ "" -> ""a _abc_ bc""\n    Thus ""aabcbc"" is valid.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcabcababcc""\n    **Output:** true\n    **Explanation:**\n    """" -> ""_abc_ "" -> ""abc _abc_ "" -> ""abcabc _abc_ "" -> ""abcabcab _abc_ c""\n    Thus ""abcabcababcc"" is valid.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""abccba""\n    **Output:** false\n    **Explanation:** It is impossible to get ""abccba"" using the operation.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 2 * 104`\n  * `s` consists of letters `'a'` `'b'` and `'c'`\n\n","class Solution:\n    def isValid(self s: str) -> bool:\n        \n        \n        ans = ''\n        for i in s:\n            ans+=i\n            while len(ans)>=3:\n                if ans[-3:]==""abc"":\n                    ans=ans[0:-3]\n                else:\n                    break\n            \n        if ans=='':\n            return True\n        else:\n            return False"
Check Whether Two Strings are Almost Equivalent,"###  2068\. Check Whether Two Strings are Almost Equivalent\n\nTwo strings `word1` and `word2` are considered **almost equivalent** if the\ndifferences between the frequencies of each letter from `'a'` to `'z'` between\n`word1` and `word2` is **at most** `3`.\n\nGiven two strings `word1` and `word2` each of length `n` return `true`\n_if_`word1` _and_ `word2` _are**almost equivalent**  or_ `false` _otherwise_.\n\nThe **frequency** of a letter `x` is the number of times it occurs in the\nstring.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word1 = ""aaaa"" word2 = ""bccb""\n    **Output:** false\n    **Explanation:** There are 4 'a's in ""aaaa"" but 0 'a's in ""bccb"".\n    The difference is 4 which is more than the allowed 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word1 = ""abcdeef"" word2 = ""abaaacc""\n    **Output:** true\n    **Explanation:** The differences between the frequencies of each letter in word1 and word2 are at most 3:\n    - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n    - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n    - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n    - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n    - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n    - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** word1 = ""cccddabba"" word2 = ""babababab""\n    **Output:** true\n    **Explanation:** The differences between the frequencies of each letter in word1 and word2 are at most 3:\n    - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n    - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n    - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n    - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.\n    \n\n\n\n**Constraints:**\n\n  * `n == word1.length == word2.length`\n  * `1 <= n <= 100`\n  * `word1` and `word2` consist only of lowercase English letters.\n\n","class Solution:\n    def checkAlmostEquivalent(self w1: str w2: str) -> bool:\n		return all(v < 4 for v in ((Counter(w1) - Counter(w2)) + (Counter(w2) - Counter(w1))).values())\n"
Cherry Pickup II,###  1463\. Cherry Pickup II\n\nYou are given a `rows x cols` matrix `grid` representing a field of cherries\nwhere `grid[i][j]` represents the number of cherries that you can collect from\nthe `(i j)` cell.\n\nYou have two robots that can collect cherries for you:\n\n  * **Robot #1** is located at the **top-left corner** `(0 0)` and\n  * **Robot #2** is located at the **top-right corner** `(0 cols - 1)`.\n\nReturn _the maximum number of cherries collection using both robots by\nfollowing the rules below_ :\n\n  * From a cell `(i j)` robots can move to cell `(i + 1 j - 1)` `(i + 1 j)` or `(i + 1 j + 1)`.\n  * When any robot passes through a cell It picks up all cherries and the cell becomes an empty cell.\n  * When both robots stay in the same cell only one takes the cherries.\n  * Both robots cannot move outside of the grid at any moment.\n  * Both robots should reach the bottom row in `grid`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/04/29/sample_1_1802.png)\n\n    \n    \n    **Input:** grid = [[311][251][155][211]]\n    **Output:** 24\n    **Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\n    Cherries taken by Robot #1 (3 + 2 + 5 + 2) = 12.\n    Cherries taken by Robot #2 (1 + 5 + 5 + 1) = 12.\n    Total of cherries: 12 + 12 = 24.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/04/23/sample_2_1802.png)\n\n    \n    \n    **Input:** grid = [[1000001][2000030][2090000][0305400][1023006]]\n    **Output:** 28\n    **Explanation:** Path of robot #1 and #2 are described in color green and blue respectively.\n    Cherries taken by Robot #1 (1 + 9 + 5 + 2) = 17.\n    Cherries taken by Robot #2 (1 + 3 + 4 + 3) = 11.\n    Total of cherries: 17 + 11 = 28.\n    \n\n\n\n**Constraints:**\n\n  * `rows == grid.length`\n  * `cols == grid[i].length`\n  * `2 <= rows cols <= 70`\n  * `0 <= grid[i][j] <= 100`\n\n,// Runtime: 609 ms (Top 95.65%) | Memory: 24.30 MB (Top 75.94%)\n\nclass Solution:\n    def cherryPickup(self grid: List[List[int]]) -> int:\n        rows cols = len(grid) len(grid[0])\n        \n        dp = [[[0]*(cols + 2) for _ in range(cols + 2)] for _ in range(rows + 1)]\n        \n        def get_next_max(row col_r1 col_r2):\n            res = 0\n            for next_col_r1 in (col_r1 - 1 col_r1 col_r1 + 1):\n                for next_col_r2 in (col_r2 - 1 col_r2 col_r2 + 1):\n                    res = max(res dp[row + 1][next_col_r1 + 1][next_col_r2 + 1])\n\n            return res\n        \n        for row in reversed(range(rows)):\n            for col_r1 in range(min(cols row + 2)):\n                for col_r2 in range(max(0 cols - row - 1) cols):\n\n                    reward = grid[row][col_r1] + grid[row][col_r2]\n                    if col_r1 == col_r2:\n                        reward /= 2\n                    \n                    dp[row][col_r1 + 1][col_r2 + 1] = reward + get_next_max(row col_r1 col_r2)\n                    \n        return dp[0][1][cols]\n
Cinema Seat Allocation,###  1386\. Cinema Seat Allocation\n\n![](https://assets.leetcode.com/uploads/2020/02/14/cinema_seats_1.png)\n\nA cinema has `n` rows of seats numbered from 1 to `n` and there are ten seats\nin each row labelled from 1 to 10 as shown in the figure above.\n\nGiven the array `reservedSeats` containing the numbers of seats already\nreserved for example `reservedSeats[i] = [38]` means the seat located in\nrow **3** and labelled with **8**  is already reserved.\n\n_Return the maximum number of four-person groups  you can assign on the cinema\nseats._ A four-person group occupies four adjacent seats **in one single\nrow**. Seats across an aisle (such as [33] and [34]) are not considered to\nbe adjacent but there is an exceptional case on which an aisle split a four-\nperson group in that case the aisle split a four-person group in the middle\nwhich means to have two people on each side.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/02/14/cinema_seats_3.png)\n\n    \n    \n    **Input:** n = 3 reservedSeats = [[12][13][18][26][31][310]]\n    **Output:** 4\n    **Explanation:** The figure above shows the optimal allocation for four groups where seats mark with blue are already reserved and contiguous seats mark with orange are for one group.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 reservedSeats = [[21][18][26]]\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 4 reservedSeats = [[43][14][46][17]]\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 10^9`\n  * `1 <= reservedSeats.length <= min(10*n 10^4)`\n  * `reservedSeats[i].length == 2`\n  * `1 <= reservedSeats[i][0] <= n`\n  * `1 <= reservedSeats[i][1] <= 10`\n  * All `reservedSeats[i]` are distinct.\n\n,"class Solution(object):\n    def maxNumberOfFamilies(self n reservedSeats):\n        """"""\n        :type n: int\n        :type reservedSeats: List[List[int]]\n        :rtype: int\n        """"""\n        d = defaultdict(set)\n        for rowseat in reservedSeats:\n            d[row].add(seat)\n        \n        def row(i):\n            a1 = not set((2345)).intersection(d[i])\n            a2 = not set((6789)).intersection(d[i])\n            if  a1 and a2:\n                return 2\n            if  a1 or a2:\n                return 1\n            return 1 if not set((4567)).intersection(d[i]) else 0\n        \n        return sum((row(i) for i in d.keys())) + (n-len(d)) * 2\n\n"
Circle and Rectangle Overlapping,###  1401\. Circle and Rectangle Overlapping\n\nYou are given a circle represented as `(radius xCenter yCenter)` and an\naxis-aligned rectangle represented as `(x1 y1 x2 y2)` where `(x1 y1)` are\nthe coordinates of the bottom-left corner and `(x2 y2)` are the coordinates\nof the top-right corner of the rectangle.\n\nReturn `true` _if the circle and rectangle are overlapped otherwise\nreturn_`false`. In other words check if there is **any** point `(xi yi)`\nthat belongs to the circle and the rectangle at the same time.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/02/20/sample_4_1728.png)\n\n    \n    \n    **Input:** radius = 1 xCenter = 0 yCenter = 0 x1 = 1 y1 = -1 x2 = 3 y2 = 1\n    **Output:** true\n    **Explanation:** Circle and rectangle share the point (10).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** radius = 1 xCenter = 1 yCenter = 1 x1 = 1 y1 = -3 x2 = 2 y2 = -1\n    **Output:** false\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/02/20/sample_2_1728.png)\n\n    \n    \n    **Input:** radius = 1 xCenter = 0 yCenter = 0 x1 = -1 y1 = 0 x2 = 0 y2 = 1\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= radius <= 2000`\n  * `-104 <= xCenter yCenter <= 104`\n  * `-104 <= x1 < x2 <= 104`\n  * `-104 <= y1 < y2 <= 104`\n\n,"class Solution:\n    def checkOverlap(self radius: int xCenter: int yCenter: int x1: int y1: int x2: int y2: int) -> bool:\n        \n        def find(a1 a2 aCenter):\n            if a1 <= aCenter and aCenter <= a2:\n                return 0 \n            elif a1 > aCenter:\n                return  a1 - aCenter\n            else:\n                return aCenter - a2\n\n        return (find(x1 x2 xCenter))**2 + (find(y1 y2 yCenter))**2 <= radius**2 \n	```"
Circular Array Loop,###  457\. Circular Array Loop\n\nYou are playing a game involving a **circular** array of non-zero integers\n`nums`. Each `nums[i]` denotes the number of indices forward/backward you must\nmove if you are located at index `i`:\n\n  * If `nums[i]` is positive move `nums[i]` steps **forward**  and\n  * If `nums[i]` is negative move `nums[i]` steps **backward**.\n\nSince the array is **circular**  you may assume that moving forward from the\nlast element puts you on the first element and moving backwards from the\nfirst element puts you on the last element.\n\nA **cycle** in the array consists of a sequence of indices `seq` of length `k`\nwhere:\n\n  * Following the movement rules above results in the repeating index sequence `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`\n  * Every `nums[seq[j]]` is either **all positive** or **all negative**.\n  * `k > 1`\n\nReturn `true` _if there is a**cycle** in _`nums` _ or_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [2-1122]\n    **Output:** true\n    **Explanation:**\n    There is a cycle from index 0 -> 2 -> 3 -> 0 -> ...\n    The cycle's length is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-12]\n    **Output:** false\n    **Explanation:**\n    The sequence from index 1 -> 1 -> 1 -> ... is not a cycle because the sequence's length is 1.\n    By definition the sequence's length must be strictly greater than 1 to be a cycle.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [-21-1-2-2]\n    **Output:** false\n    **Explanation:**\n    The sequence from index 1 -> 2 -> 1 -> ... is not a cycle because nums[1] is positive but nums[2] is negative.\n    Every nums[seq[j]] must be either all positive or all negative.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5000`\n  * `-1000 <= nums[i] <= 1000`\n  * `nums[i] != 0`\n\n\n\n**Follow up:** Could you solve it in `O(n)` time complexity and `O(1)` extra\nspace complexity?\n\n,class Solution:\n    def circularArrayLoop(self nums: List[int]) -> bool:\n        n = len(nums)\n        for i in range(n):\n            seen = set()\n            minval = float('inf')\n            maxval = float('-inf')\n            j = i\n            while j not in seen:\n                seen.add(j)\n                minval = min(minval nums[j])\n                maxval = max(maxval nums[j])\n                k = 1 + abs(nums[j]) // n\n                j = (k * n + j + nums[j]) % n\n            if j == i and len(seen) > 1 and (minval > 0 or maxval < 0):\n                return True\n        return False\n
Circular Permutation in Binary Representation,###  1238\. Circular Permutation in Binary Representation\n\nGiven 2 integers `n` and `start`. Your task is return **any** permutation `p`\nof `(012.....2^n -1) `such that :\n\n  * `p[0] = start`\n  * `p[i]` and `p[i+1]` differ by only one bit in their binary representation.\n  * `p[0]` and `p[2^n -1]` must also differ by only one bit in their binary representation.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2 start = 3\n    **Output:** [3201]\n    **Explanation:** The binary representation of the permutation is (11100001). \n    All the adjacent element differ by one bit. Another valid permutation is [3102]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3 start = 2\n    **Output:** [26754013]\n    **Explanation:** The binary representation of the permutation is (010110111101100000001011).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 16`\n  * `0 <= start < 2 ^ n`\n\n,class Solution:\n    def circularPermutation(self n: int start: int) -> List[int]:\n        gray_code = [x ^ (x >> 1) for x in range(2 ** n)]\n        start_i = gray_code.index(start)\n        return gray_code[start_i:] + gray_code[:start_i]
Clone Graph,###  133\. Clone Graph\n\nGiven a reference of a node in a\n**[connected](https://en.wikipedia.org/wiki/Connectivity_\(graph_theory\)#Connected_graph)**\nundirected graph.\n\nReturn a [**deep\ncopy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) (clone) of the\ngraph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of\nits neighbors.\n\n    \n    \n    class Node {\n        public int val;\n        public List<Node> neighbors;\n    }\n    \n\n\n\n**Test case format:**\n\nFor simplicity each node's value is the same as the node's index (1-indexed).\nFor example the first node with `val == 1` the second node with `val == 2`\nand so on. The graph is represented in the test case using an adjacency list.\n\n**An adjacency list** is a collection of unordered **lists** used to represent\na finite graph. Each list describes the set of neighbors of a node in the\ngraph.\n\nThe given node will always be the first node with `val = 1`. You must return\nthe **copy of the given node** as a reference to the cloned graph.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/11/04/133_clone_graph_question.png)\n\n    \n    \n    **Input:** adjList = [[24][13][24][13]]\n    **Output:** [[24][13][24][13]]\n    **Explanation:** There are 4 nodes in the graph.\n    1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n    2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n    3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).\n    4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/01/07/graph.png)\n\n    \n    \n    **Input:** adjList = [[]]\n    **Output:** [[]]\n    **Explanation:** Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** adjList = []\n    **Output:** []\n    **Explanation:** This an empty graph it does not have any nodes.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the graph is in the range `[0 100]`.\n  * `1 <= Node.val <= 100`\n  * `Node.val` is unique for each node.\n  * There are no repeated edges and no self-loops in the graph.\n  * The Graph is connected and all nodes can be visited starting from the given node.\n\n,    def cloneGraph(self node: 'Node') -> 'Node':\n        \n        if node == None:\n            return None\n        \n        new_node = Node(node.val [])\n        \n        visited = set()\n        \n        q = [[node new_node]]\n        visited.add(node.val)\n        \n        adj_map = {}\n        \n        adj_map[node] = new_node\n        \n        while len(q) != 0:\n            \n            curr = q.pop(0)\n            \n            \n            for n in curr[0].neighbors:\n                \n                # if n.val not in visited:\n                if n not in adj_map and n is not None:\n                    new = Node(n.val [])\n                    curr[1].neighbors.append(new)\n                    adj_map[n] = new\n                else:\n                    curr[1].neighbors.append(adj_map[n])\n                    \n                if n.val not in visited:\n                    q.append([n adj_map[n]])\n                    visited.add(n.val) \n        \n        \n        return new_node\n\n
Closest Dessert Cost,###  1774\. Closest Dessert Cost\n\nYou would like to make dessert and are preparing to buy the ingredients. You\nhave `n` ice cream base flavors and `m` types of toppings to choose from. You\nmust follow these rules when making your dessert:\n\n  * There must be **exactly one** ice cream base.\n  * You can add **one or more** types of topping or have no toppings at all.\n  * There are **at most two** of **each type** of topping.\n\nYou are given three inputs:\n\n  * `baseCosts` an integer array of length `n` where each `baseCosts[i]` represents the price of the `ith` ice cream base flavor.\n  * `toppingCosts` an integer array of length `m` where each `toppingCosts[i]` is the price of **one** of the `ith` topping.\n  * `target` an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to `target` as possible.\n\nReturn _the closest possible cost of the dessert to_`target`. If there are\nmultiple return _the**lower** one._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** baseCosts = [17] toppingCosts = [34] target = 10\n    **Output:** 10\n    **Explanation:** Consider the following combination (all 0-indexed):\n    - Choose base 1: cost 7\n    - Take 1 of topping 0: cost 1 x 3 = 3\n    - Take 0 of topping 1: cost 0 x 4 = 0\n    Total: 7 + 3 + 0 = 10.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** baseCosts = [23] toppingCosts = [45100] target = 18\n    **Output:** 17\n    **Explanation:** Consider the following combination (all 0-indexed):\n    - Choose base 1: cost 3\n    - Take 1 of topping 0: cost 1 x 4 = 4\n    - Take 2 of topping 1: cost 2 x 5 = 10\n    - Take 0 of topping 2: cost 0 x 100 = 0\n    Total: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** baseCosts = [310] toppingCosts = [25] target = 9\n    **Output:** 8\n    **Explanation:** It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.\n    \n\n\n\n**Constraints:**\n\n  * `n == baseCosts.length`\n  * `m == toppingCosts.length`\n  * `1 <= n m <= 10`\n  * `1 <= baseCosts[i] toppingCosts[i] <= 104`\n  * `1 <= target <= 104`\n\n,class Solution:\n    def closestCost(self baseCosts: List[int] toppingCosts: List[int] target: int) -> int:\n        self.ans = self.diff = float('inf')\n        \n        n = len(baseCosts)\n        m = len(toppingCosts)\n        \n        \n        def solve(sum target indx):\n            if abs(sum - target) < self.diff:\n                self.diff = abs(sum - target)\n                self.ans = sum\n            elif abs(sum - target) == self.diff:\n                self.ans = min(self.ans sum)\n            \n            \n            if indx == m:\n                return\n            \n            i = indx\n            for count in range(3):\n                sum += toppingCosts[i]*count\n                solve(sumtargeti+1)\n                sum -= toppingCosts[i]*count\n        \n        for i in baseCosts:\n            solve(i target 0)\n        return self.ans\n
Closest Divisors,###  1362\. Closest Divisors\n\nGiven an integer `num` find the closest two integers in absolute difference\nwhose product equals `num + 1` or `num + 2`.\n\nReturn the two integers in any order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 8\n    **Output:** [33]\n    **Explanation:** For num + 1 = 9 the closest divisors are 3 & 3 for num + 2 = 10 the closest divisors are 2 & 5 hence 3 & 3 is chosen.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 123\n    **Output:** [525]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = 999\n    **Output:** [4025]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num <= 10^9`\n\n,"class Solution:\n	def closestDivisors(self num: int) -> List[int]:\n		for i in range(int((num+2) ** (0.5)) 0 -1):  \n			if not (num+1) % i: return [i (num+1)//i] \n			if not (num+2) % i: return [i (num+2)//i] \n		return []\n"
Closest Subsequence Sum,###  1755\. Closest Subsequence Sum\n\nYou are given an integer array `nums` and an integer `goal`.\n\nYou want to choose a subsequence of `nums` such that the sum of its elements\nis the closest possible to `goal`. That is if the sum of the subsequence's\nelements is `sum` then you want to **minimize the absolute difference**\n`abs(sum - goal)`.\n\nReturn _the**minimum** possible value of_ `abs(sum - goal)`.\n\nNote that a subsequence of an array is an array formed by removing some\nelements **(possibly all or none)** of the original array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [5-735] goal = 6\n    **Output:** 0\n    **Explanation:** Choose the whole array as a subsequence with a sum of 6.\n    This is equal to the goal so the absolute difference is 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [7-915-2] goal = -5\n    **Output:** 1\n    **Explanation:** Choose the subsequence [7-9-2] with a sum of -4.\n    The absolute difference is abs(-4 - (-5)) = abs(1) = 1 which is the minimum.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [123] goal = -7\n    **Output:** 7\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 40`\n  * `-107 <= nums[i] <= 107`\n  * `-109 <= goal <= 109`\n\n,class Solution:\n    def minAbsDifference(self nums: List[int] goal: int) -> int:\n\n        # When goal 0 we can just choose no elements \n        if goal == 0: return 0\n\n        n = len(nums)\n        mid = n // 2\n        # Split the list in 2 parts and then find all possible subset sums \n        # T = O(2^n/2) to build all subset sums\n        leftList = nums[:mid]\n        leftSums = []\n        rightList = nums[mid:]\n        rightSums = []\n\n        # T = O(2^n/2) to build all subset sums (we only consider half list)\n        def buildSubsetSums(usedNums numsToChooseFrom ind storeIn):\n            if ind == len(numsToChooseFrom):\n                # We also keep elements with sum 0 to deal with cases like this where we don't select nums\n                # List: [123] Target: -7 (choosing no elements will give a sum close to goal)\n                # We can also have cases where we want to take only 1 element from the list\n                # so sum 0 for left and right list needs to be an option\n                storeIn.append(sum(usedNums))\n                return \n\n            usedNums.append(numsToChooseFrom[ind])\n            buildSubsetSums(usedNums numsToChooseFrom ind+1 storeIn)\n            usedNums.pop()\n            buildSubsetSums(usedNums numsToChooseFrom ind+1 storeIn)\n\n\n        buildSubsetSums([] leftList 0 leftSums)\n        buildSubsetSums([] rightList 0 rightSums)\n        # 2^n/2 log(2^n/2) = n/2 * 2^n/2 time to sort\n        rightSums.sort()\n\n        diff = float('inf')\n\n        # Loop runs 2^n/2 times and inside binary search tale n/2 time \n        # So total time is n/2 * 2^n/2\n        for leftSum in leftSums:\n            complement = goal - leftSum\n            # Bisect left takes log(2^n/2) = n/2 search time\n            idx = bisect.bisect_left(rightSums complement)\n\n            for i in [idx - 1 idx idx + 1]:\n                if 0 <= i < len(rightSums):\n                    finalSum = leftSum + rightSums[i]\n                    diff = min(diff abs(goal - finalSum))\n        \n        # Over all time complexity is - n/2 * 2^n/2\n        # 1. Making subset sums will take - 2^n/2\n        # 2. Sorting right list takes - 2^n/2 * n/2\n        # 3. Iterating one list and finding closest complement in other \n        # takes n/2 * 2^n/2\n        # Space will be O(n/2) for the list and call stack for building subset \n        return diff\n\n
Clumsy Factorial,###  1006\. Clumsy Factorial\n\nThe **factorial** of a positive integer `n` is the product of all positive\nintegers less than or equal to `n`.\n\n  * For example `factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1`.\n\nWe make a **clumsy factorial** using the integers in decreasing order by\nswapping out the multiply operations for a fixed rotation of operations with\nmultiply `'*'` divide `'/'` add `'+'` and subtract `'-'` in this order.\n\n  * For example `clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1`.\n\nHowever these operations are still applied using the usual order of\noperations of arithmetic. We do all multiplication and division steps before\nany addition or subtraction steps and multiplication and division steps are\nprocessed left to right.\n\nAdditionally the division that we use is floor division such that `10 * 9 / 8\n= 90 / 8 = 11`.\n\nGiven an integer `n` return _the clumsy factorial of_`n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** 7\n    **Explanation:** 7 = 4 * 3 / 2 + 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 12\n    **Explanation:** 12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n\n,# Runtime: 87 ms (Top 67.15%) | Memory: 13.9 MB (Top 59.65%)\nclass Solution:\n    def clumsy(self n: int) -> int:\n        if(n>2):\n            sum=n*(n-1)//(n-2)+(n-3)\n        else:\n            sum=n\n        for i in range(n-40-4):\n            if(i<3):\n                sum=sum-i\n                break;\n            sum=sum-(i)*(i-1)//(i-2)+(i-3)\n\n        return sum
Coin Change,###  518\. Coin Change\n\nYou are given an integer array `coins` representing coins of different\ndenominations and an integer `amount` representing a total amount of money.\n\nReturn _the number of combinations that make up that amount_. If that amount\nof money cannot be made up by any combination of the coins return `0`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\nThe answer is **guaranteed** to fit into a signed **32-bit** integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** amount = 5 coins = [125]\n    **Output:** 4\n    **Explanation:** there are four ways to make up the amount:\n    5=5\n    5=2+2+1\n    5=2+1+1+1\n    5=1+1+1+1+1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** amount = 3 coins = [2]\n    **Output:** 0\n    **Explanation:** the amount of 3 cannot be made up just with coins of 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** amount = 10 coins = [10]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= coins.length <= 300`\n  * `1 <= coins[i] <= 5000`\n  * All the values of `coins` are **unique**.\n  * `0 <= amount <= 5000`\n\n,// Runtime: 724 ms (Top 91.98%) | Memory: 17.70 MB (Top 44.11%)\n\nclass Solution:\n    def coinChange(self coins: List[int] amount: int) -> int:\n        numCoins = len(coins)\n        \n        # Values in this array equal the number of coins needed to achieve the cost of the index\n        minCoins = [amount + 1] * (amount + 1)\n        minCoins[0] = 0\n        \n        # Loop through every needed amount\n        for i in range(amount + 1):\n            # Loop through every coin value\n            for coin in coins:\n                # Check that the coin is not bigger than the current amount\n                if coin <= i:\n                    # minCoins[i]: number of coins needed to make amount i\n                    # minCoins[i-coin]: number of coins needed to make the amount before adding \n                    #                   the current coin to it (+1 to add the current coin)\n                    minCoins[i] = min(minCoins[i] minCoins[i-coin] + 1)\n        \n        # Check if any combination of coins was found to create the amount\n        if minCoins[amount] == amount + 1:\n            return -1\n        \n        # Return the optimal number of coins to create the amount\n        return minCoins[amount]\n
Combination Sum,###  39\. Combination Sum\n\nGiven an array of **distinct** integers `candidates` and a target integer\n`target` return _a list of all**unique combinations** of _`candidates` _where\nthe chosen numbers sum to_`target` _._ You may return the combinations in\n**any order**.\n\nThe **same** number may be chosen from `candidates` an **unlimited number of\ntimes**. Two combinations are unique if the frequency of at least one of the\nchosen numbers is different.\n\nIt is **guaranteed** that the number of unique combinations that sum up to\n`target` is less than `150` combinations for the given input.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** candidates = [2367] target = 7\n    **Output:** [[223][7]]\n    **Explanation:**\n    2 and 3 are candidates and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n    7 is a candidate and 7 = 7.\n    These are the only two combinations.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** candidates = [235] target = 8\n    **Output:** [[2222][233][35]]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** candidates = [2] target = 1\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * `1 <= candidates.length <= 30`\n  * `1 <= candidates[i] <= 200`\n  * All elements of `candidates` are **distinct**.\n  * `1 <= target <= 500`\n\n,# Runtime: 95 ms (Top 82.54%) | Memory: 14.1 MB (Top 72.96%)\nclass Solution:\n    def combinationSum(self candidates: List[int] target: int) -> List[List[int]]:\n\n        path = []\n        answer = []\n        def dp(idx total):\n            if total == target:\n                answer.append(path[:])\n                return\n            if total > target:\n                return\n\n            for i in range(idx len(candidates)):\n                path.append(candidates[i])\n                dp(i total + candidates[i])\n                path.pop()\n\n        dp(0 0)\n        return answer\n
Combination Sum II,###  40\. Combination Sum II\n\nGiven a collection of candidate numbers (`candidates`) and a target number\n(`target`) find all unique combinations in `candidates` where the candidate\nnumbers sum to `target`.\n\nEach number in `candidates` may only be used **once** in the combination.\n\n**Note:**  The solution set must not contain duplicate combinations.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** candidates = [10127615] target = 8\n    **Output:** \n    [\n    [116]\n    [125]\n    [17]\n    [26]\n    ]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** candidates = [25212] target = 5\n    **Output:** \n    [\n    [122]\n    [5]\n    ]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= candidates.length <= 100`\n  * `1 <= candidates[i] <= 50`\n  * `1 <= target <= 30`\n\n,# Runtime: 204 ms (Top 15.17%) | Memory: 14.1 MB (Top 23.77%)\nclass Solution(object):\n    def combinationSum2(self candidates target):\n        res = []\n        def dfs(numssummcurr):\n            if summ>=target:\n                if summ == target:\n                    res.append(curr)\n                return\n            for i in range(len(nums)):\n                if i !=0 and nums[i]==nums[i-1]:\n                    continue\n                dfs(nums[i+1:]summ+nums[i]curr+[nums[i]])\n        dfs(sorted(candidates)0[])\n        return res
Combination Sum III,###  216\. Combination Sum III\n\nFind all valid combinations of `k` numbers that sum up to `n` such that the\nfollowing conditions are true:\n\n  * Only numbers `1` through `9` are used.\n  * Each number is used **at most once**.\n\nReturn _a list of all possible valid combinations_. The list must not contain\nthe same combination twice and the combinations may be returned in any order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** k = 3 n = 7\n    **Output:** [[124]]\n    **Explanation:**\n    1 + 2 + 4 = 7\n    There are no other valid combinations.\n\n**Example 2:**\n\n    \n    \n    **Input:** k = 3 n = 9\n    **Output:** [[126][135][234]]\n    **Explanation:**\n    1 + 2 + 6 = 9\n    1 + 3 + 5 = 9\n    2 + 3 + 4 = 9\n    There are no other valid combinations.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** k = 4 n = 1\n    **Output:** []\n    **Explanation:** There are no valid combinations.\n    Using 4 different numbers in the range [19] the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1 there are no valid combination.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= k <= 9`\n  * `1 <= n <= 60`\n\n,class Solution:\n    \n    def solve(selfktargetanstempidxnums):\n        \n        if idx==len(nums):\n            if target==0 and k==0:\n                ans.append(list(temp))\n            return\n        \n        if nums[idx]<=target:\n            \n            temp.append(nums[idx])\n            self.solve(k-1target-nums[idx]anstempidx+1nums)\n            temp.pop()\n        \n        self.solve(ktargetanstempidx+1nums)\n        \n\n    \n    def combinationSum3(self k: int n: int) -> List[List[int]]:\n        \n        ans = []\n        temp = []\n        idx = 0\n        nums = list(range(110))\n        \n        self.solve(knanstempidxnums)\n        return ans\n                \n
Combination Sum IV,###  377\. Combination Sum IV\n\nGiven an array of **distinct** integers `nums` and a target integer `target`\nreturn _the number of possible combinations that add up to_  `target`.\n\nThe test cases are generated so that the answer can fit in a **32-bit**\ninteger.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123] target = 4\n    **Output:** 7\n    **Explanation:**\n    The possible combination ways are:\n    (1 1 1 1)\n    (1 1 2)\n    (1 2 1)\n    (1 3)\n    (2 1 1)\n    (2 2)\n    (3 1)\n    Note that different sequences are counted as different combinations.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [9] target = 3\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 200`\n  * `1 <= nums[i] <= 1000`\n  * All the elements of `nums` are **unique**.\n  * `1 <= target <= 1000`\n\n\n\n**Follow up:** What if negative numbers are allowed in the given array? How\ndoes it change the problem? What limitation we need to add to the question to\nallow negative numbers?\n\n,class Solution:\n    def combinationSum4(self nums: List[int] target: int) -> int:\n        dp = [0] * (target+1)\n        dp[0] = 1\n        for i in range(1 target+1):\n            for num in nums: \n                num_before = i - num\n                if num_before >= 0:\n                    dp[i] += dp[num_before]\n        return dp[target]\n
Combinations,###  77\. Combinations\n\nGiven two integers `n` and `k` return _all possible combinations of_ `k`\n_numbers chosen from the range_ `[1 n]`.\n\nYou may return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4 k = 2\n    **Output:** [[12][13][14][23][24][34]]\n    **Explanation:** There are 4 choose 2 = 6 total combinations.\n    Note that combinations are unordered i.e. [12] and [21] are considered to be the same combination.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1 k = 1\n    **Output:** [[1]]\n    **Explanation:** There is 1 choose 1 = 1 total combination.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 20`\n  * `1 <= k <= n`\n\n,class Solution:\n    def combine(self n: int k: int) -> List[List[int]]:\n        return itertools.combinations(range(1 n+1) k)
Compare Strings by Frequency of the Smallest Character,"###  1170\. Compare Strings by Frequency of the Smallest Character\n\nLet the function `f(s)` be the **frequency of the lexicographically smallest\ncharacter** in a non-empty string `s`. For example if `s = ""dcce""` then `f(s)\n= 2` because the lexicographically smallest character is `'c'` which has a\nfrequency of 2.\n\nYou are given an array of strings `words` and another array of query strings\n`queries`. For each query `queries[i]` count the **number of words** in\n`words` such that `f(queries[i])` < `f(W)` for each `W` in `words`.\n\nReturn _an integer array_`answer` _ where each_`answer[i]`_is the answer to\nthe_`ith` _query_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** queries = [""cbd""] words = [""zaaaz""]\n    **Output:** [1]\n    **Explanation:** On the first query we have f(""cbd"") = 1 f(""zaaaz"") = 3 so f(""cbd"") < f(""zaaaz"").\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** queries = [""bbb""""cc""] words = [""a""""aa""""aaa""""aaaa""]\n    **Output:** [12]\n    **Explanation:** On the first query only f(""bbb"") < f(""aaaa""). On the second query both f(""aaa"") and f(""aaaa"") are both > f(""cc"").\n    \n\n\n\n**Constraints:**\n\n  * `1 <= queries.length <= 2000`\n  * `1 <= words.length <= 2000`\n  * `1 <= queries[i].length words[i].length <= 10`\n  * `queries[i][j]` `words[i][j]` consist of lowercase English letters.\n\n",class Solution:\n    def numSmallerByFrequency(self queries: List[str] words: List[str]) -> List[int]:\n        def _f(s):\n            d = Counter(s)\n            d =dict(sorted(d.items() key=lambda item: item[0]))\n            for x in d:\n                return d[x]\n        \n        freq = []\n        for w in words:\n            n1 = _f(w)\n            freq.append(n1)\n        \n        freq.sort(reverse=True)\n\n        res = []\n        for q in queries:\n            n = _f(q)\n            c=0\n            for n1 in freq:\n                if n < n1:\n                    c+=1\n                else:\n                    break\n            res.append(c)\n        \n        return res\n
Compare Version Numbers,"###  165\. Compare Version Numbers\n\nGiven two version numbers `version1` and `version2` compare them.\n\nVersion numbers consist of **one or more revisions** joined by a dot `'.'`.\nEach revision consists of **digits**  and may contain leading **zeros**. Every\nrevision contains **at least one character**. Revisions are **0-indexed from\nleft to right**  with the leftmost revision being revision 0 the next\nrevision being revision 1 and so on. For example `2.5.33` and `0.1` are valid\nversion numbers.\n\nTo compare version numbers compare their revisions in **left-to-right\norder**. Revisions are compared using their **integer value ignoring any\nleading zeros**. This means that revisions `1` and `001` are considered\n**equal**. If a version number does not specify a revision at an index then\n**treat the revision as  `0`**. For example version `1.0` is less than\nversion `1.1` because their revision 0s are the same but their revision 1s\nare `0` and `1` respectively and `0 < 1`.\n\n_Return the following:_\n\n  * If `version1 < version2` return `-1`.\n  * If `version1 > version2` return `1`.\n  * Otherwise return `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** version1 = ""1.01"" version2 = ""1.001""\n    **Output:** 0\n    **Explanation:** Ignoring leading zeroes both ""01"" and ""001"" represent the same integer ""1"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** version1 = ""1.0"" version2 = ""1.0.0""\n    **Output:** 0\n    **Explanation:** version1 does not specify revision 2 which means it is treated as ""0"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** version1 = ""0.1"" version2 = ""1.1""\n    **Output:** -1\n    **Explanation:** version1's revision 0 is ""0"" while version2's revision 0 is ""1"". 0 < 1 so version1 < version2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= version1.length version2.length <= 500`\n  * `version1` and `version2` only contain digits and `'.'`.\n  * `version1` and `version2` **are valid version numbers**.\n  * All the given revisions in `version1` and `version2` can be stored in a **32-bit integer**.\n\n",class Solution:\n    def compareVersion(self v1: str v2: str) -> int:\n        v1 v2 = list(map(int v1.split('.'))) list(map(int v2.split('.')))  \n        for rev1 rev2 in zip_longest(v1 v2 fillvalue=0):\n            if rev1 == rev2:\n                continue\n\n            return -1 if rev1 < rev2 else 1 \n\n        return 0
Complement of Base 10 Integer,"###  1009\. Complement of Base 10 Integer\n\nThe **complement** of an integer is the integer you get when you flip all the\n`0`'s to `1`'s and all the `1`'s to `0`'s in its binary representation.\n\n  * For example The integer `5` is `""101""` in binary and its **complement** is `""010""` which is the integer `2`.\n\nGiven an integer `n` return _its complement_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** 2\n    **Explanation:** 5 is ""101"" in binary with complement ""010"" in binary which is 2 in base-10.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 7\n    **Output:** 0\n    **Explanation:** 7 is ""111"" in binary with complement ""000"" in binary which is 0 in base-10.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 5\n    **Explanation:** 10 is ""1010"" in binary with complement ""0101"" in binary which is 5 in base-10.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n < 109`\n\n\n\n**Note:** This question is the same as 476:\n<https://leetcode.com/problems/number-complement/>\n\n",// Runtime: 38 ms (Top 52.6%) | Memory: 17.10 MB (Top 12.47%)\n\nclass Solution:\n    def bitwiseComplement(self n: int) -> int:\n        cnt=0\n        ans=0\n        if n==0:\n            return 1\n        while n>0:\n            if n&1:\n                cnt+=1\n            else:\n                ans =ans +(2**cnt)\n                cnt+=1\n            n=n>>1\n        return ans\n
Complete Binary Tree Inserter,"###  919\. Complete Binary Tree Inserter\n\nA **complete binary tree** is a binary tree in which every level except\npossibly the last is completely filled and all nodes are as far left as\npossible.\n\nDesign an algorithm to insert a new node to a complete binary tree keeping it\ncomplete after the insertion.\n\nImplement the `CBTInserter` class:\n\n  * `CBTInserter(TreeNode root)` Initializes the data structure with the `root` of the complete binary tree.\n  * `int insert(int v)` Inserts a `TreeNode` into the tree with value `Node.val == val` so that the tree remains complete and returns the value of the parent of the inserted `TreeNode`.\n  * `TreeNode get_root()` Returns the root node of the tree.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg)\n\n    \n    \n    **Input**\n    [""CBTInserter"" ""insert"" ""insert"" ""get_root""]\n    [[[1 2]] [3] [4] []]\n    **Output**\n    [null 1 2 [1 2 3 4]]\n    \n    **Explanation**\n    CBTInserter cBTInserter = new CBTInserter([1 2]);\n    cBTInserter.insert(3);  // return 1\n    cBTInserter.insert(4);  // return 2\n    cBTInserter.get_root(); // return [1 2 3 4]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree will be in the range `[1 1000]`.\n  * `0 <= Node.val <= 5000`\n  * `root` is a complete binary tree.\n  * `0 <= val <= 5000`\n  * At most `104` calls will be made to `insert` and `get_root`.\n\n","// Runtime: 44 ms (Top 99.57%) | Memory: 18.50 MB (Top 5.17%)\n\nfrom collections import deque\n\nclass CBTInserter:\n\n    \n    def __init__(self root: TreeNode):\n        \n        self.root = root\n        \n        self.parent_keeper = deque([root])\n\n        while True:\n            \n            cur = self.parent_keeper[0]\n            \n            if cur:\n                \n                if cur.left:\n                    \n                    self.parent_keeper.append( cur.left )\n                    \n                    if cur.right:\n                        \n                        self.parent_keeper.append( cur.right )\n                        \n                        # cur is completed with two child pop out\n                        self.parent_keeper.popleft()\n                    \n                    else:\n                        # parent of next insertion is found stop\n                        break\n                \n                else:\n                    # parent of next insertion is found stop\n                    break\n        \n        \n\n    def insert(self v: int) -> int:\n        \n        parent = self.parent_keeper[0]\n        \n		# Insert with leftward compact to meet the definition of complete binary tree\n		\n        if not parent.left:\n            parent.left = TreeNode( v )\n            self.parent_keeper.append( parent.left )\n        else:\n            parent.right = TreeNode( v )\n            self.parent_keeper.append( parent.right )\n            \n            # current parent is completed with two child now pop parent from parent keeper on the head\n            self.parent_keeper.popleft()\n            \n        return parent.val\n        \n\n    def get_root(self) -> TreeNode:\n        \n        return self.root\n"
Complex Number Multiplication,"###  537\. Complex Number Multiplication\n\nA [complex number](https://en.wikipedia.org/wiki/Complex_number) can be\nrepresented as a string on the form `""**real** +**imaginary** i""` where:\n\n  * `real` is the real part and is an integer in the range `[-100 100]`.\n  * `imaginary` is the imaginary part and is an integer in the range `[-100 100]`.\n  * `i2 == -1`.\n\nGiven two complex numbers `num1` and `num2` as strings return _a string of\nthe complex number that represents their multiplications_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num1 = ""1+1i"" num2 = ""1+1i""\n    **Output:** ""0+2i""\n    **Explanation:** (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i and you need convert it to the form of 0+2i.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num1 = ""1+-1i"" num2 = ""1+-1i""\n    **Output:** ""0+-2i""\n    **Explanation:** (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i and you need convert it to the form of 0+-2i.\n    \n\n\n\n**Constraints:**\n\n  * `num1` and `num2` are valid complex numbers.\n\n",class Solution:\n    def complexNumberMultiply(self num1: str num2: str) -> str:\n        i1=num1.index('+')\n        i2=num2.index('+')\n        a=int(num1[0:i1])\n        x=int(num2[0:i2])\n        b=int(num1[i1+1:len(num1)-1])\n        y=int(num2[i2+1:len(num2)-1])\n        ans1=a*x+(-1)*b*y\n        ans2=a*y+b*x\n        return str(ans1)+'+'+(str(ans2)+'i')
Concatenated Words,"###  472\. Concatenated Words\n\nGiven an array of strings `words` (**without duplicates**) return _all\nthe**concatenated words** in the given list of_ `words`.\n\nA **concatenated word** is defined as a string that is comprised entirely of\nat least two shorter words in the given array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""cat""""cats""""catsdogcats""""dog""""dogcatsdog""""hippopotamuses""""rat""""ratcatdogcat""]\n    **Output:** [""catsdogcats""""dogcatsdog""""ratcatdogcat""]\n    **Explanation:** ""catsdogcats"" can be concatenated by ""cats"" ""dog"" and ""cats""; \n    ""dogcatsdog"" can be concatenated by ""dog"" ""cats"" and ""dog""; \n    ""ratcatdogcat"" can be concatenated by ""rat"" ""cat"" ""dog"" and ""cat"".\n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""cat""""dog""""catdog""]\n    **Output:** [""catdog""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 104`\n  * `1 <= words[i].length <= 30`\n  * `words[i]` consists of only lowercase English letters.\n  * All the strings of `words` are **unique**.\n  * `1 <= sum(words[i].length) <= 105`\n\n",class Solution:\n    def findAllConcatenatedWordsInADict(self words: List[str]) -> List[str]:\n                \n        set_words = set(words)\n\n        def check(word seen):\n            if word == '':\n                return True\n            for i in range(len(word) if seen else len(word) - 1):\n                if word[:i+1] in set_words:\n                    if check(word[i+1:] seen | {word[:i+1]}):\n                        return True\n            return False\n\n        return [word for word in words if check(word set())]\n
Concatenation of Array,###  1929\. Concatenation of Array\n\nGiven an integer array `nums` of length `n` you want to create an array `ans`\nof length `2n` where `ans[i] == nums[i]` and `ans[i + n] == nums[i]` for `0 <=\ni < n` (**0-indexed**).\n\nSpecifically `ans` is the **concatenation** of two `nums` arrays.\n\nReturn _the array_`ans`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [121]\n    **Output:** [121121]\n    **Explanation:** The array ans is formed as follows:\n    - ans = [nums[0]nums[1]nums[2]nums[0]nums[1]nums[2]]\n    - ans = [121121]\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1321]\n    **Output:** [13211321]\n    **Explanation:** The array ans is formed as follows:\n    - ans = [nums[0]nums[1]nums[2]nums[3]nums[0]nums[1]nums[2]nums[3]]\n    - ans = [13211321]\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 1000`\n  * `1 <= nums[i] <= 1000`\n\n,# Runtime: 139 ms (Top 57.29%) | Memory: 14.1 MB (Top 65.51%)\nclass Solution(object):\n    def getConcatenation(self nums):\n        return nums * 2
Concatenation of Consecutive Binary Numbers,"###  1680\. Concatenation of Consecutive Binary Numbers\n\nGiven an integer `n` return _the**decimal value** of the binary string formed\nby concatenating the binary representations of _`1` _to_`n` _in\norder**modulo**_`109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1\n    **Explanation:** ""1"" in binary corresponds to the decimal value 1. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** 27\n    **Explanation:** In binary 1 2 and 3 corresponds to ""1"" ""10"" and ""11"".\n    After concatenating them we have ""11011"" which corresponds to the decimal value 27.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 12\n    **Output:** 505379714\n    **Explanation** : The concatenation results in ""1101110010111011110001001101010111100"".\n    The decimal value of that is 118505380540.\n    After modulo 109 + 7 the result is 505379714.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n\n",class Solution:\n    def concatenatedBinary(self n: int) -> int:\n        modulo = 10 ** 9 + 7\n        shift = 0 # tracking power of 2\n        res = 0\n        \n        for i in range(1 n+1):\n            if i & (i - 1) == 0: # see if num reaches a greater power of 2\n                shift += 1\n            res = ((res << shift) + i) % modulo # do the simulation\n        \n        return res
Consecutive Characters,"###  1446\. Consecutive Characters\n\nThe **power** of the string is the maximum length of a non-empty substring\nthat contains only one unique character.\n\nGiven a string `s` return _the**power** of_ `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""leetcode""\n    **Output:** 2\n    **Explanation:** The substring ""ee"" is of length 2 with the character 'e' only.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abbcccddddeeeeedcba""\n    **Output:** 5\n    **Explanation:** The substring ""eeeee"" is of length 5 with the character 'e' only.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 500`\n  * `s` consists of only lowercase English letters.\n\n","# Runtime: 30 ms (Top 32.1%) | Memory: 13.25 MB (Top 75.9%)\n\nclass Solution(object):\n    def maxPower(self s):\n        """"""\n        :type s: str\n        :rtype: int\n        """"""\n        stack=[]\n        mxpow=0\n        for i in s:\n            if stack and stack[-1]!=i:\n                mxpow=max(mxpowlen(stack))\n                stack=[]\n                stack.append(i)\n            else:\n                stack.append(i)\n        mxpow=max(mxpowlen(stack))\n        return mxpow"
Consecutive Numbers Sum,###  829\. Consecutive Numbers Sum\n\nGiven an integer `n` return _the number of ways you can write_`n` _as the sum\nof consecutive positive integers._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** 2\n    **Explanation:** 5 = 2 + 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 9\n    **Output:** 3\n    **Explanation:** 9 = 4 + 5 = 2 + 3 + 4\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 15\n    **Output:** 4\n    **Explanation:** 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n\n,// Runtime: 77 ms (Top 82.13%) | Memory: 16.60 MB (Top 56.38%)\n\nclass Solution:\n    def consecutiveNumbersSum(self n: int) -> int:\n        csum=0\n        result=0\n        for i in range(1n+1):\n            csum+=i-1\n            if csum>=n:\n                break\n            if (n-csum)%i==0:\n                result+=1\n        return result\n
Constrained Subsequence Sum,###  1425\. Constrained Subsequence Sum\n\nGiven an integer array `nums` and an integer `k` return the maximum sum of a\n**non-empty** subsequence of that array such that for every two\n**consecutive** integers in the subsequence `nums[i]` and `nums[j]` where `i\n< j` the condition `j - i <= k` is satisfied.\n\nA _subsequence_ of an array is obtained by deleting some number of elements\n(can be zero) from the array leaving the remaining elements in their original\norder.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [102-10520] k = 2\n    **Output:** 37\n    **Explanation:** The subsequence is [10 2 5 20].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-1-2-3] k = 1\n    **Output:** -1\n    **Explanation:** The subsequence must be non-empty so we choose the largest number.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [10-2-10-520] k = 2\n    **Output:** 23\n    **Explanation:** The subsequence is [10 -2 -5 20].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= nums.length <= 105`\n  * `-104 <= nums[i] <= 104`\n\n,"# Runtime: 1386 ms (Top 69.5%) | Memory: 30.16 MB (Top 58.7%)\n\nclass Solution:\n    def constrainedSubsetSum(self nums: List[int] k: int) -> int:\n        deque = []\n        for i num in enumerate(nums):\n                \n            while(deque and deque[0] < i - k): # delete that didn't end with a number in A[i-k:i]\n                deque.pop(0)\n                \n            if deque:  # compute the max sum we can get at index i\n                nums[i] = nums[deque[0]] + num\n            \n            while(deque and nums[deque[-1]] < nums[i]): \n                # delet all the sequence that smaller than current sum becaus there will never be\n                # considers ==> smaller than current sequence and end before current sequence\n                deque.pop()\n                \n            if nums[i] > 0: # if nums[i] < 0 it can't be a useful prefix sum    \n            	deque.append(i)\n        \n        return max(nums)"
Construct Binary Search Tree from Preorder Traversal,###  1008\. Construct Binary Search Tree from Preorder Traversal\n\nGiven an array of integers preorder which represents the **preorder\ntraversal** of a BST (i.e. **binary search tree**) construct the tree and\nreturn _its root_.\n\nIt is **guaranteed** that there is always possible to find a binary search\ntree with the given requirements for the given test cases.\n\nA **binary search tree** is a binary tree where for every node any descendant\nof `Node.left` has a value **strictly less than** `Node.val` and any\ndescendant of `Node.right` has a value **strictly greater than** `Node.val`.\n\nA **preorder traversal** of a binary tree displays the value of the node\nfirst then traverses `Node.left` then traverses `Node.right`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/03/06/1266.png)\n\n    \n    \n    **Input:** preorder = [85171012]\n    **Output:** [851017null12]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** preorder = [13]\n    **Output:** [1null3]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= preorder.length <= 100`\n  * `1 <= preorder[i] <= 1000`\n  * All the values of `preorder` are **unique**.\n\n,"class Solution:\n	def bstFromPreorder(self preorder: List[int]) -> Optional[TreeNode]:\n		if not preorder:\n			return None\n		node = preorder.pop(0)\n		root = TreeNode(node)\n		l = []\n		r = []\n\n		for val in preorder:\n			if val < node:\n				l.append(val)\n			else:\n				r.append(val)\n\n		root.left = self.bstFromPreorder(l)\n		root.right =  self.bstFromPreorder(r)\n		return root"
Construct Binary Tree from Inorder and Postorder Traversal,###  106\. Construct Binary Tree from Inorder and Postorder Traversal\n\nGiven two integer arrays `inorder` and `postorder` where `inorder` is the\ninorder traversal of a binary tree and `postorder` is the postorder traversal\nof the same tree construct and return _the binary tree_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\n\n    \n    \n    **Input:** inorder = [9315207] postorder = [9157203]\n    **Output:** [3920nullnull157]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** inorder = [-1] postorder = [-1]\n    **Output:** [-1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= inorder.length <= 3000`\n  * `postorder.length == inorder.length`\n  * `-3000 <= inorder[i] postorder[i] <= 3000`\n  * `inorder` and `postorder` consist of **unique** values.\n  * Each value of `postorder` also appears in `inorder`.\n  * `inorder` is **guaranteed** to be the inorder traversal of the tree.\n  * `postorder` is **guaranteed** to be the postorder traversal of the tree.\n\n,"import bisect\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n\n    def buildTree(self inorder postorder):\n        """"""\n        7\n         2\n       -8 \n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        ([-4-103-1] [7]) ((11-82) [7])\n        """"""\n        currentSplits = [(inorder [] [])]\n        nodeDirectory = {}\n        finalSplits = []\n        for nodeVal in reversed(postorder):\n            nodeDirectory[nodeVal] = TreeNode(nodeVal)\n            for splits nodes directions in reversed(currentSplits):\n                removing = None\n                if nodeVal in splits:\n                    removing = (splits nodes directions)\n                    left = splits[:splits.index(nodeVal)]\n                    right = splits[splits.index(nodeVal)+1:]\n                    currentSplits.append((left nodes+[nodeVal] directions + ['left']))\n                    if len(left) <= 1:\n                        finalSplits.append((left nodes+[nodeVal] directions + ['left']))\n                    currentSplits.append((right nodes+[nodeVal] directions + ['right']))\n                    if len(right) <= 1:\n                        finalSplits.append((right nodes+[nodeVal] directions + ['right']))\n                    break\n                if removing:\n                    currentSplits.remove(removing)\n        finalSplits = [splits for splits in finalSplits if splits[0]]\n\n        while finalSplits:\n            nodeVal nodes directions = finalSplits.pop()\n            bottomNode = nodeDirectory[nodeVal[0]] if nodeVal else None\n            while nodes:\n                attachingNode = nodeDirectory[nodes.pop()]\n                attachingDir = directions.pop()\n                if attachingDir == 'left':\n                    attachingNode.left = bottomNode\n                else:\n                    attachingNode.right = bottomNode\n                bottomNode = attachingNode\n        return nodeDirectory[postorder[-1]]\n"
Construct Binary Tree from Preorder and Inorder Traversal,###  105\. Construct Binary Tree from Preorder and Inorder Traversal\n\nGiven two integer arrays `preorder` and `inorder` where `preorder` is the\npreorder traversal of a binary tree and `inorder` is the inorder traversal of\nthe same tree construct and return _the binary tree_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)\n\n    \n    \n    **Input:** preorder = [3920157] inorder = [9315207]\n    **Output:** [3920nullnull157]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** preorder = [-1] inorder = [-1]\n    **Output:** [-1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= preorder.length <= 3000`\n  * `inorder.length == preorder.length`\n  * `-3000 <= preorder[i] inorder[i] <= 3000`\n  * `preorder` and `inorder` consist of **unique** values.\n  * Each value of `inorder` also appears in `preorder`.\n  * `preorder` is **guaranteed** to be the preorder traversal of the tree.\n  * `inorder` is **guaranteed** to be the inorder traversal of the tree.\n\n,"# Runtime: 274 ms (Top 36.07%) | Memory: 88.6 MB (Top 22.22%)\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass Solution(object):\n    def buildTree(self preorder inorder):\n        """"""\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        """"""\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1] inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:] inorder[mid+1:])\n        return root"
Construct Binary Tree from Preorder and Postorder Traversal,###  889\. Construct Binary Tree from Preorder and Postorder Traversal\n\nGiven two integer arrays `preorder` and `postorder` where `preorder` is the\npreorder traversal of a binary tree of **distinct** values and `postorder` is\nthe postorder traversal of the same tree reconstruct and return _the binary\ntree_.\n\nIf there exist multiple answers you can **return any** of them.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/24/lc-prepost.jpg)\n\n    \n    \n    **Input:** preorder = [1245367] postorder = [4526731]\n    **Output:** [1234567]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** preorder = [1] postorder = [1]\n    **Output:** [1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= preorder.length <= 30`\n  * `1 <= preorder[i] <= preorder.length`\n  * All the values of `preorder` are **unique**.\n  * `postorder.length == preorder.length`\n  * `1 <= postorder[i] <= postorder.length`\n  * All the values of `postorder` are **unique**.\n  * It is guaranteed that `preorder` and `postorder` are the preorder traversal and postorder traversal of the same binary tree.\n\n,class Solution:\n    def constructFromPrePost(self preorder: List[int] postorder: List[int]) -> Optional[TreeNode]:\n\n        def build(preorder preStart preEnd postorder postStart postEnd):\n            if preStart > preEnd:\n                return\n            elif preStart == preEnd:\n                return TreeNode(preorder[preStart])\n            \n            rootVal = preorder[preStart]\n            leftRootVal = preorder[preStart + 1]\n            index = valToIndex[leftRootVal]\n            root = TreeNode(rootVal)\n            leftSize = index - postStart + 1\n            \n            root.left = build(preorder preStart + 1 preStart + leftSize\npostorder postStart index)\n            root.right = build(preorder preStart + leftSize + 1 preEnd\npostorder index + 1 postEnd - 1)\n            \n            return root\n        \n        valToIndex = {}\n        for i in range(len(postorder)):\n            valToIndex[postorder[i]] = i\n        \n        return build(preorder 0 len(preorder) - 1 postorder 0 len(postorder) - 1)\n
Construct K Palindrome Strings,"###  1400\. Construct K Palindrome Strings\n\nGiven a string `s` and an integer `k` return `true` _if you can use all the\ncharacters in_`s` _to construct_`k` _palindrome strings or_`false`\n_otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""annabelle"" k = 2\n    **Output:** true\n    **Explanation:** You can construct two palindromes using all characters in s.\n    Some possible constructions ""anna"" + ""elble"" ""anbna"" + ""elle"" ""anellena"" + ""b""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""leetcode"" k = 3\n    **Output:** false\n    **Explanation:** It is impossible to construct 3 palindromes using all the characters of s.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""true"" k = 4\n    **Output:** true\n    **Explanation:** The only possible solution is to put each character in a separate string.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of lowercase English letters.\n  * `1 <= k <= 105`\n\n",// Runtime: 74 ms (Top 67.79%) | Memory: 17.30 MB (Top 13.48%)\n\nfrom collections import Counter\n\nclass Solution:\n    def canConstruct(self s: str k: int) -> bool:\n        if k > len(s):\n            return False\n        h = Counter(s)\n        countOdd = 0\n        for value in h.values():\n            if value % 2:\n                countOdd += 1\n        if countOdd > k:\n            return False\n        return True\n
Construct Quad Tree,###  427\. Construct Quad Tree\n\nGiven a `n * n` matrix `grid` of `0's` and `1's` only. We want to represent\nthe `grid` with a Quad-Tree.\n\nReturn _the root of the Quad-Tree_ representing the `grid`.\n\nNotice that you can assign the value of a node to **True** or **False** when\n`isLeaf` is **False**  and both are **accepted** in the answer.\n\nA Quad-Tree is a tree data structure in which each internal node has exactly\nfour children. Besides each node has two attributes:\n\n  * `val`: True if the node represents a grid of 1's or False if the node represents a grid of 0's.\n  * `isLeaf`: True if the node is leaf node on the tree or False if the node has the four children.\n\n    \n    \n    class Node {\n        public boolean val;\n        public boolean isLeaf;\n        public Node topLeft;\n        public Node topRight;\n        public Node bottomLeft;\n        public Node bottomRight;\n    }\n\nWe can construct a Quad-Tree from a two-dimensional area using the following\nsteps:\n\n  1. If the current grid has the same value (i.e all `1's` or all `0's`) set `isLeaf` True and set `val` to the value of the grid and set the four children to Null and stop.\n  2. If the current grid has different values set `isLeaf` to False and set `val` to any value and divide the current grid into four sub-grids as shown in the photo.\n  3. Recurse for each of the children with the proper sub-grid.\n\n![](https://assets.leetcode.com/uploads/2020/02/11/new_top.png)\n\nIf you want to know more about the Quad-Tree you can refer to the\n[wiki](https://en.wikipedia.org/wiki/Quadtree).\n\n**Quad-Tree format:**\n\nThe output represents the serialized format of a Quad-Tree using level order\ntraversal where `null` signifies a path terminator where no node exists\nbelow.\n\nIt is very similar to the serialization of the binary tree. The only\ndifference is that the node is represented as a list `[isLeaf val]`.\n\nIf the value of `isLeaf` or `val` is True we represent it as **1** in the list\n`[isLeaf val]` and if the value of `isLeaf` or `val` is False we represent it\nas **0**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/02/11/grid1.png)\n\n    \n    \n    **Input:** grid = [[01][10]]\n    **Output:** [[01][10][11][11][10]]\n    **Explanation:** The explanation of this example is shown below:\n    Notice that 0 represnts False and 1 represents True in the photo representing the Quad-Tree.\n    ![](https://assets.leetcode.com/uploads/2020/02/12/e1tree.png)\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/02/12/e2mat.png)\n\n    \n    \n    **Input:** grid = [[11110000][11110000][11111111][11111111][11110000][11110000][11110000][11110000]]\n    **Output:** [[01][11][01][11][10]nullnullnullnull[10][10][11][11]]\n    **Explanation:** All values in the grid are not the same. We divide the grid into four sub-grids.\n    The topLeft bottomLeft and bottomRight each has the same value.\n    The topRight have different values so we divide it into 4 sub-grids where each has the same value.\n    Explanation is shown in the photo below:\n    ![](https://assets.leetcode.com/uploads/2020/02/12/e2tree.png)\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length == grid[i].length`\n  * `n == 2x` where `0 <= x <= 6`\n\n,"""\n# Definition for a QuadTree node.\nclass Node:\n    def __init__(self val isLeaf topLeft topRight bottomLeft bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n""\n\nclass Solution:\n    def construct(self grid: List[List[int]]) -> 'Node':\n        def is_grid_a_leaf(mylist n):\n            x = mylist[0][0]\n            for i in range(n):\n                for j in range(n):\n                    if mylist[i][j] != x:\n                        return (00)\n            return (1x)\n        \n        def tree_builder(currlist) -> 'Node':\n            node = Node()\n            n = len(currlist)\n            node.isLeaf node.val = is_grid_a_leaf(currlist n)\n            \n            if node.isLeaf:\n                node.topLeft = node.topRight = node.bottomLeft = node.bottomRight = None\n            else:\n                top_left = [[row[i] for i in range(n//2)] for row in currlist[0:n//2]]\n                top_right= [[row[i] for i in range(n//2n)] for row in currlist[0:n//2]]\n                bot_left = [[row[i] for i in range(n//2)] for row in currlist[n//2:n]]\n                bot_right= [[row[i] for i in range(n//2n)] for row in currlist[n//2:n]]\n                node.topLeft = tree_builder(top_left)\n                node.topRight = tree_builder(top_right)\n                node.bottomLeft = tree_builder(bot_left)\n                node.bottomRight = tree_builder(bot_right)\n            return node\n        \n        return tree_builder(grid)"
Construct String With Repeat Limit,"###  2182\. Construct String With Repeat Limit\n\nYou are given a string `s` and an integer `repeatLimit`. Construct a new\nstring `repeatLimitedString` using the characters of `s` such that no letter\nappears **more than** `repeatLimit` times **in a row**. You do **not** have to\nuse all characters from `s`.\n\nReturn _the**lexicographically largest** _`repeatLimitedString` _possible_.\n\nA string `a` is **lexicographically larger** than a string `b` if in the first\nposition where `a` and `b` differ string `a` has a letter that appears later\nin the alphabet than the corresponding letter in `b`. If the first\n`min(a.length b.length)` characters do not differ then the longer string is\nthe lexicographically larger one.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""cczazcc"" repeatLimit = 3\n    **Output:** ""zzcccac""\n    **Explanation:** We use all of the characters from s to construct the repeatLimitedString ""zzcccac"".\n    The letter 'a' appears at most 1 time in a row.\n    The letter 'c' appears at most 3 times in a row.\n    The letter 'z' appears at most 2 times in a row.\n    Hence no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\n    The string is the lexicographically largest repeatLimitedString possible so we return ""zzcccac"".\n    Note that the string ""zzcccca"" is lexicographically larger but the letter 'c' appears more than 3 times in a row so it is not a valid repeatLimitedString.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aababab"" repeatLimit = 2\n    **Output:** ""bbabaa""\n    **Explanation:** We use only some of the characters from s to construct the repeatLimitedString ""bbabaa"". \n    The letter 'a' appears at most 2 times in a row.\n    The letter 'b' appears at most 2 times in a row.\n    Hence no letter appears more than repeatLimit times in a row and the string is a valid repeatLimitedString.\n    The string is the lexicographically largest repeatLimitedString possible so we return ""bbabaa"".\n    Note that the string ""bbabaaa"" is lexicographically larger but the letter 'a' appears more than 2 times in a row so it is not a valid repeatLimitedString.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= repeatLimit <= s.length <= 105`\n  * `s` consists of lowercase English letters.\n\n","from heapq import heapify heappush heappop\nfrom collections import defaultdict\n\nclass Solution:\n    def repeatLimitedString(self string: str k: int) -> str:\n        """"""\n        look close to the problem:\n            it's  lexicographically largest \n            not ""longest""\n        """"""\n        appear times = defaultdict() defaultdict()\n        pq stack = [] []\n        for s in string:\n            appear[s] = appear.get(s 0) + 1\n        \n        for s in appear:\n            pq.append((-ord(s) appear[s]))\n        \n        heapify(pq)\n        appear.clear()\n        \n        while pq:\n            char num = heappop(pq)\n            s = chr(-char)\n            if s in times and times[s] == k: # if reach the repeatedLimit\n                if not pq:\n                    return ''.join(stack)\n                char2 num2 = heappop(pq)\n                token = chr(-char2)\n                stack.append(token)\n                if num2 - 1 > 0:\n                    heappush(pq (char2 num2 - 1))\n                heappush(pq (char num))\n                del times[s]\n                times[token] = 1\n                continue\n            if stack and stack[-1] != s:\n                # reset times\n                del times[stack[-1]]\n            stack.append(s)\n            times[s] = times.get(s 0) + 1\n            \n            if num - 1 > 0:\n                heappush(pq (char num - 1))\n        return ''.join(stack) \n"
Construct Target Array With Multiple Sums,###  1354\. Construct Target Array With Multiple Sums\n\nYou are given an array `target` of n integers. From a starting array `arr`\nconsisting of `n` 1's you may perform the following procedure :\n\n  * let `x` be the sum of all elements currently in your array.\n  * choose index `i` such that `0 <= i < n` and set the value of `arr` at index `i` to `x`.\n  * You may repeat this procedure as many times as needed.\n\nReturn `true` _if it is possible to construct the_ `target` _array from_ `arr`\n_ otherwise return_ `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = [935]\n    **Output:** true\n    **Explanation:** Start with arr = [1 1 1] \n    [1 1 1] sum = 3 choose index 1\n    [1 3 1] sum = 5 choose index 2\n    [1 3 5] sum = 9 choose index 0\n    [9 3 5] Done\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = [1112]\n    **Output:** false\n    **Explanation:** Impossible to create target array from [1111].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** target = [85]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `n == target.length`\n  * `1 <= n <= 5 * 104`\n  * `1 <= target[i] <= 109`\n\n,# Runtime: 492 ms (Top 22.46%) | Memory: 20 MB (Top 17.02%)\nclass Solution:\n    def isPossible(self target: List[int]) -> bool:\n        if len(target) == 1:\n            return target == [1]\n        res = sum(target)\n        heap = [-elem for elem in target]\n        heapify(heap)\n        while heap[0]<-1:\n            maximum = -heappop(heap)\n            res -= maximum\n\n            if res == 1:\n                return True\n            x = maximum % res\n            if x == 0 or (x != 1 and x == maximum):\n                return False\n\n            res += x\n            heappush(heap-x)\n        return True
Construct the Lexicographically Largest Valid Sequence,###  1718\. Construct the Lexicographically Largest Valid Sequence\n\nGiven an integer `n` find a sequence that satisfies all of the following:\n\n  * The integer `1` occurs once in the sequence.\n  * Each integer between `2` and `n` occurs twice in the sequence.\n  * For every integer `i` between `2` and `n` the **distance** between the two occurrences of `i` is exactly `i`.\n\nThe **distance** between two numbers on the sequence `a[i]` and `a[j]` is\nthe absolute difference of their indices `|j - i|`.\n\nReturn _the**lexicographically largest** sequence_ _. It is guaranteed that\nunder the given constraints there is always a solution._\n\nA sequence `a` is lexicographically larger than a sequence `b` (of the same\nlength) if in the first position where `a` and `b` differ sequence `a` has a\nnumber greater than the corresponding number in `b`. For example `[0190]`\nis lexicographically larger than `[0156]` because the first position they\ndiffer is at the third number and `9` is greater than `5`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** [31232]\n    **Explanation:** [23213] is also a valid sequence but [31232] is the lexicographically largest valid sequence.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** [531435242]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 20`\n\n,class Solution:\n    def constructDistancedSequence(self n: int) -> List[int]:\n        self.ans = None\n        def dfs(path used i):\n            self.steps += 1\n            if i == len(path):\n                self.ans = path[:]\n                return True\n            if path[i] != 0:\n                return dfs(path used i + 1)\n            my_ans = [0]\n            for x in range(n 0 -1):\n                if x in used:\n                    continue\n                if x == 1:\n                    path[i] = x\n                    used.add(1)\n                    \n                    if dfs(path used i + 1):\n                        return True\n                    \n                    path[i] = 0\n                    used.remove(1)\n                if i + x < len(path) and path[i + x] == 0:\n                    path[i + x] = path[i] = x\n                    used.add(x)\n                    \n                    if dfs(path used i + 1):\n                        return True\n                    \n                    path[i + x] = path[i] = 0\n                    used.remove(x)\n\n            return False\n\n        dfs([0] * (1 + 2 * (n - 1)) set() 0)\n        \n        return self.ans\n
Contain Virus,###  749\. Contain Virus\n\nA virus is spreading rapidly and your task is to quarantine the infected area\nby installing walls.\n\nThe world is modeled as an `m x n` binary grid `isInfected` where\n`isInfected[i][j] == 0` represents uninfected cells and `isInfected[i][j] ==\n1` represents cells contaminated with the virus. A wall (and only one wall)\ncan be installed between any two **4-directionally** adjacent cells on the\nshared boundary.\n\nEvery night the virus spreads to all neighboring cells in all four directions\nunless blocked by a wall. Resources are limited. Each day you can install\nwalls around only one region (i.e. the affected area (continuous block of\ninfected cells) that threatens the most uninfected cells the following night).\nThere **will never be a tie**.\n\nReturn _the number of walls used to quarantine all the infected regions_. If\nthe world will become fully infected return the number of walls used.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/01/virus11-grid.jpg)\n\n    \n    \n    **Input:** isInfected = [[01000001][01000001][00000001][00000000]]\n    **Output:** 10\n    **Explanation:** There are 2 contaminated regions.\n    On the first day add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n    ![](https://assets.leetcode.com/uploads/2021/06/01/virus12edited-grid.jpg)\n    On the second day add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n    ![](https://assets.leetcode.com/uploads/2021/06/01/virus13edited-grid.jpg)\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/01/virus2-grid.jpg)\n\n    \n    \n    **Input:** isInfected = [[111][101][111]]\n    **Output:** 4\n    **Explanation:** Even though there is only one cell saved there are 4 walls built.\n    Notice that walls are only built on the shared boundary of two different cells.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** isInfected = [[111000000][101011111][111000000]]\n    **Output:** 13\n    **Explanation:** The region on the left only builds two new walls.\n    \n\n\n\n**Constraints:**\n\n  * `m == isInfected.length`\n  * `n == isInfected[i].length`\n  * `1 <= m n <= 50`\n  * `isInfected[i][j]` is either `0` or `1`.\n  * There is always a contiguous viral region throughout the described process that will **infect strictly more uncontaminated squares** in the next round.\n\n," class Solution:\n    def containVirus(self mat: List[List[int]]) -> int:\n        mn = len(mat)len(mat[0])\n\n        def dfs(ijvisitednextInfected):  # return no. of walls require to quarantined dfs area\n            if 0<=i<m and 0<=j<n and (ij) not in visited:\n                if mat[i][j]==2: # Already quarantined cell\n                    return 0\n                if mat[i][j]==0:\n                    nextInfected.add((ij)) # add cell which will be infected next day\n                    return 1   # require one wall to quarantined cell from one side\n                    \n                else:\n                    visited.add((ij))\n                    return dfs(i-1jvisitednextInfected) + dfs(i+1jvisitednextInfected) + dfs(ij-1visitednextInfected) + dfs(ij+1visitednextInfected)  # traverse all four direction\n            else:\n                return 0\n				\n        ans = 0 \n        while True:   # this loop running ""how many days we should installing the walls"" times\n            # For every day check which area infect more cells\n            visited = set()  # Using in dfs\n            All_nextinfect  = set()\n            stop  walls = set()0   # here stop store the indices of maximum no. of cells in which we stop spreading of virus this day\n            \n            for i in range(m):\n                for j in range(n):\n                    if mat[i][j]==1 and (ij) not in visited:\n                        nextInfected = set()\n                        a = dfs(ijvisitednextInfected)\n                        \n                        if len(stop)<len(nextInfected):\n                            All_nextinfect  = All_nextinfect | stop # leave previous saved area from virus\n                            stop = nextInfected  # pick new area which we want to save\n                            walls = a  # require walls\n                            pq = ij  # starting position(indices) of this area\n                        else:\n                            All_nextinfect  = All_nextinfect | nextInfected   \n                            \n            if not stop : # if our job is done i.e. No cell will be infect Later\n                break\n            ans += walls  # add new walls installed this day\n            \n            # change each cell value to 2 which will be covered by quarantined area\n            def fun(pq):\n                if 0<=p<m and 0<=q<n and mat[p][q]==1:\n                    mat[p][q]=2\n                    fun(p+1q)\n                    fun(p-1q)\n                    fun(pq-1)\n                    fun(pq+1)\n            fun(pq) # start dfs from start point of quarantined area\n            \n            for ab in All_nextinfect: # set new infected cell value = 1 for iterating next day\n                mat[a][b] = 1\n\n        return ans   # Final answer \n"
Container With Most Water,###  11\. Container With Most Water\n\nYou are given an integer array `height` of length `n`. There are `n` vertical\nlines drawn such that the two endpoints of the `ith` line are `(i 0)` and\n`(i height[i])`.\n\nFind two lines that together with the x-axis form a container such that the\ncontainer contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)\n\n    \n    \n    **Input:** height = [186254837]\n    **Output:** 49\n    **Explanation:** The above vertical lines are represented by array [186254837]. In this case the max area of water (blue section) the container can contain is 49.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** height = [11]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `n == height.length`\n  * `2 <= n <= 105`\n  * `0 <= height[i] <= 104`\n\n,\nclass Solution:\n    def maxArea(self H: List[int]) -> int:\n        ans i j = 0 0 len(H)-1\n        while (i < j):\n            if H[i] <= H[j]:\n                res = H[i] * (j - i)\n                i += 1\n            else:\n                res = H[j] * (j - i)\n                j -= 1\n            if res > ans: ans = res\n        return ans\n\n
Contains Duplicate,###  217\. Contains Duplicate\n\nGiven an integer array `nums` return `true` if any value appears **at least\ntwice** in the array and return `false` if every element is distinct.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1231]\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1113343242]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-109 <= nums[i] <= 109`\n\n,# Runtime: 714 ms (Top 44.74%) | Memory: 26.1 MB (Top 5.18%)\n\nclass Solution:\n    def containsDuplicate(self nums: List[int]) -> bool:\n        return len(nums) != len(set(nums))
Contains Duplicate II,###  219\. Contains Duplicate II\n\nGiven an integer array `nums` and an integer `k` return `true` if there are\ntwo **distinct indices** `i` and `j` in the array such that `nums[i] ==\nnums[j]` and `abs(i - j) <= k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1231] k = 3\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1011] k = 1\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [123123] k = 2\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-109 <= nums[i] <= 109`\n  * `0 <= k <= 105`\n\n,# Runtime: 632 ms (Top 95.72%) | Memory: 27.2 MB (Top 74.47%)\nclass Solution:\n    def containsNearbyDuplicate(self nums: List[int] k: int) -> bool:\n        seen = {}\n        for i n in enumerate(nums):\n            if n in seen and i - seen[n] <= k:\n                    return True\n            seen[n] = i\n        return False
Contains Duplicate III,###  220\. Contains Duplicate III\n\nGiven an integer array `nums` and two integers `k` and `t` return `true` if\nthere are **two distinct indices** `i` and `j` in the array such that\n`abs(nums[i] - nums[j]) <= t` and `abs(i - j) <= k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1231] k = 3 t = 0\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1011] k = 1 t = 2\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [159159] k = 2 t = 3\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 104`\n  * `-231 <= nums[i] <= 231 - 1`\n  * `0 <= k <= 104`\n  * `0 <= t <= 231 - 1`\n\n,# Runtime: 779 ms (Top 16.27%) | Memory: 17.7 MB (Top 35.86%)\nfrom sortedcontainers import SortedList\nclass Solution:\n    def containsNearbyAlmostDuplicate(self nums k t):\n        sl = SortedList()\n        for i in range(len(nums)):\n            if i > k: sl.remove(nums[i-k-1])\n            idxl = sl.bisect_left(nums[i]-t)\n            idxr = sl.bisect_right(nums[i]+t)\n            if idxl != idxr: return True\n            sl.add(nums[i])\n        return False
Contiguous Array,###  525\. Contiguous Array\n\nGiven a binary array `nums` return _the maximum length of a contiguous\nsubarray with an equal number of_`0` _and_`1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [01]\n    **Output:** 2\n    **Explanation:** [0 1] is the longest contiguous subarray with an equal number of 0 and 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [010]\n    **Output:** 2\n    **Explanation:** [0 1] (or [1 0]) is a longest contiguous subarray with equal number of 0 and 1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `nums[i]` is either `0` or `1`.\n\n,class Solution:\n    def findMaxLength(self nums: List[int]) -> int:\n        # dictionary\n        prefixSum = {0: -1}\n        total = 0\n        maxlength = 0\n        \n        for index value in enumerate(nums):\n            if value == 0:\n                total -= 1\n            else:\n                total += 1\n            if total not in prefixSum.keys():\n                prefixSum[total] = index\n            else:\n                maxlength = max(maxlength index-prefixSum[total])        \n        return maxlength\n
Continuous Subarray Sum,###  523\. Continuous Subarray Sum\n\nGiven an integer array `nums` and an integer `k` return `true` _if_`nums`\n_has a continuous subarray of size**at least two** whose elements sum up to a\nmultiple of_ `k` _ or_`false` _otherwise_.\n\nAn integer `x` is a multiple of `k` if there exists an integer `n` such that\n`x = n * k`. `0` is **always** a multiple of `k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [23_24_ 67] k = 6\n    **Output:** true\n    **Explanation:** [2 4] is a continuous subarray of size 2 whose elements sum up to 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [_232647_] k = 6\n    **Output:** true\n    **Explanation:** [23 2 6 4 7] is an continuous subarray of size 5 whose elements sum up to 42.\n    42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [232647] k = 13\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 109`\n  * `0 <= sum(nums[i]) <= 231 - 1`\n  * `1 <= k <= 231 - 1`\n\n,class Solution:\n    def checkSubarraySum(self nums: List[int] k: int) -> bool:\n        psum = {0:-1}\n        currentSum = 0\n        for i in range(len(nums)):\n            currentSum += nums[i]\n            remainder = currentSum % k\n            if remainder not in psum:\n                psum[remainder] = i\n            else:\n                if i - psum[remainder] > 1:\n                    return True\n        return False\n
Convert a Number to Hexadecimal,"###  405\. Convert a Number to Hexadecimal\n\nGiven an integer `num` return _a string representing its hexadecimal\nrepresentation_. For negative integers [two’s\ncomplement](https://en.wikipedia.org/wiki/Two%27s_complement) method is used.\n\nAll the letters in the answer string should be lowercase characters and there\nshould not be any leading zeros in the answer except for the zero itself.\n\n**Note:  **You are not allowed to use any built-in library method to directly\nsolve this problem.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 26\n    **Output:** ""1a""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = -1\n    **Output:** ""ffffffff""\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= num <= 231 - 1`\n\n","# Runtime: 33 ms (Top 88.95%) | Memory: 13.8 MB (Top 62.28%)\nclass Solution:\n    def toHex(self num: int) -> str:\n        ret = [""0""""1""""2""""3""""4""""5""""6""""7""""8""""9""""a""""b""""c""""d""""e""""f""]\n        ans = """"\n\n        if num < 0:\n            num = pow(232) +num\n\n        if num == 0:\n            return ""0""\n        while num > 0:\n            ans = ret[num%16] +ans\n            num = num//16\n\n        return ans"
Convert Binary Number in a Linked List to Integer,###  1290\. Convert Binary Number in a Linked List to Integer\n\nGiven `head` which is a reference node to a singly-linked list. The value of\neach node in the linked list is either `0` or `1`. The linked list holds the\nbinary representation of a number.\n\nReturn the _decimal value_ of the number in the linked list.\n\nThe **most significant bit** is at the head of the linked list.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/12/05/graph-1.png)\n\n    \n    \n    **Input:** head = [101]\n    **Output:** 5\n    **Explanation:** (101) in base 2 = (5) in base 10\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** head = [0]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * The Linked List is not empty.\n  * Number of nodes will not exceed `30`.\n  * Each node's value is either `0` or `1`.\n\n,# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self val=0 next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def getDecimalValue(self head: ListNode) -> int:\n        res = 0\n        po = 0\n        stack = []\n        node = head\n        while node:\n            stack.append(node.val)\n            node = node.next\n        res = 0\n        for i in reversed(stack):\n            res += i*(2**po)\n            po += 1\n        return res\n
Convert BST to Greater Tree,###  538\. Convert BST to Greater Tree\n\nGiven the `root` of a Binary Search Tree (BST) convert it to a Greater Tree\nsuch that every key of the original BST is changed to the original key plus\nthe sum of all keys greater than the original key in BST.\n\nAs a reminder a _binary search tree_ is a tree that satisfies these\nconstraints:\n\n  * The left subtree of a node contains only nodes with keys **less than** the node's key.\n  * The right subtree of a node contains only nodes with keys **greater than** the node's key.\n  * Both the left and right subtrees must also be binary search trees.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/05/02/tree.png)\n\n    \n    \n    **Input:** root = [4160257nullnullnull3nullnullnull8]\n    **Output:** [30362136352615nullnullnull33nullnullnull8]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [0null1]\n    **Output:** [1null1]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 104]`.\n  * `-104 <= Node.val <= 104`\n  * All the values in the tree are **unique**.\n  * `root` is guaranteed to be a valid binary search tree.\n\n\n\n**Note:** This question is the same as 1038:\n<https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/>\n\n,# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def convertBST(self root: Optional[TreeNode]) -> Optional[TreeNode]:\n        ans = []\n        def inorder(node):\n            if not node:\n                return node\n            inorder(node.left)\n            ans.append(node.val)\n            inorder(node.right)\n        def dfs(node):\n            if not node:\n                return None\n            idx = ans.index(node.val)\n            node.val = node.val + sum(ans[idx+1:])\n            dfs(node.left)\n            dfs(node.right)\n\n        inorder(root)\n        dfs(root)\n        return root\n        \n
Convert Integer to the Sum of Two No-Zero Integers,###  1317\. Convert Integer to the Sum of Two No-Zero Integers\n\n**No-Zero integer** is a positive integer that **does not contain any`0`** in\nits decimal representation.\n\nGiven an integer `n` return _a list of two integers_ `[A B]` _where_ :\n\n  * `A` and `B` are **No-Zero integers**.\n  * `A + B = n`\n\nThe test cases are generated so that there is at least one valid solution. If\nthere are many valid solutions you can return any of them.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** [11]\n    **Explanation:** A = 1 B = 1. A + B = n and both A and B do not contain any 0 in their decimal representation.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 11\n    **Output:** [29]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 104`\n\n,"class Solution:\n    def getNoZeroIntegers(self n: int) -> List[int]:\n        for i in range(1n//2+1):\n            first = str(i)\n            second = str(n-i)\n            if ""0"" not in first and ""0"" not in second:\n                return [i n-i]\n"
Convert Sorted List to Binary Search Tree,###  109\. Convert Sorted List to Binary Search Tree\n\nGiven the `head` of a singly linked list where elements are **sorted in\nascending order**  convert it to a height balanced BST.\n\nFor this problem a height-balanced binary tree is defined as a binary tree in\nwhich the depth of the two subtrees of _every_ node never differ by more than\n1.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/17/linked.jpg)\n\n    \n    \n    **Input:** head = [-10-3059]\n    **Output:** [0-39-10null5]\n    **Explanation:** One possible answer is [0-39-10null5] which represents the shown height balanced BST.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** head = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in `head` is in the range `[0 2 * 104]`.\n  * `-105 <= Node.val <= 105`\n\n,class Solution:\n    def sortedListToBST(self head: Optional[ListNode]) -> Optional[TreeNode]:\n        arr = []\n        while head:\n            arr.append(head.val)\n            head = head.next\n        def dfs(left right):\n            if left > right: return\n            m = (left + right)//2\n            return TreeNode(arr[m] dfs(left m-1) dfs(m+1 right))\n        return dfs(0 len(arr)-1)
Copy List with Random Pointer,###  138\. Copy List with Random Pointer\n\nA linked list of length `n` is given such that each node contains an\nadditional random pointer which could point to any node in the list or\n`null`.\n\nConstruct a [**deep\ncopy**](https://en.wikipedia.org/wiki/Object_copying#Deep_copy) of the list.\nThe deep copy should consist of exactly `n` **brand new** nodes where each\nnew node has its value set to the value of its corresponding original node.\nBoth the `next` and `random` pointer of the new nodes should point to new\nnodes in the copied list such that the pointers in the original list and\ncopied list represent the same list state. **None of the pointers in the new\nlist should point to nodes in the original list**.\n\nFor example if there are two nodes `X` and `Y` in the original list where\n`X.random --> Y` then for the corresponding two nodes `x` and `y` in the\ncopied list `x.random --> y`.\n\nReturn _the head of the copied linked list_.\n\nThe linked list is represented in the input/output as a list of `n` nodes.\nEach node is represented as a pair of `[val random_index]` where:\n\n  * `val`: an integer representing `Node.val`\n  * `random_index`: the index of the node (range from `0` to `n-1`) that the `random` pointer points to or `null` if it does not point to any node.\n\nYour code will **only** be given the `head` of the original linked list.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/12/18/e1.png)\n\n    \n    \n    **Input:** head = [[7null][130][114][102][10]]\n    **Output:** [[7null][130][114][102][10]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/12/18/e2.png)\n\n    \n    \n    **Input:** head = [[11][21]]\n    **Output:** [[11][21]]\n    \n\n**Example 3:**\n\n**![](https://assets.leetcode.com/uploads/2019/12/18/e3.png)**\n\n    \n    \n    **Input:** head = [[3null][30][3null]]\n    **Output:** [[3null][30][3null]]\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 1000`\n  * `-104 <= Node.val <= 104`\n  * `Node.random` is `null` or is pointing to some node in the linked list.\n\n,"from collections import defaultdict\n\n""""""\n# Definition for a Node.\nclass Node:\n    def __init__(self x: int next: 'Node' = None random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n""""""\n\nclass Solution:\n    def copyRandomList(self head: 'Optional[Node]') -> 'Optional[Node]':\n        \n        \n        \n        # ll=res\n        # k=0\n        # ind=0\n        # kmk=1\n        jj=None\n        g=defaultdict(lambda:-1)\n        k=0\n        hh=head\n        while(head):\n            res=Node(head.val)\n            if k==0:\n                jj=res\n\n            if k==1:\n                prev.next=res\n            \n            g[head]=res\n            prev=res\n            k=1\n            head=head.next\n            \n        # print(g)\n        \n        # for i in g:\n        #     print(i.valg[i].val)\n            \n        kk=jj\n        mm=jj\n        # print(head)\n        while(hh):\n            if hh.random!=None:\n                \n                jj.random=g[hh.random]\n            else:\n                jj.random=None\n            hh=hh.next\n            \n            jj=jj.next    \n            # head=head.next\n        kkk=kk\n        # while(kk):\n        #     print(kk.val)\n        #     kk=kk.next\n            \n        return kkk\n#             if g[ind]!=-1:\n#                 g[ind].random=res\n                \n#             res=Node(head.val)\n#             if kmk==1:\n#                 ll=res\n#             kmk=0\n#             mm=head.next\n#             if mm:\n                \n#                 jk=Node(mm.val)\n#                 res.next=jk\n#             if head.random !=None:\n#                 g[head.random]=res\n#             else:\n#                 res.random=None\n#             head=head.next\n#             ind+=1\n#             # res=res.next\n            \n#         return ll\n            \n            # if k==0:\n            #     res.val=head.val\n            #     mm=head.next\n                \n                \n                \n            \n            \n"
Corporate Flight Bookings,###  1109\. Corporate Flight Bookings\n\nThere are `n` flights that are labeled from `1` to `n`.\n\nYou are given an array of flight bookings `bookings` where `bookings[i] =\n[firsti lasti seatsi]` represents a booking for flights `firsti` through\n`lasti` (**inclusive**) with `seatsi` seats reserved for **each flight** in\nthe range.\n\nReturn _an array_`answer` _of length_`n` _ where_`answer[i]`_is the total\nnumber of seats reserved for flight_`i`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** bookings = [[1210][2320][2525]] n = 5\n    **Output:** [1055452525]\n    **Explanation:**\n    Flight labels:        1   2   3   4   5\n    Booking 1 reserved:  10  10\n    Booking 2 reserved:      20  20\n    Booking 3 reserved:      25  25  25  25\n    Total seats:         10  55  45  25  25\n    Hence answer = [1055452525]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** bookings = [[1210][2215]] n = 2\n    **Output:** [1025]\n    **Explanation:**\n    Flight labels:        1   2\n    Booking 1 reserved:  10  10\n    Booking 2 reserved:      15\n    Total seats:         10  25\n    Hence answer = [1025]\n    \n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 2 * 104`\n  * `1 <= bookings.length <= 2 * 104`\n  * `bookings[i].length == 3`\n  * `1 <= firsti <= lasti <= n`\n  * `1 <= seatsi <= 104`\n\n,"class Solution:\n	def corpFlightBookings(self bookings: List[List[int]] n: int) -> List[int]:\n\n		flights = [0]*n\n		for startendseats in bookings:\n			flights[start-1] += seats\n			if end < n: flights[end] -= seats\n		for i in range(n-1):\n			flights[i+1] += flights[i]\n		return flights"
Count All Possible Routes,###  1575\. Count All Possible Routes\n\nYou are given an array of **distinct** positive integers locations where\n`locations[i]` represents the position of city `i`. You are also given\nintegers `start` `finish` and `fuel` representing the starting city ending\ncity and the initial amount of fuel you have respectively.\n\nAt each step if you are at city `i` you can pick any city `j` such that `j\n!= i` and `0 <= j < locations.length` and move to city `j`. Moving from city\n`i` to city `j` reduces the amount of fuel you have by `|locations[i] -\nlocations[j]|`. Please notice that `|x|` denotes the absolute value of `x`.\n\nNotice that `fuel` **cannot** become negative at any point in time and that\nyou are **allowed** to visit any city more than once (including `start` and\n`finish`).\n\nReturn _the count of all possible routes from_`start` _to_ `finish`. Since the\nanswer may be too large return it modulo `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** locations = [23684] start = 1 finish = 3 fuel = 5\n    **Output:** 4\n    **Explanation:** The following are all possible routes each uses 5 units of fuel:\n    1 -> 3\n    1 -> 2 -> 3\n    1 -> 4 -> 3\n    1 -> 4 -> 2 -> 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** locations = [431] start = 1 finish = 0 fuel = 6\n    **Output:** 5\n    **Explanation:** The following are all possible routes:\n    1 -> 0 used fuel = 1\n    1 -> 2 -> 0 used fuel = 5\n    1 -> 2 -> 1 -> 0 used fuel = 5\n    1 -> 0 -> 1 -> 0 used fuel = 3\n    1 -> 0 -> 1 -> 0 -> 1 -> 0 used fuel = 5\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** locations = [521] start = 0 finish = 2 fuel = 3\n    **Output:** 0\n    **Explanation:** It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= locations.length <= 100`\n  * `1 <= locations[i] <= 109`\n  * All integers in `locations` are **distinct**.\n  * `0 <= start finish < locations.length`\n  * `1 <= fuel <= 200`\n\n,# Runtime: 3516 ms (Top 53.70%) | Memory: 22.1 MB (Top 43.52%)\n\nfrom bisect import bisect_left\nfrom functools import lru_cache\nclass Solution:\n    def countRoutes(self locations: List[int] start: int finish: int fuel: int) -> int:\n        start = locations[start]\n        end = locations[finish]\n        locations.sort()\n        start = bisect_left(locations start)\n        end = bisect_left(locations end)\n        @lru_cache(None)\n        def dfs(i fuel):\n            if fuel == 0 and i == end: return 1\n            res = 0\n            if i == end: res += 1\n            j = i-1\n            while j>=0 and abs(locations[j]-locations[i]) <= fuel:\n                res += dfs(j fuel-abs(locations[j]-locations[i]))\n                j -= 1\n            j = i+1\n            while j<len(locations) and abs(locations[j]-locations[i]) <= fuel:\n                res += dfs(j fuel-abs(locations[j]-locations[i]))\n                j += 1\n            return res\n        return dfs(start fuel) % (10**9+7)
Count All Valid Pickup and Delivery Options,###  1359\. Count All Valid Pickup and Delivery Options\n\nGiven `n` orders each order consist in pickup and delivery services.\n\nCount all valid pickup/delivery possible sequences such that delivery(i) is\nalways after of pickup(i).\n\nSince the answer may be too large return it modulo 10^9 + 7.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1\n    **Explanation:** Unique order (P1 D1) Delivery 1 always is after of Pickup 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 6\n    **Explanation:** All possible orders: \n    (P1P2D1D2) (P1P2D2D1) (P1D1P2D2) (P2P1D1D2) (P2P1D2D1) and (P2D2P1D1).\n    This is an invalid order (P1D2P2D1) because Pickup 2 is after of Delivery 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** 90\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 500`\n\n,class Solution:\n    def countOrders(self n: int) -> int:\n        total = 1\n        mod = 10 ** 9 + 7\n        for k in reversed(range(2 n + 1)):\n            total = total * ((2 * k - 1) * (2 * k - 2) // 2 + 2 * k - 1)\n            total = total % mod\n        return total\n
Count Array Pairs Divisible by K,###  2183\. Count Array Pairs Divisible by K\n\nGiven a **0-indexed** integer array `nums` of length `n` and an integer `k`\nreturn _the**number of pairs**_ `(i j)` _such that:_\n\n  * `0 <= i < j <= n - 1` _and_\n  * `nums[i] * nums[j]` _is divisible by_ `k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12345] k = 2\n    **Output:** 7\n    **Explanation:** \n    The 7 pairs of indices whose corresponding products are divisible by 2 are\n    (0 1) (0 3) (1 2) (1 3) (1 4) (2 3) and (3 4).\n    Their products are 2 4 6 8 10 12 and 20 respectively.\n    Other pairs such as (0 2) and (2 4) have products 3 and 15 respectively which are not divisible by 2.    \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234] k = 5\n    **Output:** 0\n    **Explanation:** There does not exist any pair of indices whose corresponding product is divisible by 5.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] k <= 105`\n\n,"class Solution:\n    def countPairs(self nums: List[int] k: int) -> int:\n        counter = Counter() #hashmap dicitionary of python\n        ans = 0\n        n = len(nums)\n        \n        for i in range(n):\n            x = math.gcd(knums[i]) #ex: 10 = k and we have nums[i] as 12 so gcd will be 2\n            want = k // x #what do we want from upper ex: we need 5\n            for num in counter:\n                if num % want == 0: #so if we find a number that is divisible by 5 then we can multiply it to 12 and make it a factor of 10 for ex we find 20 so it will be 240 which is divisible by 10 hence we will add it to answer\n                    ans += counter[num] #we are adding the freq as we can find no of numbers that have same factor\n            counter[x] += 1 #here we are increasing the freq of 2 so that if we find 5 next time we can add these to the answer\n        return ans\n		```"
Count Binary Substrings,"###  696\. Count Binary Substrings\n\nGiven a binary string `s` return the number of non-empty substrings that have\nthe same number of `0`'s and `1`'s and all the `0`'s and all the `1`'s in\nthese substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they\noccur.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""00110011""\n    **Output:** 6\n    **Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's: ""0011"" ""01"" ""1100"" ""10"" ""0011"" and ""01"".\n    Notice that some of these substrings repeat and are counted the number of times they occur.\n    Also ""00110011"" is not a valid substring because all the 0's (and 1's) are not grouped together.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""10101""\n    **Output:** 4\n    **Explanation:** There are 4 substrings: ""10"" ""01"" ""10"" ""01"" that have equal number of consecutive 1's and 0's.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is either `'0'` or `'1'`.\n\n","# Runtime: 133 ms (Top 63.3%) | Memory: 16.65 MB (Top 94.0%)\n\nclass Solution:\n    def countBinarySubstrings(self s: str) -> int:\n        \n        # previous continuous occurrence current continuous occurrence\n        pre_cont_occ cur_cont_occ = 0 1\n        \n        # counter for binary substrings with equal 0s and 1s\n        counter = 0\n        \n		# scan each character pair in s\n        for idx in range(1 len(s)):\n            \n            if s[idx] == s[idx-1]:\n                \n                # update current continuous occurrence\n                cur_cont_occ += 1\n            \n            else:\n                # update counter of binary substrings between prevous character group and current character group\n                counter += min(pre_cont_occ cur_cont_occ)\n\n                # update previous as current's continuous occurrence\n                pre_cont_occ = cur_cont_occ\n                \n                # reset current continuous occurrence to 1\n                cur_cont_occ = 1\n        \n        # update for last time\n        counter += min(pre_cont_occ cur_cont_occ)\n        \n        return counter"
Count Common Words With One Occurrence,"###  2085\. Count Common Words With One Occurrence\n\nGiven two string arrays `words1` and `words2` return _the number of strings\nthat appear**exactly once** in **each**  of the two arrays._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words1 = [""leetcode""""is""""amazing""""as""""is""] words2 = [""amazing""""leetcode""""is""]\n    **Output:** 2\n    **Explanation:**\n    - ""leetcode"" appears exactly once in each of the two arrays. We count this string.\n    - ""amazing"" appears exactly once in each of the two arrays. We count this string.\n    - ""is"" appears in each of the two arrays but there are 2 occurrences of it in words1. We do not count this string.\n    - ""as"" appears once in words1 but does not appear in words2. We do not count this string.\n    Thus there are 2 strings that appear exactly once in each of the two arrays.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words1 = [""b""""bb""""bbb""] words2 = [""a""""aa""""aaa""]\n    **Output:** 0\n    **Explanation:** There are no strings that appear in each of the two arrays.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** words1 = [""a""""ab""] words2 = [""a""""a""""a""""ab""]\n    **Output:** 1\n    **Explanation:** The only string that appears exactly once in each of the two arrays is ""ab"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words1.length words2.length <= 1000`\n  * `1 <= words1[i].length words2[j].length <= 30`\n  * `words1[i]` and `words2[j]` consists only of lowercase English letters.\n\n","class Solution:\n	def countWords(self words1: List[str] words2: List[str]) -> int:\n		count = Counter(words1 + words2)\n		return len([word for word in count if count[word] == 2 and word in words1 and word in words2])\n"
Count Complete Tree Nodes,###  222\. Count Complete Tree Nodes\n\nGiven the `root` of a **complete** binary tree return the number of the nodes\nin the tree.\n\nAccording to\n**[Wikipedia](http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees)**\n every level except possibly the last is completely filled in a complete\nbinary tree and all nodes in the last level are as far left as possible. It\ncan have between `1` and `2h` nodes inclusive at the last level `h`.\n\nDesign an algorithm that runs in less than `O(n)` time complexity.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)\n\n    \n    \n    **Input:** root = [123456]\n    **Output:** 6\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = []\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 5 * 104]`.\n  * `0 <= Node.val <= 5 * 104`\n  * The tree is guaranteed to be **complete**.\n\n,// Runtime: 73 ms (Top 66.36%) | Memory: 23.80 MB (Top 18.91%)\n\nclass Solution:\n        # @param {TreeNode} root\n        # @return {integer}\n        def countNodes(self root):\n            if not root:\n                return 0\n            leftDepth = self.getDepth(root.left)\n            rightDepth = self.getDepth(root.right)\n            if leftDepth == rightDepth:\n                return pow(2 leftDepth) + self.countNodes(root.right)\n            else:\n                return pow(2 rightDepth) + self.countNodes(root.left)\n    \n        def getDepth(self root):\n            if not root:\n                return 0\n            return 1 + self.getDepth(root.left)
Count Different Palindromic Subsequences,"###  730\. Count Different Palindromic Subsequences\n\nGiven a string s return _the number of different non-empty palindromic\nsubsequences in_ `s`. Since the answer may be very large return it **modulo**\n`109 + 7`.\n\nA subsequence of a string is obtained by deleting zero or more characters from\nthe string.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences `a1 a2 ...` and `b1 b2 ...` are different if there is some\n`i` for which `ai != bi`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""bccb""\n    **Output:** 6\n    **Explanation:** The 6 different non-empty palindromic subsequences are 'b' 'c' 'bb' 'cc' 'bcb' 'bccb'.\n    Note that 'bcb' is counted only once even though it occurs twice.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba""\n    **Output:** 104860361\n    **Explanation:** There are 3104860382 different non-empty palindromic subsequences which is 104860361 modulo 109 + 7.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s[i]` is either `'a'` `'b'` `'c'` or `'d'`.\n\n","class Solution:\n    def countPalindromicSubsequences(self s: str) -> int:\n        \n        N = len(s)\n        mod = 10**9 + 7\n        memo = {}\n        \n        def backTrack(startend):\n            \n            if start >= N or end < 0: return 0\n            \n            key = (startend) \n            \n            if key in memo: return memo[key]\n            \n            strn = s[start:end+1]\n\n            memo[key] = 0\n\n            for char in ""abcd"":\n                if not char in strn: continue\n                i = start + strn.index(char)\n                j = start + strn.rindex(char)\n                memo[key] += backTrack(i+1j-1) + 2 if i != j else 1\n            \n            memo[key] %= mod\n            \n            return memo[key]\n        \n        return backTrack(0N-1)\n\n"
Count Equal and Divisible Pairs in an Array,###  2176\. Count Equal and Divisible Pairs in an Array\n\nGiven a **0-indexed** integer array `nums` of length `n` and an integer `k`\nreturn _the**number of pairs**_ `(i j)` _where_ `0 <= i < j < n` _such that_\n`nums[i] == nums[j]` _and_ `(i * j)` _is divisible by_ `k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3122213] k = 2\n    **Output:** 4\n    **Explanation:**\n    There are 4 pairs that meet all the requirements:\n    - nums[0] == nums[6] and 0 * 6 == 0 which is divisible by 2.\n    - nums[2] == nums[3] and 2 * 3 == 6 which is divisible by 2.\n    - nums[2] == nums[4] and 2 * 4 == 8 which is divisible by 2.\n    - nums[3] == nums[4] and 3 * 4 == 12 which is divisible by 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234] k = 1\n    **Output:** 0\n    **Explanation:** Since no value in nums is repeated there are no pairs (ij) that meet all the requirements.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `1 <= nums[i] k <= 100`\n\n,class Solution:\n    def countPairs(self nums: List[int] k: int) -> int:\n        n=len(nums)\n        c=0\n        for i in range(0n):\n            for j in range(i+1n):\n                if nums[i]==nums[j] and ((i*j)%k==0):\n                    c+=1\n        return c\n
Count Fertile Pyramids in a Land,###  2088\. Count Fertile Pyramids in a Land\n\nA farmer has a **rectangular grid** of land with `m` rows and `n` columns that\ncan be divided into unit cells. Each cell is either **fertile** (represented\nby a `1`) or **barren** (represented by a `0`). All cells outside the grid are\nconsidered barren.\n\nA **pyramidal plot** of land can be defined as a set of cells with the\nfollowing criteria:\n\n  1. The number of cells in the set has to be **greater than**`1` and all cells must be **fertile**.\n  2. The **apex** of a pyramid is the **topmost** cell of the pyramid. The **height** of a pyramid is the number of rows it covers. Let `(r c)` be the apex of the pyramid and its height be `h`. Then the plot comprises of cells `(i j)` where `r <= i <= r + h - 1` **and** `c - (i - r) <= j <= c + (i - r)`.\n\nAn **inverse pyramidal plot** of land can be defined as a set of cells with\nsimilar criteria:\n\n  1. The number of cells in the set has to be **greater than**`1` and all cells must be **fertile**.\n  2. The **apex** of an inverse pyramid is the **bottommost** cell of the inverse pyramid. The **height** of an inverse pyramid is the number of rows it covers. Let `(r c)` be the apex of the pyramid and its height be `h`. Then the plot comprises of cells `(i j)` where `r - h + 1 <= i <= r` **and** `c - (r - i) <= j <= c + (r - i)`.\n\nSome examples of valid and invalid pyramidal (and inverse pyramidal) plots are\nshown below. Black cells indicate fertile cells.\n\n![](https://assets.leetcode.com/uploads/2021/11/08/image.png)\n\nGiven a **0-indexed** `m x n` binary matrix `grid` representing the farmland\nreturn _the**total number** of pyramidal and inverse pyramidal plots that can\nbe found in_ `grid`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/22/1.JPG)\n\n    \n    \n    **Input:** grid = [[0110][1111]]\n    **Output:** 2\n    **Explanation:** The 2 possible pyramidal plots are shown in blue and red respectively.\n    There are no inverse pyramidal plots in this grid. \n    Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/22/2.JPG)\n\n    \n    \n    **Input:** grid = [[111][111]]\n    **Output:** 2\n    **Explanation:** The pyramidal plot is shown in blue and the inverse pyramidal plot is shown in red. \n    Hence the total number of plots is 1 + 1 = 2.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/12/22/3.JPG)\n\n    \n    \n    **Input:** grid = [[11110][11111][11111][01001]]\n    **Output:** 13\n    **Explanation:** There are 7 pyramidal plots 3 of which are shown in the 2nd and 3rd figures.\n    There are 6 inverse pyramidal plots 2 of which are shown in the last figure.\n    The total number of plots is 7 + 6 = 13.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 1000`\n  * `1 <= m * n <= 105`\n  * `grid[i][j]` is either `0` or `1`.\n\n,class Solution:\n    def countPyramids(self grid):      \n        # dp[i][j] represents the number of layers of the largest pyramid with (i j) as the vertex.\n        # Note that the 1-level pyramid is invalid in the problem so it should be removed when summing.\n        # Note that if grid[i][j] is 0 dp[i][j] will always be 0.\n        # The dp recurrence formula is dp[i][j] = min(dp[i + 1][j - 1] dp[i + 1][j + 1]) + 1\n        m n dp cnt = len(grid) len(grid[0]) copy.deepcopy(grid) 0\n        # triangle\n        for i in range(m - 2 -1 -1):\n            for j in range(1 n - 1):\n                if dp[i][j] > 0 and dp[i + 1][j] > 0:\n                    dp[i][j] = min(dp[i + 1][j - 1] dp[i + 1][j + 1]) + 1\n                    cnt += dp[i][j] - 1\n        # inverted triangle\n        dp = grid\n        for i in range(1 m):\n            for j in range(1 n - 1):\n                if dp[i][j] > 0 and dp[i - 1][j] > 0:\n                    dp[i][j] = min(dp[i - 1][j - 1] dp[i - 1][j + 1]) + 1\n                    cnt += dp[i][j] - 1\n        return cnt\n
Count Good Meals,###  1711\. Count Good Meals\n\nA **good meal** is a meal that contains **exactly two different food items**\nwith a sum of deliciousness equal to a power of two.\n\nYou can pick **any** two different foods to make a good meal.\n\nGiven an array of integers `deliciousness` where `deliciousness[i]` is the\ndeliciousness of the `i​​​​​​th​​​​`​​​​ item of\nfood return _the number of different**good meals** you can make from this\nlist modulo_ `109 + 7`.\n\nNote that items with different indices are considered different even if they\nhave the same deliciousness value.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** deliciousness = [13579]\n    **Output:** 4\n    **Explanation:** The good meals are (13) (17) (35) and (79).\n    Their respective sums are 4 8 8 and 16 all of which are powers of 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** deliciousness = [1113337]\n    **Output:** 15\n    **Explanation:** The good meals are (11) with 3 ways (13) with 9 ways and (17) with 3 ways.\n\n\n\n**Constraints:**\n\n  * `1 <= deliciousness.length <= 105`\n  * `0 <= deliciousness[i] <= 220`\n\n,"class Solution:\n    def countPairs(self deliciousness: List[int]) -> int:\n        pows = [2 ** i for i in range(022)] # form our list of powers of 2\n        dp_seen = {} # dict to store what we've seen - dynamic programming solution for time requirement\n        count = 0 # to store the answer\n\n        for j in range(0 len(deliciousness)):\n            for i in range(0 len(pows)):\n                if pows[i] - deliciousness[j] in dp_seen: # ""if we find a previous deliciousness[j] as pows[i] - deliciousness[j] then we will add dp_seen[deliciousness[j]] to count""\n                    count += dp_seen[pows[i] - deliciousness[j]]\n            if deliciousness[j] in dp_seen:\n                dp_seen[deliciousness[j]] += 1 \n            else:\n                dp_seen[deliciousness[j]] = 1\n                \n        return count % (10**9 + 7) # the arbitrary modulo presumably to reduce the answer size\n		```"
Count Good Nodes in Binary Tree,"###  1448\. Count Good Nodes in Binary Tree\n\nGiven a binary tree `root` a node _X_ in the tree is named **good** if in the\npath from root to _X_ there are no nodes with a value _greater than_ X.\n\nReturn the number of **good** nodes in the binary tree.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_1.png)**\n\n    \n    \n    **Input:** root = [3143null15]\n    **Output:** 4\n    **Explanation:** Nodes in blue are **good**.\n    Root Node (3) is always a good node.\n    Node 4 -> (34) is the maximum value in the path starting from the root.\n    Node 5 -> (345) is the maximum value in the path\n    Node 3 -> (313) is the maximum value in the path.\n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2020/04/02/test_sample_2.png)**\n\n    \n    \n    **Input:** root = [33null42]\n    **Output:** 3\n    **Explanation:** Node 2 -> (3 3 2) is not good because ""3"" is higher than it.\n\n**Example 3:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** 1\n    **Explanation:** Root is considered as **good**.\n\n\n\n**Constraints:**\n\n  * The number of nodes in the binary tree is in the range `[1 10^5]`.\n  * Each node's value is between `[-10^4 10^4]`.\n\n","// Runtime: 132 ms (Top 87.49%) | Memory: 31.70 MB (Top 89.21%)\n\nclass Solution:\n    def goodNodes(self root: TreeNode) -> int:\n        # Our counter for the good nodes.\n        count = 0\n        \n        def helper(node m):\n            nonlocal count\n			# If we run out of nodes return.\n            if not node:\n                return\n			# If the current node val is >= the largest observed in the path thus far.\n            if node.val >= m:\n			    # Add 1 to the count and update the max observed value.\n                count += 1\n                m = max(m node.val)\n			# Traverse l and r subtrees.\n            helper(node.left m)\n            helper(node.right m)\n                \n        helper(root root.val)\n        return count\n"
Count Good Numbers,"###  1922\. Count Good Numbers\n\nA digit string is **good** if the digits **(0-indexed)** at **even** indices\nare **even** and the digits at **odd** indices are **prime** (`2` `3` `5`\nor `7`).\n\n  * For example `""2582""` is good because the digits (`2` and `8`) at even positions are even and the digits (`5` and `2`) at odd positions are prime. However `""3245""` is **not** good because `3` is at an even index but is not even.\n\nGiven an integer `n` return _the**total** number of good digit strings of\nlength _`n`. Since the answer may be large **return it modulo**`109 + 7`.\n\nA **digit string** is a string consisting of digits `0` through `9` that may\ncontain leading zeros.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 5\n    **Explanation:** The good numbers of length 1 are ""0"" ""2"" ""4"" ""6"" ""8"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** 400\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 50\n    **Output:** 564908303\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1015`\n\n",class Solution:\n    def countGoodNumbers(self n: int) -> int:\n        ans = 1\n        rem = n % 2\n        n -= rem\n        ans = pow(20 n//2 10**9 + 7)\n        if rem == 1:\n            ans *= 5\n        return ans % (10**9 + 7)\n
Count Good Triplets,###  1534\. Count Good Triplets\n\nGiven an array of integers `arr` and three integers `a` `b` and `c`. You\nneed to find the number of good triplets.\n\nA triplet `(arr[i] arr[j] arr[k])` is **good** if the following conditions\nare true:\n\n  * `0 <= i < j < k < arr.length`\n  * `|arr[i] - arr[j]| <= a`\n  * `|arr[j] - arr[k]| <= b`\n  * `|arr[i] - arr[k]| <= c`\n\nWhere `|x|` denotes the absolute value of `x`.\n\nReturn _the number of good triplets_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [301197] a = 7 b = 2 c = 3\n    **Output:** 4\n    **Explanation:**  There are 4 good triplets: [(301) (301) (311) (011)].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [11223] a = 0 b = 0 c = 1\n    **Output:** 0\n    **Explanation:** No triplet satisfies all conditions.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= arr.length <= 100`\n  * `0 <= arr[i] <= 1000`\n  * `0 <= a b c <= 1000`\n\n,# Runtime: 1794 ms (Top 11.20%) | Memory: 13.8 MB (Top 87.90%)\nclass Solution:\n    def countGoodTriplets(self arr: List[int] a: int b: int c: int) -> int:\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i+1len(arr)):\n                for k in range(j+1len(arr)):\n                    if abs(arr[i]-arr[j])<=a and abs(arr[j]-arr[k])<=b and abs(arr[k]-arr[i])<=c:\n                        count+=1\n        return count
Count Good Triplets in an Array,###  2179\. Count Good Triplets in an Array\n\nYou are given two **0-indexed** arrays `nums1` and `nums2` of length `n` both\nof which are **permutations** of `[0 1 ... n - 1]`.\n\nA **good triplet** is a set of `3` **distinct** values which are present in\n**increasing order** by position both in `nums1` and `nums2`. In other words\nif we consider `pos1v` as the index of the value `v` in `nums1` and `pos2v` as\nthe index of the value `v` in `nums2` then a good triplet will be a set `(x\ny z)` where `0 <= x y z <= n - 1` such that `pos1x < pos1y < pos1z` and\n`pos2x < pos2y < pos2z`.\n\nReturn _the**total number** of good triplets_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [2013] nums2 = [0123]\n    **Output:** 1\n    **Explanation:** \n    There are 4 triplets (xyz) such that pos1x < pos1y < pos1z. They are (201) (203) (213) and (013). \n    Out of those triplets only the triplet (013) satisfies pos2x < pos2y < pos2z. Hence there is only 1 good triplet.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [40132] nums2 = [41023]\n    **Output:** 4\n    **Explanation:** The 4 good triplets are (403) (402) (413) and (412).\n    \n\n\n\n**Constraints:**\n\n  * `n == nums1.length == nums2.length`\n  * `3 <= n <= 105`\n  * `0 <= nums1[i] nums2[i] <= n - 1`\n  * `nums1` and `nums2` are permutations of `[0 1 ... n - 1]`.\n\n,from sortedcontainers import SortedList\nclass Solution:\n    def goodTriplets(self A: List[int] B: List[int]) -> int:\n        # Index of a (from A) in B.\n        pos = [0] * len(A)               \n        for idx b in enumerate(B):\n            pos[b] = idx\n        \n        # Build pre_a[i]: number of elements on a[i]'s left in both A and B.\n        # pos_in_b: sorted indexes (in B) of all the visited elements in A.\n        pos_in_b pre_a = SortedList([pos[A[0]]]) [0]      \n        for a in A[1:]:       \n            pos_in_b.add(pos[a])\n            pre_a.append(pos_in_b.bisect_left(pos[a]))\n    \n        # Build suf_a[i]: number of elements on a[i]'s right in both A and B.\n        pos_in_b suf_a = SortedList([pos[A[-1]]]) [0]\n        for a in reversed(A[:len(A)-1]):\n            idx = pos_in_b.bisect(pos[a])\n            suf_a.append(len(pos_in_b) - idx)\n            pos_in_b.add(pos[a])\n        suf_a.reverse()\n        \n        # Sum up all unique triplets centered on A[i].\n        ans = 0\n        for x y in zip(pre_a suf_a):\n            ans += x * y\n        return ans\n
Count Hills and Valleys in an Array,###  2210\. Count Hills and Valleys in an Array\n\nYou are given a **0-indexed** integer array `nums`. An index `i` is part of a\n**hill** in `nums` if the closest non-equal neighbors of `i` are smaller than\n`nums[i]`. Similarly an index `i` is part of a **valley** in `nums` if the\nclosest non-equal neighbors of `i` are larger than `nums[i]`. Adjacent indices\n`i` and `j` are part of the **same** hill or valley if `nums[i] == nums[j]`.\n\nNote that for an index to be part of a hill or valley it must have a non-\nequal neighbor on **both** the left and right of the index.\n\nReturn _the number of hills and valleys in_`nums`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [241165]\n    **Output:** 3\n    **Explanation:**\n    At index 0: There is no non-equal neighbor of 2 on the left so index 0 is neither a hill nor a valley.\n    At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1 index 1 is a hill. \n    At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6 index 2 is a valley.\n    At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6 index 3 is a valley but note that it is part of the same valley as index 2.\n    At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5 index 4 is a hill.\n    At index 5: There is no non-equal neighbor of 5 on the right so index 5 is neither a hill nor a valley. \n    There are 3 hills and valleys so we return 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [665541]\n    **Output:** 0\n    **Explanation:**\n    At index 0: There is no non-equal neighbor of 6 on the left so index 0 is neither a hill nor a valley.\n    At index 1: There is no non-equal neighbor of 6 on the left so index 1 is neither a hill nor a valley.\n    At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4 index 2 is neither a hill nor a valley.\n    At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4 index 3 is neither a hill nor a valley.\n    At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1 index 4 is neither a hill nor a valley.\n    At index 5: There is no non-equal neighbor of 1 on the right so index 5 is neither a hill nor a valley.\n    There are 0 hills and valleys so we return 0.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= nums.length <= 100`\n  * `1 <= nums[i] <= 100`\n\n,class Solution:\n    def countHillValley(self nums: List[int]) -> int:\n        c = 0\n        i = 1\n        while i <len(nums)-1:\n            j = i+1\n            while j < len(nums)-1 and nums[j] == nums[i]:\n                j += 1\n            if (nums[i-1] > nums[i] and nums[j] > nums[i]) or (nums[i-1] < nums[i] and nums[j] < nums[i]):\n                    c += 1\n            i = j\n        return c\n
Count Integers With Even Digit Sum,###  2180\. Count Integers With Even Digit Sum\n\nGiven a positive integer `num` return _the number of positive integers**less\nthan or equal to**_ `num` _whose digit sums are**even**_.\n\nThe **digit sum** of a positive integer is the sum of all its digits.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 4\n    **Output:** 2\n    **Explanation:**\n    The only integers less than or equal to 4 whose digit sums are even are 2 and 4.    \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 30\n    **Output:** 14\n    **Explanation:**\n    The 14 integers less than or equal to 30 whose digit sums are even are\n    2 4 6 8 11 13 15 17 19 20 22 24 26 and 28.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num <= 1000`\n\n,class Solution:\n    def countEven(self num: int) -> int:\n        if num%2!=0:\n            return (num//2)\n        s=0\n        t=num\n        while t:\n            s=s+(t%10)\n            t=t//10\n        if s%2==0:\n            return num//2\n        else:\n            return (num//2)-1\n
Count Items Matching a Rule,"###  1773\. Count Items Matching a Rule\n\nYou are given an array `items` where each `items[i] = [typei colori namei]`\ndescribes the type color and name of the `ith` item. You are also given a\nrule represented by two strings `ruleKey` and `ruleValue`.\n\nThe `ith` item is said to match the rule if **one** of the following is true:\n\n  * `ruleKey == ""type""` and `ruleValue == typei`.\n  * `ruleKey == ""color""` and `ruleValue == colori`.\n  * `ruleKey == ""name""` and `ruleValue == namei`.\n\nReturn _the number of items that match the given rule_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** items = [[""phone""""blue""""pixel""][""computer""""silver""""lenovo""][""phone""""gold""""iphone""]] ruleKey = ""color"" ruleValue = ""silver""\n    **Output:** 1\n    **Explanation:** There is only one item matching the given rule which is [""computer""""silver""""lenovo""].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** items = [[""phone""""blue""""pixel""][""computer""""silver""""phone""][""phone""""gold""""iphone""]] ruleKey = ""type"" ruleValue = ""phone""\n    **Output:** 2\n    **Explanation:** There are only two items matching the given rule which are [""phone""""blue""""pixel""] and [""phone""""gold""""iphone""]. Note that the item [""computer""""silver""""phone""] does not match.\n\n\n\n**Constraints:**\n\n  * `1 <= items.length <= 104`\n  * `1 <= typei.length colori.length namei.length ruleValue.length <= 10`\n  * `ruleKey` is equal to either `""type""` `""color""` or `""name""`.\n  * All strings consist only of lowercase letters.\n\n",class Solution:\n    def countMatches(self items: List[List[str]] ruleKey: str ruleValue: str) -> int:\n        d = {'type': 0 'color': 1 'name': 2}\n        return sum(1 for item in items if item[d[ruleKey]] == ruleValue)\n
Count Largest Group,###  1399\. Count Largest Group\n\nYou are given an integer `n`.\n\nEach number from `1` to `n` is grouped according to the sum of its digits.\n\nReturn _the number of groups that have the largest size_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 13\n    **Output:** 4\n    **Explanation:** There are 9 groups in total they are grouped according sum of its digits of numbers from 1 to 13:\n    [110] [211] [312] [413] [5] [6] [7] [8] [9].\n    There are 4 groups with largest size.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 2\n    **Explanation:** There are 2 groups [1] [2] of size 1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n\n,"def compute(num):\n	if num < 10:\n		return num\n\n	newVal = 0\n\n	while num > 0:\n		last = num % 10\n		newVal += last\n		num /= 10\n\n	return newVal\n\nclass Solution(object):\n	def countLargestGroup(self n):\n		""""""\n		:type n: int\n		:rtype: int\n		""""""\n		myMap = {}\n\n		for i in range(1 n + 1):\n			val = compute(i)\n\n			if val in myMap.keys():\n				myMap.get(val).append(i)\n			else:\n				myMap[val] = [i]\n\n		maxLen = 0\n\n		for n in myMap.values():\n			maxLen = max(maxLen len(n))\n\n		ans = 0\n\n		for n in myMap.values():\n			if len(n) == maxLen:\n				ans += 1\n\n		return ans\n"
Count Lattice Points Inside a Circle,###  2249\. Count Lattice Points Inside a Circle\n\nGiven a 2D integer array `circles` where `circles[i] = [xi yi ri]`\nrepresents the center `(xi yi)` and radius `ri` of the `ith` circle drawn on\na grid return _the**number of lattice points** __that are present inside**at\nleast one** circle_.\n\n**Note:**\n\n  * A **lattice point** is a point with integer coordinates.\n  * Points that lie **on the circumference of a circle** are also considered to be inside it.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/02/exa-11.png)\n\n    \n    \n    **Input:** circles = [[221]]\n    **Output:** 5\n    **Explanation:**\n    The figure above shows the given circle.\n    The lattice points present inside the circle are (1 2) (2 1) (2 2) (2 3) and (3 2) and are shown in green.\n    Other points such as (1 1) and (1 3) which are shown in red are not considered inside the circle.\n    Hence the number of lattice points present inside at least one circle is 5.\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/02/exa-22.png)\n\n    \n    \n    **Input:** circles = [[222][341]]\n    **Output:** 16\n    **Explanation:**\n    The figure above shows the given circles.\n    There are exactly 16 lattice points which are present inside at least one circle. \n    Some of them are (0 2) (2 0) (2 4) (3 2) and (4 4).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= circles.length <= 200`\n  * `circles[i].length == 3`\n  * `1 <= xi yi <= 100`\n  * `1 <= ri <= min(xi yi)`\n\n,class Solution:\n    def countLatticePoints(self c: List[List[int]]) -> int:\n        ansm=0[0]*40401\n        c=set(((xyr) for xyr in c))\n        for x y r in c:\n            for i in range(x-r x+r+1):\n                d=int(sqrt(r*r-(x-i)*(x-i)))\n                m[i*201+y-d:i*201+y+d+1]=[1]*(d+d+1)\n        return sum(m)\n
Count Negative Numbers in a Sorted Matrix,###  1351\. Count Negative Numbers in a Sorted Matrix\n\nGiven a `m x n` matrix `grid` which is sorted in non-increasing order both\nrow-wise and column-wise return _the number of**negative** numbers in_\n`grid`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** grid = [[432-1][321-1][11-1-2][-1-1-2-3]]\n    **Output:** 8\n    **Explanation:** There are 8 negatives number in the matrix.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[32][10]]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 100`\n  * `-100 <= grid[i][j] <= 100`\n\n\n\n**Follow up:** Could you find an `O(n + m)` solution?\n\n,# Runtime: 252 ms (Top 17.18%) | Memory: 15.1 MB (Top 10.42%)\nclass Solution:\n    def countNegatives(self grid: List[List[int]]) -> int:\n        count = 0\n\n        for i in grid:\n            low = 0\n            high = len(i) - 1\n\n            while low <= high:\n                mid = (low+high)//2\n                if i[mid] < 0:\n                    high = mid - 1\n                elif i[mid] >= 0:\n                    low = mid + 1\n            count += (len(i) - low)\n        return count
Count Nice Pairs in an Array,###  1814\. Count Nice Pairs in an Array\n\nYou are given an array `nums` that consists of non-negative integers. Let us\ndefine `rev(x)` as the reverse of the non-negative integer `x`. For example\n`rev(123) = 321` and `rev(120) = 21`. A pair of indices `(i j)` is **nice**\nif it satisfies all of the following conditions:\n\n  * `0 <= i < j < nums.length`\n  * `nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])`\n\nReturn _the number of nice pairs of indices_. Since that number can be too\nlarge return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [4211197]\n    **Output:** 2\n    **Explanation:** The two pairs are:\n     - (03) : 42 + rev(97) = 42 + 79 = 121 97 + rev(42) = 97 + 24 = 121.\n     - (12) : 11 + rev(1) = 11 + 1 = 12 1 + rev(11) = 1 + 11 = 12.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1310352476]\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 109`\n\n,// Runtime: 500 ms (Top 94.22%) | Memory: 26.90 MB (Top 76.37%)\n\nclass Solution:\n    def countNicePairs(self nums: List[int]) -> int:\n        res = 0\n        count = {}\n        mod = 10**9 + 7\n        \n        for n in nums:\n            rev = int(str(n)[::-1])\n            cur = count.get(n - rev 0)\n            res += cur\n            count[n - rev] = 1 + cur\n\n        return res % mod\n
Count Nodes Equal to Average of Subtree,###  2265\. Count Nodes Equal to Average of Subtree\n\nGiven the `root` of a binary tree return _the number of nodes where the value\nof the node is equal to the**average** of the values in its **subtree**_.\n\n**Note:**\n\n  * The **average** of `n` elements is the **sum** of the `n` elements divided by `n` and **rounded down** to the nearest integer.\n  * A **subtree** of `root` is a tree consisting of `root` and all of its descendants.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png)\n\n    \n    \n    **Input:** root = [48501null6]\n    **Output:** 5\n    **Explanation:** \n    For the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.\n    For the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.\n    For the node with value 0: The average of its subtree is 0 / 1 = 0.\n    For the node with value 1: The average of its subtree is 1 / 1 = 1.\n    For the node with value 6: The average of its subtree is 6 / 1 = 6.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png)\n\n    \n    \n    **Input:** root = [1]\n    **Output:** 1\n    **Explanation:** For the node with value 1: The average of its subtree is 1 / 1 = 1.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 1000]`.\n  * `0 <= Node.val <= 1000`\n\n,class Solution:\n    def averageOfSubtree(self root: Optional[TreeNode]) -> int:\n        \n        \n        def calculate_average(root):\n            if root:\n                self.summ+=root.val\n                self.nodecount+=1\n                calculate_average(root.left)\n                calculate_average(root.right)\n        \n        \n        def calculate_for_each_node(root):\n            if root:\n                self.summ = 0\n                self.nodecount = 0\n                calculate_average(root)\n                if ((self.summ)//(self.nodecount)) == root.val:\n                    self.count+=1 \n                calculate_for_each_node(root.left)\n                calculate_for_each_node(root.right)\n                \n                \n        self.count = 0\n        calculate_for_each_node(root)       \n        return self.count\n\n
Count Nodes With the Highest Score,###  2049\. Count Nodes With the Highest Score\n\nThere is a **binary** tree rooted at `0` consisting of `n` nodes. The nodes\nare labeled from `0` to `n - 1`. You are given a **0-indexed** integer array\n`parents` representing the tree where `parents[i]` is the parent of node `i`.\nSince node `0` is the root `parents[0] == -1`.\n\nEach node has a **score**. To find the score of a node consider if the node\nand the edges connected to it were **removed**. The tree would become one or\nmore **non-empty** subtrees. The **size** of a subtree is the number of the\nnodes in it. The **score** of the node is the **product of the sizes** of all\nthose subtrees.\n\nReturn _the**number** of nodes that have the **highest score**_.\n\n\n\n**Example 1:**\n\n![example-1](https://assets.leetcode.com/uploads/2021/10/03/example-1.png)\n\n    \n    \n    **Input:** parents = [-12020]\n    **Output:** 3\n    **Explanation:**\n    - The score of node 0 is: 3 * 1 = 3\n    - The score of node 1 is: 4 = 4\n    - The score of node 2 is: 1 * 1 * 2 = 2\n    - The score of node 3 is: 4 = 4\n    - The score of node 4 is: 4 = 4\n    The highest score is 4 and three nodes (node 1 node 3 and node 4) have the highest score.\n    \n\n**Example 2:**\n\n![example-2](https://assets.leetcode.com/uploads/2021/10/03/example-2.png)\n\n    \n    \n    **Input:** parents = [-120]\n    **Output:** 2\n    **Explanation:**\n    - The score of node 0 is: 2 = 2\n    - The score of node 1 is: 2 = 2\n    - The score of node 2 is: 1 * 1 = 1\n    The highest score is 2 and two nodes (node 0 and node 1) have the highest score.\n    \n\n\n\n**Constraints:**\n\n  * `n == parents.length`\n  * `2 <= n <= 105`\n  * `parents[0] == -1`\n  * `0 <= parents[i] <= n - 1` for `i != 0`\n  * `parents` represents a valid binary tree.\n\n,class Solution:\n    def countHighestScoreNodes(self parents: List[int]) -> int:\n        graph = collections.defaultdict(list)\n        for node parent in enumerate(parents):  # build graph\n            graph[parent].append(node)\n        n = len(parents)                         # total number of nodes\n        d = collections.Counter()\n        def count_nodes(node):                   # number of children node + self\n            p s = 1 0                          # p: product s: sum\n            for child in graph[node]:            # for each child (only 2 at maximum)\n                res = count_nodes(child)         # get its nodes count\n                p *= res                         # take the product\n                s += res                         # take the sum\n            p *= max(1 n - 1 - s)               # times up-branch (number of nodes other than left right children ans itself)\n            d[p] += 1                            # count the product\n            return s + 1                         # return number of children node + 1 (self)\n        count_nodes(0)                           # starting from root (0)\n        return d[max(d.keys())]                  # return max count\n
Count Number of Bad Pairs,###  2364\. Count Number of Bad Pairs\n\nYou are given a **0-indexed** integer array `nums`. A pair of indices `(i j)`\nis a **bad pair** if `i < j` and `j - i != nums[j] - nums[i]`.\n\nReturn _the total number of**bad pairs** in _`nums`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [4133]\n    **Output:** 5\n    **Explanation:** The pair (0 1) is a bad pair since 1 - 0 != 1 - 4.\n    The pair (0 2) is a bad pair since 2 - 0 != 3 - 4 2 != -1.\n    The pair (0 3) is a bad pair since 3 - 0 != 3 - 4 3 != -1.\n    The pair (1 2) is a bad pair since 2 - 1 != 3 - 1 1 != 2.\n    The pair (2 3) is a bad pair since 3 - 2 != 3 - 3 1 != 0.\n    There are a total of 5 bad pairs so we return 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12345]\n    **Output:** 0\n    **Explanation:** There are no bad pairs.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 109`\n\n,class Solution:\n    def countBadPairs(self nums: List[int]) -> int:\n        nums_len = len(nums)\n        count_dict = dict()\n        for i in range(nums_len):\n            nums[i] -= i\n            if nums[i] not in count_dict:\n                count_dict[nums[i]] = 0\n            count_dict[nums[i]] += 1\n        \n        count = 0\n        for key in count_dict:\n            count += math.comb(count_dict[key] 2)\n        return math.comb(nums_len 2) - count\n
Count Number of Maximum Bitwise-OR Subsets,###  2044\. Count Number of Maximum Bitwise-OR Subsets\n\nGiven an integer array `nums` find the **maximum** possible **bitwise OR** of\na subset of `nums` and return _the**number of different non-empty subsets**\nwith the maximum bitwise OR_.\n\nAn array `a` is a **subset** of an array `b` if `a` can be obtained from `b`\nby deleting some (possibly zero) elements of `b`. Two subsets are considered\n**different** if the indices of the elements chosen are different.\n\nThe bitwise OR of an array `a` is equal to `a[0] **OR** a[1] **OR** ... **OR**\na[a.length - 1]` (**0-indexed**).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [31]\n    **Output:** 2\n    **Explanation:** The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n    - [3]\n    - [31]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [222]\n    **Output:** 7\n    **Explanation:** All non-empty subsets of [222] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [3215]\n    **Output:** 6\n    **Explanation:** The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n    - [35]\n    - [315]\n    - [325]\n    - [3215]\n    - [25]\n    - [215]\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 16`\n  * `1 <= nums[i] <= 105`\n\n,class Solution:\n    def countMaxOrSubsets(self nums: List[int]) -> int:\n        \n        def dfs(ival):\n            if maxBit == val : return 1<<(len(nums)-i)\n            if i == len(nums): return 0\n            return dfs(i+1val|nums[i]) + dfs(i+1val)\n        maxBit = 0\n        for i in nums: maxBit |= i\n        return dfs(00)\n
Count Number of Pairs With Absolute Difference K,###  2006\. Count Number of Pairs With Absolute Difference K\n\nGiven an integer array `nums` and an integer `k` return _the number of pairs_\n`(i j)` _where_ `i < j` _such that_ `|nums[i] - nums[j]| == k`.\n\nThe value of `|x|` is defined as:\n\n  * `x` if `x >= 0`.\n  * `-x` if `x < 0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1221] k = 1\n    **Output:** 4\n    **Explanation:** The pairs with an absolute difference of 1 are:\n    - [**_1_** **_2_** 21]\n    - [**_1_** 2**_2_** 1]\n    - [1**_2_** 2**_1_**]\n    - [12**_2_** **_1_**]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [13] k = 3\n    **Output:** 0\n    **Explanation:** There are no pairs with an absolute difference of 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [32154] k = 2\n    **Output:** 3\n    **Explanation:** The pairs with an absolute difference of 2 are:\n    - [**_3_** 2**_1_** 54]\n    - [**_3_** 21**_5_** 4]\n    - [3**_2_** 15**_4_**]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 200`\n  * `1 <= nums[i] <= 100`\n  * `1 <= k <= 99`\n\n,class Solution:\n    def countKDifference(self nums: List[int] k: int) -> int:\n        seen = defaultdict(int)\n        counter = 0\n        for num in nums:\n            tmp tmp2 = num - k num + k\n            if tmp in seen:\n                counter += seen[tmp]\n            if tmp2 in seen:\n                counter += seen[tmp2]\n            \n            seen[num] += 1\n        \n        return counter\n
Count Number of Special Subsequences,###  1955\. Count Number of Special Subsequences\n\nA sequence is **special** if it consists of a **positive** number of `0`s\nfollowed by a **positive** number of `1`s then a **positive** number of `2`s.\n\n  * For example `[012]` and `[001112]` are special.\n  * In contrast `[210]` `[1]` and `[0120]` are not special.\n\nGiven an array `nums` (consisting of **only** integers `0` `1` and `2`)\nreturn _the**number of different subsequences** that are special_. Since the\nanswer may be very large **return it modulo**`109 + 7`.\n\nA **subsequence** of an array is a sequence that can be derived from the array\nby deleting some or no elements without changing the order of the remaining\nelements. Two subsequences are **different** if the **set of indices** chosen\nare different.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [0122]\n    **Output:** 3\n    **Explanation:** The special subsequences are bolded [**_0_** **_1_** **_2_** 2] [**_0_** **_1_** 2**_2_**] and [**_0_** **_1_** **_2_** **_2_**].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2200]\n    **Output:** 0\n    **Explanation:** There are no special subsequences in [2200].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [012012]\n    **Output:** 7\n    **Explanation:** The special subsequences are bolded:\n    - [**_0_** **_1_** **_2_** 012]\n    - [**_0_** **_1_** 201**_2_**]\n    - [**_0_** **_1_** **_2_** 01**_2_**]\n    - [**_0_** **_1_** 20**_1_** **_2_**]\n    - [**_0_** 12**_0_** **_1_** **_2_**]\n    - [**_0_** 120**_1_** **_2_**]\n    - [012**_0_** **_1_** **_2_**]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 2`\n\n,# Runtime: 4322 ms (Top 46.43%) | Memory: 18 MB (Top 47.62%)\nclass Solution:\n    def countSpecialSubsequences(self nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        last_0 = 0\n        last_1 = 0\n        last_2 = 0\n\n        for i in nums:\n            if i == 0:\n                last_0 = (2*last_0 + 1)% 1000000007\n            elif i == 1:\n                last_1 = (last_0 + 2*last_1) % 1000000007\n            elif i == 2:\n                last_2 = (last_1 + 2*last_2) % 1000000007\n        return last_2 % 1000000007
Count Number of Teams,###  1395\. Count Number of Teams\n\nThere are `n` soldiers standing in a line. Each soldier is assigned a\n**unique** `rating` value.\n\nYou have to form a team of 3 soldiers amongst them under the following rules:\n\n  * Choose 3 soldiers with index (`i` `j` `k`) with rating (`rating[i]` `rating[j]` `rating[k]`).\n  * A team is valid if: (`rating[i] < rating[j] < rating[k]`) or (`rating[i] > rating[j] > rating[k]`) where (`0 <= i < j < k < n`).\n\nReturn the number of teams you can form given the conditions. (soldiers can be\npart of multiple teams).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rating = [25341]\n    **Output:** 3\n    **Explanation:** We can form three teams given the conditions. (234) (541) (531). \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rating = [213]\n    **Output:** 0\n    **Explanation:** We can't form any team given the conditions.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** rating = [1234]\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `n == rating.length`\n  * `3 <= n <= 1000`\n  * `1 <= rating[i] <= 105`\n  * All the integers in `rating` are **unique**.\n\n,class Solution:\n    def numTeams(self ratings: List[int]) -> int:\n        upper_dps = [0 for _ in range(len(ratings))]\n        lower_dps = [0 for _ in range(len(ratings))]\n        \n        count = 0\n        for i in range(len(ratings)):\n            for j in range(i):\n                if ratings[j] < ratings[i]:\n                    count += upper_dps[j]\n                    upper_dps[i] += 1\n                else:\n                    count += lower_dps[j]\n                    lower_dps[i] += 1\n                    \n        return count\n
Count Number of Texts,"###  2266\. Count Number of Texts\n\nAlice is texting Bob using her phone. The **mapping** of digits to letters is\nshown in the figure below.\n\n![](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-\nkeypad2svg.png)\n\nIn order to **add** a letter Alice has to **press** the key of the\ncorresponding digit `i` times where `i` is the position of the letter in the\nkey.\n\n  * For example to add the letter `'s'` Alice has to press `'7'` four times. Similarly to add the letter `'k'` Alice has to press `'5'` twice.\n  * Note that the digits `'0'` and `'1'` do not map to any letters so Alice **does not** use them.\n\nHowever due to an error in transmission Bob did not receive Alice's text\nmessage but received a **string of pressed keys** instead.\n\n  * For example when Alice sent the message `""bob""` Bob received the string `""2266622""`.\n\nGiven a string `pressedKeys` representing the string received by Bob return\n_the**total number of possible text messages** Alice could have sent_.\n\nSince the answer may be very large return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** pressedKeys = ""22233""\n    **Output:** 8\n    **Explanation:**\n    The possible text messages Alice could have sent are:\n    ""aaadd"" ""abdd"" ""badd"" ""cdd"" ""aaae"" ""abe"" ""bae"" and ""ce"".\n    Since there are 8 possible messages we return 8.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** pressedKeys = ""222222222222222222222222222222222222""\n    **Output:** 82876089\n    **Explanation:**\n    There are 2082876103 possible text messages Alice could have sent.\n    Since we need to return the answer modulo 109 + 7 we return 2082876103 % (109 + 7) = 82876089.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= pressedKeys.length <= 105`\n  * `pressedKeys` only consists of digits from `'2'` \- `'9'`.\n\n","# Runtime: 2740 ms (Top 30.44%) | Memory: 19.5 MB (Top 65.22%)\nclass Solution(object):\n    def countTexts(self pressedKeys):\n        """"""\n        :type pressedKeys: str\n        :rtype: int\n        """"""\n        dp = [1] + [0]*len(pressedKeys)\n        mod = 10**9 + 7\n        for i n in enumerate(pressedKeys):\n            dp[i+1] = dp[i]\n            # check if is continous\n            if i >= 1 and pressedKeys[i-1] == n:\n                dp[i+1] += dp[i-1]\n                dp[i+1] %= mod\n                if i >= 2 and pressedKeys[i-2] == n:\n                    dp[i+1] += dp[i-2]\n                    dp[i+1] %= mod\n                    # Special case for '7' and '9' that can have 4 characters combination\n                    if i >= 3 and pressedKeys[i-3] == n and (n == ""7"" or n == ""9""):\n                        dp[i+1] += dp[i-3]\n                        dp[i+1] %= mod\n        return dp[-1]"
Count Number of Ways to Place Houses,###  2320\. Count Number of Ways to Place Houses\n\nThere is a street with `n * 2` **plots**  where there are `n` plots on each\nside of the street. The plots on each side are numbered from `1` to `n`. On\neach plot a house can be placed.\n\nReturn _the number of ways houses can be placed such that no two houses are\nadjacent to each other on the same side of the street_. Since the answer may\nbe very large return it **modulo** `109 + 7`.\n\nNote that if a house is placed on the `ith` plot on one side of the street a\nhouse can also be placed on the `ith` plot on the other side of the street.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 4\n    **Explanation:** \n    Possible arrangements:\n    1. All plots are empty.\n    2. A house is placed on one side of the street.\n    3. A house is placed on the other side of the street.\n    4. Two houses are placed one on each side of the street.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/05/12/arrangements.png)\n\n    \n    \n    **Input:** n = 2\n    **Output:** 9\n    **Explanation:** The 9 possible arrangements are shown in the diagram above.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n\n,"class Solution:\n    def countHousePlacements(self n: int) -> int:\n        \n        \n        @lru_cache(None)\n        def rec(i k):\n            \n            # i is the index of the house \n            # k is the state of last house 1 if there was a house on the last index else 0\n            \n            if i>=n:\n                return 1\n            \n            elif k==0:\n                return rec(i+11) + rec(i+10)\n            \n            else:\n                return rec(i+10)\n        \n        \n        \n        #l1 are the combinations possible in lane 1 the final answer will be the square \n		#of of l1 as for every combination of l1 there will be ""l1"" combinations in lane2.\n        \n        l1 = rec(10) + rec(11)\n        \n        \n        mod = 10**9 +7\n        return pow(l1 2 mod) #use this when there is mod involved along with power \n            \n"
Count Numbers with Unique Digits,###  357\. Count Numbers with Unique Digits\n\nGiven an integer `n` return the count of all numbers with unique digits `x`\nwhere `0 <= x < 10n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 91\n    **Explanation:** The answer should be the total numbers in the range of 0 ≤ x < 100 excluding 112233445566778899\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 0\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 8`\n\n,class Solution:\n    def countNumbersWithUniqueDigits(self n: int) -> int:\n        \n        if n == 0:\n            return 1\n        \n        table = [0]*(n+1)\n        \n        table[0] = 1\n        table[1] = 9\n        \n        for i in range(2 n+1):\n            table[i] = table[i-1]*(11-i)\n        \n        return sum(table)\n
Count Odd Numbers in an Interval Range,###  1523\. Count Odd Numbers in an Interval Range\n\nGiven two non-negative integers `low` and `high`. Return the _count of odd\nnumbers between_`low` _and_` high` _ (inclusive)_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** low = 3 high = 7\n    **Output:** 3\n    **Explanation:** The odd numbers between 3 and 7 are [357].\n\n**Example 2:**\n\n    \n    \n    **Input:** low = 8 high = 10\n    **Output:** 1\n    **Explanation:** The odd numbers between 8 and 10 are [9].\n\n\n\n**Constraints:**\n\n  * `0 <= low <= high <= 10^9`\n\n,class Solution:\n    def countOdds(self low: int high: int) -> int:        \n        total_nums = high - low\n        \n        answer = total_nums // 2\n        \n        if low % 2 == 1 and high % 2 == 1:\n            return answer + 1\n        \n        if low % 2 == 1:\n            answer = answer + 1\n            \n        if high % 2 == 1:\n            answer = answer + 1\n        \n        return answer\n
Count of Range Sum,###  327\. Count of Range Sum\n\nGiven an integer array `nums` and two integers `lower` and `upper` return\n_the number of range sums that lie in_ `[lower upper]` _inclusive_.\n\nRange sum `S(i j)` is defined as the sum of the elements in `nums` between\nindices `i` and `j` inclusive where `i <= j`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [-25-1] lower = -2 upper = 2\n    **Output:** 3\n    **Explanation:** The three ranges are: [00] [22] and [02] and their respective sums are: -2 -1 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0] lower = 0 upper = 0\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-231 <= nums[i] <= 231 - 1`\n  * `-105 <= lower <= upper <= 105`\n  * The answer is **guaranteed** to fit in a **32-bit** integer.\n\n,class Solution:\n    def countRangeSum(self nums: List[int] lower: int upper: int) -> int:\n        acc = list(accumulate(nums))\n        ans = a = 0\n        for n in nums:\n            a += n\n            ans += sum(1 for x in acc if lower <= x <= upper)\n            acc.pop(0)\n            lower += n\n            upper += n\n        return ans\n
Count of Smaller Numbers After Self,###  315\. Count of Smaller Numbers After Self\n\nGiven an integer array `nums` return _an integer array_`counts`\n_where_`counts[i]`_is the number of smaller elements to the right\nof_`nums[i]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [5261]\n    **Output:** [2110]\n    **Explanation:**\n    To the right of 5 there are **2** smaller elements (2 and 1).\n    To the right of 2 there is only **1** smaller element (1).\n    To the right of 6 there is **1** smaller element (1).\n    To the right of 1 there is **0** smaller element.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-1]\n    **Output:** [0]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [-1-1]\n    **Output:** [00]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-104 <= nums[i] <= 104`\n\n,# Runtime: 6019 ms (Top 15.52%) | Memory: 35.5 MB (Top 33.31%)\nclass Solution:\n    def countSmaller(self nums: List[int]) -> List[int]:\n        # build the binary indexed tree\n        num_buckets = 10 ** 4 + 10 ** 4 + 1 # 10**4 negative + 10**4 positive numbers + bucket at 0\n        tree = [0] * (num_buckets + 1) # add 1 because binary indexed tree data starts at index 1\n\n        result = [0] * len(nums)\n\n        # iterate from right to left\n        for result_index in range(len(nums) - 1 -1 -1):\n            n = nums[result_index]\n            # add 10**4 to n to account for negative numbers\n            i = n + 10 ** 4\n\n            # convert to 1-based index for the tree\n            i += 1\n            # perform range sum query of buckets [-inf n-1] where n is current number\n            # because we want n - 1 for range sum query of [-inf n-1] not n subtract 1 from i:\n            i -= 1\n\n            val = 0\n            while i != 0:\n                val += tree[i]\n                # get parent node by subtracting least significant set bit\n                i -= i & -i\n\n            result[result_index] = val\n\n            # update the binary indexed tree with new bucket\n            i = n + 10 ** 4\n            i += 1\n            while i < len(tree):\n                tree[i] += 1\n                # get next node to update by adding the least significant set bit\n                i += i & -i\n\n        return result
Count Operations to Obtain Zero,###  2169\. Count Operations to Obtain Zero\n\nYou are given two **non-negative** integers `num1` and `num2`.\n\nIn one **operation**  if `num1 >= num2` you must subtract `num2` from\n`num1` otherwise subtract `num1` from `num2`.\n\n  * For example if `num1 = 5` and `num2 = 4` subtract `num2` from `num1` thus obtaining `num1 = 1` and `num2 = 4`. However if `num1 = 4` and `num2 = 5` after one operation `num1 = 4` and `num2 = 1`.\n\nReturn _the**number of operations** required to make either_ `num1 = 0` _or_\n`num2 = 0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num1 = 2 num2 = 3\n    **Output:** 3\n    **Explanation:** \n    - Operation 1: num1 = 2 num2 = 3. Since num1 < num2 we subtract num1 from num2 and get num1 = 2 num2 = 3 - 2 = 1.\n    - Operation 2: num1 = 2 num2 = 1. Since num1 > num2 we subtract num2 from num1.\n    - Operation 3: num1 = 1 num2 = 1. Since num1 == num2 we subtract num2 from num1.\n    Now num1 = 0 and num2 = 1. Since num1 == 0 we do not need to perform any further operations.\n    So the total number of operations required is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num1 = 10 num2 = 10\n    **Output:** 1\n    **Explanation:** \n    - Operation 1: num1 = 10 num2 = 10. Since num1 == num2 we subtract num2 from num1 and get num1 = 10 - 10 = 0.\n    Now num1 = 0 and num2 = 10. Since num1 == 0 we are done.\n    So the total number of operations required is 1.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= num1 num2 <= 105`\n\n,// Runtime: 77 ms (Top 87.66%) | Memory: 17.40 MB (Top 8.01%)\n\nclass Solution:\n    def countOperations(self num1: int num2: int) -> int:\n        count = 0\n        while num1 != 0 and num2 != 0:\n            if num1 >= num2:\n                num1 -= num2\n            else:\n                num2 -= num1\n            count +=1\n        return count\n
Count Pairs Of Nodes,###  1782\. Count Pairs Of Nodes\n\nYou are given an undirected graph defined by an integer `n` the number of\nnodes and a 2D integer array `edges` the edges in the graph where `edges[i]\n= [ui vi]` indicates that there is an **undirected** edge between `ui` and\n`vi`. You are also given an integer array `queries`.\n\nLet `incident(a b)` be defined as the **number of edges** that are connected\nto **either** node `a` or `b`.\n\nThe answer to the `jth` query is the **number of pairs** of nodes `(a b)`\nthat satisfy **both** of the following conditions:\n\n  * `a < b`\n  * `incident(a b) > queries[j]`\n\nReturn _an array_`answers` _such that_`answers.length == queries.length`\n_and_`answers[j]`_is the answer of the_`jth` _query_.\n\nNote that there can be **multiple edges** between the same two nodes.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/08/winword_2021-06-08_00-58-39.png)\n\n    \n    \n    **Input:** n = 4 edges = [[12][24][13][23][21]] queries = [23]\n    **Output:** [65]\n    **Explanation:** The calculations for incident(a b) are shown in the table above.\n    The answers for each of the queries are as follows:\n    - answers[0] = 6. All the pairs have an incident(a b) value greater than 2.\n    - answers[1] = 5. All the pairs except (3 4) have an incident(a b) value greater than 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 5 edges = [[15][15][34][25][13][51][23][25]] queries = [12345]\n    **Output:** [1010986]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 2 * 104`\n  * `1 <= edges.length <= 105`\n  * `1 <= ui vi <= n`\n  * `ui != vi`\n  * `1 <= queries.length <= 20`\n  * `0 <= queries[j] < edges.length`\n\n,class Solution:\n    def countPairs(self n: int edges: List[List[int]] queries: List[int]) -> List[int]:\n        p_c = [0] * (n+1) # point counter\n        e_c = defaultdict(int) # edge counter\n        \n        for ab in edges:\n            p_c[a] += 1\n            p_c[b] += 1\n            if a<b:\n                e_c[(ab)] += 1\n            else:\n                e_c[(ba)] += 1\n        \n        f_c = defaultdict(int) # frequency of point counter (compress the individual calculations into massive one)\n        for i in range(1 n+1):\n            f_c[p_c[i]] += 1\n\n        cnt_amt = defaultdict(int) # frequency of same cnt on pairs without edge adjustment\n        f_key = list(f_c.keys()) # frequency key\n        l_f = len(f_key)\n        for i in range(l_f):\n            f1 = f_key[i]\n            cnt_amt[f1*2] += f_c[f1] * (f_c[f1]-1) // 2 # 3 points with 4 then you get 8 \n                                                        # for a frequency of 3 * (3-2) // 2 = 3\n            for j in range(i+1 l_f):\n                f2 = f_key[j]\n                cnt_amt[f1+f2] += f_c[f1] * f_c[f2] # 2 points with 2 3 points with 4\n                                                    # will have 6 with frequency of 2 * 3 = 6\n        \n        for (uv) z in e_c.items(): # edge adjustment\n            s = p_c[u] + p_c[v]\n            t = s - z\n            cnt_amt[s] -= 1\n            cnt_amt[t] += 1\n        \n        cnt_keys = sorted(cnt_amt.keys() key=lambda x: -x) # accumulate the frequency by descending order\n        res = defaultdict(int)\n        tmp = 0\n        for key in cnt_keys:\n            if cnt_amt[key]: # if it is 0 then dont bother to keep them\n                tmp += cnt_amt[key]\n                res[key] = tmp\n\n        res_keys = sorted(res.keys()) # bisection search \n        for i q in enumerate(queries):\n            local = bisect.bisect(res_keys q)\n            try:\n                queries[i] = res[res_keys[local]]\n            except:\n                queries[i] = 0 # some test cases are annoying by requesting an unreasonable large number\n        \n        return queries\n
Count Primes,###  204\. Count Primes\n\nGiven an integer `n` return _the number of prime numbers that are strictly\nless than_ `n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 4\n    **Explanation:** There are 4 prime numbers less than 10 they are 2 3 5 7.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 0\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 5 * 106`\n\n,"class Solution:\n    def countPrimes(self n: int) -> int:\n        # Prerequisite:\n        # What is prime number. What are they just the starting. \n        \n        truth = [True]*n # making a list of lenght n. And keep all the values as True.\n        if n<2: # as 0 & 1 are not prime numbers. \n            return 0\n        truth[0] truth[1] = False False #as we added True in the truth list. So will make false for ) & 1 as they are not prime numbers.\n        \n        i=2 # As we know 0 & 1 are not prime.\n        while i*i<n: # why we are doing it as i*i here is bcz lets say 5*2 = 10 is divisble by 2 as well as 5 so if 10 is already removed why to traverse a value which is already travered once. so in case of n=5 - 5<5. CONCLUSION : i<sqrt(n)\n#why we are running the loop till n is bcz question says "" prime numbers that are strictly less than n"".\n            if truth[i] == True:\n                for j in range(i*ini): # if we have mutiple of a number in the range of n we have to remove them as they can be prime. i.e 2 is prime but its multiple in n = 10 are 468 they cant be prime. So we will make them false(means not a prime).\n                    truth[j]=False\n            i += 1 # increasing our iterator.\n        return truth.count(True) # will count true value \n        \n"
Count Servers that Communicate,###  1267\. Count Servers that Communicate\n\nYou are given a map of a server center represented as a `m * n` integer\nmatrix `grid` where 1 means that on that cell there is a server and 0 means\nthat it is no server. Two servers are said to communicate if they are on the\nsame row or on the same column.  \n  \nReturn the number of servers that communicate with any other server.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-6.jpg)\n\n    \n    \n    **Input:** grid = [[10][01]]\n    **Output:** 0\n    **Explanation:**  No servers can communicate with others.\n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2019/11/13/untitled-diagram-4.jpg)**\n\n    \n    \n    **Input:** grid = [[10][11]]\n    **Output:** 3\n    **Explanation:**  All three servers can communicate with at least one other server.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/11/14/untitled-diagram-1-3.jpg)\n\n    \n    \n    **Input:** grid = [[1100][0010][0010][0001]]\n    **Output:** 4\n    **Explanation:**  The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m <= 250`\n  * `1 <= n <= 250`\n  * `grid[i][j] == 0 or 1`\n\n,class Solution:\n    def countServers(self grid: List[List[int]]) -> int:\n        def helper(rowcolcount):\n            for c in range(len(grid[0])):\n                if c == col:\n                    continue\n                if grid[row][c] == 1:\n                    count += 1\n                    return count\n            for r in range(len(grid)):\n                if r == row:\n                    continue\n                if grid[r][col] == 1:\n                    count += 1\n                    return count\n            return count\n        count = 0\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 1:\n                    count = helper(rowcolcount)\n        return count\n
Count Sorted Vowel Strings,"###  1641\. Count Sorted Vowel Strings\n\nGiven an integer `n` return _the number of strings of length_`n` _that\nconsist only of vowels (_`a` __`e` __`i` __`o` __`u` _) and\nare**lexicographically sorted**._\n\nA string `s` is **lexicographically sorted** if for all valid `i` `s[i]` is\nthe same as or comes before `s[i+1]` in the alphabet.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 5\n    **Explanation:** The 5 sorted strings that consist of vowels only are [""a""""e""""i""""o""""u""].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 15\n    **Explanation:** The 15 sorted strings that consist of vowels only are\n    [""aa""""ae""""ai""""ao""""au""""ee""""ei""""eo""""eu""""ii""""io""""iu""""oo""""ou""""uu""].\n    Note that ""ea"" is not a valid string since 'e' comes after 'a' in the alphabet.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 33\n    **Output:** 66045\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 50` \n\n",// Runtime: 28 ms (Top 98.15%) | Memory: 13.9 MB (Top 68.10%)\nclass Solution:\n    def countVowelStrings(self n: int) -> int:\n        dp = [[0] * 6 for _ in range(n+1)]\n        for i in range(1 6):\n            dp[1][i] = i\n\n        for i in range(2 n+1):\n            dp[i][1]=1\n            for j in range(2 6):\n                dp[i][j] = dp[i][j-1] + dp[i-1][j]\n\n        return dp[n][5]
Count Square Submatrices with All Ones,###  1277\. Count Square Submatrices with All Ones\n\nGiven a `m * n` matrix of ones and zeros return how many **square**\nsubmatrices have all ones.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** matrix =\n    [\n      [0111]\n      [1111]\n      [0111]\n    ]\n    **Output:** 15\n    **Explanation:** \n    There are **10** squares of side 1.\n    There are **4** squares of side 2.\n    There is  **1** square of side 3.\n    Total number of squares = 10 + 4 + 1 = **15**.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matrix = \n    [\n      [101]\n      [110]\n      [110]\n    ]\n    **Output:** 7\n    **Explanation:** \n    There are **6** squares of side 1.  \n    There is **1** square of side 2. \n    Total number of squares = 6 + 1 = **7**.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 300`\n  * `1 <= arr[0].length <= 300`\n  * `0 <= arr[i][j] <= 1`\n\n,# Runtime: 1687 ms (Top 8.20%) | Memory: 16.3 MB (Top 73.07%)\nclass Solution:\n    def countSquares(self matrix: List[List[int]]) -> int:\n\n        m = len(matrix)\n        n = len(matrix[0])\n\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        total = 0\n\n        for i in range(m):\n            for j in range(n):\n\n                if i == 0:\n                    dp[i][j] = matrix[0][j]\n\n                elif j == 0:\n                    dp[i][j] = matrix[i][0]\n\n                else:\n                    if matrix[i][j] == 1:\n                        dp[i][j] = 1 + min(dp[i][j-1] dp[i-1][j-1] dp[i-1][j])\n\n                total += dp[i][j]\n\n        return total
Count Square Sum Triples,###  1925\. Count Square Sum Triples\n\nA **square triple** `(abc)` is a triple where `a` `b` and `c` are\n**integers** and `a2 + b2 = c2`.\n\nGiven an integer `n` return _the number of**square triples** such that _`1 <=\na b c <= n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** 2\n    **Explanation** : The square triples are (345) and (435).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 4\n    **Explanation** : The square triples are (345) (435) (6810) and (8610).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 250`\n\n,class Solution:\n    def countTriples(self n: int) -> int:\n        c = 0\n        for i in range(1 n+1):\n            for j in range(i+1 n+1):\n                sq = i*i + j*j\n                r = int(sq ** 0.5)\n                if ( r*r == sq and r <= n ):\n                    c +=2\n        return c\n
Count Submatrices With All Ones,###  1504\. Count Submatrices With All Ones\n\nGiven an `m x n` binary matrix `mat` _return the number of**submatrices**\nthat have all ones_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/10/27/ones1-grid.jpg)\n\n    \n    \n    **Input:** mat = [[101][110][110]]\n    **Output:** 13\n    **Explanation:** \n    There are 6 rectangles of side 1x1.\n    There are 2 rectangles of side 1x2.\n    There are 3 rectangles of side 2x1.\n    There is 1 rectangle of side 2x2. \n    There is 1 rectangle of side 3x1.\n    Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/10/27/ones2-grid.jpg)\n\n    \n    \n    **Input:** mat = [[0110][0111][1110]]\n    **Output:** 24\n    **Explanation:** \n    There are 8 rectangles of side 1x1.\n    There are 5 rectangles of side 1x2.\n    There are 2 rectangles of side 1x3. \n    There are 4 rectangles of side 2x1.\n    There are 2 rectangles of side 2x2. \n    There are 2 rectangles of side 3x1. \n    There is 1 rectangle of side 3x2. \n    Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m n <= 150`\n  * `mat[i][j]` is either `0` or `1`.\n\n,class Solution:\n    def numSubmat(self mat: List[List[int]]) -> int:\n        from dataclasses import dataclass\n        @dataclass\n        class Cell:\n            left: int = 0\n            top: int = 0\n            \n        n = len(mat)\n        m = len(mat[0])  \n        dp = [[Cell() for _ in range(m + 1)] for _ in range(n + 1)]\n        \n        ans = 0\n        for i in range(1 n + 1):\n            for j in range(1 m + 1):\n                if mat[i - 1][j - 1]: \n                    dp[i][j].top = 1 + dp[i - 1][j].top\n                    dp[i][j].left = 1 + dp[i][j - 1].left\n                    \n                    min_height = dp[i][j].top\n                    for k in range(dp[i][j].left):\n                        min_height = min(min_height dp[i][j-k].top)\n                        ans += min_height \n        return ans\n
Count Substrings That Differ by One Character,"###  1638\. Count Substrings That Differ by One Character\n\nGiven two strings `s` and `t` find the number of ways you can choose a non-\nempty substring of `s` and replace a **single character** by a different\ncharacter such that the resulting substring is a substring of `t`. In other\nwords find the number of substrings in `s` that differ from some substring in\n`t` by **exactly** one character.\n\nFor example the underlined substrings in `""_compute_ r""` and `""_computa_\ntion""` only differ by the `'e'`/`'a'` so this is a valid way.\n\nReturn _the number of substrings that satisfy the condition above._\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aba"" t = ""baba""\n    **Output:** 6\n    **Explanation:** The following are the pairs of substrings from s and t that differ by exactly 1 character:\n    (""_a_ ba"" ""_b_ aba"")\n    (""_a_ ba"" ""ba _b_ a"")\n    (""ab _a_ "" ""_b_ aba"")\n    (""ab _a_ "" ""ba _b_ a"")\n    (""a _b_ a"" ""b _a_ ba"")\n    (""a _b_ a"" ""bab _a_ "")\n    The underlined portions are the substrings that are chosen from s and t.\n    \n\n​​**Example 2:**\n\n    \n    \n    **Input:** s = ""ab"" t = ""bb""\n    **Output:** 3\n    **Explanation:** The following are the pairs of substrings from s and t that differ by 1 character:\n    (""_a_ b"" ""_b_ b"")\n    (""_a_ b"" ""b _b_ "")\n    (""_ab_ "" ""_bb_ "")\n    ​​​​The underlined portions are the substrings that are chosen from s and t.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length t.length <= 100`\n  * `s` and `t` consist of lowercase English letters only.\n\n",class Solution:\n    def countSubstrings(self s: str t: str) -> int:\n        res = 0\n        for i in range(len(s)):\n            for j in range(len(t)):\n                miss pos = 0 0\n                while i + pos < len(s) and j + pos < len(t) and miss < 2:\n                    miss += s[i + pos] != t[j + pos]\n                    res += miss == 1\n                    pos += 1\n        return res\n
Count Subtrees With Max Distance Between Cities,###  1617\. Count Subtrees With Max Distance Between Cities\n\nThere are `n` cities numbered from `1` to `n`. You are given an array `edges`\nof size `n-1` where `edges[i] = [ui vi]` represents a bidirectional edge\nbetween cities `ui` and `vi`. There exists a unique path between each pair of\ncities. In other words the cities form a **tree**.\n\nA **subtree** is a subset of cities where every city is reachable from every\nother city in the subset where the path between each pair passes through only\nthe cities from the subset. Two subtrees are different if there is a city in\none subtree that is not present in the other.\n\nFor each `d` from `1` to `n-1` find the number of subtrees in which the\n**maximum distance** between any two cities in the subtree is equal to `d`.\n\nReturn _an array of size_ `n-1` _where the_`dth` ___element**(1-indexed)** is\nthe number of subtrees in which the **maximum distance** between any two\ncities is equal to _`d`.\n\n**Notice**  that the **distance** between the two cities is the number of\nedges in the path between them.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/09/21/p1.png)**\n\n    \n    \n    **Input:** n = 4 edges = [[12][23][24]]\n    **Output:** [340]\n    **Explanation:** The subtrees with subsets {12} {23} and {24} have a max distance of 1.\n    The subtrees with subsets {123} {124} {234} and {1234} have a max distance of 2.\n    No subtree has two nodes where the max distance between them is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 edges = [[12]]\n    **Output:** [1]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3 edges = [[12][23]]\n    **Output:** [21]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 15`\n  * `edges.length == n-1`\n  * `edges[i].length == 2`\n  * `1 <= ui vi <= n`\n  * All pairs `(ui vi)` are distinct.\n\n,# Runtime: 2577 ms (Top 35.48%) | Memory: 14.1 MB (Top 20.97%)\nfrom collections import defaultdict\nclass Solution:\n    def countSubgraphsForEachDiameter(self n: int edges: List[List[int]]) -> List[int]:\n        def floydwarshall(n edges):\n            D = [[float('inf')]*n for _ in range(n)]\n            for u v in edges:\n                D[u-1][v-1] = 1\n                D[v-1][u-1] = 1\n            for v in range(n):\n                D[v][v] = 0\n            for k in range(n):\n                for i in range(n):\n                    for j in range(n):\n                        D[i][j] = min(D[i][j]D[i][k]+D[k][j])\n            return D\n\n        G = defaultdict(list)\n        for v w in edges:\n            G[v-1].append(w-1)\n            G[w-1].append(v-1)\n\n        def dfs(G v V visited):\n            if v in visited: return\n            visited.add(v)\n            for w in G[v]:\n                if w in V:\n                    dfs(G w V visited)\n\n        def check_connected(G V):\n            if not V: return False\n            root = next(iter(V))\n            visited = set()\n            dfs(G root V visited)\n            return visited == V\n\n        def max_distance(D V):\n            res = 0\n            for v in V:\n                for w in V:\n                    res = max(res D[v][w])\n            return res\n\n        def solve(include idx ans G D):\n            if idx == n:\n                V = set(v for v in range(n) if include[v])\n                if check_connected(G V):\n                    d = max_distance(D V)\n                    if d >= 1:\n                        ans[d-1] += 1\n            else:\n                solve(include idx+1 ans G D)\n                include[idx] = True\n                solve(include idx+1 ans G D)\n                include[idx] = False\n\n        D = floydwarshall(n edges)\n        include = [False] * n\n        ans = [0]*(n-1)\n        solve(include 0 ans G D)\n        return ans\n
Count Triplets That Can Form Two Arrays of Equal XOR,###  1442\. Count Triplets That Can Form Two Arrays of Equal XOR\n\nGiven an array of integers `arr`.\n\nWe want to select three indices `i` `j` and `k` where `(0 <= i < j <= k <\narr.length)`.\n\nLet's define `a` and `b` as follows:\n\n  * `a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]`\n  * `b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]`\n\nNote that **^** denotes the **bitwise-xor** operation.\n\nReturn _the number of triplets_ (`i` `j` and `k`) Where `a == b`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [23167]\n    **Output:** 4\n    **Explanation:** The triplets are (012) (022) (234) and (244)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [11111]\n    **Output:** 10\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 300`\n  * `1 <= arr[i] <= 108`\n\n,class Solution:\n    def countTriplets(self arr: List[int]) -> int:\n        s = [0]\n        n = len(arr)\n        if n <= 1:\n            return 0 \n        for i in range(n):\n            s.append(s[-1]^arr[i])\n        # a = s[i] ^ s[j] b = s[j] ^ s[k+1]  \n        count = defaultdict(int)\n        # a = b <-> a ^ b == 0 <-> (s[i] ^ s[j]) ^ (s[j] ^ s[k+1]) == 0 \n        # <-> s[i] ^ (s[j] ^ m ) = 0 (where m = s[j] ^ s[k+1])\n        # <-> s[i] ^ s[k+1] == 0 <-> s[i] == s[k+1]\n      \n        res = 0 \n        # len(s) == n+1 0<=i<=n-2 1<=k<=n-1 i+1<=j<=k\n        for i in range(n-1):\n            for k in range(i+1 n):\n                if s[i] == s[k+1]:\n                    res += (k-i)\n        return res \n
Count Unguarded Cells in the Grid,###  2257\. Count Unguarded Cells in the Grid\n\nYou are given two integers `m` and `n` representing a **0-indexed** `m x n`\ngrid. You are also given two 2D integer arrays `guards` and `walls` where\n`guards[i] = [rowi coli]` and `walls[j] = [rowj colj]` represent the\npositions of the `ith` guard and `jth` wall respectively.\n\nA guard can see **every** cell in the four cardinal directions (north east\nsouth or west) starting from their position unless **obstructed** by a wall\nor another guard. A cell is **guarded** if there is **at least** one guard\nthat can see it.\n\nReturn _the number of unoccupied cells that are**not** **guarded**._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png)\n\n    \n    \n    **Input:** m = 4 n = 6 guards = [[00][11][23]] walls = [[01][22][14]]\n    **Output:** 7\n    **Explanation:** The guarded and unguarded cells are shown in red and green respectively in the above diagram.\n    There are a total of 7 unguarded cells so we return 7.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png)\n\n    \n    \n    **Input:** m = 3 n = 3 guards = [[11]] walls = [[01][10][21][12]]\n    **Output:** 4\n    **Explanation:** The unguarded cells are shown in green in the above diagram.\n    There are a total of 4 unguarded cells so we return 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m n <= 105`\n  * `2 <= m * n <= 105`\n  * `1 <= guards.length walls.length <= 5 * 104`\n  * `2 <= guards.length + walls.length <= m * n`\n  * `guards[i].length == walls[j].length == 2`\n  * `0 <= rowi rowj < m`\n  * `0 <= coli colj < n`\n  * All the positions in `guards` and `walls` are **unique**.\n\n,class Solution:\n    def countUnguarded(self m: int n: int guards: List[List[int]] walls: List[List[int]]) -> int:\n        dp = [[0] * n for _ in range(m)]\n        for x y in guards+walls:\n            dp[x][y] = 1\n               \n        directions = [(0 1) (1 0) (-1 0) (0 -1)]\n        \n        for x y in guards:\n            for dx dy in directions:\n                curr_x = x\n                curr_y = y\n                \n                while 0 <= curr_x+dx < m and 0 <= curr_y+dy < n and dp[curr_x+dx][curr_y+dy] != 1:\n                    curr_x += dx\n                    curr_y += dy\n                    dp[curr_x][curr_y] = 2\n                    \n        return sum(1 for i in range(m) for j in range(n) if dp[i][j] == 0)                    \n
Count Unhappy Friends,###  1583\. Count Unhappy Friends\n\nYou are given a list of `preferences` for `n` friends where `n` is always\n**even**.\n\nFor each person `i` `preferences[i]` contains a list of friends **sorted** in\nthe **order of preference**. In other words a friend earlier in the list is\nmore preferred than a friend later in the list. Friends in each list are\ndenoted by integers from `0` to `n-1`.\n\nAll the friends are divided into pairs. The pairings are given in a list\n`pairs` where `pairs[i] = [xi yi]` denotes `xi` is paired with `yi` and `yi`\nis paired with `xi`.\n\nHowever this pairing may cause some of the friends to be unhappy. A friend\n`x` is unhappy if `x` is paired with `y` and there exists a friend `u` who is\npaired with `v` but:\n\n  * `x` prefers `u` over `y` and\n  * `u` prefers `x` over `v`.\n\nReturn _the number of unhappy friends_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4 preferences = [[1 2 3] [3 2 0] [3 1 0] [1 2 0]] pairs = [[0 1] [2 3]]\n    **Output:** 2\n    **Explanation:**\n    Friend 1 is unhappy because:\n    - 1 is paired with 0 but prefers 3 over 0 and\n    - 3 prefers 1 over 2.\n    Friend 3 is unhappy because:\n    - 3 is paired with 2 but prefers 1 over 2 and\n    - 1 prefers 3 over 0.\n    Friends 0 and 2 are happy.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 preferences = [[1] [0]] pairs = [[1 0]]\n    **Output:** 0\n    **Explanation:** Both friends 0 and 1 are happy.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 4 preferences = [[1 3 2] [2 3 0] [1 3 0] [0 2 1]] pairs = [[1 3] [0 2]]\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 500`\n  * `n` is even.\n  * `preferences.length == n`\n  * `preferences[i].length == n - 1`\n  * `0 <= preferences[i][j] <= n - 1`\n  * `preferences[i]` does not contain `i`.\n  * All values in `preferences[i]` are unique.\n  * `pairs.length == n/2`\n  * `pairs[i].length == 2`\n  * `xi != yi`\n  * `0 <= xi yi <= n - 1`\n  * Each person is contained in **exactly one** pair.\n\n,class Solution:\n    def unhappyFriends(self n: int preferences: List[List[int]] pairs: List[List[int]]) -> int:\n        dd = {}\n        \n        for ix in pairs:\n            dd[i] = preferences[i][:preferences[i].index(x)]\n            dd[x] = preferences[x][:preferences[x].index(i)]\n        \n        ans = 0\n            \n        for i in dd:\n            for x in dd[i]:\n                if i in dd[x]:\n                    ans += 1\n                    break\n        \n        return ans\n
Count Unique Characters of All Substrings of a Given String,"###  828\. Count Unique Characters of All Substrings of a Given String\n\nLet's define a function `countUniqueChars(s)` that returns the number of\nunique characters on `s`.\n\n  * For example calling `countUniqueChars(s)` if `s = ""LEETCODE""` then `""L""` `""T""` `""C""` `""O""` `""D""` are the unique characters since they appear only once in `s` therefore `countUniqueChars(s) = 5`.\n\nGiven a string `s` return the sum of `countUniqueChars(t)` where `t` is a\nsubstring of `s`. The test cases are generated such that the answer fits in a\n32-bit integer.\n\nNotice that some substrings can be repeated so in this case you have to count\nthe repeated ones too.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ABC""\n    **Output:** 10\n    **Explanation:** All possible substrings are: ""A""""B""""C""""AB""""BC"" and ""ABC"".\n    Every substring is composed with only unique letters.\n    Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""ABA""\n    **Output:** 8\n    **Explanation:** The same as example 1 except countUniqueChars(""ABA"") = 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""LEETCODE""\n    **Output:** 92\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of uppercase English letters only.\n\n","class Solution:\n    def uniqueLetterString(self s: str) -> int:\n        ans = 0\n        idx_recorder = collections.defaultdict(list)\n        n = len(s)\n        \n        # record the index for every character\n        # s = ""ABCA""\n        # {\n        #     ""A"": [0 3]\n        #     ""B"": [1]\n        #     ""C"": [2]\n        # }\n        for idx in range(len(s)):\n            c = s[idx]\n            idx_recorder[c].append(idx)\n        \n        \n        def helper(idxes):\n            ans = 0\n\n            for i in range(len(idxes)):\n                # Count the number of substring which contain the character without duplicating\n                # get the left right value to compute the result.\n                # \n                # Take the middle A (idx=3) as example\n                # s = 'AxxAxxxAxx'\n                #         -\n                # left = 3 - 0 = 3 \n                # right = 7 - 3 = 4\n                #\n                # The number of substring which contain this A (idx=3) without containing\n                # other A is 3 * 4 = 12\n                \n                if i == 0:\n                    # If it is a first one: it means that there is\n                    # no duplicate character in left\n                    left = idxes[i] + 1\n                else:\n                    left = idxes[i] - idxes[i-1]\n                \n                if i == len(idxes) - 1:\n                    # If it is a last one: it means that there is\n                    # no duplicate character in right side\n                    right = n - idxes[i]\n                else:\n                    right = idxes[i+1] - idxes[i]\n                \n                ans += left * right\n                \n            return ans\n        \n        ans = 0\n        for c in idx_recorder:\n            ans += helper(idx_recorder[c])\n        return ans\n"
Count Unreachable Pairs of Nodes in an Undirected Graph,###  2316\. Count Unreachable Pairs of Nodes in an Undirected Graph\n\nYou are given an integer `n`. There is an **undirected** graph with `n` nodes\nnumbered from `0` to `n - 1`. You are given a 2D integer array `edges` where\n`edges[i] = [ai bi]` denotes that there exists an **undirected** edge\nconnecting nodes `ai` and `bi`.\n\nReturn _the**number of pairs** of different nodes that are **unreachable**\nfrom each other_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/05/05/tc-3.png)\n\n    \n    \n    **Input:** n = 3 edges = [[01][02][12]]\n    **Output:** 0\n    **Explanation:** There are no pairs of nodes that are unreachable from each other. Therefore we return 0.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/05/05/tc-2.png)\n\n    \n    \n    **Input:** n = 7 edges = [[02][05][24][16][54]]\n    **Output:** 14\n    **Explanation:** There are 14 pairs of nodes that are unreachable from each other:\n    [[01][03][06][12][13][14][15][23][26][34][35][36][46][56]].\n    Therefore we return 14.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `0 <= edges.length <= 2 * 105`\n  * `edges[i].length == 2`\n  * `0 <= ai bi < n`\n  * `ai != bi`\n  * There are no repeated edges.\n\n,# Runtime: 2311 ms (Top 90.13%) | Memory: 73.8 MB (Top 86.18%)\n'''\n* Make groups of nodes which are connected\n    eg. edges = [[02][05][24][16][54]]\n\n    0 ---- 2 1 --- 6 3\n    | |\n    | |\n    5 ---- 4\n\n    groups will be {0: 4 1: 2 3: 1}\n    i.e 4 nodes are present in group0 2 nodes are present in group1 and 1 node is present in group3\n\n* Now we have [4 2 1] as no of nodes in each group we have to multiply each of no. with remaining\n    ans = (4 * 2 + 4 * 1) + (2 * 1)\n    but calculating ans this way will give TLE.\n\n* if we notice (4 * 2 + 4 * 1) + (2 * 1) we can combine equation like this\n    4 * 2 + (4 + 2) * 1 using this we can reduce complexity.\n    so if we have count of groups array as [a b c d] ans will be\n    ans = a * b + (a + b) * c + (a + b + c) * d\n\n* will use union for generating groups.\n* ps you can modify UnionFind class as per your need. Have implemented full union-find for beginners.\n'''\n\nclass UnionFind:\n    def __init__(self size):\n        self.root = [i for i in range(size)]\n        self.rank = [1] * size\n    def find(self x):\n        if x == self.root[x]:\n            return x\n        self.root[x] = self.find(self.root[x])\n        return self.root[x]\n    def union(self x y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            if self.rank[rootX] > self.rank[rootY]:\n                self.root[rootY] = rootX\n            elif self.rank[rootX] < self.rank[rootY]:\n                self.root[rootX] = rootY\n            else:\n                self.root[rootY] = rootX\n                self.rank[rootX] += 1\n\nclass Solution:\n    def countPairs(self n: int edges: List[List[int]]) -> int:\n        dsu = UnionFind(n)\n        for u v in edges:\n            dsu.union(u v)\n        C = Counter([dsu.find(i) for i in range(n)])\n        groupCounts = list(C.values())\n        ans = 0\n        firstGroupCount = groupCounts[0]\n        for i in range(1 len(groupCounts)):\n            ans += firstGroupCount * groupCounts[i]\n            firstGroupCount += groupCounts[i]\n        return ans
Count Vowel Substrings of a String,"###  2062\. Count Vowel Substrings of a String\n\nA **substring** is a contiguous (non-empty) sequence of characters within a\nstring.\n\nA **vowel substring** is a substring that **only** consists of vowels (`'a'`\n`'e'` `'i'` `'o'` and `'u'`) and has **all five** vowels present in it.\n\nGiven a string `word` return _the number of**vowel substrings** in_ `word`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word = ""aeiouu""\n    **Output:** 2\n    **Explanation:** The vowel substrings of word are as follows (underlined):\n    - ""**_aeiou_** u""\n    - ""**_aeiouu_** ""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word = ""unicornarihan""\n    **Output:** 0\n    **Explanation:** Not all 5 vowels are present so there are no vowel substrings.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** word = ""cuaieuouac""\n    **Output:** 7\n    **Explanation:** The vowel substrings of word are as follows (underlined):\n    - ""c** _uaieuo_** uac""\n    - ""c** _uaieuou_** ac""\n    - ""c** _uaieuoua_** c""\n    - ""cu** _aieuo_** uac""\n    - ""cu** _aieuou_** ac""\n    - ""cu** _aieuoua_** c""\n    - ""cua** _ieuoua_** c""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word.length <= 100`\n  * `word` consists of lowercase English letters only.\n\n",class Solution:\n    def countVowelSubstrings(self word: str) -> int:\n        vowels = {'a''e''i''o''u'}\n        pointer = 0\n        res = 0\n        if len(word) <= 4:\n            return 0\n        while pointer != len(word)-4:\n            # if set(list(word[pointer:pointer+5])) == vowels:\n            #     temp = 1\n            #     res += 1\n            #     while set(list(word[pointer:pointer+temp+5])) == vowels and pointer+temp+4 != len(word):\n            #         res += 1\n            #         temp += 1\n            # elif word[pointer] in vowels:\n            #     temp = 1\n            #     while set(list(word[pointer:pointer+5+temp])) != vowels:\n            #         temp += 1\n            #     res += 1\n            # pointer += 1\n            temp = 0\n            if word[pointer] in vowels:\n                while temp+pointer != len(word)-4:\n                    test_1 = set(list(word[pointer:pointer+temp+5]))\n                    test_2 = word[pointer:pointer+temp+5]\n                    if set(list(word[pointer:pointer+temp+5])).issubset(vowels): \n                        if set(list(word[pointer:pointer+temp+5])) == vowels:\n                            res += 1\n                        temp+=1\n                    else:\n                        break\n                    \n            pointer += 1\n        return res\n\n            
Count Vowels Permutation,"###  1220\. Count Vowels Permutation\n\nGiven an integer `n` your task is to count how many strings of length `n` can\nbe formed under the following rules:\n\n  * Each character is a lower case vowel (`'a'` `'e'` `'i'` `'o'` `'u'`)\n  * Each vowel `'a'` may only be followed by an `'e'`.\n  * Each vowel `'e'` may only be followed by an `'a'` or an `'i'`.\n  * Each vowel `'i'` **may not** be followed by another `'i'`.\n  * Each vowel `'o'` may only be followed by an `'i'` or a `'u'`.\n  * Each vowel `'u'` may only be followed by an `'a'.`\n\nSince the answer may be too large return it modulo `10^9 + 7.`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 5\n    **Explanation:** All possible strings are: ""a"" ""e"" ""i""  ""o"" and ""u"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 10\n    **Explanation:** All possible strings are: ""ae"" ""ea"" ""ei"" ""ia"" ""ie"" ""io"" ""iu"" ""oi"" ""ou"" and ""ua"".\n    \n\n**Example 3:  **\n\n    \n    \n    **Input:** n = 5\n    **Output:** 68\n\n\n\n**Constraints:**\n\n  * `1 <= n <= 2 * 10^4`\n\n",# Runtime: 249 ms (Top 78.97%) | Memory: 19.8 MB (Top 29.73%)\nclass Solution:\n    def countVowelPermutation(self n: int) -> int:\n        # dp[i][j] means the number of strings of length i that ends with the j-th vowel.\n        dp = [[1] * 5] + [[0] * (5) for _ in range(n - 1)]\n        moduler = math.pow(10 9) + 7\n        for i in range(1 n):\n            # For vowel a\n            dp[i][0] = (dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][4]) % moduler\n            # For vowel e\n            dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % moduler\n            # For vowel i\n            dp[i][2] = (dp[i - 1][1] + dp[i - 1][3]) % moduler\n            # For vowel o\n            dp[i][3] = (dp[i - 1][2]) % moduler\n            # For vowel u\n            dp[i][4] = (dp[i - 1][2] + dp[i - 1][3]) % moduler\n\n        return int(sum(dp[-1]) % moduler)
Count Words Obtained After Adding a Letter,"###  2135\. Count Words Obtained After Adding a Letter\n\nYou are given two **0-indexed** arrays of strings `startWords` and\n`targetWords`. Each string consists of **lowercase English letters** only.\n\nFor each string in `targetWords` check if it is possible to choose a string\nfrom `startWords` and perform a **conversion operation** on it to be equal to\nthat from `targetWords`.\n\nThe **conversion operation** is described in the following two steps:\n\n  1. **Append** any lowercase letter that is **not present** in the string to its end. \n     * For example if the string is `""abc""` the letters `'d'` `'e'` or `'y'` can be added to it but not `'a'`. If `'d'` is added the resulting string will be `""abcd""`.\n  2. **Rearrange** the letters of the new string in **any** arbitrary order. \n     * For example `""abcd""` can be rearranged to `""acbd""` `""bacd""` `""cbda""` and so on. Note that it can also be rearranged to `""abcd""` itself.\n\nReturn _the**number of strings** in _`targetWords` _that can be obtained by\nperforming the operations on**any** string of _`startWords`.\n\n**Note** that you will only be verifying if the string in `targetWords` can be\nobtained from a string in `startWords` by performing the operations. The\nstrings in `startWords` **do not** actually change during this process.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** startWords = [""ant""""act""""tack""] targetWords = [""tack""""act""""acti""]\n    **Output:** 2\n    **Explanation:**\n    - In order to form targetWords[0] = ""tack"" we use startWords[1] = ""act"" append 'k' to it and rearrange ""actk"" to ""tack"".\n    - There is no string in startWords that can be used to obtain targetWords[1] = ""act"".\n      Note that ""act"" does exist in startWords but we **must** append one letter to the string before rearranging it.\n    - In order to form targetWords[2] = ""acti"" we use startWords[1] = ""act"" append 'i' to it and rearrange ""acti"" to ""acti"" itself.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** startWords = [""ab""""a""] targetWords = [""abc""""abcd""]\n    **Output:** 1\n    **Explanation:**\n    - In order to form targetWords[0] = ""abc"" we use startWords[0] = ""ab"" add 'c' to it and rearrange it to ""abc"".\n    - There is no string in startWords that can be used to obtain targetWords[1] = ""abcd"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= startWords.length targetWords.length <= 5 * 104`\n  * `1 <= startWords[i].length targetWords[j].length <= 26`\n  * Each string of `startWords` and `targetWords` consists of lowercase English letters only.\n  * No letter occurs more than once in any string of `startWords` or `targetWords`.\n\n","# Brute Force\n# O(S * T); S := len(startWors); T := len(targetWords)\n# TLE\nclass Solution:\n    def wordCount(self startWords: List[str] targetWords: List[str]) -> int:\n        cnt = 0\n        for target in targetWords:\n            for start in startWords:\n                if len(target) - len(start) == 1 and len(set(list(target)) - set(list(start))) == 1:\n                    cnt += 1\n                    break\n        return cnt\n\n# Sort + HashSet Lookup\n# O(S + T) Time\nclass Solution:\n    def wordCount(self startWords: List[str] targetWords: List[str]) -> int:\n        # Sort each start word and add it to a hash set\n        startWords_sorted = set()\n        # O(S*26*log(26))\n        for word in startWords:\n            startWords_sorted.add("""".join(sorted(list(word))))\n        \n        # sort each target word and add it to a list\n        # O(T*26*log(26))\n        targetWords_sorted = []\n        for word in targetWords:\n            targetWords_sorted.append(sorted(list(word)))\n        \n        # for each sorted target word we remove a single character and \n        # check if the resulting word is in the startWords_sorted\n        # if it is we increment cnt and break the inner loop\n        # otherwise we keep removing until we either find a hit or reach the\n        # end of the string\n        # O(T*26) = O(T)\n        cnt = 0\n        for target in targetWords_sorted:\n            for i in range(len(target)):\n                w = target[:i] + target[i+1:]\n                w = """".join(w)\n                if w in startWords_sorted:\n                    cnt += 1\n                    break\n        \n        return cnt\n\n# Using Bit Mask\n# O(S + T) Time\n# Similar algorithm as the one above implemented using a bit mask to avoid the sorts\nclass Solution:\n    def wordCount(self startWords: List[str] targetWords: List[str]) -> int:\n        start_set = set()\n        # O(S * 26)\n        for word in startWords:\n            m = 0\n            for ch in word:\n                i = ord(ch) - ord('a')\n                m |= (1 << i)\n            start_set.add(m)\n        \n        # O(T * 2 * 26)\n        cnt = 0\n        for word in targetWords:\n            m = 0\n            for ch in word:\n                i = ord(ch) - ord('a')\n                m |= (1 << i)\n            \n            for ch in word:\n                i = ord(ch) - ord('a')\n                if m ^ (1 << i) in start_set:\n                    cnt += 1\n                    break\n        return cnt\n"
Counting Words With a Given Prefix,"###  2185\. Counting Words With a Given Prefix\n\nYou are given an array of strings `words` and a string `pref`.\n\nReturn _the number of strings in_`words` _that contain_`pref` _as\na**prefix**_.\n\nA **prefix** of a string `s` is any leading contiguous substring of `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""pay""""**_at_** tention""""practice""""_**at**_ tend""] pref = ""at""\n    **Output:** 2\n    **Explanation:** The 2 strings that contain ""at"" as a prefix are: ""_**at**_ tention"" and ""_**at**_ tend"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""leetcode""""win""""loops""""success""] pref = ""code""\n    **Output:** 0\n    **Explanation:** There are no strings that contain ""code"" as a prefix.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 100`\n  * `1 <= words[i].length pref.length <= 100`\n  * `words[i]` and `pref` consist of lowercase English letters.\n\n",class Solution:\n    def prefixCount(self words: List[str] pref: str) -> int:\n        return sum(word.find(pref) == 0 for word in words)\n
Couples Holding Hands,###  765\. Couples Holding Hands\n\nThere are `n` couples sitting in `2n` seats arranged in a row and want to hold\nhands.\n\nThe people and seats are represented by an integer array `row` where `row[i]`\nis the ID of the person sitting in the `ith` seat. The couples are numbered in\norder the first couple being `(0 1)` the second couple being `(2 3)` and\nso on with the last couple being `(2n - 2 2n - 1)`.\n\nReturn _the minimum number of swaps so that every couple is sitting side by\nside_. A swap consists of choosing any two people then they stand up and\nswitch seats.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** row = [0213]\n    **Output:** 1\n    **Explanation:** We only need to swap the second (row[1]) and third (row[2]) person.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** row = [3201]\n    **Output:** 0\n    **Explanation:** All couples are already seated side by side.\n    \n\n\n\n**Constraints:**\n\n  * `2n == row.length`\n  * `2 <= n <= 30`\n  * `n` is even.\n  * `0 <= row[i] < 2n`\n  * All the elements of `row` are **unique**.\n\n,// Runtime: 35 ms (Top 84.03%) | Memory: 17.30 MB (Top 39.5%)\n\nclass Solution:\n    def minSwapsCouples(self row: List[int]) -> int:\n        loc = {x: i for i x in enumerate(row)}\n        ans = 0\n        for i in range(0 len(row) 2): \n            p = row[i] - 1 if row[i]&1 else row[i]+1\n            if row[i+1] != p: \n                ans += 1\n                ii = loc[p]\n                loc[row[i+1]] loc[row[ii]] = loc[row[ii]] loc[row[i+1]] # swap mappings\n                row[i+1] row[ii] = row[ii] row[i+1] # swap values \n        return ans \n
Course Schedule,###  207\. Course Schedule\n\nThere are a total of `numCourses` courses you have to take labeled from `0`\nto `numCourses - 1`. You are given an array `prerequisites` where\n`prerequisites[i] = [ai bi]` indicates that you **must** take course `bi`\nfirst if you want to take course `ai`.\n\n  * For example the pair `[0 1]` indicates that to take course `0` you have to first take course `1`.\n\nReturn `true` if you can finish all courses. Otherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** numCourses = 2 prerequisites = [[10]]\n    **Output:** true\n    **Explanation:** There are a total of 2 courses to take. \n    To take course 1 you should have finished course 0. So it is possible.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** numCourses = 2 prerequisites = [[10][01]]\n    **Output:** false\n    **Explanation:** There are a total of 2 courses to take. \n    To take course 1 you should have finished course 0 and to take course 0 you should also have finished course 1. So it is impossible.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= numCourses <= 2000`\n  * `0 <= prerequisites.length <= 5000`\n  * `prerequisites[i].length == 2`\n  * `0 <= ai bi < numCourses`\n  * All the pairs prerequisites[i] are **unique**.\n\n,class Solution:\n    def canFinish(self numCourses: int prerequisites: List[List[int]]) -> bool:\n                 \n        pre = {} # course: list of prerequisites\n        dep = {} # course: list of dependents\n        for p in prerequisites:\n            if p[0] not in pre:\n                pre[p[0]] = set()\n            if p[1] not in dep:\n                dep[p[1]] = set()\n            pre[p[0]].add(p[1])\n            dep[p[1]].add(p[0])\n\n        # Kahn's algorithm\n        l = []\n        s = set()\n        for i in range(numCourses):\n            if i not in dep: # if no dependents (incoming edge)\n                s.add(i) \n        while s:\n            n = s.pop()\n            l.append(n)\n            if n in pre: # if n has prerequisites\n                for m in pre[n]: # for each prerequisites m\n                    dep[m].remove(n) # remove n from m's dependents list\n                    if not dep[m]: # if m has no more dependents\n                        s.add(m)\n                        \n        return len(l) == numCourses
Course Schedule II,###  210\. Course Schedule II\n\nThere are a total of `numCourses` courses you have to take labeled from `0`\nto `numCourses - 1`. You are given an array `prerequisites` where\n`prerequisites[i] = [ai bi]` indicates that you **must** take course `bi`\nfirst if you want to take course `ai`.\n\n  * For example the pair `[0 1]` indicates that to take course `0` you have to first take course `1`.\n\nReturn _the ordering of courses you should take to finish all courses_. If\nthere are many valid answers return **any** of them. If it is impossible to\nfinish all courses return **an empty array**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** numCourses = 2 prerequisites = [[10]]\n    **Output:** [01]\n    **Explanation:** There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [01].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** numCourses = 4 prerequisites = [[10][20][31][32]]\n    **Output:** [0213]\n    **Explanation:** There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\n    So one correct course order is [0123]. Another correct ordering is [0213].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** numCourses = 1 prerequisites = []\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= numCourses <= 2000`\n  * `0 <= prerequisites.length <= numCourses * (numCourses - 1)`\n  * `prerequisites[i].length == 2`\n  * `0 <= ai bi < numCourses`\n  * `ai != bi`\n  * All the pairs `[ai bi]` are **distinct**.\n\n,class Solution:\n    def findOrder(self numCourses: int prerequisites: List[List[int]]) -> List[int]:\n        d = {i:[] for i in range(numCourses)}\n        \n        for crs prereq in prerequisites:\n            d[crs].append(prereq)\n         \n        visit cycle = set() set()\n        output = []\n        def dfs(crs):\n            if crs in cycle:\n                return False\n            if crs in visit:\n                return True\n            \n            cycle.add(crs)\n            for nei in d[crs]:\n                if not dfs(nei):\n                    return False\n            cycle.remove(crs)\n            visit.add(crs)\n            output.append(crs)\n            return True\n        \n        for crs in range(numCourses):\n            if not dfs(crs):\n                return []\n        return output\n            \n
Course Schedule III,###  630\. Course Schedule III\n\nThere are `n` different online courses numbered from `1` to `n`. You are given\nan array `courses` where `courses[i] = [durationi lastDayi]` indicate that\nthe `ith` course should be taken **continuously** for `durationi` days and\nmust be finished before or on `lastDayi`.\n\nYou will start on the `1st` day and you cannot take two or more courses\nsimultaneously.\n\nReturn _the maximum number of courses that you can take_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** courses = [[100200][2001300][10001250][20003200]]\n    **Output:** 3\n    Explanation: \n    There are totally 4 courses but you can take 3 courses at most:\n    First take the 1st course it costs 100 days so you will finish it on the 100th day and ready to take the next course on the 101st day.\n    Second take the 3rd course it costs 1000 days so you will finish it on the 1100th day and ready to take the next course on the 1101st day. \n    Third take the 2nd course it costs 200 days so you will finish it on the 1300th day. \n    The 4th course cannot be taken now since you will finish it on the 3300th day which exceeds the closed date.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** courses = [[12]]\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** courses = [[32][43]]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= courses.length <= 104`\n  * `1 <= durationi lastDayi <= 104`\n\n,class Solution {\npublic:\n    bool static cmp(vector<int> &avector<int>&b) {\n        return a[1] < b[1];\n    }\n    int scheduleCourse(vector<vector<int>>& courses) {\n         sort(courses.begin()courses.end()cmp);\n         int sm = 0;\n         priority_queue<int> pq;\n         for(int i=0; i<courses.size(); i++) {\n               pq.push(courses[i][0]);  \n               sm+=courses[i][0]; // sum of duration of courses\n               // when there exists a course duration that is invalid and can't be completed on that day!\n               if(sm>courses[i][1]) { \n                    sm-=pq.top();  // remove the biggest invalid course duration!\n                    pq.pop();\n               }\n         }\n        return pq.size();\n    }\n};\n
Course Schedule IV,###  1462\. Course Schedule IV\n\nThere are a total of `numCourses` courses you have to take labeled from `0`\nto `numCourses - 1`. You are given an array `prerequisites` where\n`prerequisites[i] = [ai bi]` indicates that you **must** take course `ai`\nfirst if you want to take course `bi`.\n\n  * For example the pair `[0 1]` indicates that you have to take course `0` before you can take course `1`.\n\nPrerequisites can also be **indirect**. If course `a` is a prerequisite of\ncourse `b` and course `b` is a prerequisite of course `c` then course `a` is\na prerequisite of course `c`.\n\nYou are also given an array `queries` where `queries[j] = [uj vj]`. For the\n`jth` query you should answer whether course `uj` is a prerequisite of course\n`vj` or not.\n\nReturn _a boolean array_`answer` _ where_`answer[j]`_is the answer to\nthe_`jth` _query._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg)\n\n    \n    \n    **Input:** numCourses = 2 prerequisites = [[10]] queries = [[01][10]]\n    **Output:** [falsetrue]\n    **Explanation:** The pair [1 0] indicates that you have to take course 1 before you can take course 0.\n    Course 0 is not a prerequisite of course 1 but the opposite is true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** numCourses = 2 prerequisites = [] queries = [[10][01]]\n    **Output:** [falsefalse]\n    **Explanation:** There are no prerequisites and each course is independent.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg)\n\n    \n    \n    **Input:** numCourses = 3 prerequisites = [[12][10][20]] queries = [[10][12]]\n    **Output:** [truetrue]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= numCourses <= 100`\n  * `0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)`\n  * `prerequisites[i].length == 2`\n  * `0 <= ai bi <= n - 1`\n  * `ai != bi`\n  * All the pairs `[ai bi]` are **unique**.\n  * The prerequisites graph has no cycles.\n  * `1 <= queries.length <= 104`\n  * `0 <= ui vi <= n - 1`\n  * `ui != vi`\n\n,"class Solution:\n    """"""\n    one approach I can think of is given a graph \n    the query[a b] will be true if there exists a path from a to b in the graph\n    else a will not be a prerequisite of b\n    but this approach may not scale as the # of queries will increase\n    """"""\n    def checkIfPrerequisite(self numCourses: int prerequisites: List[List[int]] queries: List[List[int]]) -> List[bool]:\n        graph = {node: set() for node in range(numCourses)}\n        for pre in prerequisites:\n            graph[pre[0]].add(pre[1])\n        \n        def path(cur_node node_b):\n            if cur_node == node_b:\n                return True\n            for neighbor in graph[cur_node]:\n                if path(neighbor node_b):\n                    return True\n            return False\n            \n        ans = []\n        for query in queries:\n            # see if there is a path from query[0] to query[1]\n            ans.append(path(query[0] query[1]))\n        return ans\n"
Cousins in Binary Tree,###  993\. Cousins in Binary Tree\n\nGiven the `root` of a binary tree with unique values and the values of two\ndifferent nodes of the tree `x` and `y` return `true` _if the nodes\ncorresponding to the values_`x` _and_`y` _in the tree are**cousins**  or\n_`false` _otherwise._\n\nTwo nodes of a binary tree are **cousins** if they have the same depth with\ndifferent parents.\n\nNote that in a binary tree the root node is at the depth `0` and children of\neach depth `k` node are at the depth `k + 1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png)\n\n    \n    \n    **Input:** root = [1234] x = 4 y = 3\n    **Output:** false\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png)\n\n    \n    \n    **Input:** root = [123null4null5] x = 5 y = 4\n    **Output:** true\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png)\n\n    \n    \n    **Input:** root = [123null4] x = 2 y = 3\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[2 100]`.\n  * `1 <= Node.val <= 100`\n  * Each node has a **unique** value.\n  * `x != y`\n  * `x` and `y` are exist in the tree.\n\n,# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    ans = False\n    def isCousins(self root: Optional[TreeNode] x: int y: int) -> bool:\n        def dfs(node depth):\n            if self.ans or not node: return 0\n            if node.val == x or node.val == y: return depth\n            l = dfs(node.left depth+1)\n            r = dfs(node.right depth+1)\n            if not (l and r): return l or r\n            if l == r and l != depth + 1: self.ans = True\n            return 0\n        \n        dfs(root 0)\n        return self.ans\n
Cracking the Safe,"###  753\. Cracking the Safe\n\nThere is a safe protected by a password. The password is a sequence of `n`\ndigits where each digit can be in the range `[0 k - 1]`.\n\nThe safe has a peculiar way of checking the password. When you enter in a\nsequence it checks the **most recent**`n`**digits** that were entered each\ntime you type a digit.\n\n  * For example the correct password is `""345""` and you enter in `""012345""`: \n    * After typing `0` the most recent `3` digits is `""0""` which is incorrect.\n    * After typing `1` the most recent `3` digits is `""01""` which is incorrect.\n    * After typing `2` the most recent `3` digits is `""012""` which is incorrect.\n    * After typing `3` the most recent `3` digits is `""123""` which is incorrect.\n    * After typing `4` the most recent `3` digits is `""234""` which is incorrect.\n    * After typing `5` the most recent `3` digits is `""345""` which is correct and the safe unlocks.\n\nReturn _any string of**minimum length** that will unlock the safe **at some\npoint** of entering it_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1 k = 2\n    **Output:** ""10""\n    **Explanation:** The password is a single digit so enter each digit. ""01"" would also unlock the safe.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 k = 2\n    **Output:** ""01100""\n    **Explanation:** For each possible password:\n    - ""00"" is typed in starting from the 4th digit.\n    - ""01"" is typed in starting from the 1st digit.\n    - ""10"" is typed in starting from the 3rd digit.\n    - ""11"" is typed in starting from the 2nd digit.\n    Thus ""01100"" will unlock the safe. ""01100"" ""10011"" and ""11001"" would also unlock the safe.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 4`\n  * `1 <= k <= 10`\n  * `1 <= kn <= 4096`\n\n","# Runtime: 121 ms (Top 27.97%) | Memory: 27.9 MB (Top 17.84%)\nclass Solution:\n    def crackSafe(self n: int k: int) -> str:\n        seen=set()\n        def dfs(slast_n):\n            if len(seen)==(k**n): return s\n            if len(last_n)<n: # If len<nkeep adding zeros as and valid string can be returned\n                if len(s+""0"")==n:\n                    seen.add(s+""0"")\n                ans=dfs(s+""0""last_n+""0"")\n                return ans\n            ans=None\n            for i in range(k):\n                new=last_n[1:]+str(i)\n                if new not in seen:\n                    seen.add(new)\n                    ans=dfs(s+str(i)new)\n                    if ans: return ans\n                    seen.remove(new)\n        return dfs("""""""")"
Crawler Log Folder,"###  1598\. Crawler Log Folder\n\nThe Leetcode file system keeps a log each time some user performs a _change\nfolder_ operation.\n\nThe operations are described below:\n\n  * `""../""` : Move to the parent folder of the current folder. (If you are already in the main folder **remain in the same folder**).\n  * `""./""` : Remain in the same folder.\n  * `""x/""` : Move to the child folder named `x` (This folder is **guaranteed to always exist**).\n\nYou are given a list of strings `logs` where `logs[i]` is the operation\nperformed by the user at the `ith` step.\n\nThe file system starts in the main folder then the operations in `logs` are\nperformed.\n\nReturn _the minimum number of operations needed to go back to the main folder\nafter the change folder operations._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/09/sample_11_1957.png)\n\n    \n    \n    **Input:** logs = [""d1/""""d2/""""../""""d21/""""./""]\n    **Output:** 2\n    **Explanation:** Use this change folder operation ""../"" 2 times and go back to the main folder.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/09/sample_22_1957.png)\n\n    \n    \n    **Input:** logs = [""d1/""""d2/""""./""""d3/""""../""""d31/""]\n    **Output:** 3\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** logs = [""d1/""""../""""../""""../""]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= logs.length <= 103`\n  * `2 <= logs[i].length <= 10`\n  * `logs[i]` contains lowercase English letters digits `'.'` and `'/'`.\n  * `logs[i]` follows the format described in the statement.\n  * Folder names consist of lowercase English letters and digits.\n\n","class Solution:\n    def minOperations(self logs: List[str]) -> int:\n        m='../'\n        r='./'\n		#create an empty stack\n        stk=[]\n		#iterate through the list\n        for i in logs:\n			#if Move to the parent folder (../) operator occurs and stack is not empty pop element from stack\n            if(i==m):\n                if(len(stk)>0):\n                    stk.pop()\n			#else if Remain in the same folder (./) operator occurs do nothing and move to next element in list\n            elif(i==r):\n                continue\n			#else add element to the stack\n            else:\n                stk.append(i)\n		#now return the size of the stack which would be the minimum number of operations needed to go back to the main folder\n        return(len(stk))\n		```"
Create Binary Tree From Descriptions,###  2196\. Create Binary Tree From Descriptions\n\nYou are given a 2D integer array `descriptions` where `descriptions[i] =\n[parenti childi isLefti]` indicates that `parenti` is the **parent** of\n`childi` in a **binary** tree of **unique** values. Furthermore\n\n  * If `isLefti == 1` then `childi` is the left child of `parenti`.\n  * If `isLefti == 0` then `childi` is the right child of `parenti`.\n\nConstruct the binary tree described by `descriptions` and return\n_its**root**_.\n\nThe test cases will be generated such that the binary tree is **valid**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/02/09/example1drawio.png)\n\n    \n    \n    **Input:** descriptions = [[20151][20170][50201][50800][80191]]\n    **Output:** [502080151719]\n    **Explanation:** The root node is the node with value 50 since it has no parent.\n    The resulting binary tree is shown in the diagram.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/02/09/example2drawio.png)\n\n    \n    \n    **Input:** descriptions = [[121][230][341]]\n    **Output:** [12nullnull34]\n    **Explanation:** The root node is the node with value 1 since it has no parent.\n    The resulting binary tree is shown in the diagram.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= descriptions.length <= 104`\n  * `descriptions[i].length == 3`\n  * `1 <= parenti childi <= 105`\n  * `0 <= isLefti <= 1`\n  * The binary tree described by `descriptions` is valid.\n\n,\nclass Solution:\n    def createBinaryTree(self descriptions: List[List[int]]) -> Optional[TreeNode]:\n        hashmap = {}\n        nodes = set()\n        children = set()\n        for parentchildisLeft in descriptions:\n            nodes.add(parent)\n            nodes.add(child)\n            children.add(child)\n            if parent not in hashmap:\n                hashmap[parent] = TreeNode(parent)\n            if child not in hashmap:\n                hashmap[child] = TreeNode(child)\n            if isLeft:\n                hashmap[parent].left = hashmap[child]\n            if not isLeft:\n                hashmap[parent].right = hashmap[child]\n        \n        for node in nodes:\n            if node not in children:\n                return hashmap[node]\n\n\n\n
Create Sorted Array through Instructions,###  1649\. Create Sorted Array through Instructions\n\nGiven an integer array `instructions` you are asked to create a sorted array\nfrom the elements in `instructions`. You start with an empty container `nums`.\nFor each element from **left to right** in `instructions` insert it into\n`nums`. The **cost** of each insertion is the **minimum** of the following:\n\n  * The number of elements currently in `nums` that are **strictly less than** `instructions[i]`.\n  * The number of elements currently in `nums` that are **strictly greater than** `instructions[i]`.\n\nFor example if inserting element `3` into `nums = [1235]` the **cost** of\ninsertion is `min(2 1)` (elements `1` and `2` are less than `3` element `5`\nis greater than `3`) and `nums` will become `[12335]`.\n\nReturn _the**total cost** to insert all elements from _`instructions`\n_into_`nums`. Since the answer may be large return it **modulo** `109 + 7`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** instructions = [1562]\n    **Output:** 1\n    **Explanation:** Begin with nums = [].\n    Insert 1 with cost min(0 0) = 0 now nums = [1].\n    Insert 5 with cost min(1 0) = 0 now nums = [15].\n    Insert 6 with cost min(2 0) = 0 now nums = [156].\n    Insert 2 with cost min(1 2) = 1 now nums = [1256].\n    The total cost is 0 + 0 + 0 + 1 = 1.\n\n**Example 2:**\n\n    \n    \n    **Input:** instructions = [123654]\n    **Output:** 3\n    **Explanation:** Begin with nums = [].\n    Insert 1 with cost min(0 0) = 0 now nums = [1].\n    Insert 2 with cost min(1 0) = 0 now nums = [12].\n    Insert 3 with cost min(2 0) = 0 now nums = [123].\n    Insert 6 with cost min(3 0) = 0 now nums = [1236].\n    Insert 5 with cost min(3 1) = 1 now nums = [12356].\n    Insert 4 with cost min(3 2) = 2 now nums = [123456].\n    The total cost is 0 + 0 + 0 + 0 + 1 + 2 = 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** instructions = [133324212]\n    **Output:** 4\n    **Explanation:** Begin with nums = [].\n    Insert 1 with cost min(0 0) = 0 now nums = [1].\n    Insert 3 with cost min(1 0) = 0 now nums = [13].\n    Insert 3 with cost min(1 0) = 0 now nums = [133].\n    Insert 3 with cost min(1 0) = 0 now nums = [1333].\n    Insert 2 with cost min(1 3) = 1 now nums = [12333].\n    Insert 4 with cost min(5 0) = 0 now nums = [123334].\n    ​​​​​​​Insert 2 with cost min(1 4) = 1 now nums = [1223334].\n    ​​​​​​​Insert 1 with cost min(0 6) = 0 now nums = [11223334].\n    ​​​​​​​Insert 2 with cost min(2 4) = 2 now nums = [112223334].\n    The total cost is 0 + 0 + 0 + 0 + 1 + 0 + 1 + 0 + 2 = 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= instructions.length <= 105`\n  * `1 <= instructions[i] <= 105`\n\n,"// Runtime: 5781 ms (Top 22.88%) | Memory: 36.00 MB (Top 13.56%)\n\nclass Fenwick:\n    """"""Fenwick tree aka binary indexed tree""""""\n    def __init__(self n):\n        self.nums = [0]*(n+1)\n        \n    def sum(self k): \n        ans = 0\n        while k: \n            ans += self.nums[k]\n            k &= k-1\n        return ans \n    \n    def add(self i x): \n        i += 1\n        while i < len(self.nums): \n            self.nums[i] += x\n            i += i & -i\n\n\nclass Solution:\n    def createSortedArray(self instructions: List[int]) -> int:\n        ans = 0\n        fen = Fenwick(10**5)\n        freq = {} # frequency of each instructions\n        for i x in enumerate(instructions): \n            less = fen.sum(x)\n            more = i - freq.get(x 0) - less\n            ans += min(less more)\n            fen.add(x 1)\n            freq[x] = 1 + freq.get(x 0)\n        return ans % 1_000_000_007\n"
Create Target Array in the Given Order,###  1389\. Create Target Array in the Given Order\n\nGiven two arrays of integers `nums` and `index`. Your task is to create\n_target_ array under the following rules:\n\n  * Initially _target_ array is empty.\n  * From left to right read nums[i] and index[i] insert at index `index[i]` the value `nums[i]` in _target_ array.\n  * Repeat the previous step until there are no elements to read in `nums` and `index.`\n\nReturn the _target_ array.\n\nIt is guaranteed that the insertion operations will be valid.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [01234] index = [01221]\n    **Output:** [04132]\n    **Explanation:**\n    nums       index     target\n    0            0        [0]\n    1            1        [01]\n    2            2        [012]\n    3            2        [0132]\n    4            1        [04132]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12340] index = [01230]\n    **Output:** [01234]\n    **Explanation:**\n    nums       index     target\n    1            0        [1]\n    2            1        [12]\n    3            2        [123]\n    4            3        [1234]\n    0            0        [01234]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1] index = [0]\n    **Output:** [1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length index.length <= 100`\n  * `nums.length == index.length`\n  * `0 <= nums[i] <= 100`\n  * `0 <= index[i] <= i`\n\n,class Solution:\n    def createTargetArray(self nums index):\n        \n        def merge(arr low mid high):\n            L R = arr[low:mid+1] arr[mid+1:high+1]\n            i = j = 0\n            k = low\n            \n            while i < len(L) and j < len(R):\n                if L[i][0] + j >= R[j][0]:\n                    arr[k] = R[j]\n                    j += 1\n                else:\n                    L[i][0] += j\n                    arr[k] = L[i]\n                    i += 1\n                k += 1\n            \n            while i < len(L):\n                L[i][0] += j\n                arr[k] = L[i]\n                i += 1; k += 1\n                \n            while j < len(R):\n                arr[k] = R[j]\n                j += 1; k += 1\n            \n        \n        def mergeSort(arr low high):\n            if low < high:\n                mid = (low + high) // 2\n                mergeSort(arr low mid)\n                mergeSort(arr mid + 1 high)\n                merge(arr low mid high)\n                \n        arr = [[index[i] nums[i]] for i in range(len(nums))]\n        mergeSort(arr 0 len(nums) - 1)\n        \n        for x in arr:\n            nums[x[0]] = x[1]\n        \n        return nums
Critical Connections in a Network,###  1192\. Critical Connections in a Network\n\nThere are `n` servers numbered from `0` to `n - 1` connected by undirected\nserver-to-server `connections` forming a network where `connections[i] = [ai\nbi]` represents a connection between servers `ai` and `bi`. Any server can\nreach other servers directly or indirectly through the network.\n\nA _critical connection_ is a connection that if removed will make some\nservers unable to reach some other server.\n\nReturn all critical connections in the network in any order.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/09/03/1537_ex1_2.png)\n\n    \n    \n    **Input:** n = 4 connections = [[01][12][20][13]]\n    **Output:** [[13]]\n    **Explanation:** [[31]] is also accepted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 connections = [[01]]\n    **Output:** [[01]]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 105`\n  * `n - 1 <= connections.length <= 105`\n  * `0 <= ai bi <= n - 1`\n  * `ai != bi`\n  * There are no repeated connections.\n\n,"class Solution:\n    def criticalConnections(self n: int connections: List[List[int]]) -> List[List[int]]:\n        \n        dic = collections.defaultdict(list)\n        for c in connections:\n            u v = c\n            dic[u].append(v)\n            dic[v].append(u)\n            \n        \n        timer = 0\n        \n        depth lowest parent visited = [float(""inf"")]*n [float(""inf"")]*n [float(""inf"")]*n [False]*n\n        res = []\n        \n        def find(u):\n            \n            nonlocal timer\n            \n            visited[u] = True\n            depth[u] lowest[u] = timer timer\n            timer += 1\n            \n            for v in dic[u]:   \n                \n                if not visited[v]:\n                    parent[v] = u\n                    find(v)\n                    if lowest[v]>depth[u]:\n                        res.append([uv])\n                \n                if parent[u]!=v:\n                    lowest[u] = min(lowest[u] lowest[v])\n                \n        find(0)\n        return res\n        "
Custom Sort String,"###  791\. Custom Sort String\n\nYou are given two strings order and s. All the characters of `order` are\n**unique** and were sorted in some custom order previously.\n\nPermute the characters of `s` so that they match the order that `order` was\nsorted. More specifically if a character `x` occurs before a character `y` in\n`order` then `x` should occur before `y` in the permuted string.\n\nReturn _any permutation of_`s` _that satisfies this property_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** order = ""cba"" s = ""abcd""\n    **Output:** ""cbad""\n    **Explanation:** \n    ""a"" ""b"" ""c"" appear in order so the order of ""a"" ""b"" ""c"" should be ""c"" ""b"" and ""a"". \n    Since ""d"" does not appear in order it can be at any position in the returned string. ""dcba"" ""cdba"" ""cbda"" are also valid outputs.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** order = ""cbafg"" s = ""abcd""\n    **Output:** ""cbad""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= order.length <= 26`\n  * `1 <= s.length <= 200`\n  * `order` and `s` consist of lowercase English letters.\n  * All the characters of `order` are **unique**.\n\n",# Runtime: 328 ms (Top 5.22%) | Memory: 13.9 MB (Top 17.87%)\nclass Solution:\n    def customSortString(self order: str s: str) -> str:\n        charValue = [0] * 26\n        for i in range(len(order)):\n            idx = ord(order[i]) - ord('a')\n            charValue[idx] = 26 - i\n\n        arrS = []\n        n = 0\n        for c in s:\n            arrS.append(c)\n            n += 1\n\n        sorted = False\n        while not sorted:\n            sorted = True\n            for i in range(n - 1):\n                if charValue[ord(arrS[i]) - ord('a')] < charValue[ord(arrS[i + 1]) - ord('a')]:\n                    sorted = False\n                    arrS[i] arrS[i + 1] = arrS[i + 1] arrS[i]\n\n        return ''.join(arrS)
Cut Off Trees for Golf Event,###  675\. Cut Off Trees for Golf Event\n\nYou are asked to cut off all the trees in a forest for a golf event. The\nforest is represented as an `m x n` matrix. In this matrix:\n\n  * `0` means the cell cannot be walked through.\n  * `1` represents an empty cell that can be walked through.\n  * A number greater than `1` represents a tree in a cell that can be walked through and this number is the tree's height.\n\nIn one step you can walk in any of the four directions: north east south\nand west. If you are standing in a cell with a tree you can choose whether to\ncut it off.\n\nYou must cut off the trees in order from shortest to tallest. When you cut off\na tree the value at its cell becomes `1` (an empty cell).\n\nStarting from the point `(0 0)` return _the minimum steps you need to walk\nto cut off all the trees_. If you cannot cut off all the trees return `-1`.\n\n**Note:** The input is generated such that no two trees have the same height\nand there is at least one tree needs to be cut off.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/26/trees1.jpg)\n\n    \n    \n    **Input:** forest = [[123][004][765]]\n    **Output:** 6\n    **Explanation:** Following the path above allows you to cut off the trees from shortest to tallest in 6 steps.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/26/trees2.jpg)\n\n    \n    \n    **Input:** forest = [[123][000][765]]\n    **Output:** -1\n    **Explanation:** The trees in the bottom row cannot be accessed as the middle row is blocked.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** forest = [[234][005][876]]\n    **Output:** 6\n    **Explanation:** You can follow the same path as Example 1 to cut off all the trees.\n    Note that you can cut off the first tree at (0 0) before making any steps.\n    \n\n\n\n**Constraints:**\n\n  * `m == forest.length`\n  * `n == forest[i].length`\n  * `1 <= m n <= 50`\n  * `0 <= forest[i][j] <= 109`\n  * Heights of all trees are **distinct**.\n\n,from collections import deque\n\nclass Solution:\n    def cutOffTree(self forest: List[List[int]]) -> int:\n        a = []\n        n = len(forest)\n        m = len(forest[0])\n        for i in range(n):\n            for j in range(m):\n                if forest[i][j] > 1:\n                    a.append(forest[i][j])\n        a.sort()\n        \n        s = 0\n        ux = 0\n        uy = 0\n        for h in a:\n            dist = [[None] * m for i in range(n)]\n            q = deque()\n            q.append((ux uy))\n            dist[ux][uy] = 0\n            while q:\n                ux uy = q.popleft()\n                if forest[ux][uy] == h:\n                    break\n                d = [(-1 0) (0 1) (1 0) (0 -1)]\n                for dx dy in d:\n                    vx = ux + dx\n                    vy = uy + dy\n                    if vx < 0 or vx >= n or vy < 0 or vy >= m:\n                        continue\n                    if forest[vx][vy] == 0:\n                        continue\n                    if dist[vx][vy] is None:\n                        q.append((vx vy))\n                        dist[vx][vy] = dist[ux][uy] + 1\n            if forest[ux][uy] == h:\n                s += dist[ux][uy]\n            else:\n                return -1\n        return s\n
Daily Temperatures,###  739\. Daily Temperatures\n\nGiven an array of integers `temperatures` represents the daily temperatures\nreturn _an array_ `answer` _such that_ `answer[i]` _is the number of days you\nhave to wait after the_ `ith` _day to get a warmer temperature_. If there is\nno future day for which this is possible keep `answer[i] == 0` instead.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** temperatures = [7374757169727673]\n    **Output:** [11421100]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** temperatures = [30405060]\n    **Output:** [1110]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** temperatures = [306090]\n    **Output:** [110]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= temperatures.length <= 105`\n  * `30 <= temperatures[i] <= 100`\n\n,// Runtime: 1085 ms (Top 46.04%) | Memory: 30.40 MB (Top 85.02%)\n\nclass Solution:\n    def dailyTemperatures(self T):\n        ans s = [0]*len(T) deque()\n        for cur cur_tmp in enumerate(T):\n            while s and cur_tmp > T[s[-1]]:\n                ans[s[-1]] = cur - s[-1]\n                s.pop()\n            s.append(cur)\n        return ans\n
Data Stream as Disjoint Intervals,"###  352\. Data Stream as Disjoint Intervals\n\nGiven a data stream input of non-negative integers `a1 a2 ... an`\nsummarize the numbers seen so far as a list of disjoint intervals.\n\nImplement the `SummaryRanges` class:\n\n  * `SummaryRanges()` Initializes the object with an empty stream.\n  * `void addNum(int val)` Adds the integer `val` to the stream.\n  * `int[][] getIntervals()` Returns a summary of the integers in the stream currently as a list of disjoint intervals `[starti endi]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""SummaryRanges"" ""addNum"" ""getIntervals"" ""addNum"" ""getIntervals"" ""addNum"" ""getIntervals"" ""addNum"" ""getIntervals"" ""addNum"" ""getIntervals""]\n    [[] [1] [] [3] [] [7] [] [2] [] [6] []]\n    **Output**\n    [null null [[1 1]] null [[1 1] [3 3]] null [[1 1] [3 3] [7 7]] null [[1 3] [7 7]] null [[1 3] [6 7]]]\n    \n    **Explanation**\n    SummaryRanges summaryRanges = new SummaryRanges();\n    summaryRanges.addNum(1);      // arr = [1]\n    summaryRanges.getIntervals(); // return [[1 1]]\n    summaryRanges.addNum(3);      // arr = [1 3]\n    summaryRanges.getIntervals(); // return [[1 1] [3 3]]\n    summaryRanges.addNum(7);      // arr = [1 3 7]\n    summaryRanges.getIntervals(); // return [[1 1] [3 3] [7 7]]\n    summaryRanges.addNum(2);      // arr = [1 2 3 7]\n    summaryRanges.getIntervals(); // return [[1 3] [7 7]]\n    summaryRanges.addNum(6);      // arr = [1 2 3 6 7]\n    summaryRanges.getIntervals(); // return [[1 3] [6 7]]\n    \n\n\n\n**Constraints:**\n\n  * `0 <= val <= 104`\n  * At most `3 * 104` calls will be made to `addNum` and `getIntervals`.\n\n\n\n**Follow up:** What if there are lots of merges and the number of disjoint\nintervals is small compared to the size of the data stream?\n\n",class SummaryRanges:\n    def __init__(self):\n        self.intervals = []\n    def addNum(self val: int) -> None:\n        left right = 0 len(self.intervals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            e = self.intervals[mid]\n            if e[0] <= val <= e[1]: return\n            elif val < e[0]:right = mid - 1\n            else:left = mid + 1\n        pos = left\n        self.intervals.insert(pos [val val])\n        if pos + 1 < len(self.intervals) and val + 1 == self.intervals[pos+1][0]:\n            self.intervals[pos][1] = self.intervals[pos+1][1]\n            del self.intervals[pos+1]\n        if pos - 1 >= 0 and val - 1 == self.intervals[pos-1][1]:\n            self.intervals[pos-1][1] = self.intervals[pos][1]\n            del self.intervals[pos]\n\n    def getIntervals(self) -> List[List[int]]:\n        return self.intervals\n
Day of the Week,"###  1185\. Day of the Week\n\nGiven a date return the corresponding day of the week for that date.\n\nThe input is given as three integers representing the `day` `month` and\n`year` respectively.\n\nReturn the answer as one of the following values `{""Sunday"" ""Monday""\n""Tuesday"" ""Wednesday"" ""Thursday"" ""Friday"" ""Saturday""}`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** day = 31 month = 8 year = 2019\n    **Output:** ""Saturday""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** day = 18 month = 7 year = 1999\n    **Output:** ""Sunday""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** day = 15 month = 8 year = 1993\n    **Output:** ""Sunday""\n    \n\n\n\n**Constraints:**\n\n  * The given dates are valid dates between the years `1971` and `2100`.\n\n","class Solution:\n    def dayOfTheWeek(self day: int month: int year: int) -> str:\n        LOWEST_DAY LOWEST_MONTH LOWEST_YEAR DAY = 1 1 1971 5\n        DAYS = (""Sunday"" ""Monday"" ""Tuesday"" ""Wednesday"" ""Thursday"" ""Friday"" ""Saturday"")\n\n        difference = self.daysBetweenDates((LOWEST_DAY LOWEST_MONTH LOWEST_YEAR) (day month year))\n        return DAYS[(difference + DAY) % 7]\n\n    def daysBetweenDates(self date1: tuple date2: tuple) -> int:\n        LOWEST_YEAR = 1971\n\n        def daysSinceLowest(date: tuple) -> int:\n            day month year = date\n\n            isLeapYear = lambda x: 1 if (x % 4 == 0 and x % 100 != 0) or x % 400 == 0 else 0\n\n            days: int = 0\n            # days between the LOWEST_YEAR and year\n            days += 365 * (year - LOWEST_YEAR) + sum(map(isLeapYear range(LOWEST_YEAR year)))\n            # days between year and exact date\n            daysInMonth = (31 28 + isLeapYear(year) 31 30 31 30 31 31 30 31 30 31)\n            days += sum(daysInMonth[:month - 1]) + day\n            return days\n\n        return abs(daysSinceLowest(date1) - daysSinceLowest(date2))"
Day of the Year,"###  1154\. Day of the Year\n\nGiven a string `date` representing a [Gregorian\ncalendar](https://en.wikipedia.org/wiki/Gregorian_calendar) date formatted as\n`YYYY-MM-DD` return _the day number of the year_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** date = ""2019-01-09""\n    **Output:** 9\n    **Explanation:** Given date is the 9th day of the year in 2019.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** date = ""2019-02-10""\n    **Output:** 41\n    \n\n\n\n**Constraints:**\n\n  * `date.length == 10`\n  * `date[4] == date[7] == '-'` and all other `date[i]`'s are digits\n  * `date` represents a calendar date between Jan 1st 1900 and Dec 31th 2019.\n\n",// Runtime: 123 ms (Top 44.98%) | Memory: 14 MB (Top 32.35%)\nclass Solution:\n    def dayOfYear(self date: str) -> int:\n        d={1:312:283:314:305:316:307:318:319:3010:3111:3012:31}\n        year=int(date[:4])\n        if year%4==0:\n            if year%100==0:\n                if year%400==0:\n                    d[2]=29\n            else:\n                d[2]=29\n        month=int(date[5:7])\n        day=int(date[8:])\n        ans=0\n        for i in range(1month+1):\n            ans+=d[i]\n        return ans-(d[month]-day)
Decode String,"###  394\. Decode String\n\nGiven an encoded string return its decoded string.\n\nThe encoding rule is: `k[encoded_string]` where the `encoded_string` inside\nthe square brackets is being repeated exactly `k` times. Note that `k` is\nguaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; there are no extra white\nspaces square brackets are well-formed etc. Furthermore you may assume that\nthe original data does not contain any digits and that digits are only for\nthose repeat numbers `k`. For example there will not be input like `3a` or\n`2[4]`.\n\nThe test cases are generated so that the length of the output will never\nexceed `105`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""3[a]2[bc]""\n    **Output:** ""aaabcbc""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""3[a2[c]]""\n    **Output:** ""accaccacc""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""2[abc]3[cd]ef""\n    **Output:** ""abcabccdcdcdef""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 30`\n  * `s` consists of lowercase English letters digits and square brackets `'[]'`.\n  * `s` is guaranteed to be **a valid** input.\n  * All the integers in `s` are in the range `[1 300]`.\n\n",class Solution:\n    def decodeString(self s: str) -> str:\n        stk = []\n        \n        for i in range(len(s)):\n            \n            if s[i] != ']':\n                stk.append(s[i])  \n            else:\n                strr = ''\n                while stk[-1] != '[':\n                    strr = stk.pop() + strr\n                stk.pop()\n                \n                num = ''\n                while stk and stk[-1].isdigit():\n                    num = stk.pop() + num\n                    \n                stk.append(int(num) * strr)\n        \n        return ''.join(stk)\n                    \n                    \n                    
Decode the Message,"###  2325\. Decode the Message\n\nYou are given the strings `key` and `message` which represent a cipher key\nand a secret message respectively. The steps to decode `message` are as\nfollows:\n\n  1. Use the **first** appearance of all 26 lowercase English letters in `key` as the **order** of the substitution table.\n  2. Align the substitution table with the regular English alphabet.\n  3. Each letter in `message` is then **substituted** using the table.\n  4. Spaces `' '` are transformed to themselves.\n\n  * For example given `key = ""_**hap**_ p _**y**_ _**bo**_ y""` (actual key would have **at least one** instance of each letter in the alphabet) we have the partial substitution table of (`'h' -> 'a'` `'a' -> 'b'` `'p' -> 'c'` `'y' -> 'd'` `'b' -> 'e'` `'o' -> 'f'`).\n\nReturn _the decoded message_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/05/08/ex1new4.jpg)\n\n    \n    \n    **Input:** key = ""the quick brown fox jumps over the lazy dog"" message = ""vkbs bs t suepuv""\n    **Output:** ""this is a secret""\n    **Explanation:** The diagram above shows the substitution table.\n    It is obtained by taking the first appearance of each letter in ""_**the**_ _**quick**_ _**brown**_ _**f**_ o _**x**_ _**j**_ u _**mps**_ o _**v**_ er the _**lazy**_ _**d**_ o _**g**_ "".\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/05/08/ex2new.jpg)\n\n    \n    \n    **Input:** key = ""eljuxhpwnyrdgtqkviszcfmabo"" message = ""zwx hnfx lqantp mnoeius ycgk vcnjrdb""\n    **Output:** ""the five boxing wizards jump quickly""\n    **Explanation:** The diagram above shows the substitution table.\n    It is obtained by taking the first appearance of each letter in ""_**eljuxhpwnyrdgtqkviszcfmabo**_ "".\n    \n\n\n\n**Constraints:**\n\n  * `26 <= key.length <= 2000`\n  * `key` consists of lowercase English letters and `' '`.\n  * `key` contains every letter in the English alphabet (`'a'` to `'z'`) **at least once**.\n  * `1 <= message.length <= 2000`\n  * `message` consists of lowercase English letters and `' '`.\n\n",// Runtime: 32 ms (Top 94.64%) | Memory: 17.30 MB (Top 36.34%)\n\nclass Solution:\n    def decodeMessage(self key: str message: str) -> str:\n        mapping = {' ': ' '}\n        i = 0\n        res = ''\n        letters = 'abcdefghijklmnopqrstuvwxyz'\n        \n        for char in key:\n            if char not in mapping:\n                mapping[char] = letters[i]\n                i += 1\n        \n        for char in message:\n            res += mapping[char]\n                \n        return res
Decode the Slanted Ciphertext,"###  2075\. Decode the Slanted Ciphertext\n\nA string `originalText` is encoded using a **slanted transposition cipher** to\na string `encodedText` with the help of a matrix having a **fixed number of\nrows** `rows`.\n\n`originalText` is placed first in a top-left to bottom-right manner.\n\n![](https://assets.leetcode.com/uploads/2021/11/07/exa11.png)\n\nThe blue cells are filled first followed by the red cells then the yellow\ncells and so on until we reach the end of `originalText`. The arrow\nindicates the order in which the cells are filled. All empty cells are filled\nwith `' '`. The number of columns is chosen such that the rightmost column\nwill **not be empty** after filling in `originalText`.\n\n`encodedText` is then formed by appending all characters of the matrix in a\nrow-wise fashion.\n\n![](https://assets.leetcode.com/uploads/2021/11/07/exa12.png)\n\nThe characters in the blue cells are appended first to `encodedText` then the\nred cells and so on and finally the yellow cells. The arrow indicates the\norder in which the cells are accessed.\n\nFor example if `originalText = ""cipher""` and `rows = 3` then we encode it in\nthe following manner:\n\n![](https://assets.leetcode.com/uploads/2021/10/25/desc2.png)\n\nThe blue arrows depict how `originalText` is placed in the matrix and the red\narrows denote the order in which `encodedText` is formed. In the above\nexample `encodedText = ""ch ie pr""`.\n\nGiven the encoded string `encodedText` and number of rows `rows` return _the\noriginal string_ `originalText`.\n\n**Note:** `originalText` **does not** have any trailing spaces `' '`. The test\ncases are generated such that there is only one possible `originalText`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** encodedText = ""ch   ie   pr"" rows = 3\n    **Output:** ""cipher""\n    **Explanation:** This is the same example described in the problem description.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/10/26/exam1.png)\n\n    \n    \n    **Input:** encodedText = ""iveo    eed   l te   olc"" rows = 4\n    **Output:** ""i love leetcode""\n    **Explanation:** The figure above denotes the matrix that was used to encode originalText. \n    The blue arrows show how we can find originalText from encodedText.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/10/26/eg2.png)\n\n    \n    \n    **Input:** encodedText = ""coding"" rows = 1\n    **Output:** ""coding""\n    **Explanation:** Since there is only 1 row both originalText and encodedText are the same.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= encodedText.length <= 106`\n  * `encodedText` consists of lowercase English letters and `' '` only.\n  * `encodedText` is a valid encoding of some `originalText` that **does not** have trailing spaces.\n  * `1 <= rows <= 1000`\n  * The testcases are generated such that there is **only one** possible `originalText`.\n\n","class Solution:\n    def decodeCiphertext(self encodedText: str rows: int) -> str:\n        n = len(encodedText)\n        cols = n // rows\n        step = cols + 1\n        res = """"\n        \n        for i in range(cols):\n            for j in range(i n step):\n                res += encodedText[j]\n            \n        return res.rstrip()"
Decode Ways,"###  91\. Decode Ways\n\nA message containing letters from `A-Z` can be **encoded** into numbers using\nthe following mapping:\n\n    \n    \n    'A' -> ""1""\n    'B' -> ""2""\n    ...\n    'Z' -> ""26""\n    \n\nTo **decode** an encoded message all the digits must be grouped then mapped\nback into letters using the reverse of the mapping above (there may be\nmultiple ways). For example `""11106""` can be mapped into:\n\n  * `""AAJF""` with the grouping `(1 1 10 6)`\n  * `""KJF""` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `""06""` cannot be mapped\ninto `'F'` since `""6""` is different from `""06""`.\n\nGiven a string `s` containing only digits return _the**number** of ways to\n**decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""12""\n    **Output:** 2\n    **Explanation:** ""12"" could be decoded as ""AB"" (1 2) or ""L"" (12).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""226""\n    **Output:** 3\n    **Explanation:** ""226"" could be decoded as ""BZ"" (2 26) ""VF"" (22 6) or ""BBF"" (2 2 6).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""06""\n    **Output:** 0\n    **Explanation:** ""06"" cannot be mapped to ""F"" because of the leading zero (""6"" is different from ""06"").\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s` contains only digits and may contain leading zero(s).\n\n",# Runtime: 48 ms (Top 59.57%) | Memory: 14.1 MB (Top 30.54%)\nclass Solution:\n    def numDecodings(self s: str) -> int:\n        if s[0] == '0' or '00' in s:\n            return 0\n        l = len(s)\n        if l == 1:\n            return 1\n        elif l == 2:\n            if s[1] == '0':\n                if s[0] == '1' or s[0] == '2':\n                    return 1\n                else:\n                    return 0\n            else:\n                if int(s) <= 26:\n                    return 2\n                else:\n                    return 1\n        dp = [1]\n        if s[1] == '0':\n            if s[0] == '1' or s[0] == '2':\n                dp.append(1)\n            else:\n                return 0\n        else:\n            if int(s[:2]) <= 26:\n                dp.append(2)\n            else:\n                dp.append(1)\n        for i in range(2 l):\n            num = 0\n            if s[i] == '0':\n                if s[i-1] != '1' and s[i-1] != '2':\n                    return 0\n                else:\n                    num = dp[i-2]\n            elif s[i-1] == '1' or (s[i-1] == '2' and int(f'{s[i-1]}{s[i]}') <= 26):\n                num = dp[i-1]+dp[i-2]\n            else:\n                num = dp[i-1]\n            dp.append(num)\n        return dp[l-1]
Decode Ways II,"###  639\. Decode Ways II\n\nA message containing letters from `A-Z` can be **encoded** into numbers using\nthe following mapping:\n\n    \n    \n    'A' -> ""1""\n    'B' -> ""2""\n    ...\n    'Z' -> ""26""\n    \n\nTo **decode** an encoded message all the digits must be grouped then mapped\nback into letters using the reverse of the mapping above (there may be\nmultiple ways). For example `""11106""` can be mapped into:\n\n  * `""AAJF""` with the grouping `(1 1 10 6)`\n  * `""KJF""` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `""06""` cannot be mapped\ninto `'F'` since `""6""` is different from `""06""`.\n\n**In addition** to the mapping above an encoded message may contain the `'*'`\ncharacter which can represent any digit from `'1'` to `'9'` (`'0'` is\nexcluded). For example the encoded message `""1*""` may represent any of the\nencoded messages `""11""` `""12""` `""13""` `""14""` `""15""` `""16""` `""17""`\n`""18""` or `""19""`. Decoding `""1*""` is equivalent to decoding **any** of the\nencoded messages it can represent.\n\nGiven a string `s` consisting of digits and `'*'` characters return\n_the**number** of ways to **decode** it_.\n\nSince the answer may be very large return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""*""\n    **Output:** 9\n    **Explanation:** The encoded message can represent any of the encoded messages ""1"" ""2"" ""3"" ""4"" ""5"" ""6"" ""7"" ""8"" or ""9"".\n    Each of these can be decoded to the strings ""A"" ""B"" ""C"" ""D"" ""E"" ""F"" ""G"" ""H"" and ""I"" respectively.\n    Hence there are a total of 9 ways to decode ""*"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""1*""\n    **Output:** 18\n    **Explanation:** The encoded message can represent any of the encoded messages ""11"" ""12"" ""13"" ""14"" ""15"" ""16"" ""17"" ""18"" or ""19"".\n    Each of these encoded messages have 2 ways to be decoded (e.g. ""11"" can be decoded to ""AA"" or ""K"").\n    Hence there are a total of 9 * 2 = 18 ways to decode ""1*"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""2*""\n    **Output:** 15\n    **Explanation:** The encoded message can represent any of the encoded messages ""21"" ""22"" ""23"" ""24"" ""25"" ""26"" ""27"" ""28"" or ""29"".\n    ""21"" ""22"" ""23"" ""24"" ""25"" and ""26"" have 2 ways of being decoded but ""27"" ""28"" and ""29"" only have 1 way.\n    Hence there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode ""2*"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is a digit or `'*'`.\n\n",# Runtime: 180 ms (Top 97.4%) | Memory: 21.20 MB (Top 53.7%)\n\nclass Solution:\n    def numDecodings(self s: str):\n        if s[0] == '0': return 0\n        cMap = {'0':0 '*': 9 '**': 15 '1*': 9 '2*': 6} #{char(s) : multiplier} mapping\n        for i in range(1 27): cMap[str(i)] = 1\n        for i in range(0 7): cMap['*'+str(i)] = 2\n        for i in range(7 10): cMap['*'+str(i)] = 1\n        \n        dp = [0]*(len(s)+1)\n        dp[0] dp[-1] = cMap[s[0]]  1\n        \n        for i in range(1 len(s)):\n            dp[i] += (cMap[s[i]]*dp[i-1] + cMap.get(s[i-1:i+1]0)*dp[i-2])%(10**9 + 7)\n            if not dp[i]: return 0\n            \n        return dp[-2]
Decode XORed Array,###  1720\. Decode XORed Array\n\nThere is a **hidden** integer array `arr` that consists of `n` non-negative\nintegers.\n\nIt was encoded into another integer array `encoded` of length `n - 1` such\nthat `encoded[i] = arr[i] XOR arr[i + 1]`. For example if `arr = [1021]`\nthen `encoded = [123]`.\n\nYou are given the `encoded` array. You are also given an integer `first` that\nis the first element of `arr` i.e. `arr[0]`.\n\nReturn _the original array_ `arr`. It can be proved that the answer exists and\nis unique.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** encoded = [123] first = 1\n    **Output:** [1021]\n    **Explanation:** If arr = [1021] then first = 1 and encoded = [1 XOR 0 0 XOR 2 2 XOR 1] = [123]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** encoded = [6273] first = 4\n    **Output:** [42074]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 104`\n  * `encoded.length == n - 1`\n  * `0 <= encoded[i] <= 105`\n  * `0 <= first <= 105`\n\n,class Solution:\n    def decode(self encoded: List[int] first: int) -> List[int]:\n        return [first] + [first:= first ^ x for x in encoded]\n
Decode XORed Permutation,###  1734\. Decode XORed Permutation\n\nThere is an integer array `perm` that is a permutation of the first `n`\npositive integers where `n` is always **odd**.\n\nIt was encoded into another integer array `encoded` of length `n - 1` such\nthat `encoded[i] = perm[i] XOR perm[i + 1]`. For example if `perm = [132]`\nthen `encoded = [21]`.\n\nGiven the `encoded` array return _the original array_ `perm`. It is\nguaranteed that the answer exists and is unique.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** encoded = [31]\n    **Output:** [123]\n    **Explanation:** If perm = [123] then encoded = [1 XOR 22 XOR 3] = [31]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** encoded = [6546]\n    **Output:** [24153]\n    \n\n\n\n**Constraints:**\n\n  * `3 <= n < 105`\n  * `n` is odd.\n  * `encoded.length == n - 1`\n\n,# Runtime: 1921 ms (Top 32.18%) | Memory: 33.8 MB (Top 16.09%)\n\nfrom functools import reduce\nfrom operator import xor\n\nclass Solution:\n\n    def decode(self encoded: List[int]) -> List[int]:\n        n = len(encoded) + 1\n        a = reduce(xor range(1 n+1))\n        b = reduce(xor encoded[1::2])\n        result = [a ^ b]\n        for y in encoded:\n            result.append(result[-1] ^ y)\n        return result
Decoded String at Index,"###  880\. Decoded String at Index\n\nYou are given an encoded string `s`. To decode the string to a tape the\nencoded string is read one character at a time and the following steps are\ntaken:\n\n  * If the character read is a letter that letter is written onto the tape.\n  * If the character read is a digit `d` the entire current tape is repeatedly written `d - 1` more times in total.\n\nGiven an integer `k` return _the_`kth` _letter (**1-indexed)** in the decoded\nstring_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""leet2code3"" k = 10\n    **Output:** ""o""\n    **Explanation:** The decoded string is ""leetleetcodeleetleetcodeleetleetcode"".\n    The 10th letter in the string is ""o"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""ha22"" k = 5\n    **Output:** ""h""\n    **Explanation:** The decoded string is ""hahahaha"".\n    The 5th letter is ""h"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""a2345678999999999999999"" k = 1\n    **Output:** ""a""\n    **Explanation:** The decoded string is ""a"" repeated 8301530446056247680 times.\n    The 1st letter is ""a"".\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 100`\n  * `s` consists of lowercase English letters and digits `2` through `9`.\n  * `s` starts with a letter.\n  * `1 <= k <= 109`\n  * It is guaranteed that `k` is less than or equal to the length of the decoded string.\n  * The decoded string is guaranteed to have less than `263` letters.\n\n",class Solution:\n    def decodeAtIndex(self S: str K: int) -> str:\n        idx = {}\n        acclens = [0]\n        prevd = 1\n        j = 0\n        for i c in enumerate(S + '1'):\n            if c.isalpha():\n                idx[acclens[-1] * prevd + j] = i\n                j += 1\n            else:\n                acclens.append(acclens[-1] * prevd + j)\n                prevd = int(c)\n                j = 0\n        k = K - 1\n        for al in reversed(acclens[1:]):\n            k %= al\n            if k in idx:\n                return S[idx[k]]\n        return None  # should never reach this\n
Decompress Run-Length Encoded List,###  1313\. Decompress Run-Length Encoded List\n\nWe are given a list `nums` of integers representing a list compressed with\nrun-length encoding.\n\nConsider each adjacent pair of elements `[freq val] = [nums[2*i]\nnums[2*i+1]]` (with `i >= 0`).  For each such pair there are `freq` elements\nwith value `val` concatenated in a sublist. Concatenate all the sublists from\nleft to right to generate the decompressed list.\n\nReturn the decompressed list.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** [2444]\n    **Explanation:** The first pair [12] means we have freq = 1 and val = 2 so we generate the array [2].\n    The second pair [34] means we have freq = 3 and val = 4 so we generate [444].\n    At the end the concatenation [2] + [444] is [2444].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1123]\n    **Output:** [133]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 100`\n  * `nums.length % 2 == 0`\n  * `1 <= nums[i] <= 100`\n\n,class Solution:\n    def decompressRLElist(self nums: List[int]) -> List[int]:\n        answer = []\n        \n        for i in range(0 len(nums) 2):\n            for j in range(0 nums[i]):\n                answer.append(nums[i + 1])\n        \n        return answer\n
Decrypt String from Alphabet to Integer Mapping,"###  1309\. Decrypt String from Alphabet to Integer Mapping\n\nYou are given a string `s` formed by digits and `'#'`. We want to map `s` to\nEnglish lowercase characters as follows:\n\n  * Characters (`'a'` to `'i'`) are represented by (`'1'` to `'9'`) respectively.\n  * Characters (`'j'` to `'z'`) are represented by (`'10#'` to `'26#'`) respectively.\n\nReturn _the string formed after mapping_.\n\nThe test cases are generated so that a unique mapping will always exist.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""10#11#12""\n    **Output:** ""jkab""\n    **Explanation:** ""j"" -> ""10#""  ""k"" -> ""11#""  ""a"" -> ""1""  ""b"" -> ""2"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""1326#""\n    **Output:** ""acz""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s` consists of digits and the `'#'` letter.\n  * `s` will be a valid string such that mapping is always possible.\n\n","class Solution:\n    def freqAlphabets(self s: str) -> str:\n        for i in range(260-1): s = s.replace(str(i)+""#""*(i>9)chr(96+i))\n        return s"
Deepest Leaves Sum,###  1302\. Deepest Leaves Sum\n\nGiven the `root` of a binary tree return _the sum of values of its deepest\nleaves_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png)\n\n    \n    \n    **Input:** root = [12345null67nullnullnullnull8]\n    **Output:** 15\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [67827139null14nullnullnull5]\n    **Output:** 19\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `1 <= Node.val <= 100`\n\n,"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    \n    """"""\n    THOUGHT PROCESS:\n        1) find the height of the tree this way we would know how deep we need to go.\n        2) we need a counter to check how deep we are and this is not available in deepestLeavesSum so we create a new function deepestLeave.\n        3) now we go in depth if we are at bottom we return the value we recursively visit both left and right nodes.\n        \n    """"""\n    \n    def height(self root):\n        if root is None:\n            return 0\n        else:\n            x y = 1 1\n            if root.left:\n                x = self.height(root.left)+1\n            if root.right:\n                y = self.height(root.right)+1\n            \n            return max(x y)\n            \n    \n    def deepestLeave(self root depth):\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            if depth == 1:\n                return root.val\n        \n        return self.deepestLeave(root.left depth-1) + self.deepestLeave(root.right depth-1)\n    \n    def deepestLeavesSum(self root):\n        """"""\n        :type root: TreeNode\n        :rtype: int\n        """"""\n        return self.deepestLeave(root self.height(root))\n        \n        \n        \n        \n        \n"
Defanging an IP Address,"###  1108\. Defanging an IP Address\n\nGiven a valid (IPv4) IP `address` return a defanged version of that IP\naddress.\n\nA _defanged  IP address_ replaces every period `"".""` with `""[.]""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** address = ""1.1.1.1""\n    **Output:** ""1[.]1[.]1[.]1""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** address = ""255.100.50.0""\n    **Output:** ""255[.]100[.]50[.]0""\n    \n\n\n\n**Constraints:**\n\n  * The given `address` is a valid IPv4 address.\n\n","// Runtime: 46 ms (Top 6.11%) | Memory: 16.10 MB (Top 75.91%)\n\nclass Solution:\n	def defangIPaddr(self address: str) -> str:\n		return address.replace('.' '[.]')\n"
Delete and Earn,###  740\. Delete and Earn\n\nYou are given an integer array `nums`. You want to maximize the number of\npoints you get by performing the following operation any number of times:\n\n  * Pick any `nums[i]` and delete it to earn `nums[i]` points. Afterwards you must delete **every** element equal to `nums[i] - 1` and **every** element equal to `nums[i] + 1`.\n\nReturn _the**maximum number of points** you can earn by applying the above\noperation some number of times_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [342]\n    **Output:** 6\n    **Explanation:** You can perform the following operations:\n    - Delete 4 to earn 4 points. Consequently 3 is also deleted. nums = [2].\n    - Delete 2 to earn 2 points. nums = [].\n    You earn a total of 6 points.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [223334]\n    **Output:** 9\n    **Explanation:** You can perform the following operations:\n    - Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [33].\n    - Delete a 3 again to earn 3 points. nums = [3].\n    - Delete a 3 once more to earn 3 points. nums = [].\n    You earn a total of 9 points.\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 104`\n  * `1 <= nums[i] <= 104`\n\n,class Solution:\n    def deleteAndEarn(self nums: List[int]) -> int:\n        count = Counter(nums)\n        m = max(nums)\n        memo = {}\n        def choose(num):\n            if num > m:\n                return 0\n            if num not in count:\n                count[num] = 0\n            if num in memo:\n                return memo[num]\n            memo[num] = max(choose(num + 1) num * count[num] + choose(num + 2))\n            return memo[num]\n        \n        return choose(1)\n\n# time and space complexity\n# n = max(nums)\n# time: O(n)\n# space: O(n)\n            \n            \n
Delete Characters to Make Fancy String,"###  1957\. Delete Characters to Make Fancy String\n\nA **fancy string** is a string where no **three** **consecutive** characters\nare equal.\n\nGiven a string `s` delete the **minimum** possible number of characters from\n`s` to make it **fancy**.\n\nReturn _the final string after the deletion_. It can be shown that the answer\nwill always be **unique**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""le _e_ etcode""\n    **Output:** ""leetcode""\n    **Explanation:**\n    Remove an 'e' from the first group of 'e's to create ""leetcode"".\n    No three consecutive characters are equal so return ""leetcode"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""_a_ aab _aa_ aa""\n    **Output:** ""aabaa""\n    **Explanation:**\n    Remove an 'a' from the first group of 'a's to create ""aabaaaa"".\n    Remove two 'a's from the second group of 'a's to create ""aabaa"".\n    No three consecutive characters are equal so return ""aabaa"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""aab""\n    **Output:** ""aab""\n    **Explanation:** No three consecutive characters are equal so return ""aab"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists only of lowercase English letters.\n\n",class Solution:\n    def makeFancyString(self s: str) -> str:\n        if len(s) < 3:\n            return s\n        ans = ''\n        ans += s[0]\n        ans += s[1]\n        for i in range(2len(s)):\n            if s[i] != ans[-1] or s[i] != ans[-2]:\n                ans += s[i]\n        return ans\n
Delete Columns to Make Sorted,"###  944\. Delete Columns to Make Sorted\n\nYou are given an array of `n` strings `strs` all of the same length.\n\nThe strings can be arranged such that there is one on each line making a\ngrid. For example `strs = [""abc"" ""bce"" ""cae""]` can be arranged as:\n\n    \n    \n    abc\n    bce\n    cae\n    \n\nYou want to **delete** the columns that are **not sorted lexicographically**.\nIn the above example (0-indexed) columns 0 (`'a'` `'b'` `'c'`) and 2\n(`'c'` `'e'` `'e'`) are sorted while column 1 (`'b'` `'c'` `'a'`) is not\nso you would delete column 1.\n\nReturn _the number of columns that you will delete_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** strs = [""cba""""daf""""ghi""]\n    **Output:** 1\n    **Explanation:** The grid looks as follows:\n      cba\n      daf\n      ghi\n    Columns 0 and 2 are sorted but column 1 is not so you only need to delete 1 column.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** strs = [""a""""b""]\n    **Output:** 0\n    **Explanation:** The grid looks as follows:\n      a\n      b\n    Column 0 is the only column and is sorted so you will not delete any columns.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** strs = [""zyx""""wvu""""tsr""]\n    **Output:** 3\n    **Explanation:** The grid looks as follows:\n      zyx\n      wvu\n      tsr\n    All 3 columns are not sorted so you will delete all 3.\n    \n\n\n\n**Constraints:**\n\n  * `n == strs.length`\n  * `1 <= n <= 100`\n  * `1 <= strs[i].length <= 1000`\n  * `strs[i]` consists of lowercase English letters.\n\n",# Runtime: 330 ms (Top 23.27%) | Memory: 14.6 MB (Top 66.82%)\n\nclass Solution:\n    def minDeletionSize(self strs: List[str]) -> int:\n\n        cols={}\n        l=len(strs)\n        l_s = len(strs[0])\n        delete = set()\n        for i in range(l):\n            for col in range(l_s):\n                if col in cols:\n                    if cols[col]>strs[i][col]:\n                        delete.add(col)\n                cols[col] = strs[i][col]\n        return len(delete)
Delete Columns to Make Sorted II,"###  955\. Delete Columns to Make Sorted II\n\nYou are given an array of `n` strings `strs` all of the same length.\n\nWe may choose any deletion indices and we delete all the characters in those\nindices for each string.\n\nFor example if we have `strs = [""abcdef""""uvwxyz""]` and deletion indices `{0\n2 3}` then the final array after deletions is `[""bef"" ""vyz""]`.\n\nSuppose we chose a set of deletion indices `answer` such that after deletions\nthe final array has its elements in **lexicographic** order (i.e. `strs[0] <=\nstrs[1] <= strs[2] <= ... <= strs[n - 1]`). Return _the minimum possible value\nof_ `answer.length`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** strs = [""ca""""bb""""ac""]\n    **Output:** 1\n    **Explanation:** \n    After deleting the first column strs = [""a"" ""b"" ""c""].\n    Now strs is in lexicographic order (ie. strs[0] <= strs[1] <= strs[2]).\n    We require at least 1 deletion since initially strs was not in lexicographic order so the answer is 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** strs = [""xc""""yb""""za""]\n    **Output:** 0\n    **Explanation:** \n    strs is already in lexicographic order so we do not need to delete anything.\n    Note that the rows of strs are not necessarily in lexicographic order:\n    i.e. it is NOT necessarily true that (strs[0][0] <= strs[0][1] <= ...)\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** strs = [""zyx""""wvu""""tsr""]\n    **Output:** 3\n    **Explanation:** We have to delete every column.\n    \n\n\n\n**Constraints:**\n\n  * `n == strs.length`\n  * `1 <= n <= 100`\n  * `1 <= strs[i].length <= 100`\n  * `strs[i]` consists of lowercase English letters.\n\n",class Solution:\n    def minDeletionSize(self strs: List[str]) -> int:\n        n = len(strs)\n        col_size = len(strs[0])\n        # a b c d e f g h i j k l m n o p q r s t u v w x y z\n        \n        i = 0\n        ans = 0\n        \n        def getRemoved(idx):\n             # removing the idx column \n            for x in range(n):           \n                strs[x] = strs[x][:idx] + strs[x][idx+1:]\n        \n        while i < col_size:\n            tmp = strs[0][:i+1]\n            flag = True\n            similar = False\n            \n            for j in range(1n):                 \n                if  strs[j][:i+1] < tmp :\n                    # previous element is larger ( unsorted )\n                    flag = False\n                    break\n                \n                elif strs[j][:i+1] > tmp : \n                    # previous element is smaller ( sorted )\n                    tmp = strs[j][:i+1]\n                \n                else:\n                    # previous element is equal ( not clear )\n                    tmp = strs[j][:i+1]\n                    similar = True\n            \n            if flag == True and similar == False:\n                # all are sorted and we are ready to return ans\n                return ans\n            \n            elif flag == True and similar == True:\n                # all are sorted but can't be decided for further columns. check for next col\n                i += 1\n            \n            elif flag == False:\n                # unsorted column = removal\n                getRemoved(i)\n                # increment the answer and since we removed i th col decrement col_size\n                ans += 1\n                col_size -= 1\n        \n        return ans\n
Delete Columns to Make Sorted III,"###  960\. Delete Columns to Make Sorted III\n\nYou are given an array of `n` strings `strs` all of the same length.\n\nWe may choose any deletion indices and we delete all the characters in those\nindices for each string.\n\nFor example if we have `strs = [""abcdef""""uvwxyz""]` and deletion indices `{0\n2 3}` then the final array after deletions is `[""bef"" ""vyz""]`.\n\nSuppose we chose a set of deletion indices `answer` such that after deletions\nthe final array has **every string (row) in lexicographic** order. (i.e.\n`(strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1])` and\n`(strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1])` and so\non). Return _the minimum possible value of_ `answer.length`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** strs = [""babca""""bbazb""]\n    **Output:** 3\n    **Explanation:** After deleting columns 0 1 and 4 the final array is strs = [""bc"" ""az""].\n    Both these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]).\n    Note that strs[0] > strs[1] - the array strs is not necessarily in lexicographic order.\n\n**Example 2:**\n\n    \n    \n    **Input:** strs = [""edcba""]\n    **Output:** 4\n    **Explanation:** If we delete less than 4 columns the only row will not be lexicographically sorted.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** strs = [""ghi""""def""""abc""]\n    **Output:** 0\n    **Explanation:** All rows are already lexicographically sorted.\n    \n\n\n\n**Constraints:**\n\n  * `n == strs.length`\n  * `1 <= n <= 100`\n  * `1 <= strs[i].length <= 100`\n  * `strs[i]` consists of lowercase English letters.\n\n  *  \n\n",// Runtime: 83 ms (Top 95.45%) | Memory: 16.80 MB (Top 79.55%)\n\nclass Solution:\n    def minDeletionSize(self strs: List[str]) -> int:\n        n = len(strs[0])\n        dp = [1] * n\n        for i in range(1 n):\n            for j in range(i):\n                valid = True\n                for a in strs:\n                    if a[j] > a[i]: \n                        valid = False\n                        break\n                if valid:\n                    dp[i] = max(dp[i] dp[j] + 1)\n        return n - max(dp)\n
Delete Duplicate Folders in System,"###  1948\. Delete Duplicate Folders in System\n\nDue to a bug there are many duplicate folders in a file system. You are given\na 2D array `paths` where `paths[i]` is an array representing an absolute path\nto the `ith` folder in the file system.\n\n  * For example `[""one"" ""two"" ""three""]` represents the path `""/one/two/three""`.\n\nTwo folders (not necessarily on the same level) are **identical** if they\ncontain the **same non-empty** set of identical subfolders and underlying\nsubfolder structure. The folders **do not** need to be at the root level to be\nidentical. If two or more folders are **identical**  then **mark** the\nfolders as well as all their subfolders.\n\n  * For example folders `""/a""` and `""/b""` in the file structure below are identical. They (as well as their subfolders) should **all** be marked: \n    * `/a`\n    * `/a/x`\n    * `/a/x/y`\n    * `/a/z`\n    * `/b`\n    * `/b/x`\n    * `/b/x/y`\n    * `/b/z`\n  * However if the file structure also included the path `""/b/w""` then the folders `""/a""` and `""/b""` would not be identical. Note that `""/a/x""` and `""/b/x""` would still be considered identical even with the added folder.\n\nOnce all the identical folders and their subfolders have been marked the file\nsystem will **delete** all of them. The file system only runs the deletion\nonce so any folders that become identical after the initial deletion are not\ndeleted.\n\nReturn _the 2D array_`ans` _containing the paths of the**remaining** folders\nafter deleting all the marked folders. The paths may be returned in **any**\norder_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder1.jpg)\n\n    \n    \n    **Input:** paths = [[""a""][""c""][""d""][""a""""b""][""c""""b""][""d""""a""]]\n    **Output:** [[""d""][""d""""a""]]\n    **Explanation:** The file structure is as shown.\n    Folders ""/a"" and ""/c"" (and their subfolders) are marked for deletion because they both contain an empty\n    folder named ""b"".\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder2.jpg)\n\n    \n    \n    **Input:** paths = [[""a""][""c""][""a""""b""][""c""""b""][""a""""b""""x""][""a""""b""""x""""y""][""w""][""w""""y""]]\n    **Output:** [[""c""][""c""""b""][""a""][""a""""b""]]\n    **Explanation:** The file structure is as shown. \n    Folders ""/a/b/x"" and ""/w"" (and their subfolders) are marked for deletion because they both contain an empty folder named ""y"".\n    Note that folders ""/a"" and ""/c"" are identical after the deletion but they are not deleted because they were not marked beforehand.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/07/19/lc-dupfolder3.jpg)\n\n    \n    \n    **Input:** paths = [[""a""""b""][""c""""d""][""c""][""a""]]\n    **Output:** [[""c""][""c""""d""][""a""][""a""""b""]]\n    **Explanation:** All folders are unique in the file system.\n    Note that the returned array can be in a different order as the order does not matter.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= paths.length <= 2 * 104`\n  * `1 <= paths[i].length <= 500`\n  * `1 <= paths[i][j].length <= 10`\n  * `1 <= sum(paths[i][j].length) <= 2 * 105`\n  * `path[i][j]` consists of lowercase English letters.\n  * No two paths lead to the same folder.\n  * For any folder not at the root level its parent folder will also be in the input.\n\n",class Node:\n    def __init__(self):\n        self.children = defaultdict(Node)\n        self.hash = ''\n        self.deleted = False\n    \n    def add(self path i=0):\n        if i != len(path):\n            self.children[path[i]].add(path i + 1)\n            \n    def calc_hash(self hashes name='root'):\n        for child_name child in sorted(self.children.items()):\n            self.hash += f'{child.calc_hash(hashes child_name)}+'\n        if self.hash:\n            hashes[self.hash].append(self)\n        return f'{name}({self.hash})'\n    \n    def to_list(self lst path=[]):\n        for name node in self.children.items():\n            if not node.deleted:\n                lst.append(path + [name])\n                node.to_list(lst path + [name])\n\nclass Solution:\n    def deleteDuplicateFolder(self paths: List[List[str]]) -> List[List[str]]:\n        root = Node()\n        for path in paths:\n            root.add(path)\n        hash_to_nodes = defaultdict(list)\n        root.calc_hash(hash_to_nodes)\n        for nodes in hash_to_nodes.values():\n            if len(nodes) > 1:\n                for node in nodes:\n                    node.deleted = True\n        res = []\n        root.to_list(res)\n        return res\n
Delete Node in a BST,###  450\. Delete Node in a BST\n\nGiven a root node reference of a BST and a key delete the node with the given\nkey in the BST. Return _the**root node reference** (possibly updated) of the\nBST_.\n\nBasically the deletion can be divided into two stages:\n\n  1. Search for a node to remove.\n  2. If the node is found delete the node.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)\n\n    \n    \n    **Input:** root = [53624null7] key = 3\n    **Output:** [5462nullnull7]\n    **Explanation:** Given key to delete is 3. So we find the node with value 3 and delete it.\n    One valid answer is [5462nullnull7] shown in the above BST.\n    Please notice that another valid answer is [526null4null7] and it's also accepted.\n    ![](https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [53624null7] key = 0\n    **Output:** [53624null7]\n    **Explanation:** The tree does not contain a node with value = 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [] key = 0\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 104]`.\n  * `-105 <= Node.val <= 105`\n  * Each node has a **unique** value.\n  * `root` is a valid binary search tree.\n  * `-105 <= key <= 105`\n\n\n\n**Follow up:** Could you solve it with time complexity `O(height of tree)`?\n\n,"\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\ndef deleteNode(self root: Optional[TreeNode] key: int) -> Optional[TreeNode]:\n\ndef find_inorder(root key):\n\n	if root is None :\n		return []\n\n	return find_inorder(root.left key) + [root.val] + find_inorder(root.right key)\n\ndef find_preorder(root key):\n\n	if root is None:\n		return []\n\n	return [root.val] + find_preorder(root.leftkey) + find_preorder(root.right key)\n\npreorder = find_preorder(root key)\n\ntry:\n	preorder.remove(key)\nexcept:\n	return root\n\ninorder = find_inorder(root key)\n\ninorder.remove(key)\n\n\n\n\nhashmap = {}\n\nfor i in range(len(inorder)):\n	key = inorder[i]\n	hashmap[key] = i\n\ndef buildTree(left right):\n\n	if left > right:\n		return \n\n	val = inorder[left]\n	root = TreeNode(val)\n\n	index = hashmap[val]\n\n	root.left = buildTree(left index-1)\n	root.right = buildTree(index+1 right)\n\n	return root\n\nN = len(inorder)\nnew_tree = buildTree(0N-1)\n\nreturn new_tree\n\n\n"
Delete Node in a Linked List,###  237\. Delete Node in a Linked List\n\nWrite a function to **delete a node** in a singly-linked list. You will\n**not** be given access to the `head` of the list instead you will be given\naccess to **the node to be deleted** directly.\n\nIt is **guaranteed** that the node to be deleted is **not a tail node** in the\nlist.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/01/node1.jpg)\n\n    \n    \n    **Input:** head = [4519] node = 5\n    **Output:** [419]\n    **Explanation:** You are given the second node with value 5 the linked list should become 4 -> 1 -> 9 after calling your function.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/01/node2.jpg)\n\n    \n    \n    **Input:** head = [4519] node = 1\n    **Output:** [459]\n    **Explanation:** You are given the third node with value 1 the linked list should become 4 -> 5 -> 9 after calling your function.\n    \n\n\n\n**Constraints:**\n\n  * The number of the nodes in the given list is in the range `[2 1000]`.\n  * `-1000 <= Node.val <= 1000`\n  * The value of each node in the list is **unique**.\n  * The `node` to be deleted is **in the list** and is **not a tail** node\n\n,// Runtime: 39 ms (Top 87.58%) | Memory: 17.70 MB (Top 6.02%)\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteNode(self node):\n        node.val = node.next.val\n        node.next = node.next.next\n
Delete Nodes And Return Forest,###  1110\. Delete Nodes And Return Forest\n\nGiven the `root` of a binary tree each node in the tree has a distinct value.\n\nAfter deleting all nodes with a value in `to_delete` we are left with a\nforest (a disjoint union of trees).\n\nReturn the roots of the trees in the remaining forest. You may return the\nresult in any order.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/07/01/screen-\nshot-2019-07-01-at-53836-pm.png)\n\n    \n    \n    **Input:** root = [1234567] to_delete = [35]\n    **Output:** [[12null4][6][7]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [124null3] to_delete = [3]\n    **Output:** [[124]]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the given tree is at most `1000`.\n  * Each node has a distinct value between `1` and `1000`.\n  * `to_delete.length <= 1000`\n  * `to_delete` contains distinct values between `1` and `1000`.\n\n,# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def traverse(selfnodepar):\n        if node:\n            self.parent[node.val] = par\n            self.traverse(node.leftnode)\n            self.traverse(node.rightnode)\n            \n    def deleteNode(selftoDelete):\n                node = None\n                par = self.parent[toDelete]\n                if par.val == toDelete:\n                    node = par\n                elif par.left and par.left.val == toDelete:\n                    node = par.left\n                elif par.right and par.right.val == toDelete:\n                    node = par.right\n                if node.left:  \n                    self.unique[node.left] = True\n                if node.right: \n                    self.unique[node.right] = True\n                    \n                if node in self.unique: self.unique.pop(node)\n                if node != self.parent[toDelete]:\n                    if par.left == node: par.left = None\n                    else: par.right = None\n\n    \n    def delNodes(self root: Optional[TreeNode] to_delete: List[int]) -> List[TreeNode]:\n        self.parent = {}\n        self.traverse(rootroot)\n        self.unique = {root:True}\n        for node in to_delete:\n                self.deleteNode(node)\n        return self.unique\n
Delete Operation for Two Strings,"###  583\. Delete Operation for Two Strings\n\nGiven two strings `word1` and `word2` return _the minimum number of**steps**\nrequired to make_ `word1` _and_ `word2` _the same_.\n\nIn one **step**  you can delete exactly one character in either string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word1 = ""sea"" word2 = ""eat""\n    **Output:** 2\n    **Explanation:** You need one step to make ""sea"" to ""ea"" and another step to make ""eat"" to ""ea"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word1 = ""leetcode"" word2 = ""etco""\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word1.length word2.length <= 500`\n  * `word1` and `word2` consist of only lowercase English letters.\n\n","class Solution:\n    def minDistance(self word1: str word2: str) -> int:\n        m = len(word1)\n        n = len(word2)\n        a = []\n        for i in range(m+1):\n            a.append([])\n            for j in range(n+1):\n                a[-1].append(0)\n        \n        for i in range(m):\n            for j in range(n):\n                if word1[i]==word2[j]:\n                    a[i+1][j+1] = 1 + a[i][j]\n                else:\n                    a[i+1][j+1] = max( a[i][j+1] a[i+1][j])\n					\n        return m + n - ( 2 * a [-1][-1] )"
Delete the Middle Node of a Linked List,###  2095\. Delete the Middle Node of a Linked List\n\nYou are given the `head` of a linked list. **Delete** the **middle node** \nand return _the_ `head` _of the modified linked list_.\n\nThe **middle node** of a linked list of size `n` is the `⌊n / 2⌋th` node\nfrom the **start** using **0-based indexing**  where `⌊x⌋` denotes the\nlargest integer less than or equal to `x`.\n\n  * For `n` = `1` `2` `3` `4` and `5` the middle nodes are `0` `1` `1` `2` and `2` respectively.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/11/16/eg1drawio.png)\n\n    \n    \n    **Input:** head = [1347126]\n    **Output:** [134126]\n    **Explanation:**\n    The above figure represents the given linked list. The indices of the nodes are written below.\n    Since n = 7 node 3 with value 7 is the middle node which is marked in red.\n    We return the new list after removing this node. \n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/11/16/eg2drawio.png)\n\n    \n    \n    **Input:** head = [1234]\n    **Output:** [124]\n    **Explanation:**\n    The above figure represents the given linked list.\n    For n = 4 node 2 with value 3 is the middle node which is marked in red.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/11/16/eg3drawio.png)\n\n    \n    \n    **Input:** head = [21]\n    **Output:** [2]\n    **Explanation:**\n    The above figure represents the given linked list.\n    For n = 2 node 1 with value 1 is the middle node which is marked in red.\n    Node 0 with value 2 is the only node remaining after removing node 1.\n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[1 105]`.\n  * `1 <= Node.val <= 105`\n\n,# Runtime: 2948 ms (Top 45.50%) | Memory: 60.7 MB (Top 40.45%)\n# Definition for singly-linked list.\n# class ListNode:\n# def __init__(self val=0 next=None):\n# self.val = val\n# self.next = next\nclass Solution:\n  def deleteMiddle(self head: Optional[ListNode]) -> Optional[ListNode]:\n    if not head: return head\n    if head and not head.next: return None\n\n    prev = ListNode(0 head)\n    slow = fast = head\n    while fast and fast.next:\n      prev = slow\n      slow = slow.next\n      fast = fast.next.next\n\n    prev.next = slow.next\n    return head
Delivering Boxes from Storage to Ports,###  1687\. Delivering Boxes from Storage to Ports\n\nYou have the task of delivering some boxes from storage to their ports using\nonly one ship. However this ship has a **limit** on the **number of boxes**\nand the **total weight** that it can carry.\n\nYou are given an array `boxes` where `boxes[i] = [ports​​i​ weighti]`\nand three integers `portsCount` `maxBoxes` and `maxWeight`.\n\n  * `ports​​i` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.\n  * `portsCount` is the number of ports.\n  * `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.\n\nThe boxes need to be delivered **in the order they are given**. The ship will\nfollow these steps:\n\n  * The ship will take some number of boxes from the `boxes` queue not violating the `maxBoxes` and `maxWeight` constraints.\n  * For each loaded box **in order**  the ship will make a **trip** to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port no **trip** is needed and the box can immediately be delivered.\n  * The ship then makes a return **trip** to storage to take more boxes from the queue.\n\nThe ship must end at storage after all the boxes have been delivered.\n\nReturn _the**minimum** number of **trips** the ship needs to make to deliver\nall boxes to their respective ports._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** boxes = [[11][21][11]] portsCount = 2 maxBoxes = 3 maxWeight = 3\n    **Output:** 4\n    **Explanation:** The optimal strategy is as follows: \n    - The ship takes all the boxes in the queue goes to port 1 then port 2 then port 1 again then returns to storage. 4 trips.\n    So the total number of trips is 4.\n    Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** boxes = [[12][33][31][31][24]] portsCount = 3 maxBoxes = 3 maxWeight = 6\n    **Output:** 6\n    **Explanation:** The optimal strategy is as follows: \n    - The ship takes the first box goes to port 1 then returns to storage. 2 trips.\n    - The ship takes the second third and fourth boxes goes to port 3 then returns to storage. 2 trips.\n    - The ship takes the fifth box goes to port 3 then returns to storage. 2 trips.\n    So the total number of trips is 2 + 2 + 2 = 6.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** boxes = [[14][12][21][21][32][34]] portsCount = 3 maxBoxes = 6 maxWeight = 7\n    **Output:** 6\n    **Explanation:** The optimal strategy is as follows:\n    - The ship takes the first and second boxes goes to port 1 then returns to storage. 2 trips.\n    - The ship takes the third and fourth boxes goes to port 2 then returns to storage. 2 trips.\n    - The ship takes the fifth and sixth boxes goes to port 3 then returns to storage. 2 trips.\n    So the total number of trips is 2 + 2 + 2 = 6.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= boxes.length <= 105`\n  * `1 <= portsCount maxBoxes maxWeight <= 105`\n  * `1 <= ports​​i <= portsCount`\n  * `1 <= weightsi <= maxWeight`\n\n,// Runtime: 2593 ms (Top 36.11%) | Memory: 66.70 MB (Top 22.22%)\n\nfrom sortedcontainers import SortedList as MonoQueue\nclass Solution:\n    def boxDelivering(self A __ B W):\n        n = len(A)\n        def slidingWindow():\n            l=0\n            cW = 0\n            for r in range(n):\n                cW+=A[r][1]\n                while cW>W or r-l+1>B:\n                    cW-=A[l][1]\n                    l+=1\n                yield lr\n        Seg=MonoQueue(key=lambda t:t[1])\n        addAll = 0\n        olddp = 0\n        for lr in slidingWindow():\n            if r!=0:\n                addAll+= ( A[r][0]!=A[r-1][0] )\n            Seg.add((r olddp-addAll+2))\n            while Seg[0][0]<l:\n                Seg.pop(0)\n            olddp = Seg[0][1]+addAll\n        return olddp\n
Describe the Painting,###  1943\. Describe the Painting\n\nThere is a long and thin painting that can be represented by a number line.\nThe painting was painted with multiple overlapping segments where each segment\nwas painted with a **unique** color. You are given a 2D integer array\n`segments` where `segments[i] = [starti endi colori]` represents the\n**half-closed segment** `[starti endi)` with `colori` as the color.\n\nThe colors in the overlapping segments of the painting were **mixed** when it\nwas painted. When two or more colors mix they form a new color that can be\nrepresented as a **set** of mixed colors.\n\n  * For example if colors `2` `4` and `6` are mixed then the resulting mixed color is `{246}`.\n\nFor the sake of simplicity you should only output the **sum** of the elements\nin the set rather than the full set.\n\nYou want to **describe** the painting with the **minimum** number of non-\noverlapping **half-closed segments** of these mixed colors. These segments can\nbe represented by the 2D array `painting` where `painting[j] = [leftj rightj\nmixj]` describes a **half-closed segment** `[leftj rightj)` with the mixed\ncolor **sum** of `mixj`.\n\n  * For example the painting created with `segments = [[145][177]]` can be described by `painting = [[1412][477]]` because: \n    * `[14)` is colored `{57}` (with a sum of `12`) from both the first and second segments.\n    * `[47)` is colored `{7}` from only the second segment.\n\nReturn _the 2D array_`painting` _describing the finished painting (excluding\nany parts that are**not** painted). You may return the segments in **any\norder**_.\n\nA **half-closed segment** `[a b)` is the section of the number line between\npoints `a` and `b` **including** point `a` and **not including** point `b`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/18/1.png)\n\n    \n    \n    **Input:** segments = [[145][477][179]]\n    **Output:** [[1414][4716]]\n    **Explanation:** The painting can be described as follows:\n    - [14) is colored {59} (with a sum of 14) from the first and third segments.\n    - [47) is colored {79} (with a sum of 16) from the second and third segments.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/18/2.png)\n\n    \n    \n    **Input:** segments = [[179][6815][8107]]\n    **Output:** [[169][6724][7815][8107]]\n    **Explanation:** The painting can be described as follows:\n    - [16) is colored 9 from the first segment.\n    - [67) is colored {915} (with a sum of 24) from the first and second segments.\n    - [78) is colored 15 from the second segment.\n    - [810) is colored 7 from the third segment.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/07/04/c1.png)\n\n    \n    \n    **Input:** segments = [[145][147][471][4711]]\n    **Output:** [[1412][4712]]\n    **Explanation:** The painting can be described as follows:\n    - [14) is colored {57} (with a sum of 12) from the first and second segments.\n    - [47) is colored {111} (with a sum of 12) from the third and fourth segments.\n    Note that returning a single segment [17) is incorrect because the mixed color sets are different.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= segments.length <= 2 * 104`\n  * `segments[i].length == 3`\n  * `1 <= starti < endi <= 105`\n  * `1 <= colori <= 109`\n  * Each `colori` is distinct.\n\n,class Solution:\n    def splitPainting(self segments: List[List[int]]) -> List[List[int]]:\n        mix res last_i = DefaultDict(int) [] 0\n        for start end color in segments:\n            mix[start] += color\n            mix[end] -= color\n        for i in sorted(mix.keys()):\n            if last_i in mix and mix[last_i]:\n                res.append([last_i i mix[last_i]])\n                mix[i] += mix[last_i]\n            last_i = i\n        return res\n
Design a Food Rating System,"###  2353\. Design a Food Rating System\n\nDesign a food rating system that can do the following:\n\n  * **Modify** the rating of a food item listed in the system.\n  * Return the highest-rated food item for a type of cuisine in the system.\n\nImplement the `FoodRatings` class:\n\n  * `FoodRatings(String[] foods String[] cuisines int[] ratings)` Initializes the system. The food items are described by `foods` `cuisines` and `ratings` all of which have a length of `n`. \n    * `foods[i]` is the name of the `ith` food\n    * `cuisines[i]` is the type of cuisine of the `ith` food and\n    * `ratings[i]` is the initial rating of the `ith` food.\n  * `void changeRating(String food int newRating)` Changes the rating of the food item with the name `food`.\n  * `String highestRated(String cuisine)` Returns the name of the food item that has the highest rating for the given type of `cuisine`. If there is a tie return the item with the **lexicographically smaller** name.\n\nNote that a string `x` is lexicographically smaller than string `y` if `x`\ncomes before `y` in dictionary order that is either `x` is a prefix of `y`\nor if `i` is the first position such that `x[i] != y[i]` then `x[i]` comes\nbefore `y[i]` in alphabetic order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""FoodRatings"" ""highestRated"" ""highestRated"" ""changeRating"" ""highestRated"" ""changeRating"" ""highestRated""]\n    [[[""kimchi"" ""miso"" ""sushi"" ""moussaka"" ""ramen"" ""bulgogi""] [""korean"" ""japanese"" ""japanese"" ""greek"" ""japanese"" ""korean""] [9 12 8 15 14 7]] [""korean""] [""japanese""] [""sushi"" 16] [""japanese""] [""ramen"" 16] [""japanese""]]\n    **Output**\n    [null ""kimchi"" ""ramen"" null ""sushi"" null ""ramen""]\n    \n    **Explanation**\n    FoodRatings foodRatings = new FoodRatings([""kimchi"" ""miso"" ""sushi"" ""moussaka"" ""ramen"" ""bulgogi""] [""korean"" ""japanese"" ""japanese"" ""greek"" ""japanese"" ""korean""] [9 12 8 15 14 7]);\n    foodRatings.highestRated(""korean""); // return ""kimchi""\n                                        // ""kimchi"" is the highest rated korean food with a rating of 9.\n    foodRatings.highestRated(""japanese""); // return ""ramen""\n                                          // ""ramen"" is the highest rated japanese food with a rating of 14.\n    foodRatings.changeRating(""sushi"" 16); // ""sushi"" now has a rating of 16.\n    foodRatings.highestRated(""japanese""); // return ""sushi""\n                                          // ""sushi"" is the highest rated japanese food with a rating of 16.\n    foodRatings.changeRating(""ramen"" 16); // ""ramen"" now has a rating of 16.\n    foodRatings.highestRated(""japanese""); // return ""ramen""\n                                          // Both ""sushi"" and ""ramen"" have a rating of 16.\n                                          // However ""ramen"" is lexicographically smaller than ""sushi"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 2 * 104`\n  * `n == foods.length == cuisines.length == ratings.length`\n  * `1 <= foods[i].length cuisines[i].length <= 10`\n  * `foods[i]` `cuisines[i]` consist of lowercase English letters.\n  * `1 <= ratings[i] <= 108`\n  * All the strings in `foods` are **distinct**.\n  * `food` will be the name of a food item in the system across all calls to `changeRating`.\n  * `cuisine` will be a type of cuisine of **at least one** food item in the system across all calls to `highestRated`.\n  * At most `2 * 104` calls **in total** will be made to `changeRating` and `highestRated`.\n\n","from heapq import heapify heappop heappush\n\nclass RatedFood:\n    def __init__(self rating food):\n        self.rating = rating\n        self.food = food\n        \n    def __lt__(self other):\n        if other.rating == self.rating:\n            return self.food < other.food\n        return self.rating < other.rating\n\nclass FoodRatings:\n    def __init__(self foods: List[str] cuisines: List[str] ratings: List[int]):\n        self.cuis_to_score_heap = defaultdict(list)\n        self.food_to_latest_ratings = defaultdict(int)\n        self.food_to_cuis = defaultdict(str)\n        \n        for food cuis rating in zip(foods cuisines ratings):\n            self.food_to_cuis[food] = cuis\n            self.food_to_latest_ratings[food] = rating\n            heappush(self.cuis_to_score_heap[cuis] RatedFood(-rating food))\n        \n        \n\n    def changeRating(self food: str newRating: int) -> None:\n        self.food_to_latest_ratings[food] = newRating\n        cuis = self.food_to_cuis[food]\n        heappush(self.cuis_to_score_heap[cuis] RatedFood(-newRating food))\n        \n\n    def highestRated(self cuisine: str) -> str:\n        while True:\n            ratedFood = heappop(self.cuis_to_score_heap[cuisine])\n            if self.food_to_latest_ratings[ratedFood.food] == (-ratedFood.rating):\n			\n				# because the food item is still valid we put it back into the heap\n                heappush(self.cuis_to_score_heap[cuisine] ratedFood)\n				\n                return ratedFood.food\n"
Design a Number Container System,"###  2349\. Design a Number Container System\n\nDesign a number container system that can do the following:\n\n  * **Insert** or **Replace** a number at the given index in the system.\n  * **Return** the smallest index for the given number in the system.\n\nImplement the `NumberContainers` class:\n\n  * `NumberContainers()` Initializes the number container system.\n  * `void change(int index int number)` Fills the container at `index` with the `number`. If there is already a number at that `index` replace it.\n  * `int find(int number)` Returns the smallest index for the given `number` or `-1` if there is no index that is filled by `number` in the system.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""NumberContainers"" ""find"" ""change"" ""change"" ""change"" ""change"" ""find"" ""change"" ""find""]\n    [[] [10] [2 10] [1 10] [3 10] [5 10] [10] [1 20] [10]]\n    **Output**\n    [null -1 null null null null 1 null 2]\n    \n    **Explanation**\n    NumberContainers nc = new NumberContainers();\n    nc.find(10); // There is no index that is filled with number 10. Therefore we return -1.\n    nc.change(2 10); // Your container at index 2 will be filled with number 10.\n    nc.change(1 10); // Your container at index 1 will be filled with number 10.\n    nc.change(3 10); // Your container at index 3 will be filled with number 10.\n    nc.change(5 10); // Your container at index 5 will be filled with number 10.\n    nc.find(10); // Number 10 is at the indices 1 2 3 and 5. Since the smallest index that is filled with 10 is 1 we return 1.\n    nc.change(1 20); // Your container at index 1 will be filled with number 20. Note that index 1 was filled with 10 and then replaced with 20. \n    nc.find(10); // Number 10 is at the indices 2 3 and 5. The smallest index that is filled with 10 is 2. Therefore we return 2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= index number <= 109`\n  * At most `105` calls will be made **in total** to `change` and `find`.\n\n",class NumberContainers:\n    def __init__(self):\n        self.numbersByIndex = {}\n        self.numberIndexes = defaultdict(set)\n        self.numberIndexesHeap = defaultdict(list)\n\n    def change(self index: int number: int) -> None:\n        if index in self.numbersByIndex:\n            if number != self.numbersByIndex[index]:\n                self.numberIndexes[self.numbersByIndex[index]].remove(index)\n                self.numbersByIndex[index] = number\n                self.numberIndexes[number].add(index)\n                heappush(self.numberIndexesHeap[number] index)\n        else:\n            self.numbersByIndex[index] = number\n            self.numberIndexes[number].add(index)\n            heappush(self.numberIndexesHeap[number] index)\n\n    def find(self number: int) -> int:\n        while self.numberIndexesHeap[number] and self.numberIndexesHeap[number][0] not in self.numberIndexes[number]:\n                heappop(self.numberIndexesHeap[number])  # make sure the smallest index in heap is still an index for number\n        return self.numberIndexesHeap[number][0] if self.numberIndexesHeap[number] else -1\n\n
Design a Stack With Increment Operation,"###  1381\. Design a Stack With Increment Operation\n\nDesign a stack which supports the following operations.\n\nImplement the `CustomStack` class:\n\n  * `CustomStack(int maxSize)` Initializes the object with `maxSize` which is the maximum number of elements in the stack or do nothing if the stack reached the `maxSize`.\n  * `void push(int x)` Adds `x` to the top of the stack if the stack hasn't reached the `maxSize`.\n  * `int pop()` Pops and returns the top of stack or **-1** if the stack is empty.\n  * `void inc(int k int val)` Increments the bottom `k` elements of the stack by `val`. If there are less than `k` elements in the stack just increment all the elements in the stack.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""CustomStack""""push""""push""""pop""""push""""push""""push""""increment""""increment""""pop""""pop""""pop""""pop""]\n    [[3][1][2][][2][3][4][5100][2100][][][][]]\n    **Output**\n    [nullnullnull2nullnullnullnullnull103202201-1]\n    **Explanation**\n    CustomStack customStack = new CustomStack(3); // Stack is Empty []\n    customStack.push(1);                          // stack becomes [1]\n    customStack.push(2);                          // stack becomes [1 2]\n    customStack.pop();                            // return 2 --> Return top of the stack 2 stack becomes [1]\n    customStack.push(2);                          // stack becomes [1 2]\n    customStack.push(3);                          // stack becomes [1 2 3]\n    customStack.push(4);                          // stack still [1 2 3] Don't add another elements as size is 4\n    customStack.increment(5 100);                // stack becomes [101 102 103]\n    customStack.increment(2 100);                // stack becomes [201 202 103]\n    customStack.pop();                            // return 103 --> Return top of the stack 103 stack becomes [201 202]\n    customStack.pop();                            // return 202 --> Return top of the stack 102 stack becomes [201]\n    customStack.pop();                            // return 201 --> Return top of the stack 101 stack becomes []\n    customStack.pop();                            // return -1 --> Stack is empty return -1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= maxSize <= 1000`\n  * `1 <= x <= 1000`\n  * `1 <= k <= 1000`\n  * `0 <= val <= 100`\n  * At most `1000` calls will be made to each method of `increment` `push` and `pop` each separately.\n\n","	class CustomStack:\n\n		def __init__(self maxSize: int):\n			self.size = maxSize\n			self.stack = []\n\n		def push(self x: int) -> None:\n			if self.size > len(self.stack):\n				self.stack.append(x)\n\n		def pop(self) -> int:\n			if self.stack:\n				return self.stack.pop()\n			return -1\n\n		def increment(self k: int val: int) -> None:\n			len_stack = len(self.stack)\n\n			if len_stack < k:\n				self.stack[:] = [i + val for i in self.stack]\n				return\n\n			for i in range(k):\n				self.stack[i] += val\n"
Design a Text Editor,"###  2296\. Design a Text Editor\n\nDesign a text editor with a cursor that can do the following:\n\n  * **Add** text to where the cursor is.\n  * **Delete** text from where the cursor is (simulating the backspace key).\n  * **Move** the cursor either left or right.\n\nWhen deleting text only characters to the left of the cursor will be deleted.\nThe cursor will also remain within the actual text and cannot be moved beyond\nit. More formally we have that `0 <= cursor.position <= currentText.length`\nalways holds.\n\nImplement the `TextEditor` class:\n\n  * `TextEditor()` Initializes the object with empty text.\n  * `void addText(string text)` Appends `text` to where the cursor is. The cursor ends to the right of `text`.\n  * `int deleteText(int k)` Deletes `k` characters to the left of the cursor. Returns the number of characters actually deleted.\n  * `string cursorLeft(int k)` Moves the cursor to the left `k` times. Returns the last `min(10 len)` characters to the left of the cursor where `len` is the number of characters to the left of the cursor.\n  * `string cursorRight(int k)` Moves the cursor to the right `k` times. Returns the last `min(10 len)` characters to the left of the cursor where `len` is the number of characters to the left of the cursor.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""TextEditor"" ""addText"" ""deleteText"" ""addText"" ""cursorRight"" ""cursorLeft"" ""deleteText"" ""cursorLeft"" ""cursorRight""]\n    [[] [""leetcode""] [4] [""practice""] [3] [8] [10] [2] [6]]\n    **Output**\n    [null null 4 null ""etpractice"" ""leet"" 4 """" ""practi""]\n    \n    **Explanation**\n    TextEditor textEditor = new TextEditor(); // The current text is ""|"". (The '|' character represents the cursor)\n    textEditor.addText(""leetcode""); // The current text is ""leetcode|"".\n    textEditor.deleteText(4); // return 4\n                              // The current text is ""leet|"". \n                              // 4 characters were deleted.\n    textEditor.addText(""practice""); // The current text is ""leetpractice|"". \n    textEditor.cursorRight(3); // return ""etpractice""\n                               // The current text is ""leetpractice|"". \n                               // The cursor cannot be moved beyond the actual text and thus did not move.\n                               // ""etpractice"" is the last 10 characters to the left of the cursor.\n    textEditor.cursorLeft(8); // return ""leet""\n                              // The current text is ""leet|practice"".\n                              // ""leet"" is the last min(10 4) = 4 characters to the left of the cursor.\n    textEditor.deleteText(10); // return 4\n                               // The current text is ""|practice"".\n                               // Only 4 characters were deleted.\n    textEditor.cursorLeft(2); // return """"\n                              // The current text is ""|practice"".\n                              // The cursor cannot be moved beyond the actual text and thus did not move. \n                              // """" is the last min(10 0) = 0 characters to the left of the cursor.\n    textEditor.cursorRight(6); // return ""practi""\n                               // The current text is ""practi|ce"".\n                               // ""practi"" is the last min(10 6) = 6 characters to the left of the cursor.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length k <= 40`\n  * `text` consists of lowercase English letters.\n  * At most `2 * 104` calls **in total** will be made to `addText` `deleteText` `cursorLeft` and `cursorRight`.\n\n\n\n**Follow-up:** Could you find a solution with time complexity of `O(k)` per\ncall?\n\n",# Runtime: 1865 ms (Top 50.36%) | Memory: 27.8 MB (Top 82.98%)\nclass TextEditor:\n\n    def __init__(self):\n        self.s = ''\n        self.cursor = 0\n\n    def addText(self text: str) -> None:\n        self.s = self.s[:self.cursor] + text + self.s[self.cursor:]\n        self.cursor += len(text)\n\n    def deleteText(self k: int) -> int:\n        new_cursor = max(0 self.cursor - k)\n        noOfChars = k if self.cursor - k >= 0 else self.cursor\n        self.s = self.s[:new_cursor] + self.s[self.cursor:]\n        self.cursor = new_cursor\n        return noOfChars\n\n    def cursorLeft(self k: int) -> str:\n        self.cursor = max(0 self.cursor - k)\n        start = max(0 self.cursor-10)\n        return self.s[start:self.cursor]\n\n    def cursorRight(self k: int) -> str:\n        self.cursor = min(len(self.s) self.cursor + k)\n        start = max(0 self.cursor - 10)\n        return self.s[start:self.cursor]
Design Add and Search Words Data Structure,"###  211\. Design Add and Search Words Data Structure\n\nDesign a data structure that supports adding new words and finding if a string\nmatches any previously added string.\n\nImplement the `WordDictionary` class:\n\n  * `WordDictionary()` Initializes the object.\n  * `void addWord(word)` Adds `word` to the data structure it can be matched later.\n  * `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `'.'` where dots can be matched with any letter.\n\n\n\n**Example:**\n\n    \n    \n    **Input**\n    [""WordDictionary""""addWord""""addWord""""addWord""""search""""search""""search""""search""]\n    [[][""bad""][""dad""][""mad""][""pad""][""bad""]["".ad""][""b..""]]\n    **Output**\n    [nullnullnullnullfalsetruetruetrue]\n    \n    **Explanation**\n    WordDictionary wordDictionary = new WordDictionary();\n    wordDictionary.addWord(""bad"");\n    wordDictionary.addWord(""dad"");\n    wordDictionary.addWord(""mad"");\n    wordDictionary.search(""pad""); // return False\n    wordDictionary.search(""bad""); // return True\n    wordDictionary.search("".ad""); // return True\n    wordDictionary.search(""b..""); // return True\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word.length <= 25`\n  * `word` in `addWord` consists of lowercase English letters.\n  * `word` in `search` consist of `'.'` or lowercase English letters.\n  * There will be at most `3` dots in `word` for `search` queries.\n  * At most `104` calls will be made to `addWord` and `search`.\n\n","class TrieNode:\n    \n    def __init__(self val):\n        self.val = val\n        self.children = {}\n        self.isEnd = False\n\n\nclass WordDictionary:\n\n    def __init__(self):\n        self.root = TrieNode(""*"")\n        \n    def addWord(self word: str) -> None:\n        \n        curr = self.root\n        \n        for c in word:\n            \n            if c not in curr.children:\n                curr.children[c] = TrieNode(c)\n                \n            curr = curr.children[c]\n        \n        curr.isEnd = True\n        \n    def search(self word: str) -> bool:\n        \n        def dfs(root word):\n            curr = root\n\n            for i in range(len(word)):\n\n                if word[i] == ""."":\n                    for l in curr.children.values():\n                        if dfs(l word[i+1:]) == True:\n                            return True\n                        \n                    return False\n\n                if word[i] not in curr.children:\n                    return False\n\n                curr = curr.children[word[i]]\n\n            return curr.isEnd\n        \n        return dfs(self.root word)\n"
Design an ATM Machine,"###  2241\. Design an ATM Machine\n\nThere is an ATM machine that stores banknotes of `5` denominations: `20`\n`50` `100` `200` and `500` dollars. Initially the ATM is empty. The user\ncan use the machine to deposit or withdraw any amount of money.\n\nWhen withdrawing the machine prioritizes using banknotes of **larger**\nvalues.\n\n  * For example if you want to withdraw `$300` and there are `2` `$50` banknotes `1` `$100` banknote and `1` `$200` banknote then the machine will use the `$100` and `$200` banknotes.\n  * However if you try to withdraw `$600` and there are `3` `$200` banknotes and `1` `$500` banknote then the withdraw request will be rejected because the machine will first try to use the `$500` banknote and then be unable to use banknotes to complete the remaining `$100`. Note that the machine is **not** allowed to use the `$200` banknotes instead of the `$500` banknote.\n\nImplement the ATM class:\n\n  * `ATM()` Initializes the ATM object.\n  * `void deposit(int[] banknotesCount)` Deposits new banknotes in the order `$20` `$50` `$100` `$200` and `$500`.\n  * `int[] withdraw(int amount)` Returns an array of length `5` of the number of banknotes that will be handed to the user in the order `$20` `$50` `$100` `$200` and `$500` and update the number of banknotes in the ATM after withdrawing. Returns `[-1]` if it is not possible (do **not** withdraw any banknotes in this case).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""ATM"" ""deposit"" ""withdraw"" ""deposit"" ""withdraw"" ""withdraw""]\n    [[] [[00121]] [600] [[01011]] [600] [550]]\n    **Output**\n    [null null [00101] null [-1] [01001]]\n    \n    **Explanation**\n    ATM atm = new ATM();\n    atm.deposit([00121]); // Deposits 1 $100 banknote 2 $200 banknotes\n                              // and 1 $500 banknote.\n    atm.withdraw(600);        // Returns [00101]. The machine uses 1 $100 banknote\n                              // and 1 $500 banknote. The banknotes left over in the\n                              // machine are [00020].\n    atm.deposit([01011]); // Deposits 1 $50 $200 and $500 banknote.\n                              // The banknotes in the machine are now [01031].\n    atm.withdraw(600);        // Returns [-1]. The machine will try to use a $500 banknote\n                              // and then be unable to complete the remaining $100\n                              // so the withdraw request will be rejected.\n                              // Since the request is rejected the number of banknotes\n                              // in the machine is not modified.\n    atm.withdraw(550);        // Returns [01001]. The machine uses 1 $50 banknote\n                              // and 1 $500 banknote.\n\n\n\n**Constraints:**\n\n  * `banknotesCount.length == 5`\n  * `0 <= banknotesCount[i] <= 109`\n  * `1 <= amount <= 109`\n  * At most `5000` calls **in total** will be made to `withdraw` and `deposit`.\n  * At least **one** call will be made to each function `withdraw` and `deposit`.\n\n",// Runtime: 906 ms (Top 67.28%) | Memory: 18 MB (Top 21.66%)\nclass ATM:\n    def __init__(self):\n        self.cash = [0] * 5\n        self.values = [20 50 100 200 500]\n\n    def deposit(self banknotes_count: List[int]) -> None:\n        for i n in enumerate(banknotes_count):\n            self.cash[i] += n\n\n    def withdraw(self amount: int) -> List[int]:\n        res = []\n        for val n in zip(self.values[::-1] self.cash[::-1]):\n            need = min(n amount // val)\n            res = [need] + res\n            amount -= (need * val)\n        if amount == 0:\n            self.deposit([-x for x in res])\n            return res\n        else:\n            return [-1]\n
Design an Ordered Stream,"###  1656\. Design an Ordered Stream\n\nThere is a stream of `n` `(idKey value)` pairs arriving in an **arbitrary**\norder where `idKey` is an integer between `1` and `n` and `value` is a\nstring. No two pairs have the same `id`.\n\nDesign a stream that returns the values in **increasing order of their IDs**\nby returning a **chunk** (list) of values after each insertion. The\nconcatenation of all the **chunks** should result in a list of the sorted\nvalues.\n\nImplement the `OrderedStream` class:\n\n  * `OrderedStream(int n)` Constructs the stream to take `n` values.\n  * `String[] insert(int idKey String value)` Inserts the pair `(idKey value)` into the stream then returns the **largest possible chunk** of currently inserted values that appear next in the order.\n\n\n\n**Example:**\n\n**![](https://assets.leetcode.com/uploads/2020/11/10/q1.gif)**\n\n    \n    \n    **Input**\n    [""OrderedStream"" ""insert"" ""insert"" ""insert"" ""insert"" ""insert""]\n    [[5] [3 ""ccccc""] [1 ""aaaaa""] [2 ""bbbbb""] [5 ""eeeee""] [4 ""ddddd""]]\n    **Output**\n    [null [] [""aaaaa""] [""bbbbb"" ""ccccc""] [] [""ddddd"" ""eeeee""]]\n    \n    **Explanation**\n    // Note that the values ordered by ID is [""aaaaa"" ""bbbbb"" ""ccccc"" ""ddddd"" ""eeeee""].\n    OrderedStream os = new OrderedStream(5);\n    os.insert(3 ""ccccc""); // Inserts (3 ""ccccc"") returns [].\n    os.insert(1 ""aaaaa""); // Inserts (1 ""aaaaa"") returns [""aaaaa""].\n    os.insert(2 ""bbbbb""); // Inserts (2 ""bbbbb"") returns [""bbbbb"" ""ccccc""].\n    os.insert(5 ""eeeee""); // Inserts (5 ""eeeee"") returns [].\n    os.insert(4 ""ddddd""); // Inserts (4 ""ddddd"") returns [""ddddd"" ""eeeee""].\n    // Concatentating all the chunks returned:\n    // [] + [""aaaaa""] + [""bbbbb"" ""ccccc""] + [] + [""ddddd"" ""eeeee""] = [""aaaaa"" ""bbbbb"" ""ccccc"" ""ddddd"" ""eeeee""]\n    // The resulting order is the same as the order above.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n  * `1 <= id <= n`\n  * `value.length == 5`\n  * `value` consists only of lowercase letters.\n  * Each call to `insert` will have a unique `id.`\n  * Exactly `n` calls will be made to `insert`.\n\n",class OrderedStream:\n\n    def __init__(self n: int):\n        self.seen = {}\n        self.ptr = 1\n\n    def insert(self id: int value: str) -> List[str]:\n        seen ptr = self.seen self.ptr\n        \n        seen[id] = value\n        result = []\n        while ptr in seen:\n            result.append(seen[ptr])\n            del seen[ptr]\n            ptr += 1\n        \n        self.ptr = ptr\n        return result\n\n\n# Your OrderedStream object will be instantiated and called as such:\n# obj = OrderedStream(n)\n# param_1 = obj.insert(idvalue)\n
Design Authentication Manager,"###  1797\. Design Authentication Manager\n\nThere is an authentication system that works with authentication tokens. For\neach session the user will receive a new authentication token that will\nexpire `timeToLive` seconds after the `currentTime`. If the token is renewed\nthe expiry time will be **extended** to expire `timeToLive` seconds after the\n(potentially different) `currentTime`.\n\nImplement the `AuthenticationManager` class:\n\n  * `AuthenticationManager(int timeToLive)` constructs the `AuthenticationManager` and sets the `timeToLive`.\n  * `generate(string tokenId int currentTime)` generates a new token with the given `tokenId` at the given `currentTime` in seconds.\n  * `renew(string tokenId int currentTime)` renews the **unexpired** token with the given `tokenId` at the given `currentTime` in seconds. If there are no unexpired tokens with the given `tokenId` the request is ignored and nothing happens.\n  * `countUnexpiredTokens(int currentTime)` returns the number of **unexpired** tokens at the given currentTime.\n\nNote that if a token expires at time `t` and another action happens on time\n`t` (`renew` or `countUnexpiredTokens`) the expiration takes place **before**\nthe other actions.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/25/copy-of-pc68_q2.png)\n\n    \n    \n    **Input**\n    [""AuthenticationManager"" ""renew"" ""generate"" ""countUnexpiredTokens"" ""generate"" ""renew"" ""renew"" ""countUnexpiredTokens""]\n    [[5] [""aaa"" 1] [""aaa"" 2] [6] [""bbb"" 7] [""aaa"" 8] [""bbb"" 10] [15]]\n    **Output**\n    [null null null 1 null null null 0]\n    \n    **Explanation**\n    AuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.\n    authenticationManager.renew(""aaa"" 1); // No token exists with tokenId ""aaa"" at time 1 so nothing happens.\n    authenticationManager.generate(""aaa"" 2); // Generates a new token with tokenId ""aaa"" at time 2.\n    authenticationManager.countUnexpiredTokens(6); // The token with tokenId ""aaa"" is the only unexpired one at time 6 so return 1.\n    authenticationManager.generate(""bbb"" 7); // Generates a new token with tokenId ""bbb"" at time 7.\n    authenticationManager.renew(""aaa"" 8); // The token with tokenId ""aaa"" expired at time 7 and 8 >= 7 so at time 8 the renew request is ignored and nothing happens.\n    authenticationManager.renew(""bbb"" 10); // The token with tokenId ""bbb"" is unexpired at time 10 so the renew request is fulfilled and now the token will expire at time 15.\n    authenticationManager.countUnexpiredTokens(15); // The token with tokenId ""bbb"" expires at time 15 and the token with tokenId ""aaa"" expired at time 7 so currently no token is unexpired so return 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= timeToLive <= 108`\n  * `1 <= currentTime <= 108`\n  * `1 <= tokenId.length <= 5`\n  * `tokenId` consists only of lowercase letters.\n  * All calls to `generate` will contain unique values of `tokenId`.\n  * The values of `currentTime` across all the function calls will be **strictly increasing**.\n  * At most `2000` calls will be made to all functions combined.\n\n",# Runtime: 732 ms (Top 5.07%) | Memory: 15.5 MB (Top 65.88%)\nclass AuthenticationManager(object):\n\n    def __init__(self timeToLive):\n        self.token = dict()\n        self.time = timeToLive # store timeToLive and create dictionary\n\n    def generate(self tokenId currentTime):\n        self.token[tokenId] = currentTime # store tokenId with currentTime\n\n    def renew(self tokenId currentTime):\n        limit = currentTime-self.time # calculate limit time to filter unexpired tokens\n        if tokenId in self.token and self.token[tokenId]>limit: # filter tokens and renew its time\n            self.token[tokenId] = currentTime\n\n    def countUnexpiredTokens(self currentTime):\n        limit = currentTime-self.time # calculate limit time to filter unexpired tokens\n        c = 0\n        for i in self.token:\n            if self.token[i]>limit: # count unexpired tokens\n                c+=1\n        return c
Design Bitset,"###  2166\. Design Bitset\n\nA **Bitset** is a data structure that compactly stores bits.\n\nImplement the `Bitset` class:\n\n  * `Bitset(int size)` Initializes the Bitset with `size` bits all of which are `0`.\n  * `void fix(int idx)` Updates the value of the bit at the index `idx` to `1`. If the value was already `1` no change occurs.\n  * `void unfix(int idx)` Updates the value of the bit at the index `idx` to `0`. If the value was already `0` no change occurs.\n  * `void flip()` Flips the values of each bit in the Bitset. In other words all bits with value `0` will now have value `1` and vice versa.\n  * `boolean all()` Checks if the value of **each** bit in the Bitset is `1`. Returns `true` if it satisfies the condition `false` otherwise.\n  * `boolean one()` Checks if there is **at least one** bit in the Bitset with value `1`. Returns `true` if it satisfies the condition `false` otherwise.\n  * `int count()` Returns the **total number** of bits in the Bitset which have value `1`.\n  * `String toString()` Returns the current composition of the Bitset. Note that in the resultant string the character at the `ith` index should coincide with the value at the `ith` bit of the Bitset.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Bitset"" ""fix"" ""fix"" ""flip"" ""all"" ""unfix"" ""flip"" ""one"" ""unfix"" ""count"" ""toString""]\n    [[5] [3] [1] [] [] [0] [] [] [0] [] []]\n    **Output**\n    [null null null null false null null true null 2 ""01010""]\n    \n    **Explanation**\n    Bitset bs = new Bitset(5); // bitset = ""00000"".\n    bs.fix(3);     // the value at idx = 3 is updated to 1 so bitset = ""00010"".\n    bs.fix(1);     // the value at idx = 1 is updated to 1 so bitset = ""01010"". \n    bs.flip();     // the value of each bit is flipped so bitset = ""10101"". \n    bs.all();      // return False as not all values of the bitset are 1.\n    bs.unfix(0);   // the value at idx = 0 is updated to 0 so bitset = ""00101"".\n    bs.flip();     // the value of each bit is flipped so bitset = ""11010"". \n    bs.one();      // return True as there is at least 1 index with value 1.\n    bs.unfix(0);   // the value at idx = 0 is updated to 0 so bitset = ""01010"".\n    bs.count();    // return 2 as there are 2 bits with value 1.\n    bs.toString(); // return ""01010"" which is the composition of bitset.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= size <= 105`\n  * `0 <= idx <= size - 1`\n  * At most `105` calls will be made **in total** to `fix` `unfix` `flip` `all` `one` `count` and `toString`.\n  * At least one call will be made to `all` `one` `count` or `toString`.\n  * At most `5` calls will be made to `toString`.\n\n",# Runtime: 1967 ms (Top 8.78%) | Memory: 45.4 MB (Top 61.95%)\nclass Bitset(object):\n\n    def __init__(self size):\n        self.a = 0\n        self.size = size\n        self.cnt = 0\n\n    def fix(self idx):\n        if self.a & (1 << idx) == 0:\n            self.a |= 1 << idx\n            self.cnt += 1\n\n    def unfix(self idx):\n        if self.a & (1 << idx):\n            self.a ^= 1 << idx\n            self.cnt -= 1\n\n    def flip(self):\n        self.a ^= (1 << self.size) - 1\n        self.cnt = self.size - self.cnt\n\n    def all(self):\n        return self.cnt == self.size\n\n    def one(self):\n        return self.a > 0\n\n    def count(self):\n        return self.cnt\n\n    def toString(self):\n        a = bin(self.a)[2:]\n        return a[::-1] + '0' * (self.size - len(a))
Design Browser History,"###  1472\. Design Browser History\n\nYou have a **browser** of one tab where you start on the `homepage` and you\ncan visit another `url` get back in the history number of `steps` or move\nforward in the history number of `steps`.\n\nImplement the `BrowserHistory` class:\n\n  * `BrowserHistory(string homepage)` Initializes the object with the `homepage` of the browser.\n  * `void visit(string url)` Visits `url` from the current page. It clears up all the forward history.\n  * `string back(int steps)` Move `steps` back in history. If you can only return `x` steps in the history and `steps > x` you will return only `x` steps. Return the current `url` after moving back in history **at most** `steps`.\n  * `string forward(int steps)` Move `steps` forward in history. If you can only forward `x` steps in the history and `steps > x` you will forward only `x` steps. Return the current `url` after forwarding in history **at most** `steps`.\n\n\n\n**Example:**\n\n    \n    \n    **Input:**\n    [""BrowserHistory""""visit""""visit""""visit""""back""""back""""forward""""visit""""forward""""back""""back""]\n    [[""leetcode.com""][""google.com""][""facebook.com""][""youtube.com""][1][1][1][""linkedin.com""][2][2][7]]\n    **Output:**\n    [nullnullnullnull""facebook.com""""google.com""""facebook.com""null""linkedin.com""""google.com""""leetcode.com""]\n    \n    **Explanation:**\n    BrowserHistory browserHistory = new BrowserHistory(""leetcode.com"");\n    browserHistory.visit(""google.com"");       // You are in ""leetcode.com"". Visit ""google.com""\n    browserHistory.visit(""facebook.com"");     // You are in ""google.com"". Visit ""facebook.com""\n    browserHistory.visit(""youtube.com"");      // You are in ""facebook.com"". Visit ""youtube.com""\n    browserHistory.back(1);                   // You are in ""youtube.com"" move back to ""facebook.com"" return ""facebook.com""\n    browserHistory.back(1);                   // You are in ""facebook.com"" move back to ""google.com"" return ""google.com""\n    browserHistory.forward(1);                // You are in ""google.com"" move forward to ""facebook.com"" return ""facebook.com""\n    browserHistory.visit(""linkedin.com"");     // You are in ""facebook.com"". Visit ""linkedin.com""\n    browserHistory.forward(2);                // You are in ""linkedin.com"" you cannot move forward any steps.\n    browserHistory.back(2);                   // You are in ""linkedin.com"" move back two steps to ""facebook.com"" then to ""google.com"". return ""google.com""\n    browserHistory.back(7);                   // You are in ""google.com"" you can move back only one step to ""leetcode.com"". return ""leetcode.com""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= homepage.length <= 20`\n  * `1 <= url.length <= 20`\n  * `1 <= steps <= 100`\n  * `homepage` and `url` consist of  '.' or lower case English letters.\n  * At most `5000` calls will be made to `visit` `back` and `forward`.\n\n",# Runtime: 702 ms (Top 9.12%) | Memory: 16.8 MB (Top 36.03%)\nclass Node:\n    def __init__(self val):\n        self.val = val\n        self.prev = None\n        self.next = None\n\nclass BrowserHistory:\n    def __init__(self web):\n        self.Node = Node(web)\n        self.ptr = self.Node\n\n    def visit(self web):\n        self.newWeb = Node(web)\n        self.newWeb.prev = self.ptr\n        self.ptr.next = self.newWeb\n        self.ptr = self.ptr.next\n\n    def back(self steps):\n        i = 0\n        while i < steps:\n            if self.ptr.prev:\n                self.ptr = self.ptr.prev\n            else:\n                break\n            i += 1\n        return self.ptr.val\n\n    def forward(self steps):\n        i = 0\n        while i < steps:\n            if self.ptr.next:\n                self.ptr = self.ptr.next\n            else:\n                break\n            i += 1\n        return self.ptr.val
Design Circular Deque,"###  641\. Design Circular Deque\n\nDesign your implementation of the circular double-ended queue (deque).\n\nImplement the `MyCircularDeque` class:\n\n  * `MyCircularDeque(int k)` Initializes the deque with a maximum size of `k`.\n  * `boolean insertFront()` Adds an item at the front of Deque. Returns `true` if the operation is successful or `false` otherwise.\n  * `boolean insertLast()` Adds an item at the rear of Deque. Returns `true` if the operation is successful or `false` otherwise.\n  * `boolean deleteFront()` Deletes an item from the front of Deque. Returns `true` if the operation is successful or `false` otherwise.\n  * `boolean deleteLast()` Deletes an item from the rear of Deque. Returns `true` if the operation is successful or `false` otherwise.\n  * `int getFront()` Returns the front item from the Deque. Returns `-1` if the deque is empty.\n  * `int getRear()` Returns the last item from Deque. Returns `-1` if the deque is empty.\n  * `boolean isEmpty()` Returns `true` if the deque is empty or `false` otherwise.\n  * `boolean isFull()` Returns `true` if the deque is full or `false` otherwise.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MyCircularDeque"" ""insertLast"" ""insertLast"" ""insertFront"" ""insertFront"" ""getRear"" ""isFull"" ""deleteLast"" ""insertFront"" ""getFront""]\n    [[3] [1] [2] [3] [4] [] [] [] [4] []]\n    **Output**\n    [null true true true false 2 true true true 4]\n    \n    **Explanation**\n    MyCircularDeque myCircularDeque = new MyCircularDeque(3);\n    myCircularDeque.insertLast(1);  // return True\n    myCircularDeque.insertLast(2);  // return True\n    myCircularDeque.insertFront(3); // return True\n    myCircularDeque.insertFront(4); // return False the queue is full.\n    myCircularDeque.getRear();      // return 2\n    myCircularDeque.isFull();       // return True\n    myCircularDeque.deleteLast();   // return True\n    myCircularDeque.insertFront(4); // return True\n    myCircularDeque.getFront();     // return 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= 1000`\n  * `0 <= value <= 1000`\n  * At most `2000` calls will be made to `insertFront` `insertLast` `deleteFront` `deleteLast` `getFront` `getRear` `isEmpty` `isFull`.\n\n",// Runtime: 57 ms (Top 91.39%) | Memory: 18.00 MB (Top 39.07%)\n\nclass MyCircularDeque:\n  def __init__(self k: int):\n    self.queue = [None] * k\n    self.max_size = k\n    self.head = 0\n    self.tail = 0\n    self.size = 0\n\n  def insertFront(self value: int) -> bool:\n    if self.isFull():\n        return False\n    self.head = (self.head - 1) % self.max_size\n    self.queue[self.head] = value\n    self.size += 1\n    return True\n\n  def insertLast(self value: int) -> bool:\n    if self.isFull():\n        return False\n    self.queue[self.tail] = value\n    self.tail = (self.tail + 1) % self.max_size\n    self.size += 1\n    return True\n\n  def deleteFront(self) -> bool:\n    if self.isEmpty():\n        return False\n    self.head = (self.head + 1) % self.max_size\n    self.size -= 1\n    return True\n\n  def deleteLast(self) -> bool:\n    if self.isEmpty():\n        return False\n    self.tail = (self.tail - 1) % self.max_size\n    self.size -= 1\n    return True\n\n  def getFront(self) -> int:\n    if self.isEmpty():\n        return -1\n    return self.queue[self.head]\n\n  def getRear(self) -> int:\n    if self.isEmpty():\n        return -1\n    return self.queue[(self.tail - 1) % self.max_size]\n\n  def isEmpty(self) -> bool:\n    return self.size == 0\n\n  def isFull(self) -> bool:\n    return self.size == self.max_size\n\n
Design Circular Queue,"###  622\. Design Circular Queue\n\nDesign your implementation of the circular queue. The circular queue is a\nlinear data structure in which the operations are performed based on FIFO\n(First In First Out) principle and the last position is connected back to the\nfirst position to make a circle. It is also called ""Ring Buffer"".\n\nOne of the benefits of the circular queue is that we can make use of the\nspaces in front of the queue. In a normal queue once the queue becomes full\nwe cannot insert the next element even if there is a space in front of the\nqueue. But using the circular queue we can use the space to store new values.\n\nImplementation the `MyCircularQueue` class:\n\n  * `MyCircularQueue(k)` Initializes the object with the size of the queue to be `k`.\n  * `int Front()` Gets the front item from the queue. If the queue is empty return `-1`.\n  * `int Rear()` Gets the last item from the queue. If the queue is empty return `-1`.\n  * `boolean enQueue(int value)` Inserts an element into the circular queue. Return `true` if the operation is successful.\n  * `boolean deQueue()` Deletes an element from the circular queue. Return `true` if the operation is successful.\n  * `boolean isEmpty()` Checks whether the circular queue is empty or not.\n  * `boolean isFull()` Checks whether the circular queue is full or not.\n\nYou must solve the problem without using the built-in queue data structure in\nyour programming language.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MyCircularQueue"" ""enQueue"" ""enQueue"" ""enQueue"" ""enQueue"" ""Rear"" ""isFull"" ""deQueue"" ""enQueue"" ""Rear""]\n    [[3] [1] [2] [3] [4] [] [] [] [4] []]\n    **Output**\n    [null true true true false 3 true true true 4]\n    \n    **Explanation**\n    MyCircularQueue myCircularQueue = new MyCircularQueue(3);\n    myCircularQueue.enQueue(1); // return True\n    myCircularQueue.enQueue(2); // return True\n    myCircularQueue.enQueue(3); // return True\n    myCircularQueue.enQueue(4); // return False\n    myCircularQueue.Rear();     // return 3\n    myCircularQueue.isFull();   // return True\n    myCircularQueue.deQueue();  // return True\n    myCircularQueue.enQueue(4); // return True\n    myCircularQueue.Rear();     // return 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= 1000`\n  * `0 <= value <= 1000`\n  * At most `3000` calls will be made to `enQueue` `deQueue` `Front` `Rear` `isEmpty` and `isFull`.\n\n",// Runtime: 66 ms (Top 68.44%) | Memory: 18.10 MB (Top 5.6%)\n\nclass MyCircularQueue:\n    def __init__(self k: int):\n        self.data = [0] * k\n        self.maxSize = k\n        self.head = 0\n        self.tail = -1\n    def enQueue(self val: int) -> bool:\n        if self.isFull(): return False\n        self.tail = (self.tail + 1) % self.maxSize\n        self.data[self.tail] = val\n        return True\n    def deQueue(self) -> bool:\n        if self.isEmpty(): return False\n        if self.head == self.tail: self.head self.tail = 0 -1\n        else: self.head = (self.head + 1) % self.maxSize\n        return True\n    def Front(self) -> int:\n        return -1 if self.isEmpty() else self.data[self.head]\n    def Rear(self) -> int:\n        return -1 if self.isEmpty() else self.data[self.tail]\n    def isEmpty(self) -> bool:\n        return self.tail == -1\n    def isFull(self) -> bool:\n        return not self.isEmpty() and (self.tail + 1) % self.maxSize == self.head\n
Design Front Middle Back Queue,"###  1670\. Design Front Middle Back Queue\n\nDesign a queue that supports `push` and `pop` operations in the front middle\nand back.\n\nImplement the `FrontMiddleBack` class:\n\n  * `FrontMiddleBack()` Initializes the queue.\n  * `void pushFront(int val)` Adds `val` to the **front** of the queue.\n  * `void pushMiddle(int val)` Adds `val` to the **middle** of the queue.\n  * `void pushBack(int val)` Adds `val` to the **back** of the queue.\n  * `int popFront()` Removes the **front** element of the queue and returns it. If the queue is empty return `-1`.\n  * `int popMiddle()` Removes the **middle** element of the queue and returns it. If the queue is empty return `-1`.\n  * `int popBack()` Removes the **back** element of the queue and returns it. If the queue is empty return `-1`.\n\n**Notice** that when there are **two** middle position choices the operation\nis performed on the **frontmost** middle position choice. For example:\n\n  * Pushing `6` into the middle of `[1 2 3 4 5]` results in `[1 2 _6_  3 4 5]`.\n  * Popping the middle from `[1 2 _3_  4 5 6]` returns `3` and results in `[1 2 4 5 6]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:**\n    [""FrontMiddleBackQueue"" ""pushFront"" ""pushBack"" ""pushMiddle"" ""pushMiddle"" ""popFront"" ""popMiddle"" ""popMiddle"" ""popBack"" ""popFront""]\n    [[] [1] [2] [3] [4] [] [] [] [] []]\n    **Output:**\n    [null null null null null 1 3 4 2 -1]\n    \n    **Explanation:**\n    FrontMiddleBackQueue q = new FrontMiddleBackQueue();\n    q.pushFront(1);   // [_1_]\n    q.pushBack(2);    // [1 _2_]\n    q.pushMiddle(3);  // [1 _3_  2]\n    q.pushMiddle(4);  // [1 _4_  3 2]\n    q.popFront();     // return 1 -> [4 3 2]\n    q.popMiddle();    // return 3 -> [4 2]\n    q.popMiddle();    // return 4 -> [2]\n    q.popBack();      // return 2 -> []\n    q.popFront();     // return -1 -> [] (The queue is empty)\n    \n\n\n\n**Constraints:**\n\n  * `1 <= val <= 109`\n  * At most `1000` calls will be made to `pushFront` `pushMiddle` `pushBack` `popFront` `popMiddle` and `popBack`.\n\n",# Runtime: 176 ms (Top 11.57%) | Memory: 14.6 MB (Top 46.27%)\nclass FrontMiddleBackQueue:\n\n    def __init__(self):\n        self.front = deque()\n        self.back = deque()\n\n    def _correct_size(self):\n        while len(self.back) > len(self.front):\n            self.front.append(self.back.popleft())\n\n        while len(self.front) > len(self.back) + 1:\n            self.back.appendleft(self.front.pop())\n\n    def pushFront(self val: int) -> None:\n        self.front.appendleft(val)\n        self._correct_size()\n\n    def pushMiddle(self val: int) -> None:\n        if len(self.front) > len(self.back):\n            self.back.appendleft(self.front.pop())\n        self.front.append(val)\n        self._correct_size()\n\n    def pushBack(self val: int) -> None:\n        self.back.append(val)\n        self._correct_size()\n\n    def popFront(self) -> int:\n        front = self.front if self.front else self.back\n        ret = front.popleft() if front else -1\n        self._correct_size()\n        return ret\n\n    def popMiddle(self) -> int:\n        ret = self.front.pop() if self.front else -1\n        self._correct_size()\n        return ret\n\n    def popBack(self) -> int:\n        back = self.back if self.back else self.front\n        ret = back.pop() if back else -1\n        self._correct_size()\n        return ret
Design HashSet,"###  705\. Design HashSet\n\nDesign a HashSet without using any built-in hash table libraries.\n\nImplement `MyHashSet` class:\n\n  * `void add(key)` Inserts the value `key` into the HashSet.\n  * `bool contains(key)` Returns whether the value `key` exists in the HashSet or not.\n  * `void remove(key)` Removes the value `key` in the HashSet. If `key` does not exist in the HashSet do nothing.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MyHashSet"" ""add"" ""add"" ""contains"" ""contains"" ""add"" ""contains"" ""remove"" ""contains""]\n    [[] [1] [2] [1] [3] [2] [2] [2] [2]]\n    **Output**\n    [null null null true false null true null false]\n    \n    **Explanation**\n    MyHashSet myHashSet = new MyHashSet();\n    myHashSet.add(1);      // set = [1]\n    myHashSet.add(2);      // set = [1 2]\n    myHashSet.contains(1); // return True\n    myHashSet.contains(3); // return False (not found)\n    myHashSet.add(2);      // set = [1 2]\n    myHashSet.contains(2); // return True\n    myHashSet.remove(2);   // set = [1]\n    myHashSet.contains(2); // return False (already removed)\n\n\n\n**Constraints:**\n\n  * `0 <= key <= 106`\n  * At most `104` calls will be made to `add` `remove` and `contains`.\n\n",# Runtime: 1864 ms (Top 22.23%) | Memory: 174.5 MB (Top 5.09%)\nclass MyHashSet:\n\n    def __init__(self):\n        self.hash_list = [0]*10000000\n\n    def add(self key: int) -> None:\n        self.hash_list[key]+=1\n\n    def remove(self key: int) -> None:\n        self.hash_list[key] = 0\n\n    def contains(self key: int) -> bool:\n        if self.hash_list[key] > 0:\n            return True\n        return False
Design Linked List,"###  707\. Design Linked List\n\nDesign your implementation of the linked list. You can choose to use a singly\nor doubly linked list.  \nA node in a singly linked list should have two attributes: `val` and `next`.\n`val` is the value of the current node and `next` is a pointer/reference to\nthe next node.  \nIf you want to use the doubly linked list you will need one more attribute\n`prev` to indicate the previous node in the linked list. Assume all nodes in\nthe linked list are **0-indexed**.\n\nImplement the `MyLinkedList` class:\n\n  * `MyLinkedList()` Initializes the `MyLinkedList` object.\n  * `int get(int index)` Get the value of the `indexth` node in the linked list. If the index is invalid return `-1`.\n  * `void addAtHead(int val)` Add a node of value `val` before the first element of the linked list. After the insertion the new node will be the first node of the linked list.\n  * `void addAtTail(int val)` Append a node of value `val` as the last element of the linked list.\n  * `void addAtIndex(int index int val)` Add a node of value `val` before the `indexth` node in the linked list. If `index` equals the length of the linked list the node will be appended to the end of the linked list. If `index` is greater than the length the node **will not be inserted**.\n  * `void deleteAtIndex(int index)` Delete the `indexth` node in the linked list if the index is valid.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MyLinkedList"" ""addAtHead"" ""addAtTail"" ""addAtIndex"" ""get"" ""deleteAtIndex"" ""get""]\n    [[] [1] [3] [1 2] [1] [1] [1]]\n    **Output**\n    [null null null null 2 null 3]\n    \n    **Explanation**\n    MyLinkedList myLinkedList = new MyLinkedList();\n    myLinkedList.addAtHead(1);\n    myLinkedList.addAtTail(3);\n    myLinkedList.addAtIndex(1 2);    // linked list becomes 1->2->3\n    myLinkedList.get(1);              // return 2\n    myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3\n    myLinkedList.get(1);              // return 3\n    \n\n\n\n**Constraints:**\n\n  * `0 <= index val <= 1000`\n  * Please do not use the built-in LinkedList library.\n  * At most `2000` calls will be made to `get` `addAtHead` `addAtTail` `addAtIndex` and `deleteAtIndex`.\n\n",class Node:\n    def __init__(self val: int):\n        self.val = val\n        self.next = None\n        self.prev = None\n        \nclass MyLinkedList:\n    def __init__(self):\n        self.head = Node(0)\n        self.tail = Node(0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n        \n    def get(self index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n        # Distance of index is closer to head\n        if index + 1 < self.size - index:\n            curr = self.head\n            for i in range(index + 1):\n                curr = curr.next\n        # Distance of index is closer to tail\n        else:\n            curr = self.tail\n            for i in range(self.size - index):\n                curr = curr.prev\n        return curr.val\n\n    def addAtHead(self val: int) -> None:\n        curr = Node(val)\n        prevNode = self.head\n        nextNode = self.head.next\n        self.size += 1\n        curr.prev = prevNode\n        curr.next = nextNode\n        prevNode.next = curr\n        nextNode.prev = curr\n\n    def addAtTail(self val: int) -> None:\n        curr = Node(val)\n        prevNode = self.tail.prev\n        nextNode = self.tail\n        self.size += 1\n        curr.prev = prevNode\n        curr.next = nextNode\n        prevNode.next = curr\n        nextNode.prev = curr\n\n    def addAtIndex(self index: int val: int) -> None:\n        curr = Node(val)\n        if index > self.size:\n            return\n        if index < 0:\n            index = 0\n        if index < self.size - index:\n            prevNode = self.head\n            for i in range(index):\n                prevNode = prevNode.next\n            nextNode = prevNode.next\n        else:\n            nextNode = self.tail\n            for i in range(self.size - index):\n                nextNode = nextNode.prev\n            prevNode = nextNode.prev\n        self.size += 1\n        curr.prev = prevNode\n        curr.next = nextNode\n        prevNode.next = curr\n        nextNode.prev = curr\n        \n    def deleteAtIndex(self index: int) -> None:\n        if index < 0 or index >= self.size:\n            return \n        if index < self.size - index:\n            prevNode = self.head\n            for i in range(index):\n                prevNode = prevNode.next\n            nextNode = prevNode.next.next\n        else:\n            nextNode = self.tail\n            for i in range(self.size - index - 1):\n                nextNode = nextNode.prev\n            prevNode = nextNode.prev.prev\n        self.size -= 1\n        prevNode.next = nextNode\n        nextNode.prev = prevNode\n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(indexval)\n# obj.deleteAtIndex(index)
Design Parking System,"###  1603\. Design Parking System\n\nDesign a parking system for a parking lot. The parking lot has three kinds of\nparking spaces: big medium and small with a fixed number of slots for each\nsize.\n\nImplement the `ParkingSystem` class:\n\n  * `ParkingSystem(int big int medium int small)` Initializes object of the `ParkingSystem` class. The number of slots for each parking space are given as part of the constructor.\n  * `bool addCar(int carType)` Checks whether there is a parking space of `carType` for the car that wants to get into the parking lot. `carType` can be of three kinds: big medium or small which are represented by `1` `2` and `3` respectively. **A car can only park in a parking space of its**`carType`. If there is no space available return `false` else park the car in that size space and return `true`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""ParkingSystem"" ""addCar"" ""addCar"" ""addCar"" ""addCar""]\n    [[1 1 0] [1] [2] [3] [1]]\n    **Output**\n    [null true true false false]\n    \n    **Explanation**\n    ParkingSystem parkingSystem = new ParkingSystem(1 1 0);\n    parkingSystem.addCar(1); // return true because there is 1 available slot for a big car\n    parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\n    parkingSystem.addCar(3); // return false because there is no available slot for a small car\n    parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= big medium small <= 1000`\n  * `carType` is `1` `2` or `3`\n  * At most `1000` calls will be made to `addCar`\n\n",# Runtime: 111 ms (Top 92.4%) | Memory: 16.70 MB (Top 96.9%)\n\nclass ParkingSystem:\n    def __init__(self big: int medium: int small: int):\n        self.vehicle  =[bigmediumsmall]\n\n    def addCar(self carType: int) -> bool:\n        if carType == 1 :\n            if self.vehicle[0] > 0:\n                self.vehicle[0]-=1\n                return True\n        elif carType == 2:\n            if self.vehicle[1] > 0:\n                self.vehicle[1]-=1\n                return True\n        elif carType == 3:\n            if self.vehicle[2] > 0:\n                self.vehicle[2]-=1\n                return True\n        return False
Design Skiplist,"###  1206\. Design Skiplist\n\nDesign a **Skiplist** without using any built-in libraries.\n\nA **skiplist** is a data structure that takes `O(log(n))` time to add erase\nand search. Comparing with treap and red-black tree which has the same\nfunction and performance the code length of Skiplist can be comparatively\nshort and the idea behind Skiplists is just simple linked lists.\n\nFor example we have a Skiplist containing `[304050607090]` and we want\nto add `80` and `45` into it. The Skiplist works this way:\n\n![](https://assets.leetcode.com/uploads/2019/09/27/1506_skiplist.gif)  \nArtyom Kalinin [CC BY-SA 3.0] via [Wikimedia\nCommons](https://commons.wikimedia.org/wiki/File:Skip_list_add_element-en.gif\n""Artyom Kalinin \[CC BY-SA 3.0 \(https://creativecommons.org/licenses/by-\nsa/3.0\)\] via Wikimedia Commons"")\n\nYou can see there are many layers in the Skiplist. Each layer is a sorted\nlinked list. With the help of the top layers add erase and search can be\nfaster than `O(n)`. It can be proven that the average time complexity for each\noperation is `O(log(n))` and space complexity is `O(n)`.\n\nSee more about Skiplist: <https://en.wikipedia.org/wiki/Skip_list>\n\nImplement the `Skiplist` class:\n\n  * `Skiplist()` Initializes the object of the skiplist.\n  * `bool search(int target)` Returns `true` if the integer `target` exists in the Skiplist or `false` otherwise.\n  * `void add(int num)` Inserts the value `num` into the SkipList.\n  * `bool erase(int num)` Removes the value `num` from the Skiplist and returns `true`. If `num` does not exist in the Skiplist do nothing and return `false`. If there exist multiple `num` values removing any one of them is fine.\n\nNote that duplicates may exist in the Skiplist your code needs to handle this\nsituation.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Skiplist"" ""add"" ""add"" ""add"" ""search"" ""add"" ""search"" ""erase"" ""erase"" ""search""]\n    [[] [1] [2] [3] [0] [4] [1] [0] [1] [1]]\n    **Output**\n    [null null null null false null true false true false]\n    \n    **Explanation**\n    Skiplist skiplist = new Skiplist();\n    skiplist.add(1);\n    skiplist.add(2);\n    skiplist.add(3);\n    skiplist.search(0); // return False\n    skiplist.add(4);\n    skiplist.search(1); // return True\n    skiplist.erase(0);  // return False 0 is not in skiplist.\n    skiplist.erase(1);  // return True\n    skiplist.search(1); // return False 1 has already been erased.\n\n\n\n**Constraints:**\n\n  * `0 <= num target <= 2 * 104`\n  * At most `5 * 104` calls will be made to `search` `add` and `erase`.\n\n",# Runtime: 3867 ms (Top 5.16%) | Memory: 20.8 MB (Top 90.23%)\nclass Skiplist:\n    def __init__(self):\n        self.data = []\n    def search(self target: int) -> bool:\n        if target in self.data:\n            return True\n        else:\n            return False\n    def add(self num: int) -> None:\n        self.data.append(num)\n    def erase(self num: int) -> bool:\n        for i in range(len(self.data)):\n            if self.data[i] == num:\n                self.data.pop(i)\n                return True\n        if num not in self.data:\n            return False
Design Twitter,"###  355\. Design Twitter\n\nDesign a simplified version of Twitter where users can post tweets\nfollow/unfollow another user and is able to see the `10` most recent tweets\nin the user's news feed.\n\nImplement the `Twitter` class:\n\n  * `Twitter()` Initializes your twitter object.\n  * `void postTweet(int userId int tweetId)` Composes a new tweet with ID `tweetId` by the user `userId`. Each call to this function will be made with a unique `tweetId`.\n  * `List<Integer> getNewsFeed(int userId)` Retrieves the `10` most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be **ordered from most recent to least recent**.\n  * `void follow(int followerId int followeeId)` The user with ID `followerId` started following the user with ID `followeeId`.\n  * `void unfollow(int followerId int followeeId)` The user with ID `followerId` started unfollowing the user with ID `followeeId`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Twitter"" ""postTweet"" ""getNewsFeed"" ""follow"" ""postTweet"" ""getNewsFeed"" ""unfollow"" ""getNewsFeed""]\n    [[] [1 5] [1] [1 2] [2 6] [1] [1 2] [1]]\n    **Output**\n    [null null [5] null null [6 5] null [5]]\n    \n    **Explanation**\n    Twitter twitter = new Twitter();\n    twitter.postTweet(1 5); // User 1 posts a new tweet (id = 5).\n    twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\n    twitter.follow(1 2);    // User 1 follows user 2.\n    twitter.postTweet(2 6); // User 2 posts a new tweet (id = 6).\n    twitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\n    twitter.unfollow(1 2);  // User 1 unfollows user 2.\n    twitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5] since user 1 is no longer following user 2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= userId followerId followeeId <= 500`\n  * `0 <= tweetId <= 104`\n  * All the tweets have **unique** IDs.\n  * At most `3 * 104` calls will be made to `postTweet` `getNewsFeed` `follow` and `unfollow`.\n\n",class Twitter:\n\n    def __init__(self):\n        self.tweets = []\n        self.friends = defaultdict(list)\n\n    def postTweet(self userId: int tweetId: int) -> None:\n        self.tweets.append([userId tweetId])   \n\n    def getNewsFeed(self userId: int) -> List[int]:\n        try:\n            tweets = [x[1] for x in self.tweets if x[0] in [userId]+self.friends[userId]]\n            return list(reversed(tweets))[:10]\n        except:\n            return \n\n    def follow(self followerId: int followeeId: int) -> None:\n        self.friends[followerId].append(followeeId)  \n\n    def unfollow(self followerId: int followeeId: int) -> None:\n        try:\n            self.friends[followerId].remove(followeeId)\n        except:\n            pass\n
Design Underground System,"###  1396\. Design Underground System\n\nAn underground railway system is keeping track of customer travel times\nbetween different stations. They are using this data to calculate the average\ntime it takes to travel from one station to another.\n\nImplement the `UndergroundSystem` class:\n\n  * `void checkIn(int id string stationName int t)`\n    * A customer with a card ID equal to `id` checks in at the station `stationName` at time `t`.\n    * A customer can only be checked into one place at a time.\n  * `void checkOut(int id string stationName int t)`\n    * A customer with a card ID equal to `id` checks out from the station `stationName` at time `t`.\n  * `double getAverageTime(string startStation string endStation)`\n    * Returns the average time it takes to travel from `startStation` to `endStation`.\n    * The average time is computed from all the previous traveling times from `startStation` to `endStation` that happened **directly**  meaning a check in at `startStation` followed by a check out from `endStation`.\n    * The time it takes to travel from `startStation` to `endStation` **may be different** from the time it takes to travel from `endStation` to `startStation`.\n    * There will be at least one customer that has traveled from `startStation` to `endStation` before `getAverageTime` is called.\n\nYou may assume all calls to the `checkIn` and `checkOut` methods are\nconsistent. If a customer checks in at time `t1` then checks out at time `t2`\nthen `t1 < t2`. All events happen in chronological order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""UndergroundSystem""""checkIn""""checkIn""""checkIn""""checkOut""""checkOut""""checkOut""""getAverageTime""""getAverageTime""""checkIn""""getAverageTime""""checkOut""""getAverageTime""]\n    [[][45""Leyton""3][32""Paradise""8][27""Leyton""10][45""Waterloo""15][27""Waterloo""20][32""Cambridge""22][""Paradise""""Cambridge""][""Leyton""""Waterloo""][10""Leyton""24][""Leyton""""Waterloo""][10""Waterloo""38][""Leyton""""Waterloo""]]\n    \n    **Output**\n    [nullnullnullnullnullnullnull14.0000011.00000null11.00000null12.00000]\n    \n    **Explanation**\n    UndergroundSystem undergroundSystem = new UndergroundSystem();\n    undergroundSystem.checkIn(45 ""Leyton"" 3);\n    undergroundSystem.checkIn(32 ""Paradise"" 8);\n    undergroundSystem.checkIn(27 ""Leyton"" 10);\n    undergroundSystem.checkOut(45 ""Waterloo"" 15);  // Customer 45 ""Leyton"" -> ""Waterloo"" in 15-3 = 12\n    undergroundSystem.checkOut(27 ""Waterloo"" 20);  // Customer 27 ""Leyton"" -> ""Waterloo"" in 20-10 = 10\n    undergroundSystem.checkOut(32 ""Cambridge"" 22); // Customer 32 ""Paradise"" -> ""Cambridge"" in 22-8 = 14\n    undergroundSystem.getAverageTime(""Paradise"" ""Cambridge""); // return 14.00000. One trip ""Paradise"" -> ""Cambridge"" (14) / 1 = 14\n    undergroundSystem.getAverageTime(""Leyton"" ""Waterloo"");    // return 11.00000. Two trips ""Leyton"" -> ""Waterloo"" (10 + 12) / 2 = 11\n    undergroundSystem.checkIn(10 ""Leyton"" 24);\n    undergroundSystem.getAverageTime(""Leyton"" ""Waterloo"");    // return 11.00000\n    undergroundSystem.checkOut(10 ""Waterloo"" 38);  // Customer 10 ""Leyton"" -> ""Waterloo"" in 38-24 = 14\n    undergroundSystem.getAverageTime(""Leyton"" ""Waterloo"");    // return 12.00000. Three trips ""Leyton"" -> ""Waterloo"" (10 + 12 + 14) / 3 = 12\n    \n\n**Example 2:**\n\n    \n    \n    **Input**\n    [""UndergroundSystem""""checkIn""""checkOut""""getAverageTime""""checkIn""""checkOut""""getAverageTime""""checkIn""""checkOut""""getAverageTime""]\n    [[][10""Leyton""3][10""Paradise""8][""Leyton""""Paradise""][5""Leyton""10][5""Paradise""16][""Leyton""""Paradise""][2""Leyton""21][2""Paradise""30][""Leyton""""Paradise""]]\n    \n    **Output**\n    [nullnullnull5.00000nullnull5.50000nullnull6.66667]\n    \n    **Explanation**\n    UndergroundSystem undergroundSystem = new UndergroundSystem();\n    undergroundSystem.checkIn(10 ""Leyton"" 3);\n    undergroundSystem.checkOut(10 ""Paradise"" 8); // Customer 10 ""Leyton"" -> ""Paradise"" in 8-3 = 5\n    undergroundSystem.getAverageTime(""Leyton"" ""Paradise""); // return 5.00000 (5) / 1 = 5\n    undergroundSystem.checkIn(5 ""Leyton"" 10);\n    undergroundSystem.checkOut(5 ""Paradise"" 16); // Customer 5 ""Leyton"" -> ""Paradise"" in 16-10 = 6\n    undergroundSystem.getAverageTime(""Leyton"" ""Paradise""); // return 5.50000 (5 + 6) / 2 = 5.5\n    undergroundSystem.checkIn(2 ""Leyton"" 21);\n    undergroundSystem.checkOut(2 ""Paradise"" 30); // Customer 2 ""Leyton"" -> ""Paradise"" in 30-21 = 9\n    undergroundSystem.getAverageTime(""Leyton"" ""Paradise""); // return 6.66667 (5 + 6 + 9) / 3 = 6.66667\n    \n\n\n\n**Constraints:**\n\n  * `1 <= id t <= 106`\n  * `1 <= stationName.length startStation.length endStation.length <= 10`\n  * All strings consist of uppercase and lowercase English letters and digits.\n  * There will be at most `2 * 104` calls **in total** to `checkIn` `checkOut` and `getAverageTime`.\n  * Answers within `10-5` of the actual value will be accepted.\n\n",# Runtime: 441 ms (Top 30.19%) | Memory: 23.9 MB (Top 87.19%)\nfrom collections import defaultdict\nclass UndergroundSystem:\n    def __init__(self):\n        self.checkin = {}\n        self.traveltime = defaultdict(dict)\n\n    def checkIn(self id: int stationName: str t: int) -> None:\n        self.checkin[id] = (stationName t)\n\n    def checkOut(self id: int stationName: str t: int) -> None:\n        startStation startTime = self.checkin[id]\n        del self.checkin[id]\n        if stationName not in self.traveltime[startStation]:\n            self.traveltime[startStation][stationName] = []\n        self.traveltime[startStation][stationName].append(t-startTime)\n\n    def getAverageTime(self startStation: str endStation: str) -> float:\n        return sum(self.traveltime[startStation][endStation])/len(self.traveltime[startStation][endStation])
Destination City,"###  1436\. Destination City\n\nYou are given the array `paths` where `paths[i] = [cityAi cityBi]` means\nthere exists a direct path going from `cityAi` to `cityBi`. _Return the\ndestination city that is the city without any path outgoing to another\ncity._\n\nIt is guaranteed that the graph of paths forms a line without any loop\ntherefore there will be exactly one destination city.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** paths = [[""London""""New York""][""New York""""Lima""][""Lima""""Sao Paulo""]]\n    **Output:** ""Sao Paulo"" \n    **Explanation:** Starting at ""London"" city you will reach ""Sao Paulo"" city which is the destination city. Your trip consist of: ""London"" -> ""New York"" -> ""Lima"" -> ""Sao Paulo"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** paths = [[""B""""C""][""D""""B""][""C""""A""]]\n    **Output:** ""A""\n    **Explanation:** All possible trips are: \n    ""D"" -> ""B"" -> ""C"" -> ""A"". \n    ""B"" -> ""C"" -> ""A"". \n    ""C"" -> ""A"". \n    ""A"". \n    Clearly the destination city is ""A"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** paths = [[""A""""Z""]]\n    **Output:** ""Z""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= paths.length <= 100`\n  * `paths[i].length == 2`\n  * `1 <= cityAi.length cityBi.length <= 10`\n  * `cityAi != cityBi`\n  * All strings consist of lowercase and uppercase English letters and the space character.\n\n",# Runtime: 101 ms (Top 25.06%) | Memory: 13.8 MB (Top 81.64%)\nfrom collections import defaultdict\nclass Solution:\n    def destCity(self paths: List[List[str]]) -> str:\n        deg = defaultdict(int)\n        for v w in paths:\n            deg[v] += 1\n            deg[w]\n        for v in deg:\n            if not deg[v]: return v
Destroying Asteroids,###  2126\. Destroying Asteroids\n\nYou are given an integer `mass` which represents the original mass of a\nplanet. You are further given an integer array `asteroids` where\n`asteroids[i]` is the mass of the `ith` asteroid.\n\nYou can arrange for the planet to collide with the asteroids in **any\narbitrary order**. If the mass of the planet is **greater than or equal to**\nthe mass of the asteroid the asteroid is **destroyed** and the planet\n**gains** the mass of the asteroid. Otherwise the planet is destroyed.\n\nReturn `true` _if**all** asteroids can be destroyed. Otherwise return\n_`false` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** mass = 10 asteroids = [3919521]\n    **Output:** true\n    **Explanation:** One way to order the asteroids is [9195321]:\n    - The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19\n    - The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38\n    - The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43\n    - The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46\n    - The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67\n    All asteroids are destroyed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mass = 5 asteroids = [49234]\n    **Output:** false\n    **Explanation:** \n    The planet cannot ever gain enough mass to destroy the asteroid with a mass of 23.\n    After the planet destroys the other asteroids it will have a mass of 5 + 4 + 9 + 4 = 22.\n    This is less than 23 so a collision would not destroy the last asteroid.\n\n\n\n**Constraints:**\n\n  * `1 <= mass <= 105`\n  * `1 <= asteroids.length <= 105`\n  * `1 <= asteroids[i] <= 105`\n\n,# Runtime: 2207 ms (Top 14.71%) | Memory: 27.8 MB (Top 42.78%)\nclass Solution:\n    def asteroidsDestroyed(self mass: int asteroids: List[int]) -> bool:\n        asteroids = sorted(asteroids)\n        for i in asteroids:\n            if i <= mass:\n                mass += i\n            else:\n                return False\n        return True
Detect Capital,"###  520\. Detect Capital\n\nWe define the usage of capitals in a word to be right when one of the\nfollowing cases holds:\n\n  * All letters in this word are capitals like `""USA""`.\n  * All letters in this word are not capitals like `""leetcode""`.\n  * Only the first letter in this word is capital like `""Google""`.\n\nGiven a string `word` return `true` if the usage of capitals in it is right.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word = ""USA""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word = ""FlaG""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word.length <= 100`\n  * `word` consists of lowercase and uppercase English letters.\n\n",class Solution:\n    def detectCapitalUse(self word: str) -> bool:\n        l=len(word)\n        if l==1:\n            return True\n        if word[0]==word[0].lower() and word[1]==word[1].upper():\n            return False\n            \n        u=False\n        if word[0]==word[0].upper():\n            if word[1]==word[1].upper():\n                u=True\n                \n        for i in word[2:]:\n            if i==i.upper() and u==False:\n                return False\n            elif i==i.lower() and u==True:\n                return False\n        return True\n
Detect Cycles in 2D Grid,"###  1559\. Detect Cycles in 2D Grid\n\nGiven a 2D array of characters `grid` of size `m x n` you need to find if\nthere exists any cycle consisting of the **same value** in `grid`.\n\nA cycle is a path of **length 4 or more** in the grid that starts and ends at\nthe same cell. From a given cell you can move to one of the cells adjacent to\nit - in one of the four directions (up down left or right) if it has the\n**same value** of the current cell.\n\nAlso you cannot move to the cell that you visited in your last move. For\nexample the cycle `(1 1) -> (1 2) -> (1 1)` is invalid because from `(1\n2)` we visited `(1 1)` which was the last visited cell.\n\nReturn `true` if any cycle of the same value exists in `grid` otherwise\nreturn `false`.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/07/15/1.png)**\n\n    \n    \n    **Input:** grid = [[""a""""a""""a""""a""][""a""""b""""b""""a""][""a""""b""""b""""a""][""a""""a""""a""""a""]]\n    **Output:** true\n    **Explanation:** There are two valid cycles shown in different colors in the image below:\n    ![](https://assets.leetcode.com/uploads/2020/07/15/11.png)\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2020/07/15/22.png)**\n\n    \n    \n    **Input:** grid = [[""c""""c""""c""""a""][""c""""d""""c""""c""][""c""""c""""e""""c""][""f""""c""""c""""c""]]\n    **Output:** true\n    **Explanation:** There is only one valid cycle highlighted in the image below:\n    ![](https://assets.leetcode.com/uploads/2020/07/15/2.png)\n    \n\n**Example 3:**\n\n**![](https://assets.leetcode.com/uploads/2020/07/15/3.png)**\n\n    \n    \n    **Input:** grid = [[""a""""b""""b""][""b""""z""""b""][""b""""b""""a""]]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 500`\n  * `grid` consists only of lowercase English letters.\n\n",class Solution:\n    def containsCycle(self grid: List[List[str]]) -> bool:\n        \n        def getNeighbours(rowcolchar):\n            neighbours = []\n            if row > 0 and grid[row-1][col] == char and not visited[row-1][col]:\n                neighbours.append([row-1col])\n            if col > 0 and grid[row][col-1] == char and not visited[row][col-1]:\n                neighbours.append([rowcol-1])\n            if row < len(grid)-1 and grid[row+1][col] == char and not visited[row+1][col]:\n                neighbours.append([row+1col])\n            if col < len(grid[0])-1 and grid[row][col+1] == char and not visited[row][col+1]:\n                neighbours.append([rowcol+1])\n            return neighbours\n        \n        def dfs(rowcolcharcyclePresent):\n            if visited[row][col] or cyclePresent:\n                cyclePresent = True\n                return cyclePresent\n            visited[row][col] = True\n            neighbours = getNeighbours(rowcolchar)\n            for rc in neighbours:\n                cyclePresent = dfs(rccharcyclePresent)\n            return cyclePresent\n        \n        visited = [[False for _ in range(len(grid[0]))] for _ in range(len(grid))]\n        cyclePresent = False\n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if cyclePresent:\n                    return True\n                if visited[row][col]:\n                    continue\n                cyclePresent = dfs(rowcolgrid[row][col]cyclePresent)\n        \n        return cyclePresent\n
Detect Pattern of Length M Repeated K or More Times,###  1566\. Detect Pattern of Length M Repeated K or More Times\n\nGiven an array of positive integers `arr` find a pattern of length `m` that\nis repeated `k` or more times.\n\nA **pattern** is a subarray (consecutive sub-sequence) that consists of one or\nmore values repeated multiple times **consecutively** without overlapping. A\npattern is defined by its length and the number of repetitions.\n\nReturn `true` _if there exists a pattern of length_ `m` _that is repeated_ `k`\n_or more times otherwise return_ `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [124444] m = 1 k = 3\n    **Output:** true\n    **Explanation:** The pattern **(4)** of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [12121113] m = 2 k = 2\n    **Output:** true\n    **Explanation:** The pattern **(12)** of length 2 is repeated 2 consecutive times. Another valid pattern **(21) is** also repeated 2 times.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [121213] m = 2 k = 3\n    **Output:** false\n    **Explanation:** The pattern (12) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= arr.length <= 100`\n  * `1 <= arr[i] <= 100`\n  * `1 <= m <= 100`\n  * `2 <= k <= 100`\n\n,class Solution:\n    def containsPattern(self arr: List[int] m: int k: int) -> bool:\n        if len(arr) < k*m:\n            return False\n        \n        n = len(arr)\n        pattern = arr[0:m]\n        repeats = 1\n        for i in range(m n - m + 1 m):\n            if arr[i:i+m] != pattern:\n                break\n            \n            repeats += 1\n            if repeats >= k:\n                return True\n            \n        return self.containsPattern(arr[1:] m k)
Detect Squares,"###  2013\. Detect Squares\n\nYou are given a stream of points on the X-Y plane. Design an algorithm that:\n\n  * **Adds** new points from the stream into a data structure. **Duplicate** points are allowed and should be treated as different points.\n  * Given a query point **counts** the number of ways to choose three points from the data structure such that the three points and the query point form an **axis-aligned square** with **positive area**.\n\nAn **axis-aligned square** is a square whose edges are all the same length and\nare either parallel or perpendicular to the x-axis and y-axis.\n\nImplement the `DetectSquares` class:\n\n  * `DetectSquares()` Initializes the object with an empty data structure.\n  * `void add(int[] point)` Adds a new point `point = [x y]` to the data structure.\n  * `int count(int[] point)` Counts the number of ways to form **axis-aligned squares** with point `point = [x y]` as described above.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/09/01/image.png)\n\n    \n    \n    **Input**\n    [""DetectSquares"" ""add"" ""add"" ""add"" ""count"" ""count"" ""add"" ""count""]\n    [[] [[3 10]] [[11 2]] [[3 2]] [[11 10]] [[14 8]] [[11 2]] [[11 10]]]\n    **Output**\n    [null null null null 1 0 null 2]\n    \n    **Explanation**\n    DetectSquares detectSquares = new DetectSquares();\n    detectSquares.add([3 10]);\n    detectSquares.add([11 2]);\n    detectSquares.add([3 2]);\n    detectSquares.count([11 10]); // return 1. You can choose:\n                                   //   - The first second and third points\n    detectSquares.count([14 8]);  // return 0. The query point cannot form a square with any points in the data structure.\n    detectSquares.add([11 2]);    // Adding duplicate points is allowed.\n    detectSquares.count([11 10]); // return 2. You can choose:\n                                   //   - The first second and third points\n                                   //   - The first third and fourth points\n    \n\n\n\n**Constraints:**\n\n  * `point.length == 2`\n  * `0 <= x y <= 1000`\n  * At most `3000` calls **in total** will be made to `add` and `count`.\n\n","# Runtime: 658 ms (Top 42.61%) | Memory: 16 MB (Top 39.48%)\n""""""\nStore every points and number of their appearance\nGroup the points by their x value\n\nGiven a point(x1y1) to count try to find p2(x1y2)p3(x2y2)p4(x2y1)\nand add product of their appearances\n\nGo through every points that has same x1(except the point that is the same as (x1y1) the length of the side of the square is decided by abd(y2-y1).\n\nUse the decided side length to calculate p3 and p4 see if they are in the dict. If do add product of their appearances.\n\np3 p2 p3`\n\np4 p1 p4`\n\nNotice that p3 and p4 can be on both left side and right side of side (p2p1)\n\n""""""\nfrom collections import defaultdict\nclass DetectSquares:\n\n    def __init__(self):\n        self.pts=defaultdict(int)\n        self.by_x=defaultdict(set)\n\n    def add(self point: List[int]) -> None:\n        self.pts[(point[0]point[1])]+=1\n        self.by_x[point[0]].add((point[0]point[1]))\n\n    def count(self p1: List[int]) -> int:\n        res=0\n        x1y1=p1[0]p1[1]\n        if x1 in self.by_x:\n            #p2:x1y2\n            for p2 in self.by_x[x1]:\n                x2y2=p2\n                if y1==y2:\n                    continue\n                #length of side of square\n                b=abs(y1-y2)\n                #left side\n                p3=(x1-by2)\n                p4=(x1-by1)\n                if p3 in self.pts and p4 in self.pts:\n                    res+=self.pts[p2]*self.pts[p3]*self.pts[p4]\n                #right side\n                p3=(x1+by2)\n                p4=(x1+by1)\n                if p3 in self.pts and p4 in self.pts:\n                    res+=self.pts[p2]*self.pts[p3]*self.pts[p4]\n        return res\n\n# Your DetectSquares object will be instantiated and called as such:\n# obj = DetectSquares()\n# obj.add(point)\n# param_2 = obj.count(point)"
Determine Color of a Chessboard Square,"###  1812\. Determine Color of a Chessboard Square\n\nYou are given `coordinates` a string that represents the coordinates of a\nsquare of the chessboard. Below is a chessboard for your reference.\n\n![](https://assets.leetcode.com/uploads/2021/02/19/screenshot-2021-02-20-at-22159-pm.png)\n\nReturn `true` _if the square is white and_`false` _if the square is black_.\n\nThe coordinate will always represent a valid chessboard square. The coordinate\nwill always have the letter first and the number second.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** coordinates = ""a1""\n    **Output:** false\n    **Explanation:** From the chessboard above the square with coordinates ""a1"" is black so return false.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** coordinates = ""h3""\n    **Output:** true\n    **Explanation:** From the chessboard above the square with coordinates ""h3"" is white so return true.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** coordinates = ""c7""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `coordinates.length == 2`\n  * `'a' <= coordinates[0] <= 'h'`\n  * `'1' <= coordinates[1] <= '8'`\n\n",# Runtime: 62 ms (Top 10.11%) | Memory: 13.8 MB (Top 56.37%)\nclass Solution:\n    def squareIsWhite(self coordinates: str) -> bool:\n        return (ord(coordinates[0])+ord(coordinates[1]))%2
Determine if String Halves Are Alike,"###  1704\. Determine if String Halves Are Alike\n\nYou are given a string `s` of even length. Split this string into two halves\nof equal lengths and let `a` be the first half and `b` be the second half.\n\nTwo strings are **alike** if they have the same number of vowels (`'a'`\n`'e'` `'i'` `'o'` `'u'` `'A'` `'E'` `'I'` `'O'` `'U'`). Notice that\n`s` contains uppercase and lowercase letters.\n\nReturn `true` _if_`a` _and_`b` _are**alike**_. Otherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""book""\n    **Output:** true\n    **Explanation:** a = ""b _o_ "" and b = ""_o_ k"". a has 1 vowel and b has 1 vowel. Therefore they are alike.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""textbook""\n    **Output:** false\n    **Explanation:** a = ""t _e_ xt"" and b = ""b _oo_ k"". a has 1 vowel whereas b has 2. Therefore they are not alike.\n    Notice that the vowel o is counted twice.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 1000`\n  * `s.length` is even.\n  * `s` consists of **uppercase and lowercase** letters.\n\n","vowels = ""aeiouAEIOU""\n\nclass Solution:\n    def halvesAreAlike(self S: str) -> bool:\n        mid ans = len(S) // 2 0\n        for i in range(mid):\n            if S[i] in vowels: ans += 1\n            if S[mid+i] in vowels: ans -=1\n        return ans == 0\n"
Detonate the Maximum Bombs,###  2101\. Detonate the Maximum Bombs\n\nYou are given a list of bombs. The **range** of a bomb is defined as the area\nwhere its effect can be felt. This area is in the shape of a **circle** with\nthe center as the location of the bomb.\n\nThe bombs are represented by a **0-indexed** 2D integer array `bombs` where\n`bombs[i] = [xi yi ri]`. `xi` and `yi` denote the X-coordinate and\nY-coordinate of the location of the `ith` bomb whereas `ri` denotes the\n**radius** of its range.\n\nYou may choose to detonate a **single** bomb. When a bomb is detonated it\nwill detonate **all bombs** that lie in its range. These bombs will further\ndetonate the bombs that lie in their ranges.\n\nGiven the list of `bombs` return _the**maximum** number of bombs that can be\ndetonated if you are allowed to detonate **only one** bomb_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-3.png)\n\n    \n    \n    **Input:** bombs = [[213][614]]\n    **Output:** 2\n    **Explanation:**\n    The above figure shows the positions and ranges of the 2 bombs.\n    If we detonate the left bomb the right bomb will not be affected.\n    But if we detonate the right bomb both bombs will be detonated.\n    So the maximum bombs that can be detonated is max(1 2) = 2.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/11/06/desmos-eg-2.png)\n\n    \n    \n    **Input:** bombs = [[115][10105]]\n    **Output:** 1\n    **Explanation:** Detonating either bomb will not detonate the other bomb so the maximum number of bombs that can be detonated is 1.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/11/07/desmos-eg1.png)\n\n    \n    \n    **Input:** bombs = [[123][231][342][453][564]]\n    **Output:** 5\n    **Explanation:**\n    The best bomb to detonate is bomb 0 because:\n    - Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.\n    - Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.\n    - Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.\n    Thus all 5 bombs are detonated.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= bombs.length <= 100`\n  * `bombs[i].length == 3`\n  * `1 <= xi yi ri <= 105`\n\n,class Solution(object):\n    def maximumDetonation(self bombs):\n        def count(i):\n            dq ret = [i] [i]\n            while len(dq) > 0:\n                i = dq.pop()\n                for j in adj[i]:\n                    if j not in ret and j not in dq:\n                        dq.append(j)\n                        ret.append(j)\n            return len(ret)\n\n        adj = collections.defaultdict(list)\n        for i in range(len(bombs)):\n            for j in range(i + 1 len(bombs)):\n                if (bombs[i][0] - bombs[j][0]) ** 2 + (bombs[i][1] - bombs[j][1]) ** 2 <= bombs[i][2] ** 2:\n                    adj[i].append(j)\n                if (bombs[i][0] - bombs[j][0]) ** 2 + (bombs[i][1] - bombs[j][1]) ** 2 <= bombs[j][2] ** 2:\n                    adj[j].append(i)\n        ret = 0\n        for i in range(len(bombs)):\n            ret = max(ret count(i))\n        return ret\n
DI String Match,"###  942\. DI String Match\n\nA permutation `perm` of `n + 1` integers of all the integers in the range `[0\nn]` can be represented as a string `s` of length `n` where:\n\n  * `s[i] == 'I'` if `perm[i] < perm[i + 1]` and\n  * `s[i] == 'D'` if `perm[i] > perm[i + 1]`.\n\nGiven a string `s` reconstruct the permutation `perm` and return it. If there\nare multiple valid permutations perm return **any of them**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""IDID""\n    **Output:** [04132]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""III""\n    **Output:** [0123]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""DDI""\n    **Output:** [3201]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is either `'I'` or `'D'`.\n\n","class Solution:\n    def diStringMatch(self s: str) -> List[int]:\n        result = []\n        min_ = 0\n        max_ = len(s)\n        for x in s:\n            if x==""I"":\n                result.append(min_)\n                min_ += 1\n            elif x==""D"":\n                result.append(max_)\n                max_ -= 1\n        result.append(min_)\n        return result\n"
Diagonal Traverse,###  498\. Diagonal Traverse\n\nGiven an `m x n` matrix `mat` return _an array of all the elements of the\narray in a diagonal order_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg)\n\n    \n    \n    **Input:** mat = [[123][456][789]]\n    **Output:** [124753689]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mat = [[12][34]]\n    **Output:** [1234]\n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat[i].length`\n  * `1 <= m n <= 104`\n  * `1 <= m * n <= 104`\n  * `-105 <= mat[i][j] <= 105`\n\n,class Solution:\n    def findDiagonalOrder(self mat: List[List[int]]) -> List[int]:\n        flag rowNum colNum = True len(mat) len(mat[0])\n\n        total ans = 0 []\n        while total <= rowNum + colNum - 2:\n            iLimited = rowNum - 1 if flag else colNum - 1 \n            jLimited = colNum - 1 if flag else rowNum - 1\n            i = total if total < iLimited else iLimited\n            j = total - i\n            while i >= 0 and j <= jLimited:\n                if flag:\n                    ans.append(mat[i][j])\n                else:\n                    ans.append(mat[j][i])\n                i -= 1\n                j += 1\n            total += 1\n            flag = not flag\n        return ans\n
Diagonal Traverse II,###  1424\. Diagonal Traverse II\n\nGiven a 2D integer array `nums` return _all elements of_`nums` _in diagonal\norder as shown in the below images_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/04/08/sample_1_1784.png)\n\n    \n    \n    **Input:** nums = [[123][456][789]]\n    **Output:** [142753869]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/04/08/sample_2_1784.png)\n\n    \n    \n    **Input:** nums = [[12345][67][8][91011][1213141516]]\n    **Output:** [16287394121051311141516]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i].length <= 105`\n  * `1 <= sum(nums[i].length) <= 105`\n  * `1 <= nums[i][j] <= 105`\n\n,"class Solution:\n    def findDiagonalOrder(self nums: List[List[int]]) -> List[int]:\n		# sort the index of element\n        heap = list()\n        n = len(nums)\n        for i in range(n):\n            m = len(nums[i])\n            for j in range(m):\n                heapq.heappush(heap[i+jji])\n				\n		# append the element one by one\n        ans = []\n        while heap:\n            temp = heapq.heappop(heap)\n            ans.append(nums[temp[2]][temp[1]])\n        return ans\n"
Diameter of Binary Tree,###  543\. Diameter of Binary Tree\n\nGiven the `root` of a binary tree return _the length of the**diameter** of\nthe tree_.\n\nThe **diameter** of a binary tree is the **length** of the longest path\nbetween any two nodes in a tree. This path may or may not pass through the\n`root`.\n\nThe **length** of a path between two nodes is represented by the number of\nedges between them.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)\n\n    \n    \n    **Input:** root = [12345]\n    **Output:** 3\n    **Explanation:** 3 is the length of the path [4213] or [5213].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [12]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `-100 <= Node.val <= 100`\n\n,"# Runtime: 95 ms (Top 16.95%) | Memory: 16.5 MB (Top 10.21%)\nclass Solution:\n    """"""\n    Top Down recursion approach: it is sub optimal\n    """"""\n    def __init__(self):\n        self.max_diameter = 0\n    def diameter(self root):\n        if root is None:\n            return 0\n        return self.max_depth(root.left) + self.max_depth(root.right)\n\n    def max_depth(self root):\n        if root is None:\n            return 0\n        return 1 + max(self.max_depth(root.left) self.max_depth(root.right))\n\n    def func(self root):\n        if root is not None:\n            diameter = self.diameter(root)\n            if self.max_diameter < diameter:\n                self.max_diameter = diameter\n            self.diameterOfBinaryTree(root.left)\n            self.diameterOfBinaryTree(root.right)\n\n    def diameterOfBinaryTree(self root: Optional[TreeNode]) -> int:\n        self.func(root)\n        return self.max_diameter\n\n    """"""\n    Better Approach: I can try to approach this problem using bottom up recursion\n    """"""\n    def diameterOfBinaryTree(self root: Optional[TreeNode]) -> int:\n        self.diameter = 0\n        def fun(root):\n            if root is None:\n                return 0\n            left = fun(root.left)\n            right = fun(root.right)\n            if left + right > self.diameter:\n                self.diameter = left + right\n            return max(left right) + 1\n        fun(root)\n        return self.diameter"
Dice Roll Simulation,###  1223\. Dice Roll Simulation\n\nA die simulator generates a random number from `1` to `6` for each roll. You\nintroduced a constraint to the generator such that it cannot roll the number\n`i` more than `rollMax[i]` (**1-indexed**) consecutive times.\n\nGiven an array of integers `rollMax` and an integer `n` return _the number of\ndistinct sequences that can be obtained with exact_`n` _rolls_. Since the\nanswer may be too large return it **modulo** `109 + 7`.\n\nTwo sequences are considered different if at least one element differs from\neach other.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2 rollMax = [112223]\n    **Output:** 34\n    **Explanation:** There will be 2 rolls of die if there are no constraints on the die there are 6 * 6 = 36 possible combinations. In this case looking at rollMax array the numbers 1 and 2 appear at most once consecutively therefore sequences (11) and (22) cannot occur so the final answer is 36-2 = 34.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 rollMax = [111111]\n    **Output:** 30\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3 rollMax = [111223]\n    **Output:** 181\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 5000`\n  * `rollMax.length == 6`\n  * `1 <= rollMax[i] <= 15`\n\n,class Solution:\n    def dieSimulator(self n: int rollMax: List[int]) -> int:\n        dp = {}\n        def solve(nlastcount):\n            if n == 0: return 1\n            if (nlastcount) in dp: return dp[(nlastcount)]\n            ans = 0\n            for i in range(6):\n                if last == i:\n                    if count == rollMax[i]: continue\n                    ans += solve(n-1lastcount + 1)\n                else:\n                    ans += solve(n-1i1)\n            dp[(nlastcount)] = ans\n            return ans\n        \n        return solve(nNone0) % 1000000007\n
Dinner Plate Stacks,"###  1172\. Dinner Plate Stacks\n\nYou have an infinite number of stacks arranged in a row and numbered (left to\nright) from `0` each of the stacks has the same maximum capacity.\n\nImplement the `DinnerPlates` class:\n\n  * `DinnerPlates(int capacity)` Initializes the object with the maximum capacity of the stacks `capacity`.\n  * `void push(int val)` Pushes the given integer `val` into the leftmost stack with a size less than `capacity`.\n  * `int pop()` Returns the value at the top of the rightmost non-empty stack and removes it from that stack and returns `-1` if all the stacks are empty.\n  * `int popAtStack(int index)` Returns the value at the top of the stack with the given index `index` and removes it from that stack or returns `-1` if the stack with that given index is empty.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""DinnerPlates"" ""push"" ""push"" ""push"" ""push"" ""push"" ""popAtStack"" ""push"" ""push"" ""popAtStack"" ""popAtStack"" ""pop"" ""pop"" ""pop"" ""pop"" ""pop""]\n    [[2] [1] [2] [3] [4] [5] [0] [20] [21] [0] [2] [] [] [] [] []]\n    **Output**\n    [null null null null null null 2 null null 20 21 5 4 3 1 -1]\n    \n    **Explanation:** \n    DinnerPlates D = DinnerPlates(2);  // Initialize with capacity = 2\n    D.push(1);\n    D.push(2);\n    D.push(3);\n    D.push(4);\n    D.push(5);         // The stacks are now:  2  4\n                                               1  3  5\n                                               ﹈ ﹈ ﹈\n    D.popAtStack(0);   // Returns 2.  The stacks are now:     4\n                                                           1  3  5\n                                                           ﹈ ﹈ ﹈\n    D.push(20);        // The stacks are now: 20  4\n                                               1  3  5\n                                               ﹈ ﹈ ﹈\n    D.push(21);        // The stacks are now: 20  4 21\n                                               1  3  5\n                                               ﹈ ﹈ ﹈\n    D.popAtStack(0);   // Returns 20.  The stacks are now:     4 21\n                                                            1  3  5\n                                                            ﹈ ﹈ ﹈\n    D.popAtStack(2);   // Returns 21.  The stacks are now:     4\n                                                            1  3  5\n                                                            ﹈ ﹈ ﹈ \n    D.pop()            // Returns 5.  The stacks are now:      4\n                                                            1  3 \n                                                            ﹈ ﹈  \n    D.pop()            // Returns 4.  The stacks are now:   1  3 \n                                                            ﹈ ﹈   \n    D.pop()            // Returns 3.  The stacks are now:   1 \n                                                            ﹈   \n    D.pop()            // Returns 1.  There are no stacks.\n    D.pop()            // Returns -1.  There are still no stacks.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= capacity <= 2 * 104`\n  * `1 <= val <= 2 * 104`\n  * `0 <= index <= 105`\n  * At most `2 * 105` calls will be made to `push` `pop` and `popAtStack`.\n\n",class DinnerPlates:\n\n    def __init__(self capacity: int):\n        self.heap = []\n        self.stacks = []\n        self.capacity = capacity\n\n    def push(self val: int) -> None:\n        if self.heap:\n            index = heapq.heappop(self.heap)\n            if index < len(self.stacks):\n                self.stacks[index].append(val)\n            else:\n                self.push(val)\n        elif self.stacks:\n            lastStack = self.stacks[-1]\n            if len(lastStack) != self.capacity:\n                lastStack.append(val)\n            else:\n                stack = deque()\n                stack.append(val)\n                self.stacks.append(stack)\n        else:\n            stack = deque()\n            stack.append(val)\n            self.stacks.append(stack)\n            \n    def pop(self) -> int:\n        while self.stacks:\n            lastStack = self.stacks[-1]\n            if lastStack:\n                val = lastStack.pop()\n                if not lastStack:\n                    self.stacks.pop()\n                return val\n            else:\n                self.stacks.pop()\n        return -1\n\n    def popAtStack(self index: int) -> int:\n        if index == len(self.stacks) - 1:\n            return self.pop()\n        if index < len(self.stacks):\n            stack = self.stacks[index]\n            if stack:\n                val = stack.pop()\n                heapq.heappush(self.heap index)\n                return val\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)\n
Distant Barcodes,###  1054\. Distant Barcodes\n\nIn a warehouse there is a row of barcodes where the `ith` barcode is\n`barcodes[i]`.\n\nRearrange the barcodes so that no two adjacent barcodes are equal. You may\nreturn any answer and it is guaranteed an answer exists.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** barcodes = [111222]\n    **Output:** [212121]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** barcodes = [11112233]\n    **Output:** [13131212]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= barcodes.length <= 10000`\n  * `1 <= barcodes[i] <= 10000`\n\n,# Runtime: 1287 ms (Top 5.56%) | Memory: 16.2 MB (Top 67.41%)\n\nimport heapq\n\nclass Solution:\n\n    def rearrangeBarcodes(self barcodes: List[int]) -> List[int]:\n        barcodes_counter = Counter(barcodes)\n        if len(barcodes_counter) == len(barcodes):\n            return barcodes\n\n        barcodes_heapq = [ (-c b) for b c in barcodes_counter.items() ]\n        heapq.heapify(barcodes_heapq)\n\n        idx prev_count prev_barcode = 0 0 0\n        while barcodes_heapq:\n            (curr_count curr_barcode) = heapq.heappop(barcodes_heapq)\n\n            barcodes[idx] = curr_barcode\n            idx += 1\n            curr_count += 1\n\n            if prev_count:\n                heapq.heappush(barcodes_heapq (prev_count prev_barcode))\n\n            prev_count prev_barcode = curr_count curr_barcode\n\n        return barcodes\n
Distinct Echo Substrings,"###  1316\. Distinct Echo Substrings\n\nReturn the number of **distinct** non-empty substrings of `text` that can be\nwritten as the concatenation of some string with itself (i.e. it can be\nwritten as `a + a` where `a` is some string).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text = ""abcabcabc""\n    **Output:** 3\n    **Explanation:** The 3 substrings are ""abcabc"" ""bcabca"" and ""cabcab"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text = ""leetcodeleetcode""\n    **Output:** 2\n    **Explanation:** The 2 substrings are ""ee"" and ""leetcodeleetcode"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length <= 2000`\n  * `text` has only lowercase English letters.\n\n",class Solution:\n    def distinctEchoSubstrings(self s: str) -> int:\n        hash=set()\n        n=len(s)\n        for i in range(n):\n            for j in range(i):\n                \n                if (i-j)&1==1:\n                    \n                    k=(i-j)//2\n                    \n                    if s[j:j+k+1]==s[j+k+1:i+1]:\n                        hash.add(s[j:j+k+1]+s[j+k+1:i+1])\n        return len(hash)\n                    \n                    \n                    \n        \n
Distinct Subsequences II,"###  940\. Distinct Subsequences II\n\nGiven a string s return _the number of**distinct non-empty subsequences** of_\n`s`. Since the answer may be very large return it **modulo** `109 + 7`.\n\nA **subsequence** of a string is a new string that is formed from the original\nstring by deleting some (can be none) of the characters without disturbing the\nrelative positions of the remaining characters. (i.e. `""ace""` is a\nsubsequence of `""_a_ b _c_ d _e_ ""` while `""aec""` is not.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abc""\n    **Output:** 7\n    **Explanation:** The 7 distinct subsequences are ""a"" ""b"" ""c"" ""ab"" ""ac"" ""bc"" and ""abc"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aba""\n    **Output:** 6\n    **Explanation:** The 6 distinct subsequences are ""a"" ""b"" ""ab"" ""aa"" ""ba"" and ""aba"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""aaa""\n    **Output:** 3\n    **Explanation:** The 3 distinct subsequences are ""a"" ""aa"" and ""aaa"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 2000`\n  * `s` consists of lowercase English letters.\n\n",class Solution:\n    def distinctSubseqII(self s: str) -> int:\n        #number of subsequences that startwith each alphabet\n        startwith = [0]*26\n        for c in s[::-1]:\n            startwith[ord(c)-ord('a')] = sum(startwith) + 1\n        return sum(startwith)%(10**9+7)\n
Distribute Candies,###  575\. Distribute Candies\n\nAlice has `n` candies where the `ith` candy is of type `candyType[i]`. Alice\nnoticed that she started to gain weight so she visited a doctor.\n\nThe doctor advised Alice to only eat `n / 2` of the candies she has (`n` is\nalways even). Alice likes her candies very much and she wants to eat the\nmaximum number of different types of candies while still following the\ndoctor's advice.\n\nGiven the integer array `candyType` of length `n` return _the**maximum**\nnumber of different types of candies she can eat if she only eats _`n / 2` _of\nthem_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** candyType = [112233]\n    **Output:** 3\n    **Explanation:** Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types she can eat one of each type.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** candyType = [1123]\n    **Output:** 2\n    **Explanation:** Alice can only eat 4 / 2 = 2 candies. Whether she eats types [12] [13] or [23] she still can only eat 2 different types.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** candyType = [6666]\n    **Output:** 1\n    **Explanation:** Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies she only has 1 type.\n    \n\n\n\n**Constraints:**\n\n  * `n == candyType.length`\n  * `2 <= n <= 104`\n  * `n` is even.\n  * `-105 <= candyType[i] <= 105`\n\n,# Runtime: 1728 ms (Top 12.88%) | Memory: 16.4 MB (Top 8.29%)\nclass Solution:\n    def distributeCandies(self candyType: List[int]) -> int:\n        return min(len(set(candyType)) (len(candyType)//2))
Distribute Candies to People,###  1103\. Distribute Candies to People\n\nWe distribute some number of `candies` to a row of **`n = num_people`**\npeople in the following way:\n\nWe then give 1 candy to the first person 2 candies to the second person and\nso on until we give `n` candies to the last person.\n\nThen we go back to the start of the row giving `n + 1` candies to the first\nperson `n + 2` candies to the second person and so on until we give `2 * n`\ncandies to the last person.\n\nThis process repeats (with us giving one more candy each time and moving to\nthe start of the row after we reach the end) until we run out of candies.  The\nlast person will receive all of our remaining candies (not necessarily one\nmore than the previous gift).\n\nReturn an array (of length `num_people` and sum `candies`) that represents the\nfinal distribution of candies.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** candies = 7 num_people = 4\n    **Output:** [1231]\n    **Explanation:**\n    On the first turn ans[0] += 1 and the array is [1000].\n    On the second turn ans[1] += 2 and the array is [1200].\n    On the third turn ans[2] += 3 and the array is [1230].\n    On the fourth turn ans[3] += 1 (because there is only one candy left) and the final array is [1231].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** candies = 10 num_people = 3\n    **Output:** [523]\n    **Explanation:**\n    On the first turn ans[0] += 1 and the array is [100].\n    On the second turn ans[1] += 2 and the array is [120].\n    On the third turn ans[2] += 3 and the array is [123].\n    On the fourth turn ans[0] += 4 and the final array is [523].\n    \n\n\n\n**Constraints:**\n\n  * 1 <= candies <= 10^9\n  * 1 <= num_people <= 1000\n\n,class Solution:\n    def distributeCandies(self candies: int num_people: int) -> List[int]:\n        candy_dict = {}\n        for i in range(num_people) : \n            candy_dict[i] = 0 \n        \n        candy i totalCandy = 1 0 0\n        while totalCandy < candies : \n            if i >= num_people : \n                i = 0\n            if candies - totalCandy >= candy : \n                candy_dict[i] += candy \n                totalCandy += candy\n            else : \n                candy_dict[i] += candies - totalCandy\n                totalCandy += candies - totalCandy\n            i += 1 \n            candy += 1  \n        return candy_dict.values()\n
Distribute Coins in Binary Tree,###  979\. Distribute Coins in Binary Tree\n\nYou are given the `root` of a binary tree with `n` nodes where each `node` in\nthe tree has `node.val` coins. There are `n` coins in total throughout the\nwhole tree.\n\nIn one move we may choose two adjacent nodes and move one coin from one node\nto another. A move may be from parent to child or from child to parent.\n\nReturn _the**minimum** number of moves required to make every node have\n**exactly** one coin_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/01/18/tree1.png)\n\n    \n    \n    **Input:** root = [300]\n    **Output:** 2\n    **Explanation:** From the root of the tree we move one coin to its left child and one coin to its right child.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/01/18/tree2.png)\n\n    \n    \n    **Input:** root = [030]\n    **Output:** 3\n    **Explanation:** From the left child of the root we move two coins to the root [taking two moves]. Then we move one coin from the root of the tree to the right child.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is `n`.\n  * `1 <= n <= 100`\n  * `0 <= Node.val <= n`\n  * The sum of all `Node.val` is `n`.\n\n,"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def distributeCoins(self root: Optional[TreeNode]) -> int:\n        \n        def dfs(root):\n            if not root:\n                return 00\n            \n            net_leftleft_walk = dfs(root.left)\n            net_rightright_walk = dfs(root.right)\n            \n			# if any node has extra or deficiency in both cases there has to be a walk of abs(extra) or abs(deficiency)\n			\n            return net_left+net_right+(root.val-1) left_walk+right_walk+abs(net_left)+abs(net_right)\n        return dfs(root)[1]\n"
Distribute Repeating Integers,###  1655\. Distribute Repeating Integers\n\nYou are given an array of `n` integers `nums` where there are at most `50`\nunique values in the array. You are also given an array of `m` customer order\nquantities `quantity` where `quantity[i]` is the amount of integers the\n`ith` customer ordered. Determine if it is possible to distribute `nums` such\nthat:\n\n  * The `ith` customer gets **exactly** `quantity[i]` integers\n  * The integers the `ith` customer gets are **all equal**  and\n  * Every customer is satisfied.\n\nReturn `true` _if it is possible to distribute_`nums` _according to the above\nconditions_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234] quantity = [2]\n    **Output:** false\n    **Explanation:** The 0th customer cannot be given two different integers.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1233] quantity = [2]\n    **Output:** true\n    **Explanation:** The 0th customer is given [33]. The integers [12] are not used.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1122] quantity = [22]\n    **Output:** true\n    **Explanation:** The 0th customer is given [11] and the 1st customer is given [22].\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 105`\n  * `1 <= nums[i] <= 1000`\n  * `m == quantity.length`\n  * `1 <= m <= 10`\n  * `1 <= quantity[i] <= 105`\n  * There are at most `50` unique values in `nums`.\n\n,// Runtime: 584 ms (Top 98.04%) | Memory: 28.70 MB (Top 26.47%)\n\nfrom collections import Counter defaultdict\n\nclass Solution:\n    def canDistribute(self nums: List[int] quantity: List[int]) -> bool:\n        quantity.sort(reverse=True)\n        freqCounts = defaultdict(int Counter(Counter(nums).values()))\n        def backtrack(i: int = 0) -> bool:\n            if i == len(quantity):\n                return True\n            \n            for freq count in list(freqCounts.items()):\n                if freq >= quantity[i] and count > 0:\n                    freqCounts[freq] -= 1\n                    freqCounts[freq - quantity[i]] += 1\n                    if backtrack(i + 1):\n                        return True\n                    freqCounts[freq] += 1\n                    freqCounts[freq - quantity[i]] -= 1\n            \n            return False\n        \n        return backtrack()\n
Divide a String Into Groups of Size k,"###  2138\. Divide a String Into Groups of Size k\n\nA string `s` can be partitioned into groups of size `k` using the following\nprocedure:\n\n  * The first group consists of the first `k` characters of the string the second group consists of the next `k` characters of the string and so on. Each character can be a part of **exactly one** group.\n  * For the last group if the string **does not** have `k` characters remaining a character `fill` is used to complete the group.\n\nNote that the partition is done so that after removing the `fill` character\nfrom the last group (if it exists) and concatenating all the groups in order\nthe resultant string should be `s`.\n\nGiven the string `s` the size of each group `k` and the character `fill`\nreturn _a string array denoting the**composition of every group** _`s` _has\nbeen divided into using the above procedure_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcdefghi"" k = 3 fill = ""x""\n    **Output:** [""abc""""def""""ghi""]\n    **Explanation:**\n    The first 3 characters ""abc"" form the first group.\n    The next 3 characters ""def"" form the second group.\n    The last 3 characters ""ghi"" form the third group.\n    Since all groups can be completely filled by characters from the string we do not need to use fill.\n    Thus the groups formed are ""abc"" ""def"" and ""ghi"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcdefghij"" k = 3 fill = ""x""\n    **Output:** [""abc""""def""""ghi""""jxx""]\n    **Explanation:**\n    Similar to the previous example we are forming the first three groups ""abc"" ""def"" and ""ghi"".\n    For the last group we can only use the character 'j' from the string. To complete this group we add 'x' twice.\n    Thus the 4 groups formed are ""abc"" ""def"" ""ghi"" and ""jxx"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s` consists of lowercase English letters only.\n  * `1 <= k <= 100`\n  * `fill` is a lowercase English letter.\n\n",// Runtime: 38 ms (Top 66.92%) | Memory: 17.30 MB (Top 6.27%)\n\nclass Solution:\n    def divideString(self s: str k: int fill: str) -> List[str]:\n        return [(s+k*fill)[i:i+k] for i in range(0len(s)k)]\n
Divide Array in Sets of K Consecutive Numbers,###  1296\. Divide Array in Sets of K Consecutive Numbers\n\nGiven an array of integers `nums` and a positive integer `k` check whether it\nis possible to divide this array into sets of `k` consecutive numbers.\n\nReturn `true` _if it is possible_.**** Otherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12334456] k = 4\n    **Output:** true\n    **Explanation:** Array can be divided into [1234] and [3456].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [32123434591011] k = 3\n    **Output:** true\n    **Explanation:** Array can be divided into [123]  [234]  [345] and [91011].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1234] k = 3\n    **Output:** false\n    **Explanation:** Each array should be divided in subarrays of size 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= nums.length <= 105`\n  * `1 <= nums[i] <= 109`\n\n\n\n**Note:** This question is the same as 846:\n<https://leetcode.com/problems/hand-of-straights/>\n\n,// Runtime: 304 ms (Top 99.22%) | Memory: 27.60 MB (Top 95.6%)\n\nclass Solution:\n    def isPossibleDivide(self nums: List[int] k: int) -> bool:\n        # if we see x we expect to see x+1 later\n        #   and then x+2 after that\n        #   and then x+3 after that\n\n        # so maybe we can enqueue (x+1 k-2)  === (next number expected count after x+1)\n        #   e.g. k == 2: find x enqueue (x+1 0)\n        \n        # for each x:\n        #   if front of queue has x pop it. Re-enqueue with rem-1 if rem else we finished a length k sequence\n        #   if front of queue has x' < x we have a gap. return False\n        #   otherwise we found the start of a new sequence: append (x+1 k-2)\n        #     meaning we found x (1) we're looking for x+1 (another 1) and after that we should find another k-2 numbers\n\n        if k == 1: return True # length 1 sequences are trivial\n\n        nums.sort()\n        q = deque()\n        for n in nums:\n            if not q or q[0][0] > n:\n                q.append((n+1 k-2))\n            elif q[0][0] == n:\n                _ rem = q.popleft()\n                if rem:\n                    q.append((n+1 rem-1))\n                # else: end of len k sequence\n            else:\n                return False # found n > next expected so we can't complete an earlier sequence\n\n        if q:\n            return False # expected at least one more element to finish a sequence\n        else:\n            return True\n
Divide Array Into Equal Pairs,###  2206\. Divide Array Into Equal Pairs\n\nYou are given an integer array `nums` consisting of `2 * n` integers.\n\nYou need to divide `nums` into `n` pairs such that:\n\n  * Each element belongs to **exactly one** pair.\n  * The elements present in a pair are **equal**.\n\nReturn `true` _if nums can be divided into_ `n` _pairs otherwise return_\n`false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [323222]\n    **Output:** true\n    **Explanation:** \n    There are 6 elements in nums so they should be divided into 6 / 2 = 3 pairs.\n    If nums is divided into the pairs (2 2) (3 3) and (2 2) it will satisfy all the conditions.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** false\n    **Explanation:** \n    There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.\n    \n\n\n\n**Constraints:**\n\n  * `nums.length == 2 * n`\n  * `1 <= n <= 500`\n  * `1 <= nums[i] <= 500`\n\n,# Runtime: 213 ms (Top 19.18%) | Memory: 14.1 MB (Top 63.60%)\nclass Solution:\n\n    def divideArray(self nums: List[int]) -> bool:\n        lena = len(nums)\n        count = sum(num//2 for num in Counter(nums).values())\n        return (lena/2 == count)\n
Divisor Game,###  1025\. Divisor Game\n\nAlice and Bob take turns playing a game with Alice starting first.\n\nInitially there is a number `n` on the chalkboard. On each player's turn\nthat player makes a move consisting of:\n\n  * Choosing any `x` with `0 < x < n` and `n % x == 0`.\n  * Replacing the number `n` on the chalkboard with `n - x`.\n\nAlso if a player cannot make a move they lose the game.\n\nReturn `true` _if and only if Alice wins the game assuming both players play\noptimally_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** true\n    **Explanation:** Alice chooses 1 and Bob has no more moves.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** false\n    **Explanation:** Alice chooses 1 Bob chooses 1 and Alice has no more moves.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n\n,// Runtime: 34 ms (Top 78.15%) | Memory: 16.60 MB (Top 64.13%)\n\nclass Solution:\n    def divisorGame(self n: int) -> bool:\n        return n%2 == 0\n
Domino and Tromino Tiling,###  790\. Domino and Tromino Tiling\n\nYou have two types of tiles: a `2 x 1` domino shape and a tromino shape. You\nmay rotate these shapes.\n\n![](https://assets.leetcode.com/uploads/2021/07/15/lc-domino.jpg)\n\nGiven an integer n return _the number of ways to tile an_ `2 x n` _board_.\nSince the answer may be very large return it **modulo** `109 + 7`.\n\nIn a tiling every square must be covered by a tile. Two tilings are different\nif and only if there are two 4-directionally adjacent cells on the board such\nthat exactly one of the tilings has both squares occupied by a tile.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/15/lc-domino1.jpg)\n\n    \n    \n    **Input:** n = 3\n    **Output:** 5\n    **Explanation:** The five different ways are show above.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n\n,# Runtime: 35 ms (Top 93.5%) | Memory: 16.27 MB (Top 85.2%)\n\nclass Solution(object):\n    def numTilings(self n):\n        dp = [1 2 5] + [0] * n\n        for i in range(3 n):\n            dp[i] = (dp[i - 1] * 2 + dp[i - 3]) % 1000000007\n        return dp[n - 1]
Dota2 Senate,"###  649\. Dota2 Senate\n\nIn the world of Dota2 there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists of senators coming from two parties. Now the Senate\nwants to decide on a change in the Dota2 game. The voting for this change is a\nround-based procedure. In each round each senator can exercise **one** of the\ntwo rights:\n\n  * **Ban one senator's right:** A senator can make another senator lose all his rights in this and all the following rounds.\n  * **Announce the victory:** If this senator found the senators who still have rights to vote are all from the same party he can announce the victory and decide on the change in the game.\n\nGiven a string `senate` representing each senator's party belonging. The\ncharacter `'R'` and `'D'` represent the Radiant party and the Dire party. Then\nif there are `n` senators the size of the given string will be `n`.\n\nThe round-based procedure starts from the first senator to the last senator in\nthe given order. This procedure will last until the end of voting. All the\nsenators who have lost their rights will be skipped during the procedure.\n\nSuppose every senator is smart enough and will play the best strategy for his\nown party. Predict which party will finally announce the victory and change\nthe Dota2 game. The output should be `""Radiant""` or `""Dire""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** senate = ""RD""\n    **Output:** ""Radiant""\n    **Explanation:** \n    The first senator comes from Radiant and he can just ban the next senator's right in round 1. \n    And the second senator can't exercise any rights anymore since his right has been banned. \n    And in round 2 the first senator can just announce the victory since he is the only guy in the senate who can vote.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** senate = ""RDD""\n    **Output:** ""Dire""\n    **Explanation:** \n    The first senator comes from Radiant and he can just ban the next senator's right in round 1. \n    And the second senator can't exercise any rights anymore since his right has been banned. \n    And the third senator comes from Dire and he can ban the first senator's right in round 1. \n    And in round 2 the third senator can just announce the victory since he is the only guy in the senate who can vote.\n    \n\n\n\n**Constraints:**\n\n  * `n == senate.length`\n  * `1 <= n <= 104`\n  * `senate[i]` is either `'R'` or `'D'`.\n\n","// Runtime: 44 ms (Top 92.53%) | Memory: 16.90 MB (Top 59.64%)\n\nfrom collections import deque\n\nclass Solution:\n    def predictPartyVictory(self senate: str) -> str:\n        n = len(senate)\n        radiant = deque()\n        dire = deque()\n        for i s in enumerate(senate):\n            if s == 'R':\n                radiant.append(i)\n            else:\n                dire.append(i)\n        while radiant and dire:\n            r_idx = radiant.popleft()\n            d_idx = dire.popleft()\n            if r_idx < d_idx:\n                radiant.append(r_idx + n)\n            else:\n                dire.append(d_idx + n)\n        return ""Radiant"" if radiant else ""Dire""\n\n"
Duplicate Zeros,###  1089\. Duplicate Zeros\n\nGiven a fixed-length integer array `arr` duplicate each occurrence of zero\nshifting the remaining elements to the right.\n\n**Note** that elements beyond the length of the original array are not\nwritten. Do the above modifications to the input array in place and do not\nreturn anything.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [10230450]\n    **Output:** [10023004]\n    **Explanation:** After calling your function the input array is modified to: [10023004]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [123]\n    **Output:** [123]\n    **Explanation:** After calling your function the input array is modified to: [123]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 104`\n  * `0 <= arr[i] <= 9`\n\n,"# Runtime: 107 ms (Top 60.66%) | Memory: 14.9 MB (Top 70.68%)\nclass Solution:\n    def duplicateZeros(self arr: List[int]) -> None:\n        """"""\n        Do not return anything modify arr in-place instead.\n        """"""\n        l = len(arr)\n        ic=00\n        while i<l:\n            if arr[i]==0:\n                arr.insert(i+10)\n                i+=1\n                arr.pop()\n            i+=1\n"
Earliest Possible Day of Full Bloom,###  2136\. Earliest Possible Day of Full Bloom\n\nYou have `n` flower seeds. Every seed must be planted first before it can\nbegin to grow then bloom. Planting a seed takes time and so does the growth\nof a seed. You are given two **0-indexed** integer arrays `plantTime` and\n`growTime` of length `n` each:\n\n  * `plantTime[i]` is the number of **full days** it takes you to **plant** the `ith` seed. Every day you can work on planting exactly one seed. You **do not** have to work on planting the same seed on consecutive days but the planting of a seed is not complete **until** you have worked `plantTime[i]` days on planting it in total.\n  * `growTime[i]` is the number of **full days** it takes the `ith` seed to grow after being completely planted. **After** the last day of its growth the flower **blooms** and stays bloomed forever.\n\nFrom the beginning of day `0` you can plant the seeds in **any** order.\n\nReturn _the**earliest** possible day where **all** seeds are blooming_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/21/1.png)\n\n    \n    \n    **Input:** plantTime = [143] growTime = [231]\n    **Output:** 9\n    **Explanation:** The grayed out pots represent planting days colored pots represent growing days and the flower represents the day it blooms.\n    One optimal way is:\n    On day 0 plant the 0th seed. The seed grows for 2 full days and blooms on day 3.\n    On days 1 2 3 and 4 plant the 1st seed. The seed grows for 3 full days and blooms on day 8.\n    On days 5 6 and 7 plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.\n    Thus on day 9 all the seeds are blooming.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/21/2.png)\n\n    \n    \n    **Input:** plantTime = [1232] growTime = [2121]\n    **Output:** 9\n    **Explanation:** The grayed out pots represent planting days colored pots represent growing days and the flower represents the day it blooms.\n    One optimal way is:\n    On day 1 plant the 0th seed. The seed grows for 2 full days and blooms on day 4.\n    On days 0 and 3 plant the 1st seed. The seed grows for 1 full day and blooms on day 5.\n    On days 2 4 and 5 plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.\n    On days 6 and 7 plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.\n    Thus on day 9 all the seeds are blooming.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** plantTime = [1] growTime = [1]\n    **Output:** 2\n    **Explanation:** On day 0 plant the 0th seed. The seed grows for 1 full day and blooms on day 2.\n    Thus on day 2 all the seeds are blooming.\n    \n\n\n\n**Constraints:**\n\n  * `n == plantTime.length == growTime.length`\n  * `1 <= n <= 105`\n  * `1 <= plantTime[i] growTime[i] <= 104`\n\n,class Solution:\n    def earliestFullBloom(self plantTime: List[int] growTime: List[int]) -> int:\n        data = list(zip(plantTime growTime))\n        data.sort(key=lambda x: -x[1]) #sort by grow time in descending order\n        \n        res = 0\n        start_time = 0\n        for plant grow in data:\n            start_time += plant\n            res = max(res start_time + grow)\n        return res\n
Edit Distance,"###  72\. Edit Distance\n\nGiven two strings `word1` and `word2` return _the minimum number of\noperations required to convert`word1` to `word2`_.\n\nYou have the following three operations permitted on a word:\n\n  * Insert a character\n  * Delete a character\n  * Replace a character\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word1 = ""horse"" word2 = ""ros""\n    **Output:** 3\n    **Explanation:** \n    horse -> rorse (replace 'h' with 'r')\n    rorse -> rose (remove 'r')\n    rose -> ros (remove 'e')\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word1 = ""intention"" word2 = ""execution""\n    **Output:** 5\n    **Explanation:** \n    intention -> inention (remove 't')\n    inention -> enention (replace 'i' with 'e')\n    enention -> exention (replace 'n' with 'x')\n    exention -> exection (replace 'n' with 'c')\n    exection -> execution (insert 'u')\n    \n\n\n\n**Constraints:**\n\n  * `0 <= word1.length word2.length <= 500`\n  * `word1` and `word2` consist of lowercase English letters.\n\n",from functools import cache\n\n\nclass Solution:\n    def minDistance(self word1: str word2: str) -> int:\n        m n = len(word1) len(word2)\n        \n        @cache\n        def dp(i j):\n            if i == 0:\n                return j\n            if j == 0:\n                return i\n            \n            l1 l2 = word1[i - 1] word2[j - 1]\n            if l1 != l2:\n                return 1 + min(\n                    dp(i j - 1)     # Delete / insert j\n                    dp(i - 1 j)     # Delete / insert i\n                    dp(i - 1 j - 1)  # Replace i or j\n                )\n            return dp(i - 1 j - 1)         \n                    \n        return dp(m n)\n
Egg Drop With 2 Eggs and N Floors,###  1884\. Egg Drop With 2 Eggs and N Floors\n\nYou are given **two identical** eggs and you have access to a building with\n`n` floors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg\ndropped at a floor **higher** than `f` will **break**  and any egg dropped\n**at or below** floor `f` will **not break**.\n\nIn each move you may take an **unbroken** egg and drop it from any floor `x`\n(where `1 <= x <= n`). If the egg breaks you can no longer use it. However\nif the egg does not break you may **reuse** it in future moves.\n\nReturn _the**minimum number of moves** that you need to determine **with\ncertainty** what the value of _`f` is.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 2\n    **Explanation:** We can drop the first egg from floor 1 and the second egg from floor 2.\n    If the first egg breaks we know that f = 0.\n    If the second egg breaks but the first egg didn't we know that f = 1.\n    Otherwise if both eggs survive we know that f = 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 100\n    **Output:** 14\n    **Explanation:** One optimal strategy is:\n    - Drop the 1st egg at floor 9. If it breaks we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n    - If the 1st egg does not break drop the 1st egg again at floor 22. If it breaks we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n    - If the 1st egg does not break again follow a similar process dropping the 1st egg from floors 34 45 55 64 72 79 85 90 94 97 99 and 100.\n    Regardless of the outcome it takes at most 14 drops to determine f.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n\n,// Runtime: 37 ms (Top 76.06%) | Memory: 17.40 MB (Top 35.12%)\n\nclass Solution:\n    def twoEggDrop(self n: int) -> int:\n        return ceil(((1+n*8)**0.5-1)/2)\n
Eliminate Maximum Number of Monsters,###  1921\. Eliminate Maximum Number of Monsters\n\nYou are playing a video game where you are defending your city from a group of\n`n` monsters. You are given a **0-indexed** integer array `dist` of size `n`\nwhere `dist[i]` is the **initial distance** in kilometers of the `ith` monster\nfrom the city.\n\nThe monsters walk toward the city at a **constant** speed. The speed of each\nmonster is given to you in an integer array `speed` of size `n` where\n`speed[i]` is the speed of the `ith` monster in kilometers per minute.\n\nYou have a weapon that once fully charged can eliminate a **single**\nmonster. However the weapon takes **one minute** to charge.The weapon is\nfully charged at the very start.\n\nYou lose when any monster reaches your city. If a monster reaches the city at\nthe exact moment the weapon is fully charged it counts as a **loss**  and\nthe game ends before you can use your weapon.\n\nReturn _the**maximum** number of monsters that you can eliminate before you\nlose or _`n` _if you can eliminate all the monsters before they reach the\ncity._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** dist = [134] speed = [111]\n    **Output:** 3\n    **Explanation:**\n    In the beginning the distances of the monsters are [134]. You eliminate the first monster.\n    After a minute the distances of the monsters are [X23]. You eliminate the second monster.\n    After a minute the distances of the monsters are [XX2]. You eliminate the thrid monster.\n    All 3 monsters can be eliminated.\n\n**Example 2:**\n\n    \n    \n    **Input:** dist = [1123] speed = [1111]\n    **Output:** 1\n    **Explanation:**\n    In the beginning the distances of the monsters are [1123]. You eliminate the first monster.\n    After a minute the distances of the monsters are [X012] so you lose.\n    You can only eliminate 1 monster.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** dist = [324] speed = [532]\n    **Output:** 1\n    **Explanation:**\n    In the beginning the distances of the monsters are [324]. You eliminate the first monster.\n    After a minute the distances of the monsters are [X02] so you lose.\n    You can only eliminate 1 monster.\n    \n\n\n\n**Constraints:**\n\n  * `n == dist.length == speed.length`\n  * `1 <= n <= 105`\n  * `1 <= dist[i] speed[i] <= 105`\n\n,class Solution:\n    def eliminateMaximum(self dist: List[int] speed: List[int]) -> int:\n        for i t in enumerate(sorted([(d - 1) // s for d s in zip(dist speed)])):\n            if i > t:\n                return i\n        return len(dist)  \n
Elimination Game,###  390\. Elimination Game\n\nYou have a list `arr` of all integers in the range `[1 n]` sorted in a\nstrictly increasing order. Apply the following algorithm on `arr`:\n\n  * Starting from left to right remove the first number and every other number afterward until you reach the end of the list.\n  * Repeat the previous step again but this time from right to left remove the rightmost number and every other number from the remaining numbers.\n  * Keep repeating the steps again alternating left to right and right to left until a single number remains.\n\nGiven the integer `n` return _the last number that remains in_ `arr`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 9\n    **Output:** 6\n    **Explanation:**\n    arr = [_1_  2 _3_  4 _5_  6 _7_  8 _9_]\n    arr = [2 _4_  6 _8_]\n    arr = [_2_  6]\n    arr = [6]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n\n,class Solution:\n    def lastRemaining(self n: int) -> int:\n        beg = 1\n        len = n\n        d = 1\n        fromleft = True\n\n        while len > 1:\n            if(fromleft or len%2 == 1):\n                beg += d\n            d <<= 1\n            len >>= 1\n            fromleft = not fromleft\n        \n        return beg\n
Employee Importance,###  690\. Employee Importance\n\nYou have a data structure of employee information including the employee's\nunique ID importance value and direct subordinates' IDs.\n\nYou are given an array of employees `employees` where:\n\n  * `employees[i].id` is the ID of the `ith` employee.\n  * `employees[i].importance` is the importance value of the `ith` employee.\n  * `employees[i].subordinates` is a list of the IDs of the direct subordinates of the `ith` employee.\n\nGiven an integer `id` that represents an employee's ID return _the**total**\nimportance value of this employee and all their direct and indirect\nsubordinates_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/31/emp1-tree.jpg)\n\n    \n    \n    **Input:** employees = [[15[23]][23[]][33[]]] id = 1\n    **Output:** 11\n    **Explanation:** Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3.\n    They both have an importance value of 3.\n    Thus the total importance value of employee 1 is 5 + 3 + 3 = 11.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/05/31/emp2-tree.jpg)\n\n    \n    \n    **Input:** employees = [[12[5]][5-3[]]] id = 5\n    **Output:** -3\n    **Explanation:** Employee 5 has an importance value of -3 and has no direct subordinates.\n    Thus the total importance value of employee 5 is -3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= employees.length <= 2000`\n  * `1 <= employees[i].id <= 2000`\n  * All `employees[i].id` are **unique**.\n  * `-100 <= employees[i].importance <= 100`\n  * One employee has at most one direct leader and may have several subordinates.\n  * The IDs in `employees[i].subordinates` are valid IDs.\n\n,"# Runtime: 254 ms (Top 40.58%) | Memory: 15.6 MB (Top 60.31%)\n""""""\n# Definition for Employee.\nclass Employee:\n    def __init__(self id: int importance: int subordinates: List[int]):\n        self.id = id\n        self.importance = importance\n        self.subordinates = subordinates\n""""""\n\nclass Solution:\n    def dfs(self graph employees empId totalImportance visited):\n        totalImportance += graph[empId][0]\n        visited.add(empId)\n\n        for neighbour in graph[empId][1]:\n            if neighbour not in visited:\n                totalImportance = self.dfs(graph employees neighbour totalImportance visited)\n\n        return totalImportance\n\n    def getImportance(self employees: List['Employee'] id: int) -> int:\n        graph = {}\n\n        for employeeInfo in employees:\n            empId importance suboordinates = employeeInfo.id employeeInfo.importance employeeInfo.subordinates\n            graph[empId] = [importance suboordinates]\n\n        n = len(employees)\n\n        if graph[id][1] == []:\n            return graph[id][0]\n\n        visited = set()\n        totalImportance = 0\n        totalImportance = self.dfs(graph employees id totalImportance visited)\n\n        return totalImportance"
Encode and Decode TinyURL,"###  535\. Encode and Decode TinyURL\n\n> Note: This is a companion problem to the [System\n> Design](https://leetcode.com/discuss/interview-question/system-design/)\n> problem: [Design TinyURL](https://leetcode.com/discuss/interview-\n> question/124658/Design-a-URL-Shortener-\(-TinyURL-\)-System/).\n\nTinyURL is a URL shortening service where you enter a URL such as\n`https://leetcode.com/problems/design-tinyurl` and it returns a short URL such\nas `http://tinyurl.com/4e9iAk`. Design a class to encode a URL and decode a\ntiny URL.\n\nThere is no restriction on how your encode/decode algorithm should work. You\njust need to ensure that a URL can be encoded to a tiny URL and the tiny URL\ncan be decoded to the original URL.\n\nImplement the `Solution` class:\n\n  * `Solution()` Initializes the object of the system.\n  * `String encode(String longUrl)` Returns a tiny URL for the given `longUrl`.\n  * `String decode(String shortUrl)` Returns the original long URL for the given `shortUrl`. It is guaranteed that the given `shortUrl` was encoded by the same object.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** url = ""https://leetcode.com/problems/design-tinyurl""\n    **Output:** ""https://leetcode.com/problems/design-tinyurl""\n    \n    **Explanation:**\n    Solution obj = new Solution();\n    string tiny = obj.encode(url); // returns the encoded tiny url.\n    string ans = obj.decode(tiny); // returns the original url after deconding it.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= url.length <= 104`\n  * `url` is guranteed to be a valid URL.\n\n",class Codec:\n\n    def encode(self longUrl):\n        return longUrl\n\n    def decode(self shortUrl):\n        return shortUrl\n
Encrypt and Decrypt Strings,"###  2227\. Encrypt and Decrypt Strings\n\nYou are given a character array `keys` containing **unique** characters and a\nstring array `values` containing strings of length 2. You are also given\nanother string array `dictionary` that contains all permitted original strings\nafter decryption. You should implement a data structure that can encrypt or\ndecrypt a **0-indexed** string.\n\nA string is **encrypted** with the following process:\n\n  1. For each character `c` in the string we find the index `i` satisfying `keys[i] == c` in `keys`.\n  2. Replace `c` with `values[i]` in the string.\n\nNote that in case a character of the string is **not present** in `keys` the\nencryption process cannot be carried out and an empty string `""""` is\nreturned.\n\nA string is **decrypted** with the following process:\n\n  1. For each substring `s` of length 2 occurring at an even index in the string we find an `i` such that `values[i] == s`. If there are multiple valid `i` we choose **any** one of them. This means a string could have multiple possible strings it can decrypt to.\n  2. Replace `s` with `keys[i]` in the string.\n\nImplement the `Encrypter` class:\n\n  * `Encrypter(char[] keys String[] values String[] dictionary)` Initializes the `Encrypter` class with `keys values` and `dictionary`.\n  * `String encrypt(String word1)` Encrypts `word1` with the encryption process described above and returns the encrypted string.\n  * `int decrypt(String word2)` Returns the number of possible strings `word2` could decrypt to that also appear in `dictionary`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Encrypter"" ""encrypt"" ""decrypt""]\n    [[['a' 'b' 'c' 'd'] [""ei"" ""zf"" ""ei"" ""am""] [""abcd"" ""acbd"" ""adbc"" ""badc"" ""dacb"" ""cadb"" ""cbda"" ""abad""]] [""abcd""] [""eizfeiam""]]\n    **Output**\n    [null ""eizfeiam"" 2]\n    \n    **Explanation**\n    Encrypter encrypter = new Encrypter([['a' 'b' 'c' 'd'] [""ei"" ""zf"" ""ei"" ""am""] [""abcd"" ""acbd"" ""adbc"" ""badc"" ""dacb"" ""cadb"" ""cbda"" ""abad""]);\n    encrypter.encrypt(""abcd""); // return ""eizfeiam"". \n                               // 'a' maps to ""ei"" 'b' maps to ""zf"" 'c' maps to ""ei"" and 'd' maps to ""am"".\n    encrypter.decrypt(""eizfeiam""); // return 2. \n                                  // ""ei"" can map to 'a' or 'c' ""zf"" maps to 'b' and ""am"" maps to 'd'. \n                                  // Thus the possible strings after decryption are ""abad"" ""cbad"" ""abcd"" and ""cbcd"". \n                                  // 2 of those strings ""abad"" and ""abcd"" appear in dictionary so the answer is 2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= keys.length == values.length <= 26`\n  * `values[i].length == 2`\n  * `1 <= dictionary.length <= 100`\n  * `1 <= dictionary[i].length <= 100`\n  * All `keys[i]` and `dictionary[i]` are **unique**.\n  * `1 <= word1.length <= 2000`\n  * `1 <= word2.length <= 200`\n  * All `word1[i]` appear in `keys`.\n  * `word2.length` is even.\n  * `keys` `values[i]` `dictionary[i]` `word1` and `word2` only contain lowercase English letters.\n  * At most `200` calls will be made to `encrypt` and `decrypt` **in total**.\n\n",class Encrypter:\n\n    def __init__(self keys: List[str] values: List[str] dictionary: List[str]):\n        self.hashmap = dict()\n        for i in range(len(keys)):\n            self.hashmap[keys[i]] = values[i]\n        self.dictmap = defaultdict(int)\n        for word in dictionary:\n            self.dictmap[self.encrypt(word)] += 1\n\n    def encrypt(self word1: str) -> str:\n        output = ''\n        for char in word1:\n            output += self.hashmap[char]\n        return output\n\n    def decrypt(self word2: str) -> int:\n        return self.dictmap[word2]\n
Equal Rational Numbers,"###  972\. Equal Rational Numbers\n\nGiven two strings `s` and `t` each of which represents a non-negative\nrational number return `true` if and only if they represent the same number.\nThe strings may use parentheses to denote the repeating part of the rational\nnumber.\n\nA **rational number** can be represented using up to three parts:\n`<IntegerPart>` `<NonRepeatingPart>` and a `<RepeatingPart>`. The number\nwill be represented in one of the following three ways:\n\n  * `<IntegerPart>`\n    * For example `12` `0` and `123`.\n  * `<IntegerPart>**<.>**<NonRepeatingPart>`\n    * For example `0.5` `1.` `2.12` and `123.0001`.\n  * `<IntegerPart>**<.>**<NonRepeatingPart>**<(>**<RepeatingPart>**<)>**`\n    * For example `0.1(6)` `1.(9)` `123.00(1212)`.\n\nThe repeating portion of a decimal expansion is conventionally denoted within\na pair of round brackets. For example:\n\n  * `1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""0.(52)"" t = ""0.5(25)""\n    **Output:** true\n    **Explanation:** Because ""0.(52)"" represents 0.52525252... and ""0.5(25)"" represents 0.52525252525.....  the strings represent the same number.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""0.1666(6)"" t = ""0.166(66)""\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""0.9(9)"" t = ""1.""\n    **Output:** true\n    **Explanation:** ""0.9(9)"" represents 0.999999999... repeated forever which equals 1.  [[See this link for an explanation.](https://en.wikipedia.org/wiki/0.999...)]\n    ""1."" represents the number 1 which is formed correctly: (IntegerPart) = ""1"" and (NonRepeatingPart) = """".\n    \n\n\n\n**Constraints:**\n\n  * Each part consists only of digits.\n  * The `<IntegerPart>` does not have leading zeros (except for the zero itself).\n  * `1 <= <IntegerPart>.length <= 4`\n  * `0 <= <NonRepeatingPart>.length <= 4`\n  * `1 <= <RepeatingPart>.length <= 4`\n\n","// Runtime: 69 ms (Top 5.88%) | Memory: 14 MB (Top 23.53%)\nclass Solution:\n    # inspired from:\n    # https://coolconversion.com/math/recurring-decimals-as-a-fraction/\n    # to which we wouldn't have access during interview.\n\n    import typing\n    def isRationalEqual(self s: str t: str) -> bool:\n\n        # intuition:\n        # write each numbes as fraction: num / den\n        # then compare the two fractions.\n\n        num1 den1 = self.toFraction(s)\n        num2 den2 = self.toFraction(t)\n\n        return den1 * num2 == den2 * num1\n\n    def toFraction(self s: str) -> typing.Tuple[int int]:\n        if ""."" not in s:\n            return int(s) 1\n\n        intp frac = s.split(""."")\n        # decimal dot but no repeating part:\n        # xyz.abc = xyzabc / 1000\n        if ""("" not in frac:\n            ifrac = int(frac) if len(frac) > 0 else 0\n            num = int(intp) * (10 ** len(frac)) + ifrac\n            den = 10 ** len(frac)\n            return num den\n\n        # this is for cases like a.b(c)\n        # let n = a.b(c)\n        # then 10^(len(b+c)) * n = abc.(c)\n        # and 10^(len(b)) * n = ab.(c)\n        # subtract the two and solve for n:\n        # n = (abc - ab) / (10^len(b + c) - 10^len(b))\n        frac repfrac = frac.split(""("")\n        repfrac = repfrac[:-1]\n\n        iintp = int(intp)\n        ifrac = int(frac) if len(frac) > 0 else 0\n        irep = int(repfrac)\n\n        return (\n            (iintp * (10 ** (len(frac + repfrac))) + ifrac * 10 ** len(repfrac) + irep) - (iintp * 10 ** len(frac) + ifrac)\n            (10** len(frac+repfrac) - 10 **len(frac))\n        )\n    ```"
Equal Row and Column Pairs,###  2352\. Equal Row and Column Pairs\n\nGiven a **0-indexed** `n x n` integer matrix `grid` _return the number of\npairs_`(Ri Cj)`_such that row_`Ri` _and column_`Cj` _are equal_.\n\nA row and column pair is considered equal if they contain the same elements in\nthe same order (i.e. an equal array).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/06/01/ex1.jpg)\n\n    \n    \n    **Input:** grid = [[321][176][277]]\n    **Output:** 1\n    **Explanation:** There is 1 equal row and column pair:\n    - (Row 2 Column 1): [277]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/06/01/ex2.jpg)\n\n    \n    \n    **Input:** grid = [[3122][1445][2422][2422]]\n    **Output:** 3\n    **Explanation:** There are 3 equal row and column pairs:\n    - (Row 0 Column 0): [3122]\n    - (Row 2 Column 2): [2422]\n    - (Row 3 Column 2): [2422]\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length == grid[i].length`\n  * `1 <= n <= 200`\n  * `1 <= grid[i][j] <= 105`\n\n,# Runtime: 467 ms (Top 64.2%) | Memory: 21.54 MB (Top 44.5%)\n\nclass Solution:\n    def equalPairs(self grid: List[List[int]]) -> int:\n        m = defaultdict(int)\n        cnt = 0\n\n        for row in grid:\n            m[str(row)] += 1\n        \n        for i in range(len(grid[0])):\n            col = []\n            for j in range(len(grid)):\n                col.append(grid[j][i])\n            cnt += m[str(col)]\n        return cnt\n
Equal Sum Arrays With Minimum Number of Operations,###  1775\. Equal Sum Arrays With Minimum Number of Operations\n\nYou are given two arrays of integers `nums1` and `nums2` possibly of\ndifferent lengths. The values in the arrays are between `1` and `6`\ninclusive.\n\nIn one operation you can change any integer's value in **any** of the arrays\nto **any** value between `1` and `6` inclusive.\n\nReturn _the minimum number of operations required to make the sum of values\nin_`nums1` _equal to the sum of values in_`nums2` _._ Return\n`-1`​​​​​ if it is not possible to make the sum of the two arrays\nequal.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [123456] nums2 = [112222]\n    **Output:** 3\n    **Explanation:** You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed.\n    - Change nums2[0] to 6. nums1 = [123456] nums2 = [_**6**_ 12222].\n    - Change nums1[5] to 1. nums1 = [12345**_1_**] nums2 = [612222].\n    - Change nums1[2] to 2. nums1 = [12**_2_** 451] nums2 = [612222].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [1111111] nums2 = [6]\n    **Output:** -1\n    **Explanation:** There is no way to decrease the sum of nums1 or to increase the sum of nums2 to make them equal.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [66] nums2 = [1]\n    **Output:** 3\n    **Explanation:** You can make the sums of nums1 and nums2 equal with 3 operations. All indices are 0-indexed. \n    - Change nums1[0] to 2. nums1 = [**_2_** 6] nums2 = [1].\n    - Change nums1[1] to 2. nums1 = [2**_2_**] nums2 = [1].\n    - Change nums2[0] to 4. nums1 = [22] nums2 = [**_4_**].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 105`\n  * `1 <= nums1[i] nums2[i] <= 6`\n\n,"class Solution:\n    def minOperations(self nums1: List[int] nums2: List[int]) -> int:\n        \n		# step1. determine the larger array and the smaller array and get the difference on sum\n        sum1 = sum(nums1)\n        sum2 = sum(nums2)\n        \n        if sum1==sum2:\n            return 0\n        elif sum1>sum2:\n            larger_sum_nums = nums1\n            smaller_sum_nums = nums2\n        else:\n            larger_sum_nums = nums2\n            smaller_sum_nums = nums1\n		\n        sum_diff = abs(sum1-sum2)\n            \n        # step2. calculate the max ""gain"" at each position (how much difference we can reduce if operating on that position)    \n        gains_in_larger_array = [num-1 for num in larger_sum_nums]\n        gains_in_smaller_array = [6-num for num in smaller_sum_nums]\n        \n		# step3. sort the ""gain"" and check the least number of steps to reduce the difference to 0\n        gains = gains_in_larger_array + gains_in_smaller_array\n        gains.sort(reverse = True)\n        \n        count = 0\n        target_diff = sum_diff\n        \n        for i in range(len(gains)):\n            target_diff -= gains[i]\n            count += 1\n            \n            if target_diff <= 0:\n                return count\n		\n		# return -1 if the difference still cannot be reduced to 0 even after operating on all positions\n        return -1\n"
Erect the Fence,###  587\. Erect the Fence\n\nYou are given an array `trees` where `trees[i] = [xi yi]` represents the\nlocation of a tree in the garden.\n\nYou are asked to fence the entire garden using the minimum length of rope as\nit is expensive. The garden is well fenced only if **all the trees are\nenclosed**.\n\nReturn _the coordinates of trees that are exactly located on the fence\nperimeter_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/erect2-plane.jpg)\n\n    \n    \n    **Input:** points = [[11][22][20][24][33][42]]\n    **Output:** [[11][20][33][24][42]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/erect1-plane.jpg)\n\n    \n    \n    **Input:** points = [[12][22][42]]\n    **Output:** [[42][22][12]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= points.length <= 3000`\n  * `points[i].length == 2`\n  * `0 <= xi yi <= 100`\n  * All the given points are **unique**.\n\n,"class Solution:\n\n    """"""Compute the convex hull of a set of points.\n\n        Use Andrew's Monotone Chain algorithm which has order O(N log(N))\n        where N is the number of input points.\n    """"""\n\n    def cross(self p a b):\n        """"""Return the cross product of the vectors p -> a and p -> b.""""""\n        return (a[0] - p[0]) * (b[1] - p[1]) \\n            - (a[1] - p[1]) * (b[0] - p[0])\n\n    def _convex_hull_monotone_chain(self points):\n        """"""Compute the convex hull of a list of points.\n        \n        Use Andrew's Monotone Chain algorithm which is similar to Graham Scan\n        except that it doesn't require sorting the points by angle.  This algorithm\n        takes O(N log(N)) time where N is len(points).\n        """"""\n        # Ensure all points are unique and sort lexicographically.\n        points = list(sorted(set(points)))\n        \n        # If there are fewer than three points they must form a hull.\n        if len(points) <= 2:\n            return points\n        \n        # Compute the lower and upper portion of the hull.\n        lower upper = [] []\n        for out it in ((lower points) (upper reversed(points))):\n            for p in it:\n                while len(out) >= 2 and self.cross(out[-2] out[-1] p) > 0:\n                    out.pop()\n                out.append(p)\n\n        # Concatenate the upper and lower hulls.  Remove the last point from each\n        # because those points are duplicated in both upper and lower.\n        return lower[:-1] + upper[:-1]\n\n    def outerTrees(self trees: List[List[int]]) -> List[List[int]]:\n        """"""\n        Find the convex hull of a collection of points.\n        Return a list of indices of points forming the hull in clockwise order\n        starting with the leftmost point.\n        """"""\n        # Convert input points to tuples.\n        points = [tuple(p) for p in trees]\n        ans = set()\n        for point in self._convex_hull_monotone_chain(points):\n            ans.add(point)\n        return ans"
Escape a Large Maze,###  1036\. Escape a Large Maze\n\nThere is a 1 million by 1 million grid on an XY-plane and the coordinates of\neach grid square are `(x y)`.\n\nWe start at the `source = [sx sy]` square and want to reach the `target =\n[tx ty]` square. There is also an array of `blocked` squares where each\n`blocked[i] = [xi yi]` represents a blocked square with coordinates `(xi\nyi)`.\n\nEach move we can walk one square north east south or west if the square is\n**not** in the array of `blocked` squares. We are also not allowed to walk\noutside of the grid.\n\nReturn `true` _if and only if it is possible to reach the_`target` _square\nfrom the_`source` _square through a sequence of valid moves_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** blocked = [[01][10]] source = [00] target = [02]\n    **Output:** false\n    **Explanation:** The target square is inaccessible starting from the source square because we cannot move.\n    We cannot move north or east because those squares are blocked.\n    We cannot move south or west because we cannot go outside of the grid.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** blocked = [] source = [00] target = [999999999999]\n    **Output:** true\n    **Explanation:** Because there are no blocked cells it is possible to reach the target square.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= blocked.length <= 200`\n  * `blocked[i].length == 2`\n  * `0 <= xi yi < 106`\n  * `source.length == target.length == 2`\n  * `0 <= sx sy tx ty < 106`\n  * `source != target`\n  * It is guaranteed that `source` and `target` are not blocked.\n\n,"class Solution(object):   \n    def isEscapePossible(self blocked source target):\n        """"""\n        :type blocked: List[List[int]]\n        :type source: List[int]\n        :type target: List[int]\n        :rtype: bool\n        """"""\n        \n        self.blocked = blocked\n        self.source = source\n        self.target = target\n        \n        #hashset of all blocked cells\n        self.blocked_dict = {}\n        \n        #hashset of all visited edges\n        self.edge_dict = {}\n        \n        #min/max x/y coords used for checking if an edge intersects the ""easy path""\n        self.min_x = min(self.source[0]self.target[0])\n        self.max_x = max(self.source[0]self.target[0])\n        self.min_y = min(self.source[1]self.target[1])\n        self.max_y = max(self.source[1]self.target[1])\n        \n        #iterate through all cells in blocked\n        #and add each cell to the hash set\n        for blocked_cell in blocked:\n            if blocked_cell[0] in self.blocked_dict:\n                self.blocked_dict[blocked_cell[0]][blocked_cell[1]] = None\n            else:\n                self.blocked_dict[blocked_cell[0]]={blocked_cell[1]:None}\n        \n        #for each cell in blocked\n        for blocked_cell in self.blocked:\n            \n            #list the faces of blocked_cell that belong to an outline (4 of these at most)\n            exposed_faces = self.enumerate_exposed_faces(blocked_cell[0]blocked_cell[1])\n            \n            #for each of these faces\n            for face in exposed_faces:\n                \n                #check to see if we've already visited the edge while tracing out a loop\n                x_edge = face[3]\n                y_edge = face[4]\n                edge_type = face[5]\n                edge_visited = (x_edge in self.edge_dict \n                                and y_edge in self.edge_dict[x_edge]\n                                and edge_type in self.edge_dict[x_edge][y_edge])\n                \n                #if not then we are looking at a new outline that we haven't seen before\n                if not edge_visited:   \n                   \n                    #count the number of edges of the outline that intersect the ""easy path""\n                    num_intervening_edges =  self.check_loop(face[0]face[1]face[2])\n                    \n                    #if the number of intersections is odd a path does not exist. return false\n                    if num_intervening_edges%2==1:\n                        return False\n            \n        #if we could not find an outline the separates source from target return true    \n        return True\n    \n    #lists the faces of occupied cell xy that do not touch other occupied cells\n    #these cell faces are edges that belong to one of the outlines that are formed \n    #by painting in all occupied cells and grid boundaries\n    #there are at most 4 such edges per cell\n    def enumerate_exposed_faces(selfxy):\n        out_list = []\n        \n        #iterate through each neighbor of the cell\n        for i in range(4):\n            \n            #if the neighbor cell is not occupied (blocked) then the corresponding face is a boundary face\n            #in which case add it to the list\n            if not self.is_occupied(x+self.dxe[i]y+self.dye[i]):\n                \n                #there is a little bit of accounting going on to keep track of the correct edge coordinates\n                #note that what we are really listing here is a starting grid point (not cell) + starting direction\n                #and we also need to take into account that cells are indexed by their bottom left corner\n                x_star = x+self.dxe2[i]\n                y_star = y+self.dye2[i]\n                x_edge_coords = x_star + self.dx_edge_coords[(i+2)%4]\n                y_edge_coords = y_star + self.dy_edge_coords[(i+2)%4]\n                \n                out_list.append([x_stary_starix_edge_coordsy_edge_coordsself.edge_code_list[i]])\n        return out_list\n        \n    #returns the number of times a given outline intersects the ""easy path""\n    #x_starty_start is the starting gridpoint on the outline\n    #starting_direction is... the starting direction (see __init__ for how it's coded)\n    #is_cc is True if traversing in counterclockwise direction False if clockwise\n    #note that (counter)clockwise is referring to the winding number of the whole outline we are tracing\n    def check_loop(selfx_starty_startstarting_directionis_cc = True):\n        #correct the starting direction if it needs to be adjusted\n        starting_direction = self.update_edge_direction(x_starty_startstarting_directionis_cc)\n        direction = starting_direction\n        \n        x = x_start\n        y = y_start\n                \n        num_intervening_edges = 0\n        \n        # return False\n        touched_grid_boundary = False\n        \n        #iterate until we either touch the grid boundary\n        #or return to where we started\n        #this is a do-while hence the True + break condition\n        while True:  \n            #evaluate next grid point after moving along edge\n            x_new = x+self.dxp[direction]\n            y_new = y+self.dyp[direction]\n            \n            #if the edge is on the boundary do not proceed. break out of the loop\n            if self.edge_on_boundary(xyx_newy_new):\n                touched_grid_boundary = True\n                break\n            \n            #otherwise mark the edge as visited\n            x_edge_coords = x + self.dx_edge_coords[direction]\n            y_edge_coords = y + self.dy_edge_coords[direction]\n            edge_coords = [x_edge_coordsy_edge_coords]\n            \n            #a little bit of a hassle since it's a dictionary of dictionaries of 1-2 element lists\n            if x_edge_coords in self.edge_dict:\n                if y_edge_coords in self.edge_dict[x_edge_coords]:\n                    if self.edge_code_list[direction] not in self.edge_dict[x_edge_coords][y_edge_coords]:\n                        self.edge_dict[x_edge_coords][y_edge_coords].append(self.edge_code_list[direction])\n                else:\n                    self.edge_dict[x_edge_coords][y_edge_coords] = [self.edge_code_list[direction]] \n            else:\n                self.edge_dict[x_edge_coords] = {y_edge_coords: [self.edge_code_list[direction]]}\n            \n            \n            #check to see if the edge intersects our ""easy path"" from source to target\n            #if an intersection has occured increment the intersection counter\n            \n            #checks to see if the edge intersects the horizontal portion of the easy path\n            #for an edge to do so it must be vertical have the same y as source\n            #and must have an x between source and target\n            if self.edge_code_list[direction]=='v':\n                if (self.min_x<edge_coords[0] and edge_coords[0]<=self.max_x\n                    and edge_coords[1]==self.source[1]):\n                    \n                    num_intervening_edges+=1\n                    \n            #checks to see if the edge interesects the vertical portion of the easy path\n            #for an edge to do so it must be horizontal have the same x as source\n            #and must have a y between source and target\n            if self.edge_code_list[direction]=='h':\n                if (self.min_y<edge_coords[1] and edge_coords[1]<=self.max_y \n                    and edge_coords[0]==self.target[0]):\n                    \n                    num_intervening_edges+=1\n            \n            #update the grid point\n            x=x_new\n            y=y_new\n            \n            #update the direction\n            direction = self.update_edge_direction(xydirectionis_cc)\n            \n            #if we returned back to the beginning break out of the loop\n            #we need to take direction into account because it is possible to return to\n            #the same grid point during the the middle of the traversal\n            #for example imagine tracing the outline of two cells that are diagonally adjacent\n            #here you would pass through the point where the two cells touch each other twice\n            #if you happen to get unlucky and start at such a point things would break if you \n            #terminated conditioned just on the x/y coordinates\n            #taking into account the current direction dodges this issue\n            if x==x_start and y==y_start and direction == starting_direction:\n                break\n        \n        #if we touched a grid boundary we need to go back to the beginning\n        #and then go in reverse until we touch the grid boundary again\n        #thus finishing the outline.\n        #since we are going in reverse direction\n        #the setting is clockwise instead of counter-clockwise\n        if touched_grid_boundary and is_cc:\n            num_intervening_edges+=self.check_loop(\n                x_starty_start(starting_direction+2)%4is_cc = False)\n        \n        #return the number of intersections between the loop and the easy path\n        return num_intervening_edges\n    \n    #changes the edge direction right or left (or keeps straight)\n    #depending on our current grid point and direction\n    def update_edge_direction(selfxydirectionis_cc):\n        #coordinate of the cell in front of us (given our current direction) and to the right\n        x_right = x + self.dx_fwrd_right[direction]\n        y_right = y + self.dy_fwrd_right[direction]\n\n        #coordinate of the cell in front of us (given our current direction) and to the left\n        x_left = x + self.dx_fwrd_left[direction]\n        y_left = y + self.dy_fwrd_left[direction]\n            \n            \n        #the following logic tells us how to change the direction as we move along the outline\n        #I'm not going to explain it here but if you draw the cases out it will become apparent\n        #the one thing to note is that you can still turn right during a counter-clockwise traversal\n        #(and left during a clockwise traversal). The traversal handedness is referring \n        #to the global winding number of the whole loop \n        #(which is either +1 or -1 depending on clockwise or counter-clockwise)\n        #if we are doing a counterclockwise traversal...\n        if is_cc:\n            #if the cell in front of us to the right is occupied turn right\n            if self.is_occupied(x_righty_right):\n                direction+=1\n                direction%=4\n            #if neither cells in front of us are occupied turn left\n            elif not self.is_occupied(x_lefty_left):\n                direction-=1\n                direction%=4\n\n        #if we are doing a clockwise traversal...\n        else:\n            #if the cell in front of us to the left is occupied turn left\n            if self.is_occupied(x_lefty_left):\n                direction-=1\n                direction%=4\n            #if neither cells in front of us are occupied turn right\n            elif not self.is_occupied(x_righty_right):\n                direction+=1\n                direction%=4\n        return direction\n    \n    #checks to see if an edge belongs to the boundary of the grid\n    def edge_on_boundary(selfx0y0x1y1):\n        #an edge is on the boundary of the grid iff both endpoints\n        #are on the boundary of the grid\n        b_test0 = x0==0 or x0==self.l or y0==0 or y0==self.l\n        b_test1 = x1==0 or x1==self.l or y1==0 or y1==self.l\n        return b_test0 and b_test1\n    \n    #checks to see if a given cell is blocked. a cell is blocked if either \n    #it is on the boundary/exterior of the grid or it was listed in blocked\n    def is_occupied(selfxy):\n        return (x in self.blocked_dict and y in self.blocked_dict[x]) or x<0 or y<0 or x==self.l or y==self.l\n        \n    #here is where I hid away all the definitions of constants that we use to make things easier    \n    def __init__(self):    \n        #grid dimensions which we use to check if we hit a grid boundary\n        self.l = 10**6\n        \n        #used to traverse perimeter. clockwise order\n        #direction 0 = down\n        #direction 1 = left\n        #direction 2 = up\n        #direction 3 = right\n        self.dxp = [ 0-1 0 1]\n        self.dyp = [-1 0 1 0]\n        \n        #used to check for faces of a cell that are exposed\n        #if the face of a cell is exposed then that face belongs\n        #to a perimeter that may prevent source from reaching target\n        \n        #perimeters are traversed in a counterclockwise loop by default\n        #specifically while travelling along a perimenter\n        #the cell to your left will always be occupied and the\n        #the cell to your right will always be empty\n        \n        #faces of the cell are indexed as:\n        #[left top right bottom]\n        #if cell x+dxe[i]y+dye[i] if not occupied then the ith face\n        #of the cell is part of a perimeter which corresponds to motion\n        #in direction i\n        self.dxe = [-1 0 1 0]\n        self.dye = [ 0 1 0-1]\n        \n        #used to maps an exposed face of a cell to the corner of the cell\n        #used to start the perimeter traversal\n        #left face: start at bottom left corner\n        #top face: start at top left corner\n        #right face: start at top right corner\n        #bottom face: start at bottom right corner\n        self.dxe2 = [ 0 0 1 1]\n        self.dye2 = [ 0 1 1 0]\n        \n        #used to determine what cells to look at\n        #when checking if we need to turn clockwise or counterclockwise\n        #while traversing the perimeter\n        self.dx_fwrd_right = [-1-1 0 0]\n        self.dy_fwrd_right = [-1 0 0-1]\n        \n        self.dx_fwrd_left  = [ 0-1-1 0]\n        self.dy_fwrd_left  = [-1-1 0 0]\n        \n        #note that for the above a grid point and a cell have the same\n        #coordinates if the grid point is the bottom left corner of that cell\n        \n        \n        #used to map directed edges to undirected edges\n        #we index edges using their bottom/leftmost point and whether they\n        #are vertical or horizontal\n        self.edge_code_list = ['v''h''v''h']\n        self.dx_edge_coords = [ 0-1 0 0]\n        self.dy_edge_coords = [-1 0 0 0]\n\n        \n\n        \n\n\n        \n        \n\n        \n"
Escape The Ghosts,###  789\. Escape The Ghosts\n\nYou are playing a simplified PAC-MAN game on an infinite 2-D grid. You start\nat the point `[0 0]` and you are given a destination point `target =\n[xtarget ytarget]` that you are trying to get to. There are several ghosts on\nthe map with their starting positions given as a 2D array `ghosts` where\n`ghosts[i] = [xi yi]` represents the starting position of the `ith` ghost.\nAll inputs are **integral coordinates**.\n\nEach turn you and all the ghosts may independently choose to either **move 1\nunit** in any of the four cardinal directions: north east south or west or\n**stay still**. All actions happen **simultaneously**.\n\nYou escape if and only if you can reach the target **before** any ghost\nreaches you. If you reach any square (including the target) at the **same\ntime** as a ghost it **does not** count as an escape.\n\nReturn `true` _if it is possible to escape regardless of how the ghosts move\notherwise return_`false` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** ghosts = [[10][03]] target = [01]\n    **Output:** true\n    **Explanation:** You can reach the destination (0 1) after 1 turn while the ghosts located at (1 0) and (0 3) cannot catch up with you.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** ghosts = [[10]] target = [20]\n    **Output:** false\n    **Explanation:** You need to reach the destination (2 0) but the ghost at (1 0) lies between you and the destination.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** ghosts = [[20]] target = [10]\n    **Output:** false\n    **Explanation:** The ghost can reach the target at the same time as you.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= ghosts.length <= 100`\n  * `ghosts[i].length == 2`\n  * `-104 <= xi yi <= 104`\n  * There can be **multiple ghosts** in the same location.\n  * `target.length == 2`\n  * `-104 <= xtarget ytarget <= 104`\n\n,// Runtime: 62 ms (Top 9.13%) | Memory: 17.50 MB (Top 9.13%)\n\nclass Solution:\n    def escapeGhosts(self ghosts: List[List[int]] target: List[int]) -> bool:\n        \n        dist = lambda x : abs(x[0] - target[0]) + abs(x[1] - target[1])\n\n        return dist((00)) < min(dist(g) for g in ghosts)\n
Escape the Spreading Fire,###  2258\. Escape the Spreading Fire\n\nYou are given a **0-indexed** 2D integer array `grid` of size `m x n` which\nrepresents a field. Each cell has one of three values:\n\n  * `0` represents grass\n  * `1` represents fire\n  * `2` represents a wall that you and fire cannot pass through.\n\nYou are situated in the top-left cell `(0 0)` and you want to travel to the\nsafehouse at the bottom-right cell `(m - 1 n - 1)`. Every minute you may\nmove to an **adjacent** grass cell. **After** your move every fire cell will\nspread to all **adjacent** cells that are not walls.\n\nReturn _the**maximum** number of minutes that you can stay in your initial\nposition before moving while still safely reaching the safehouse_. If this is\nimpossible return `-1`. If you can **always** reach the safehouse regardless\nof the minutes stayed return `109`.\n\nNote that even if the fire spreads to the safehouse immediately after you have\nreached it it will be counted as safely reaching the safehouse.\n\nA cell is **adjacent** to another cell if the former is directly north east\nsouth or west of the latter (i.e. their sides are touching).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg)\n\n    \n    \n    **Input:** grid = [[0200000][0002210][0200120][0022202][0000000]]\n    **Output:** 3\n    **Explanation:** The figure above shows the scenario where you stay in the initial position for 3 minutes.\n    You will still be able to safely reach the safehouse.\n    Staying for more than 3 minutes will not allow you to safely reach the safehouse.\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg)\n\n    \n    \n    **Input:** grid = [[0000][0120][0200]]\n    **Output:** -1\n    **Explanation:** The figure above shows the scenario where you immediately move towards the safehouse.\n    Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.\n    Thus -1 is returned.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg)\n\n    \n    \n    **Input:** grid = [[000][220][120]]\n    **Output:** 1000000000\n    **Explanation:** The figure above shows the initial grid.\n    Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.\n    Thus 109 is returned.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `2 <= m n <= 300`\n  * `4 <= m * n <= 2 * 104`\n  * `grid[i][j]` is either `0` `1` or `2`.\n  * `grid[0][0] == grid[m - 1][n - 1] == 0`\n\n,class Solution(object):\n    def maximumMinutes(self A):\n        m n = len(A) len(A[0])\n        inf = 10 ** 10\n        d = [[01][10][0-1][-10]]\n        fires = [[i j 0] for i in range(m) for j in range(n) if A[i][j] == 1]\n        A = [[inf if a < 2 else -1 for a in r] for r in A]\n\n        def bfs(queue seen):\n            for i j t in queue:\n                if seen[i][j] < inf: continue\n                seen[i][j] = t\n                for didj in d:\n                    x y = i + di j + dj\n                    if 0 <= x < m and 0 <= y < n and seen[x][y] >= inf and t + 1 < A[x][y]:\n                        queue.append([x y t + 1])\n        \n        def die(t):\n            seen = [[inf + 10] * n for i in range(m)]\n            bfs([[0 0 t]] seen)\n            return seen[-1][-1] > A[-1][-1]\n\n        bfs(fires A)\n        A[-1][-1] += 1\n        return bisect_left(range(10**9 + 1) True key=die) - 1\n
Evaluate Boolean Binary Tree,###  2331\. Evaluate Boolean Binary Tree\n\nYou are given the `root` of a **full binary tree** with the following\nproperties:\n\n  * **Leaf nodes** have either the value `0` or `1` where `0` represents `False` and `1` represents `True`.\n  * **Non-leaf nodes** have either the value `2` or `3` where `2` represents the boolean `OR` and `3` represents the boolean `AND`.\n\nThe **evaluation** of a node is as follows:\n\n  * If the node is a leaf node the evaluation is the **value** of the node i.e. `True` or `False`.\n  * Otherwise **evaluate** the node's two children and **apply** the boolean operation of its value with the children's evaluations.\n\nReturn _the boolean result of**evaluating** the _`root` _node._\n\nA **full binary tree** is a binary tree where each node has either `0` or `2`\nchildren.\n\nA **leaf node** is a node that has zero children.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/05/16/example1drawio1.png)\n\n    \n    \n    **Input:** root = [213nullnull01]\n    **Output:** true\n    **Explanation:** The above diagram illustrates the evaluation process.\n    The AND node evaluates to False AND True = False.\n    The OR node evaluates to True OR False = True.\n    The root node evaluates to True so we return true.\n\n**Example 2:**\n\n    \n    \n    **Input:** root = [0]\n    **Output:** false\n    **Explanation:** The root node is a leaf node and it evaluates to false so we return false.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 1000]`.\n  * `0 <= Node.val <= 3`\n  * Every node has either `0` or `2` children.\n  * Leaf nodes have a value of `0` or `1`.\n  * Non-leaf nodes have a value of `2` or `3`.\n\n,# Runtime: 98 ms (Top 35.75%) | Memory: 14.7 MB (Top 20.30%)\nclass Solution:\n    def evaluateTree(self root: Optional[TreeNode]) -> bool:\n        def recur(node):\n            if not node.left and not node.right: #leaf node\n                return True if node.val == 1 else False\n            left = recur(node.left)\n            right = recur(node.right)\n            if node.val == 2: #if node is or\n                return left or right\n            if node.val == 3: #if node is and\n                return left and right\n        return recur(root)
Evaluate Division,"###  399\. Evaluate Division\n\nYou are given an array of variable pairs `equations` and an array of real\nnumbers `values` where `equations[i] = [Ai Bi]` and `values[i]` represent\nthe equation `Ai / Bi = values[i]`. Each `Ai` or `Bi` is a string that\nrepresents a single variable.\n\nYou are also given some `queries` where `queries[j] = [Cj Dj]` represents\nthe `jth` query where you must find the answer for `Cj / Dj = ?`.\n\nReturn _the answers to all queries_. If a single answer cannot be determined\nreturn `-1.0`.\n\n**Note:** The input is always valid. You may assume that evaluating the\nqueries will not result in division by zero and that there is no\ncontradiction.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** equations = [[""a""""b""][""b""""c""]] values = [2.03.0] queries = [[""a""""c""][""b""""a""][""a""""e""][""a""""a""][""x""""x""]]\n    **Output:** [6.000000.50000-1.000001.00000-1.00000]\n    **Explanation:** \n    Given: _a / b = 2.0_  _b / c = 3.0_\n    queries are: _a / c = ?_  _b / a = ?_  _a / e = ?_  _a / a = ?_  _x / x = ?_\n    return: [6.0 0.5 -1.0 1.0 -1.0 ]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** equations = [[""a""""b""][""b""""c""][""bc""""cd""]] values = [1.52.55.0] queries = [[""a""""c""][""c""""b""][""bc""""cd""][""cd""""bc""]]\n    **Output:** [3.750000.400005.000000.20000]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** equations = [[""a""""b""]] values = [0.5] queries = [[""a""""b""][""b""""a""][""a""""c""][""x""""y""]]\n    **Output:** [0.500002.00000-1.00000-1.00000]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= equations.length <= 20`\n  * `equations[i].length == 2`\n  * `1 <= Ai.length Bi.length <= 5`\n  * `values.length == equations.length`\n  * `0.0 < values[i] <= 20.0`\n  * `1 <= queries.length <= 20`\n  * `queries[i].length == 2`\n  * `1 <= Cj.length Dj.length <= 5`\n  * `Ai Bi Cj Dj` consist of lower case English letters and digits.\n\n",class Solution:\n    def calcEquation(self equations: List[List[str]] values: List[float] queries: List[List[str]]) -> List[float]:\n        graph = dict()\n        \n        for (n d) v in zip(equations values):\n            if n not in graph:\n                graph[n] = []\n            if d not in graph:\n                graph[d] = []\n                \n            graph[n].append((d v))\n            graph[d].append((n 1/v))\n        \n        def dfs(node target product visited):\n            if n not in graph or d not in graph:\n                return -1\n            \n            if node == target:\n                return product\n            \n            visited.add(node)\n            \n            for neighbor quotient in graph[node]:\n                if neighbor not in visited:\n                    soln = dfs(neighbor target product * quotient visited)\n                    if soln != -1:\n                        return soln\n                    \n            return -1\n        \n        solns = []\n        for n d in queries:\n            solns.append(dfs(n d 1 set()))\n            \n        return solns
Evaluate Reverse Polish Notation,"###  150\. Evaluate Reverse Polish Notation\n\nEvaluate the value of an arithmetic expression in [Reverse Polish\nNotation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nValid operators are `+` `-` `*` and `/`. Each operand may be an integer or\nanother expression.\n\n**Note** that division between two integers should truncate toward zero.\n\nIt is guaranteed that the given RPN expression is always valid. That means the\nexpression would always evaluate to a result and there will not be any\ndivision by zero operation.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** tokens = [""2""""1""""+""""3""""*""]\n    **Output:** 9\n    **Explanation:** ((2 + 1) * 3) = 9\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** tokens = [""4""""13""""5""""/""""+""]\n    **Output:** 6\n    **Explanation:** (4 + (13 / 5)) = 6\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** tokens = [""10""""6""""9""""3""""+""""-11""""*""""/""""*""""17""""+""""5""""+""]\n    **Output:** 22\n    **Explanation:** ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n    = ((10 * (6 / (12 * -11))) + 17) + 5\n    = ((10 * (6 / -132)) + 17) + 5\n    = ((10 * 0) + 17) + 5\n    = (0 + 17) + 5\n    = 17 + 5\n    = 22\n    \n\n\n\n**Constraints:**\n\n  * `1 <= tokens.length <= 104`\n  * `tokens[i]` is either an operator: `""+""` `""-""` `""*""` or `""/""` or an integer in the range `[-200 200]`.\n\n","class Solution:\n    def evalRPN(self tokens: List[str]) -> int:\n        stack = []      \n        for i in tokens:\n            if i == ""+"":\n                stack[-1] = stack[-2] + stack.pop()\n            elif i == ""-"":\n                stack[-1] = stack[-2] - stack.pop()\n            elif i == ""*"":\n                stack[-1] = stack[-2] * stack.pop()\n            elif i == ""/"":\n                stack[-1] = int(stack[-2] / stack.pop())\n            else:\n                stack.append(int(i))\n                \n        return stack.pop()\n                    \n"
Evaluate the Bracket Pairs of a String,"###  1807\. Evaluate the Bracket Pairs of a String\n\nYou are given a string `s` that contains some bracket pairs with each pair\ncontaining a **non-empty** key.\n\n  * For example in the string `""(name)is(age)yearsold""` there are **two** bracket pairs that contain the keys `""name""` and `""age""`.\n\nYou know the values of a wide range of keys. This is represented by a 2D\nstring array `knowledge` where each `knowledge[i] = [keyi valuei]` indicates\nthat key `keyi` has a value of `valuei`.\n\nYou are tasked to evaluate **all** of the bracket pairs. When you evaluate a\nbracket pair that contains some key `keyi` you will:\n\n  * Replace `keyi` and the bracket pair with the key's corresponding `valuei`.\n  * If you do not know the value of the key you will replace `keyi` and the bracket pair with a question mark `""?""` (without the quotation marks).\n\nEach key will appear at most once in your `knowledge`. There will not be any\nnested brackets in `s`.\n\nReturn _the resulting string after evaluating**all** of the bracket pairs._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""(name)is(age)yearsold"" knowledge = [[""name""""bob""][""age""""two""]]\n    **Output:** ""bobistwoyearsold""\n    **Explanation:**\n    The key ""name"" has a value of ""bob"" so replace ""(name)"" with ""bob"".\n    The key ""age"" has a value of ""two"" so replace ""(age)"" with ""two"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""hi(name)"" knowledge = [[""a""""b""]]\n    **Output:** ""hi?""\n    **Explanation:** As you do not know the value of the key ""name"" replace ""(name)"" with ""?"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""(a)(a)(a)aaa"" knowledge = [[""a""""yes""]]\n    **Output:** ""yesyesyesaaa""\n    **Explanation:** The same key can appear multiple times.\n    The key ""a"" has a value of ""yes"" so replace all occurrences of ""(a)"" with ""yes"".\n    Notice that the ""a""s not in a bracket pair are not evaluated.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `0 <= knowledge.length <= 105`\n  * `knowledge[i].length == 2`\n  * `1 <= keyi.length valuei.length <= 10`\n  * `s` consists of lowercase English letters and round brackets `'('` and `')'`.\n  * Every open bracket `'('` in `s` will have a corresponding close bracket `')'`.\n  * The key in each bracket pair of `s` will be non-empty.\n  * There will not be any nested bracket pairs in `s`.\n  * `keyi` and `valuei` consist of lowercase English letters.\n  * Each `keyi` in `knowledge` is unique.\n\n",class Solution:\n    def evaluate(self s: str knowledge: List[List[str]]) -> str:\n        knowledge = dict(knowledge)\n        answer start = [] None\n        for i char in enumerate(s):\n            if char == '(': \n                start = i + 1\n            elif char == ')':\n                answer.append(knowledge.get(s[start:i] '?'))\n                start = None\n            elif start is None: \n                answer.append(char)\n        return ''.join(answer)\n
Even Odd Tree,###  1609\. Even Odd Tree\n\nA binary tree is named **Even-Odd** if it meets the following conditions:\n\n  * The root of the binary tree is at level index `0` its children are at level index `1` their children are at level index `2` etc.\n  * For every **even-indexed** level all nodes at the level have **odd** integer values in **strictly increasing** order (from left to right).\n  * For every **odd-indexed** level all nodes at the level have **even** integer values in **strictly decreasing** order (from left to right).\n\nGiven the `root` of a binary tree _return_`true` _if the binary tree\nis**Even-Odd**  otherwise return _`false` _._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/15/sample_1_1966.png)\n\n    \n    \n    **Input:** root = [11043null791286nullnull2]\n    **Output:** true\n    **Explanation:** The node values on each level are:\n    Level 0: [1]\n    Level 1: [104]\n    Level 2: [379]\n    Level 3: [12862]\n    Since levels 0 and 2 are all odd and increasing and levels 1 and 3 are all even and decreasing the tree is Even-Odd.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/15/sample_2_1966.png)\n\n    \n    \n    **Input:** root = [542337]\n    **Output:** false\n    **Explanation:** The node values on each level are:\n    Level 0: [5]\n    Level 1: [42]\n    Level 2: [337]\n    Node values in level 2 must be in strictly increasing order so the tree is not Even-Odd.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/09/22/sample_1_333_1966.png)\n\n    \n    \n    **Input:** root = [591357]\n    **Output:** false\n    **Explanation:** Node values in the level 1 should be even integers.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 105]`.\n  * `1 <= Node.val <= 106`\n\n,from collections import deque\n# Runtime:838ms 44.05% || Memory: 40.8mb 57.22%\n# O(n) || O(h); where h is the height of the tree\n\nclass Solution:\n    def isEvenOddTree(self root: Optional[TreeNode]) -> bool:\n        if not root:\n            return False\n\n        level = 0\n        evenOddLevel = {0:1 1:0}\n        queue = deque([root])\n\n        while queue:\n            prev = 0\n            for _ in range(len(queue)):\n                currNode = queue.popleft()\n                comparison = {0:prev < currNode.val 1:prev > currNode.val}\n                if currNode.val % 2 != evenOddLevel[level % 2]:\n                    return False\n                else:\n                    if prev != 0 and comparison[level % 2]:\n                        prev = currNode.val\n                    elif prev == 0:\n                        prev = currNode.val\n                    else:\n                        return False\n\n                if currNode.left:\n                    queue.append(currNode.left)\n\n                if currNode.right:\n                    queue.append(currNode.right)\n\n            level += 1\n\n        return True\n
Exam Room,"###  855\. Exam Room\n\nThere is an exam room with `n` seats in a single row labeled from `0` to `n -\n1`.\n\nWhen a student enters the room they must sit in the seat that maximizes the\ndistance to the closest person. If there are multiple such seats they sit in\nthe seat with the lowest number. If no one is in the room then the student\nsits at seat number `0`.\n\nDesign a class that simulates the mentioned exam room.\n\nImplement the `ExamRoom` class:\n\n  * `ExamRoom(int n)` Initializes the object of the exam room with the number of the seats `n`.\n  * `int seat()` Returns the label of the seat at which the next student will set.\n  * `void leave(int p)` Indicates that the student sitting at seat `p` will leave the room. It is guaranteed that there will be a student sitting at seat `p`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""ExamRoom"" ""seat"" ""seat"" ""seat"" ""seat"" ""leave"" ""seat""]\n    [[10] [] [] [] [] [4] []]\n    **Output**\n    [null 0 9 4 2 null 5]\n    \n    **Explanation**\n    ExamRoom examRoom = new ExamRoom(10);\n    examRoom.seat(); // return 0 no one is in the room then the student sits at seat number 0.\n    examRoom.seat(); // return 9 the student sits at the last seat number 9.\n    examRoom.seat(); // return 4 the student sits at the last seat number 4.\n    examRoom.seat(); // return 2 the student sits at the last seat number 2.\n    examRoom.leave(4);\n    examRoom.seat(); // return 5 the student sits at the last seat number 5.\n    \n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n  * It is guaranteed that there is a student sitting at seat `p`.\n  * At most `104` calls will be made to `seat` and `leave`.\n\n",# Runtime: 182 ms (Top 65.24%) | Memory: 20.7 MB (Top 5.08%)\nclass ExamRoom:\n\n    def __init__(self n: int):\n        self.N = n\n        self.pq = []\n        self.dict = {}\n        self.addSegment(0 self.N - 1)\n\n    def seat(self) -> int:\n        start end distance = heapq.heappop(self.pq)\n        self.dict.pop(start None) #Remove old segment from dictionary\n        self.dict.pop(end None)\n\n        if start == end:\n            position = start\n\n        elif start == 0:\n            position = start\n            right = self.addSegment(start + 1 end)\n\n        elif end == self.N - 1:\n            position = end\n            left = self.addSegment(start end - 1)\n\n        elif end - start == 1: #ONLY ONE PLACE TO PUT\n            position = start\n            left = self.addSegment(start + 1 end)\n\n        else:\n            position = start + (end - start) // 2\n            right = self.addSegment(start position - 1)\n            left = self.addSegment(position + 1 end)\n\n        return position\n\n    def leave(self p: int) -> None:\n        left = self.dict.get(p - 1 None)\n        right = self.dict.get(p + 1 None)\n\n        new_start = new_end = p\n\n        if left:\n            self.removeSegment(left)\n            new_start = left.start\n\n        if right:\n            self.removeSegment(right)\n            new_end = right.end\n\n        self.addSegment(new_start new_end)\n\n    def addSegment(self start end):\n            segment = Segment(start end self.N)\n            self.dict[segment.start] = segment\n            self.dict[segment.end] = segment\n            heapq.heappush(self.pq segment)\n\n    def removeSegment(self segment):\n            self.dict.pop(segment.start None)\n            self.dict.pop(segment.end None)\n            self.pq.remove(segment)\n\nclass Segment():\n    def __init__(self start end N):\n        self.start = start\n        self.end = end\n        self.distance = self.calculateDistance(start end N)\n\n    def __lt__(self other_segment):\n        return self.distance > other_segment.distance if self.distance != other_segment.distance else self.start < other_segment.start\n\n    def calculateDistance(self start end N):\n        if start == 0:\n            return end\n\n        if end == N - 1:\n            return end - start\n\n        else:\n            return (end - start) // 2\n\n    def __iter__(self):\n        return iter((self.start self.end self.distance))
Excel Sheet Column Number,"###  171\. Excel Sheet Column Number\n\nGiven a string `columnTitle` that represents the column title as appears in an\nExcel sheet return _its corresponding column number_.\n\nFor example:\n\n    \n    \n    A -> 1\n    B -> 2\n    C -> 3\n    ...\n    Z -> 26\n    AA -> 27\n    AB -> 28 \n    ...\n    \n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** columnTitle = ""A""\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** columnTitle = ""AB""\n    **Output:** 28\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** columnTitle = ""ZY""\n    **Output:** 701\n    \n\n\n\n**Constraints:**\n\n  * `1 <= columnTitle.length <= 7`\n  * `columnTitle` consists only of uppercase English letters.\n  * `columnTitle` is in the range `[""A"" ""FXSHRXW""]`.\n\n","def let_to_num(char):\n    abc = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""\n    return abc.index(char) + 1\n\nclass Solution:\n    def titleToNumber(self columnTitle: str) -> int:\n        ans = 0\n        for i in range(len(columnTitle)):\n            ans *= 26\n            ans += let_to_num(columnTitle[i])\n        return ans\n"
Excel Sheet Column Title,"###  168\. Excel Sheet Column Title\n\nGiven an integer `columnNumber` return _its corresponding column title as it\nappears in an Excel sheet_.\n\nFor example:\n\n    \n    \n    A -> 1\n    B -> 2\n    C -> 3\n    ...\n    Z -> 26\n    AA -> 27\n    AB -> 28 \n    ...\n    \n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** columnNumber = 1\n    **Output:** ""A""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** columnNumber = 28\n    **Output:** ""AB""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** columnNumber = 701\n    **Output:** ""ZY""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= columnNumber <= 231 - 1`\n\n","class Solution:\n    def convertToTitle(self num: int) -> str:\n		# We make this lookup list having A-Z in ascending order\n        alpha = [chr(x) for x in range(ord(""A"") ord(""Z"")+1)]     # range(65 90+1) -> 91-65 = 26\n        res = """"\n\n        while num > 0:\n            res += alpha[(num-1)%26]     # since 0 indexed list num-1 % 26 gives the index of ch in alpha\n            num = (num-1) // 26 \n        return res[::-1]\n"
Exclusive Time of Functions,"###  636\. Exclusive Time of Functions\n\nOn a **single-threaded** CPU we execute a program containing `n` functions.\nEach function has a unique ID between `0` and `n-1`.\n\nFunction calls are **stored in a[call\nstack](https://en.wikipedia.org/wiki/Call_stack)**: when a function call\nstarts its ID is pushed onto the stack and when a function call ends its ID\nis popped off the stack. The function whose ID is at the top of the stack is\n**the current function being executed**. Each time a function starts or ends\nwe write a log with the ID whether it started or ended and the timestamp.\n\nYou are given a list `logs` where `logs[i]` represents the `ith` log message formatted as a string `""{function_id}:{""start"" | ""end""}:{timestamp}""`. For example `""0:start:3""` means a function call with function ID `0` **started at the beginning** of timestamp `3` and `""1:end:2""` means a function call with function ID `1` **ended at the end** of timestamp `2`. Note that a function can be called **multiple times possibly recursively**.\n\nA function's **exclusive time** is the sum of execution times for all function\ncalls in the program. For example if a function is called twice one call\nexecuting for `2` time units and another call executing for `1` time unit the\n**exclusive time** is `2 + 1 = 3`.\n\nReturn _the**exclusive time** of each function in an array where the value at\nthe _`ith` _index represents the exclusive time for the function with ID_`i`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/04/05/diag1b.png)\n\n    \n    \n    **Input:** n = 2 logs = [""0:start:0""""1:start:2""""1:end:5""""0:end:6""]\n    **Output:** [34]\n    **Explanation:**\n    Function 0 starts at the beginning of time 0 then it executes 2 for units of time and reaches the end of time 1.\n    Function 1 starts at the beginning of time 2 executes for 4 units of time and ends at the end of time 5.\n    Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.\n    So function 0 spends 2 + 1 = 3 units of total time executing and function 1 spends 4 units of total time executing.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1 logs = [""0:start:0""""0:start:2""""0:end:5""""0:start:6""""0:end:6""""0:end:7""]\n    **Output:** [8]\n    **Explanation:**\n    Function 0 starts at the beginning of time 0 executes for 2 units of time and recursively calls itself.\n    Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\n    Function 0 (initial call) resumes execution then immediately calls itself again.\n    Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.\n    Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.\n    So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 2 logs = [""0:start:0""""0:start:2""""0:end:5""""1:start:6""""1:end:6""""0:end:7""]\n    **Output:** [71]\n    **Explanation:**\n    Function 0 starts at the beginning of time 0 executes for 2 units of time and recursively calls itself.\n    Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.\n    Function 0 (initial call) resumes execution then immediately calls function 1.\n    Function 1 starts at the beginning of time 6 executes 1 unit of time and ends at the end of time 6.\n    Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.\n    So function 0 spends 2 + 4 + 1 = 7 units of total time executing and function 1 spends 1 unit of total time executing.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 100`\n  * `1 <= logs.length <= 500`\n  * `0 <= function_id < n`\n  * `0 <= timestamp <= 109`\n  * No two start events will happen at the same timestamp.\n  * No two end events will happen at the same timestamp.\n  * Each function has an `""end""` log for each `""start""` log.\n\n","# Runtime: 78 ms (Top 92.98%) | Memory: 14.2 MB (Top 33.69%)\nclass Solution:\n    #T=O(n) S=O(d)\n    #n=len of logs d=depth of stack\n    def exclusiveTime(self n: int logs: List[str]) -> List[int]:\n        #init result array to zeroes of length n (function ids)\n        res = [0]*n\n        stack = []\n        #iterate through logs\n        for log in logs:\n            #split the log\n            #function_id: start|end: timestamp\n            log = log.split("":"")\n            #type cast function id and timestamp to int type\n            id = int(log[0])\n            timestamp = int(log[2])\n            state = log[1]\n            #detect start of a function call\n            #stack[function_id start_timestamp]\n            if state == ""start"":\n                #stack is non empty\n                if stack:\n                    #get the time taken by last function so far\n                    res[stack[-1][0]] += timestamp - stack[-1][1]\n                #append the current function_id and start timestamp to the stack\n                stack.append([id timestamp])\n            else:\n                #get the time consumed by current function\n                #dont forget to add 1 as the last unit of time should be included\n                res[id] += timestamp - stack.pop()[1] + 1\n                if stack:\n                    #update the start time of last function in stack to get the cumulative result\n                    stack[-1][1] = timestamp + 1\n\n        return res"
Execution of All Suffix Instructions Staying in a Grid,"###  2120\. Execution of All Suffix Instructions Staying in a Grid\n\nThere is an `n x n` grid with the top-left cell at `(0 0)` and the bottom-\nright cell at `(n - 1 n - 1)`. You are given the integer `n` and an integer\narray `startPos` where `startPos = [startrow startcol]` indicates that a\nrobot is initially at cell `(startrow startcol)`.\n\nYou are also given a **0-indexed** string `s` of length `m` where `s[i]` is\nthe `ith` instruction for the robot: `'L'` (move left) `'R'` (move right)\n`'U'` (move up) and `'D'` (move down).\n\nThe robot can begin executing from any `ith` instruction in `s`. It executes\nthe instructions one by one towards the end of `s` but it stops if either of\nthese conditions is met:\n\n  * The next instruction will move the robot off the grid.\n  * There are no more instructions left to execute.\n\nReturn _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is**the number\nof instructions** the robot can execute if the robot **begins executing from**\nthe_ `ith` _instruction in_ `s`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/09/1.png)\n\n    \n    \n    **Input:** n = 3 startPos = [01] s = ""RRDDLU""\n    **Output:** [154310]\n    **Explanation:** Starting from startPos and beginning execution from the ith instruction:\n    - 0th: ""_**R**_ RDDLU"". Only one instruction ""R"" can be executed before it moves off the grid.\n    - 1st:  ""_**RDDLU**_ "". All five instructions can be executed while it stays in the grid and ends at (1 1).\n    - 2nd:   ""_**DDLU**_ "". All four instructions can be executed while it stays in the grid and ends at (1 0).\n    - 3rd:    ""_**DLU**_ "". All three instructions can be executed while it stays in the grid and ends at (0 0).\n    - 4th:     ""_**L**_ U"". Only one instruction ""L"" can be executed before it moves off the grid.\n    - 5th:      ""U"". If moving up it would move off the grid.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/09/2.png)\n\n    \n    \n    **Input:** n = 2 startPos = [11] s = ""LURD""\n    **Output:** [4100]\n    **Explanation:**\n    - 0th: ""_**LURD**_ "".\n    - 1st:  ""_**U**_ RD"".\n    - 2nd:   ""RD"".\n    - 3rd:    ""D"".\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/12/09/3.png)\n\n    \n    \n    **Input:** n = 1 startPos = [00] s = ""LRUD""\n    **Output:** [0000]\n    **Explanation:** No matter which instruction the robot begins execution from it would move off the grid.\n    \n\n\n\n**Constraints:**\n\n  * `m == s.length`\n  * `1 <= n m <= 500`\n  * `startPos.length == 2`\n  * `0 <= startrow startcol < n`\n  * `s` consists of `'L'` `'R'` `'U'` and `'D'`.\n\n",class Solution:\n    def executeInstructions(self n: int startPos: List[int] s: str) -> List[int]:\n        result = []\n        for idx in range(len(s)):\n            count row col = 0 startPos[0]startPos[1]\n            while  idx < len(s):\n                if s[idx] == 'D':\n                    row += 1\n                    if row >= n:\n                        break\n                    count += 1\n                elif s[idx] == 'U':\n                    row -= 1\n                    if row < 0:\n                        break\n                    count += 1\n                elif s[idx] == 'R':\n                    col += 1\n                    if col >= n:\n                        break\n                    count += 1\n                else:\n                    col -= 1\n                    if col < 0:\n                        break\n                    count += 1\n                idx += 1\n            result.append(count)\n        return result\n
Expression Add Operators,"###  282\. Expression Add Operators\n\nGiven a string `num` that contains only digits and an integer `target` return\n_**all possibilities** to insert the binary operators _`'+'`__`'-'`_\nand/or_`'*'`_between the digits of_`num` _so that the resultant expression\nevaluates to the_`target` _value_.\n\nNote that operands in the returned expressions **should not** contain leading\nzeros.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = ""123"" target = 6\n    **Output:** [""1*2*3""""1+2+3""]\n    **Explanation:** Both ""1*2*3"" and ""1+2+3"" evaluate to 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = ""232"" target = 8\n    **Output:** [""2*3+2""""2+3*2""]\n    **Explanation:** Both ""2*3+2"" and ""2+3*2"" evaluate to 8.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = ""3456237490"" target = 9191\n    **Output:** []\n    **Explanation:** There are no expressions that can be created from ""3456237490"" to evaluate to 9191.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num.length <= 10`\n  * `num` consists of only digits.\n  * `-231 <= target <= 231 - 1`\n\n","class Solution:\n    def addOperators(self num: str target: int) -> List[str]:\n        s=num[0]\n        q=[""+""""-""""*""""""]\n        ans=[]\n        def cal(w):\n            i=1\n            while i<len(w)-1:\n                if w[i]=='*':\n                    q=int(w[i-1])*int(w[i+1])\n                    del w[i+1]\n                    del w[i]\n                    w[i-1]=q\n                    continue\n                i+=2\n            i=1 \n            while i<len(w)-1:\n                if w[i]=='+':\n                    q=int(w[i-1])+int(w[i+1])\n                    del w[i+1]\n                    del w[i]\n                    w[i-1]=q\n                    continue\n                elif w[i]=='-':\n                    q=int(w[i-1])-int(w[i+1])\n                    del w[i+1]\n                    del w[i]\n                    w[i-1]=q\n                    continue\n                i+=2\n            return w\n        def dfs(si):\n            nonlocal ans\n            if i==len(num):\n                x=''\n                myl=[]\n                for i in s:\n                    if i not in ['+''-''*']:\n                        x+=i\n                    else:\n                        myl.append(int(x))\n                        myl.append(i)\n                        x=''\n                myl.append(int(x))\n                print(myl)\n                a=cal(myl)\n                print(a)\n                if a[0]==target:\n                    ans.append(s)\n                return\n            for j in q:\n                dfs(s+j+num[i]i+1)\n        dfs(s1)\n        return ans\n"
Expressive Words,"###  809\. Expressive Words\n\nSometimes people repeat letters to represent extra feeling. For example:\n\n  * `""hello"" -> ""heeellooo""`\n  * `""hi"" -> ""hiiii""`\n\nIn these strings like `""heeellooo""` we have groups of adjacent letters that\nare all the same: `""h""` `""eee""` `""ll""` `""ooo""`.\n\nYou are given a string `s` and an array of query strings `words`. A query word\nis **stretchy** if it can be made to be equal to `s` by any number of\napplications of the following extension operation: choose a group consisting\nof characters `c` and add some number of characters `c` to the group so that\nthe size of the group is **three or more**.\n\n  * For example starting with `""hello""` we could do an extension on the group `""o""` to get `""hellooo""` but we cannot get `""helloo""` since the group `""oo""` has a size less than three. Also we could do another extension like `""ll"" -> ""lllll""` to get `""helllllooo""`. If `s = ""helllllooo""` then the query word `""hello""` would be **stretchy** because of these two extension operations: `query = ""hello"" -> ""hellooo"" -> ""helllllooo"" = s`.\n\nReturn _the number of query strings that are**stretchy**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""heeellooo"" words = [""hello"" ""hi"" ""helo""]\n    **Output:** 1\n    **Explanation:** \n    We can extend ""e"" and ""o"" in the word ""hello"" to get ""heeellooo"".\n    We can't extend ""helo"" to get ""heeellooo"" because the group ""ll"" is not size 3 or more.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""zzzzzyyyyy"" words = [""zzyy""""zy""""zyy""]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length words.length <= 100`\n  * `1 <= words[i].length <= 100`\n  * `s` and `words[i]` consist of lowercase letters.\n\n",class Solution:\n    def expressiveWords(self s: str words: List[str]) -> int:\n        # edge cases\n        if len(s) == 0 and len(words) != 0:\n            return False\n        if len(words) == 0 and len(s) != 0:\n            return False\n        if len(s) == 0 and len(words) == 0:\n            return True\n     \n        # helper function compressing string and extract counts\n        def compressor(s_word):\n            init_string =[s_word[0]]\n            array = []\n            start = 0\n            for ic in enumerate(s_word):\n                if c == init_string[-1]:\n                    continue\n                array.append(i-start)\n                start = i\n                init_string += c  \n            array.append(i-start+1)    \n            return init_stringarray\n\n        res = len(words)\n        s_split s_array = compressor(s)\n        for word in words:\n            word_split = ['']\n            word_array = []\n            word_splitword_array = compressor(word)\n            if s_split == word_split:\n                for num_snum_word in zip(s_arrayword_array):\n                    if num_s != num_word and num_s < 3 or num_word > num_s:\n                        res -= 1\n                        break\n            else:\n                res -= 1\n        return res
Fair Candy Swap,###  888\. Fair Candy Swap\n\nAlice and Bob have a different total number of candies. You are given two\ninteger arrays `aliceSizes` and `bobSizes` where `aliceSizes[i]` is the number\nof candies of the `ith` box of candy that Alice has and `bobSizes[j]` is the\nnumber of candies of the `jth` box of candy that Bob has.\n\nSince they are friends they would like to exchange one candy box each so that\nafter the exchange they both have the same total amount of candy. The total\namount of candy a person has is the sum of the number of candies in each box\nthey have.\n\nReturn a _n integer array_`answer` _where_`answer[0]`_is the number of candies\nin the box that Alice must exchange and_`answer[1]`_is the number of candies\nin the box that Bob must exchange_. If there are multiple answers you may\n**return any** one of them. It is guaranteed that at least one answer exists.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** aliceSizes = [11] bobSizes = [22]\n    **Output:** [12]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** aliceSizes = [12] bobSizes = [23]\n    **Output:** [12]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** aliceSizes = [2] bobSizes = [13]\n    **Output:** [23]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= aliceSizes.length bobSizes.length <= 104`\n  * `1 <= aliceSizes[i] bobSizes[j] <= 105`\n  * Alice and Bob have a different total number of candies.\n  * There will be at least one valid answer for the given input.\n\n,class Solution {\npublic:\nvector<int> fairCandySwap(vector<int>& aliceSizes vector<int>& bobSizes) {\n\n    sort(bobSizes.begin()bobSizes.end());\n    sort(aliceSizes.begin()aliceSizes.end());\n\n    int sum1=0;\n    int sum2=0;\n    vector <int> ans;\n    for(int i =0 ; i <aliceSizes.size(); i++)\n    {\n        sum1+=aliceSizes[i];\n    }\n    for(int i =0 ; i <bobSizes.size(); i++)\n    {\n        sum2+=bobSizes[i];\n    }\n    \n    int dif = (sum1-sum2)/2;\n    \n    \n    for(int i = 0 ; i <aliceSizes.size(); i++)\n    {\n        \n        int st=0;\n        int end = bobSizes.size()-1;\n        \n        while(st<=end)\n        {\n            int mid = (st+end)/2;\n            \n            if(bobSizes[mid]==aliceSizes[i]-dif)\n            {\n             ans.push_back(aliceSizes[i]);\n             ans.push_back(bobSizes[mid]);\n             return ans;\n            }\n            \n            else if(bobSizes[mid]<aliceSizes[i]-dif)\n            {\n                st=mid+1;\n            }\n            else if(bobSizes[mid]>aliceSizes[i]-dif)\n            {\n                end=mid-1;\n            }\n              \n        }    \n    }\n    \n    return ans;\n    \n}\n};\n
Fair Distribution of Cookies,###  2305\. Fair Distribution of Cookies\n\nYou are given an integer array `cookies` where `cookies[i]` denotes the\nnumber of cookies in the `ith` bag. You are also given an integer `k` that\ndenotes the number of children to distribute **all** the bags of cookies to.\nAll the cookies in the same bag must go to the same child and cannot be split\nup.\n\nThe **unfairness** of a distribution is defined as the **maximum** **total**\ncookies obtained by a single child in the distribution.\n\nReturn _the**minimum** unfairness of all distributions_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** cookies = [81510208] k = 2\n    **Output:** 31\n    **Explanation:** One optimal distribution is [8158] and [1020]\n    - The 1st child receives [8158] which has a total of 8 + 15 + 8 = 31 cookies.\n    - The 2nd child receives [1020] which has a total of 10 + 20 = 30 cookies.\n    The unfairness of the distribution is max(3130) = 31.\n    It can be shown that there is no distribution with an unfairness less than 31.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cookies = [61322412] k = 3\n    **Output:** 7\n    **Explanation:** One optimal distribution is [61] [322] and [412]\n    - The 1st child receives [61] which has a total of 6 + 1 = 7 cookies.\n    - The 2nd child receives [322] which has a total of 3 + 2 + 2 = 7 cookies.\n    - The 3rd child receives [412] which has a total of 4 + 1 + 2 = 7 cookies.\n    The unfairness of the distribution is max(777) = 7.\n    It can be shown that there is no distribution with an unfairness less than 7.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= cookies.length <= 8`\n  * `1 <= cookies[i] <= 105`\n  * `2 <= k <= cookies.length`\n\n,"class Solution:\n    def distributeCookies(self cookies: List[int] k: int) -> int:\n        ans = float('inf')\n        fair = [0]*k\n        def rec(i):\n            nonlocal ansfair\n            if i == len(cookies):\n                ans = min(ansmax(fair))\n                return\n			# Bounding condition to stop a branch if unfairness already exceeds current optimal soltution\n			if ans <= max(fair):\n                return\n            for j in range(k):\n                fair[j] += cookies[i]\n                rec(i+1)\n                fair[j] -= cookies[i]\n        rec(0)\n        return ans\n"
Falling Squares,###  699\. Falling Squares\n\nThere are several squares being dropped onto the X-axis of a 2D plane.\n\nYou are given a 2D integer array `positions` where `positions[i] = [lefti\nsideLengthi]` represents the `ith` square with a side length of `sideLengthi`\nthat is dropped with its left edge aligned with X-coordinate `lefti`.\n\nEach square is dropped one at a time from a height above any landed squares.\nIt then falls downward (negative Y direction) until it either lands **on the\ntop side of another square** or **on the X-axis**. A square brushing the\nleft/right side of another square does not count as landing on it. Once it\nlands it freezes in place and cannot be moved.\n\nAfter each square is dropped you must record the **height of the current\ntallest stack of squares**.\n\nReturn _an integer array_`ans` _where_`ans[i]`_represents the height described\nabove after dropping the_`ith` _square_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg)\n\n    \n    \n    **Input:** positions = [[12][23][61]]\n    **Output:** [255]\n    **Explanation:**\n    After the first drop the tallest stack is square 1 with a height of 2.\n    After the second drop the tallest stack is squares 1 and 2 with a height of 5.\n    After the third drop the tallest stack is still squares 1 and 2 with a height of 5.\n    Thus we return an answer of [2 5 5].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** positions = [[100100][200100]]\n    **Output:** [100100]\n    **Explanation:**\n    After the first drop the tallest stack is square 1 with a height of 100.\n    After the second drop the tallest stack is either square 1 or square 2 both with heights of 100.\n    Thus we return an answer of [100 100].\n    Note that square 2 only brushes the right side of square 1 which does not count as landing on it.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= positions.length <= 1000`\n  * `1 <= lefti <= 108`\n  * `1 <= sideLengthi <= 106`\n\n,"class SegmentTreeNode:\n    def __init__(self low high):\n        self.low = low\n        self.high = high\n        self.left = None\n        self.right = None\n        self.max = 0\n\nclass Solution:       \n    def _build(self left right):\n        root = SegmentTreeNode(self.coords[left] self.coords[right])\n        if left == right:\n            return root\n        \n        mid = (left+right)//2\n        root.left = self._build(left mid)\n        root.right = self._build(mid+1 right)\n        return root\n    \n    def _update(self root lower upper val):\n        if not root:\n            return\n        if lower <= root.high and root.low <= upper:# intersect\n            root.max = val\n            self._update(root.left lower upper val)\n            self._update(root.right lower upper val)\n        \n    def _query(self root lower upper):\n        if lower <= root.low and root.high <= upper:\n            return root.max\n        if upper < root.low or root.high < lower:\n            return 0\n        return max(self._query(root.left lower upper) self._query(root.right lower upper))\n    \n    def fallingSquares(self positions: List[List[int]]) -> List[int]:\n		# coordinates compression\n        coords = set()\n        for left size in positions:\n            right = left+size-1\n            coords.add(left)\n            coords.add(right)\n        self.coords = sorted(list(coords))\n        root = self._build(0 len(self.coords)-1)\n        \n        res = []\n        for left size in positions:\n            right = left+size-1\n            h = self._query(root left right) + size\n            res.append(max(res[-1]h)) if res else res.append(h)\n            self._update(root left right h)\n        return res\n"
Fancy Sequence,"###  1622\. Fancy Sequence\n\nWrite an API that generates fancy sequences using the `append` `addAll` and\n`multAll` operations.\n\nImplement the `Fancy` class:\n\n  * `Fancy()` Initializes the object with an empty sequence.\n  * `void append(val)` Appends an integer `val` to the end of the sequence.\n  * `void addAll(inc)` Increments all existing values in the sequence by an integer `inc`.\n  * `void multAll(m)` Multiplies all existing values in the sequence by an integer `m`.\n  * `int getIndex(idx)` Gets the current value at index `idx` (0-indexed) of the sequence **modulo** `109 + 7`. If the index is greater or equal than the length of the sequence return `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Fancy"" ""append"" ""addAll"" ""append"" ""multAll"" ""getIndex"" ""addAll"" ""append"" ""multAll"" ""getIndex"" ""getIndex"" ""getIndex""]\n    [[] [2] [3] [7] [2] [0] [3] [10] [2] [0] [1] [2]]\n    **Output**\n    [null null null null null 10 null null null 26 34 20]\n    \n    **Explanation**\n    Fancy fancy = new Fancy();\n    fancy.append(2);   // fancy sequence: [2]\n    fancy.addAll(3);   // fancy sequence: [2+3] -> [5]\n    fancy.append(7);   // fancy sequence: [5 7]\n    fancy.multAll(2);  // fancy sequence: [5*2 7*2] -> [10 14]\n    fancy.getIndex(0); // return 10\n    fancy.addAll(3);   // fancy sequence: [10+3 14+3] -> [13 17]\n    fancy.append(10);  // fancy sequence: [13 17 10]\n    fancy.multAll(2);  // fancy sequence: [13*2 17*2 10*2] -> [26 34 20]\n    fancy.getIndex(0); // return 26\n    fancy.getIndex(1); // return 34\n    fancy.getIndex(2); // return 20\n    \n\n\n\n**Constraints:**\n\n  * `1 <= val inc m <= 100`\n  * `0 <= idx <= 105`\n  * At most `105` calls total will be made to `append` `addAll` `multAll` and `getIndex`.\n\n","def egcd(a b):\n    if a == 0:\n        return (b 0 1)\n    else:\n        g y x = egcd(b % a a)\n        return (g x - (b // a) * y y)\n\ndef modinv(a m):\n    g x y = egcd(a m)\n    return x % m\n\nmod = 1000000007\n\nclass Fancy(object):\n\n    def __init__(self):\n        self.seq = []\n        self.addC = 0\n        self.mulC = 1\n        \n    def append(self val):\n        """"""\n        :type val: int\n        :rtype: None\n        """"""\n        self.seq.append([val self.mulC self.addC])\n        \n\n    def addAll(self inc):\n        """"""\n        :type inc: int\n        :rtype: None\n        """"""\n        self.addC = (self.addC%mod + inc%mod)%mod\n\n    def multAll(self m):\n        """"""\n        :type m: int\n        :rtype: None\n        """"""\n        self.mulC = (self.mulC%mod * m%mod)%mod\n        self.addC = (self.addC%mod * m%mod)%mod\n        \n\n    def getIndex(self idx):\n        """"""\n        :type idx: int\n        :rtype: int\n        """"""\n        if(idx >= len(self.seq)):\n            return -1\n        \n        mulCo = self.seq[idx][1]\n        addCo = self.seq[idx][2]\n        val = self.seq[idx][0]\n        \n        inv = modinv(mulCo mod)\n        a = (self.mulC%mod * inv%mod)%mod\n        val = (val%mod * a%mod)%mod\n        b = (addCo%mod * a%mod)%mod\n        val = (val%mod - b%mod)%mod\n        val = (val%mod + self.addC%mod)%mod\n        \n        return val\n"
Filling Bookcase Shelves,###  1105\. Filling Bookcase Shelves\n\nYou are given an array `books` where `books[i] = [thicknessi heighti]`\nindicates the thickness and height of the `ith` book. You are also given an\ninteger `shelfWidth`.\n\nWe want to place these books in order onto bookcase shelves that have a total\nwidth `shelfWidth`.\n\nWe choose some of the books to place on this shelf such that the sum of their\nthickness is less than or equal to `shelfWidth` then build another level of\nthe shelf of the bookcase so that the total height of the bookcase has\nincreased by the maximum height of the books we just put down. We repeat this\nprocess until there are no more books to place.\n\nNote that at each step of the above process the order of the books we place\nis the same order as the given sequence of books.\n\n  * For example if we have an ordered list of `5` books we might place the first and second book onto the first shelf the third book on the second shelf and the fourth and fifth book on the last shelf.\n\nReturn _the minimum possible height that the total bookshelf can be after\nplacing shelves in this manner_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/06/24/shelves.png)\n\n    \n    \n    **Input:** books = [[11][23][23][11][11][11][12]] shelf_width = 4\n    **Output:** 6\n    **Explanation:**\n    The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.\n    Notice that book number 2 does not have to be on the first shelf.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** books = [[13][24][32]] shelfWidth = 6\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= books.length <= 1000`\n  * `1 <= thicknessi <= shelfWidth <= 1000`\n  * `1 <= heighti <= 1000`\n\n,class Solution:\n    def minHeightShelves(self books shelf_width: int) -> int:\n        n dp = len(books) [float('inf')] * (len(books)+1)\n        dp[0] = 0\n\n        for i in range(1 n+1):\n            max_width max_height j = shelf_width 0 i - 1\n            \n            while j >= 0 and max_width - books[j][0] >= 0:\n                max_width -= books[j][0]\n                max_height = max(max_height books[j][1])\n                dp[i] = max_height\n                j -= 1\n\n            if j >= 0 and max_width - books[j][0] < 0:\n                j = i - 1\n                dp[i] = float('inf')\n                width height = 0 0\n                while j >= 0 and width + books[j][0] <= shelf_width:\n                    width = width + books[j][0]\n                    height = max(books[j][1] height)\n                    dp[i] = min(dp[i] height + dp[j])\n                    j -= 1\n\n        return dp[n]\n
Filter Restaurants by Vegan-Friendly Price and Distance,###  1333\. Filter Restaurants by Vegan-Friendly Price and Distance\n\nGiven the array `restaurants` where  `restaurants[i] = [idi ratingi\nveganFriendlyi pricei distancei]`. You have to filter the restaurants using\nthree filters.\n\nThe `veganFriendly` filter will be either _true_ (meaning you should only\ninclude restaurants with `veganFriendlyi` set to true) or _false_  (meaning\nyou can include any restaurant). In addition you have the filters `maxPrice`\nand `maxDistance` which are the maximum value for price and distance of\nrestaurants you should consider respectively.\n\nReturn the array of restaurant _**IDs**_ after filtering ordered by\n**rating** from highest to lowest. For restaurants with the same rating order\nthem by _**id**_ from highest to lowest. For simplicity `veganFriendlyi` and\n`veganFriendly` take value _1_ when it is _true_  and _0_ when it is _false_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** restaurants = [[1414010][280505][381304][4100103][511151]] veganFriendly = 1 maxPrice = 50 maxDistance = 10\n    **Output:** [315] \n    **Explanation:** The restaurants are:\n    Restaurant 1 [id=1 rating=4 veganFriendly=1 price=40 distance=10]\n    Restaurant 2 [id=2 rating=8 veganFriendly=0 price=50 distance=5]\n    Restaurant 3 [id=3 rating=8 veganFriendly=1 price=30 distance=4]\n    Restaurant 4 [id=4 rating=10 veganFriendly=0 price=10 distance=3]\n    Restaurant 5 [id=5 rating=1 veganFriendly=1 price=15 distance=1] \n    After filter restaurants with veganFriendly = 1 maxPrice = 50 and maxDistance = 10 we have restaurant 3 restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** restaurants = [[1414010][280505][381304][4100103][511151]] veganFriendly = 0 maxPrice = 50 maxDistance = 10\n    **Output:** [43215]\n    **Explanation:** The restaurants are the same as in example 1 but in this case the filter veganFriendly = 0 therefore all restaurants are considered.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** restaurants = [[1414010][280505][381304][4100103][511151]] veganFriendly = 0 maxPrice = 30 maxDistance = 3\n    **Output:** [45]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= restaurants.length <= 10^4`\n  * `restaurants[i].length == 5`\n  * `1 <= idi ratingi pricei distancei <= 10^5`\n  * `1 <= maxPrice maxDistance <= 10^5`\n  * `veganFriendlyi` and `veganFriendly` are 0 or 1.\n  * All `idi` are distinct.\n\n,"class Solution:\ndef f_fcn(selfrestaurants veganFriendly maxPrice maxDistance):\n	f_lst = filter(lambda x: (veganFriendly == 1 and x[2] == 1 and x[3] <= maxPrice and x[4] <= maxDistance) or\n				   (veganFriendly == 0 and x[3] <= maxPrice and x[4] <= maxDistance) restaurants)\n	return f_lst\n\ndef h_fcn(selflst):\n	return([lst[0] lst[1]])\n\ndef filterRestaurants(self restaurants: List[List[int]] veganFriendly: int maxPrice: int maxDistance: int) -> List[int]:\n\n	res = map(self.h_fcn self.f_fcn(restaurants veganFriendly maxPrice maxDistance))\n\n\n	return map(lambda x: x[0] sorted(res key=lambda x: (-x[1] -x[0])))\n"
Final Value of Variable After Performing Operations,"###  2011\. Final Value of Variable After Performing Operations\n\nThere is a programming language with only **four** operations and **one**\nvariable `X`:\n\n  * `++X` and `X++` **increments** the value of the variable `X` by `1`.\n  * `--X` and `X--` **decrements** the value of the variable `X` by `1`.\n\nInitially the value of `X` is `0`.\n\nGiven an array of strings `operations` containing a list of operations return\n_the**final** value of _`X` _after performing all the operations_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** operations = [""--X""""X++""""X++""]\n    **Output:** 1\n    **Explanation:**  The operations are performed as follows:\n    Initially X = 0.\n    --X: X is decremented by 1 X =  0 - 1 = -1.\n    X++: X is incremented by 1 X = -1 + 1 =  0.\n    X++: X is incremented by 1 X =  0 + 1 =  1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** operations = [""++X""""++X""""X++""]\n    **Output:** 3\n    **Explanation:** The operations are performed as follows:\n    Initially X = 0.\n    ++X: X is incremented by 1 X = 0 + 1 = 1.\n    ++X: X is incremented by 1 X = 1 + 1 = 2.\n    X++: X is incremented by 1 X = 2 + 1 = 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** operations = [""X++""""++X""""--X""""X--""]\n    **Output:** 0\n    **Explanation:**  The operations are performed as follows:\n    Initially X = 0.\n    X++: X is incremented by 1 X = 0 + 1 = 1.\n    ++X: X is incremented by 1 X = 1 + 1 = 2.\n    --X: X is decremented by 1 X = 2 - 1 = 1.\n    X--: X is decremented by 1 X = 1 - 1 = 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= operations.length <= 100`\n  * `operations[i]` will be either `""++X""` `""X++""` `""--X""` or `""X--""`.\n\n",# Runtime: 111 ms (Top 13.83%) | Memory: 14 MB (Top 12.56%)\nclass Solution:\n    def finalValueAfterOperations(self operations: List[str]) -> int:\n        x = 0\n        for o in operations:\n            if '+' in o:\n                x += 1\n            else:\n                x -= 1\n        return x
Find a Corresponding Node of a Binary Tree in a Clone of That Tree,###  1379\. Find a Corresponding Node of a Binary Tree in a Clone of That Tree\n\nGiven two binary trees `original` and `cloned` and given a reference to a node\n`target` in the original tree.\n\nThe `cloned` tree is a **copy of** the `original` tree.\n\nReturn _a reference to the same node_ in the `cloned` tree.\n\n**Note** that you are **not allowed** to change any of the two trees or the\n`target` node and the answer **must be** a reference to a node in the `cloned`\ntree.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/02/21/e1.png)\n\n    \n    \n    **Input:** tree = [743nullnull619] target = 3\n    **Output:** 3\n    **Explanation:** In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/02/21/e2.png)\n\n    \n    \n    **Input:** tree = [7] target =  7\n    **Output:** 7\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/02/21/e3.png)\n\n    \n    \n    **Input:** tree = [8null6null5null4null3null2null1] target = 4\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the `tree` is in the range `[1 104]`.\n  * The values of the nodes of the `tree` are unique.\n  * `target` node is a node from the `original` tree and is not `null`.\n\n\n\n**Follow up:** Could you solve the problem if repeated values on the tree are\nallowed?\n\n,# Runtime: 1109 ms (Top 30.14%) | Memory: 24.2 MB (Top 19.53%)\nclass Solution:\n    def getTargetCopy(self original: TreeNode cloned: TreeNode target: TreeNode) -> TreeNode:\n        def DFS(node1node2):\n            if node1==target:\n                return node2\n            if node1 and node1.left is None and node1.right is None:\n                return\n\n            res1 = DFS(node1.leftnode2.left) if node1 else None\n            if res1 is not None:\n                return res1\n            res2 = DFS(node1.rightnode2.right) if node1 else None\n            if res2 is not None:\n                return res2\n        res=DFS(originalcloned)\n        return res
Find a Value of a Mysterious Function Closest to Target,###  1521\. Find a Value of a Mysterious Function Closest to Target\n\n![](https://assets.leetcode.com/uploads/2020/07/09/change.png)\n\nWinston was given the above mysterious function `func`. He has an integer\narray `arr` and an integer `target` and he wants to find the values `l` and\n`r` that make the value `|func(arr l r) - target|` minimum possible.\n\nReturn _the minimum possible value_ of `|func(arr l r) - target|`.\n\nNotice that `func` should be called with the values `l` and `r` where `0 <= l\nr < arr.length`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [9123715] target = 5\n    **Output:** 2\n    **Explanation:** Calling func with all the pairs of [lr] = [[00][11][22][33][44][01][12][23][34][02][13][24][03][14][04]] Winston got the following results [91237158037003000]. The value closest to 5 is 7 and 3 thus the minimum difference is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [100000010000001000000] target = 1\n    **Output:** 999999\n    **Explanation:** Winston called the func with all possible values of [lr] and he always got 1000000 thus the min difference is 999999.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [124816] target = 0\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 105`\n  * `1 <= arr[i] <= 106`\n  * `0 <= target <= 107`\n\n,# Runtime: 1091 ms (Top 49.0%) | Memory: 27.44 MB (Top 83.6%)\n\nclass Solution:\n    def closestToTarget(self arr: List[int] target: int) -> int:\n        ans seen = inf set()\n        for x in arr: \n            seen = {ss & x for ss in seen} | {x}\n            ans = min(ans min(abs(ss - target) for ss in seen))\n        return ans 
Find All Anagrams in a String,"###  438\. Find All Anagrams in a String\n\nGiven two strings `s` and `p` return _an array of all the start indices\nof_`p` _'s anagrams in_`s`. You may return the answer in **any order**.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a\ndifferent word or phrase typically using all the original letters exactly\nonce.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""cbaebabacd"" p = ""abc""\n    **Output:** [06]\n    **Explanation:**\n    The substring with start index = 0 is ""cba"" which is an anagram of ""abc"".\n    The substring with start index = 6 is ""bac"" which is an anagram of ""abc"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abab"" p = ""ab""\n    **Output:** [012]\n    **Explanation:**\n    The substring with start index = 0 is ""ab"" which is an anagram of ""ab"".\n    The substring with start index = 1 is ""ba"" which is an anagram of ""ab"".\n    The substring with start index = 2 is ""ab"" which is an anagram of ""ab"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length p.length <= 3 * 104`\n  * `s` and `p` consist of lowercase English letters.\n\n",from collections import Counter\nclass Solution:\n    def findAnagrams(self s: str p: str) -> List[int]:\n        l='abcdefghijklmnopqrstuvwxyz'\n        if len(p)>len(s):\n            return []\n        d={}\n        for x in l:\n            d[x]=0\n        d1=dict(d)\n        d2=dict(d)\n        for x in range(len(p)):\n            d1[s[x]]+=1\n            d2[p[x]]+=1\n        l1=[]\n        if d1==d2:\n            l1=[0]\n        #print(d1)\n        for x in range(len(p)len(s)):\n            d1[s[x]]+=1\n            d1[s[x-len(p)]]-=1\n            if d1==d2:\n                l1.append(x-len(p)+1)\n        return l1\n
Find All Duplicates in an Array,###  442\. Find All Duplicates in an Array\n\nGiven an integer array `nums` of length `n` where all the integers of `nums`\nare in the range `[1 n]` and each integer appears **once** or **twice** \nreturn _an array of all the integers that appears**twice**_.\n\nYou must write an algorithm that runs in `O(n) `time and uses only constant\nextra space.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [43278231]\n    **Output:** [23]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [112]\n    **Output:** [1]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1]\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 105`\n  * `1 <= nums[i] <= n`\n  * Each element in `nums` appears **once** or **twice**.\n\n,class Solution:\n    def findDuplicates(self nums: List[int]) -> List[int]:\n        res = []\n        hm = {}\n        # adding entries in hashmap to check frequency\n        for i v in enumerate(nums):\n            if v not in hm:\n                hm[v] = 1\n            else:\n                hm[v] += 1\n        # checking frequency of item and adding output to an array\n        for key value in hm.items():\n            if value > 1:\n                res.append(key)\n        return res
Find All Groups of Farmland,###  1992\. Find All Groups of Farmland\n\nYou are given a **0-indexed** `m x n` binary matrix `land` where a `0`\nrepresents a hectare of forested land and a `1` represents a hectare of\nfarmland.\n\nTo keep the land organized there are designated rectangular areas of hectares\nthat consist **entirely** of farmland. These rectangular areas are called\n**groups**. No two groups are adjacent meaning farmland in one group is\n**not** four-directionally adjacent to another farmland in a different group.\n\n`land` can be represented by a coordinate system where the top left corner of\n`land` is `(0 0)` and the bottom right corner of `land` is `(m-1 n-1)`. Find\nthe coordinates of the top left and bottom right corner of each **group** of\nfarmland. A **group** of farmland with a top left corner at `(r1 c1)` and a\nbottom right corner at `(r2 c2)` is represented by the 4-length array `[r1\nc1 r2 c2].`\n\nReturn _a 2D array containing the 4-length arrays described above for\neach**group** of farmland in _`land` _. If there are no groups of farmland\nreturn an empty array. You may return the answer in**any order**_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-23-15-copy-\nof-diagram-drawio-diagrams-net.png)\n\n    \n    \n    **Input:** land = [[100][011][011]]\n    **Output:** [[0000][1122]]\n    **Explanation:**\n    The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].\n    The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-30-26-copy-\nof-diagram-drawio-diagrams-net.png)\n\n    \n    \n    **Input:** land = [[11][11]]\n    **Output:** [[0011]]\n    **Explanation:**\n    The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/07/27/screenshot-2021-07-27-at-12-32-24-copy-\nof-diagram-drawio-diagrams-net.png)\n\n    \n    \n    **Input:** land = [[0]]\n    **Output:** []\n    **Explanation:**\n    There are no groups of farmland.\n    \n\n\n\n**Constraints:**\n\n  * `m == land.length`\n  * `n == land[i].length`\n  * `1 <= m n <= 300`\n  * `land` consists of only `0`'s and `1`'s.\n  * Groups of farmland are **rectangular** in shape.\n\n,# Runtime: 1416 ms (Top 90.80%) | Memory: 33.1 MB (Top 49.64%)\nclass Solution:\n\n    def findFarmland(self land: List[List[int]]) -> List[List[int]]:\n        n = len(land)\n        m = len(land[0])\n\n        groups = []\n        visited = set()\n\n        for y in range(n):\n            for x in range(m):\n                if land[y][x] == 0:\n                    continue\n\n                if (y x) in visited:\n                    continue\n\n                q = collections.deque()\n                q.append((y x))\n                visited.add((y x))\n\n                while q:\n                    cy cx = q.popleft()\n\n                    for dy dx in ((0 1) (1 0)):\n                        if (cy + dy cx + dx) in visited:\n                            continue\n\n                        if 0 <= cy + dy < n and 0 <= cx + dx < m:\n                            if land[cy + dy][cx + dx] == 1:\n                                q.append((cy + dy cx + dx))\n                                visited.add((cy + dy cx + dx))\n\n                groups.append([y x cy cx])\n\n        return groups
Find All K-Distant Indices in an Array,###  2200\. Find All K-Distant Indices in an Array\n\nYou are given a **0-indexed** integer array `nums` and two integers `key` and\n`k`. A **k-distant index** is an index `i` of `nums` for which there exists at\nleast one index `j` such that `|i - j| <= k` and `nums[j] == key`.\n\nReturn _a list of all k-distant indices sorted in**increasing order**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3491395] key = 9 k = 1\n    **Output:** [123456]\n    **Explanation:** Here nums[2] == key and nums[5] == key.\n    - For index 0 |0 - 2| > k and |0 - 5| > k so there is no j where |0 - j| <= k and nums[j] == key. Thus 0 is not a k-distant index.\n    - For index 1 |1 - 2| <= k and nums[2] == key so 1 is a k-distant index.\n    - For index 2 |2 - 2| <= k and nums[2] == key so 2 is a k-distant index.\n    - For index 3 |3 - 2| <= k and nums[2] == key so 3 is a k-distant index.\n    - For index 4 |4 - 5| <= k and nums[5] == key so 4 is a k-distant index.\n    - For index 5 |5 - 5| <= k and nums[5] == key so 5 is a k-distant index.\n    - For index 6 |6 - 5| <= k and nums[5] == key so 6 is a k-distant index.\n    Thus we return [123456] which is sorted in increasing order. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [22222] key = 2 k = 2\n    **Output:** [01234]\n    **Explanation:** For all indices i in nums there exists some index j such that |i - j| <= k and nums[j] == key so every index is a k-distant index. \n    Hence we return [01234].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 1000`\n  * `key` is an integer from the array `nums`.\n  * `1 <= k <= nums.length`\n\n,class Solution:\n    def findKDistantIndices(self nums: List[int] key: int k: int) -> List[int]:\n        lis=deque([])\n        prev_popped=-1\n        for i in range(len(nums)):\n            if(nums[i]==key):\n                lis.append(i)\n        ans=[]\n        for i in range(len(nums)):\n            if(len(lis)>0 and lis[0]<i):\n                prev_popped = lis.popleft()\n            if(prev_popped!=-1 and (i-prev_popped) <=k):\n                ans.append(i)\n            elif(len(lis)>0 and (lis[0]-i)<=k):\n                ans.append(i)\n        return ans\n
Find All Numbers Disappeared in an Array,###  448\. Find All Numbers Disappeared in an Array\n\nGiven an array `nums` of `n` integers where `nums[i]` is in the range `[1\nn]` return _an array of all the integers in the range_ `[1 n]` _that do not\nappear in_ `nums`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [43278231]\n    **Output:** [56]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [11]\n    **Output:** [2]\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 105`\n  * `1 <= nums[i] <= n`\n\n\n\n**Follow up:** Could you do it without extra space and in `O(n)` runtime? You\nmay assume the returned list does not count as extra space.\n\n,class Solution:\n    def findDisappearedNumbers(self nums: List[int]) -> List[int]:\n        return set(nums) ^ set(range(1len(nums)+1))\n
Find All People With Secret,###  2092\. Find All People With Secret\n\nYou are given an integer `n` indicating there are `n` people numbered from `0`\nto `n - 1`. You are also given a **0-indexed** 2D integer array `meetings`\nwhere `meetings[i] = [xi yi timei]` indicates that person `xi` and person\n`yi` have a meeting at `timei`. A person may attend **multiple meetings** at\nthe same time. Finally you are given an integer `firstPerson`.\n\nPerson `0` has a **secret** and initially shares the secret with a person\n`firstPerson` at time `0`. This secret is then shared every time a meeting\ntakes place with a person that has the secret. More formally for every\nmeeting if a person `xi` has the secret at `timei` then they will share the\nsecret with person `yi` and vice versa.\n\nThe secrets are shared **instantaneously**. That is a person may receive the\nsecret and share it with people in other meetings within the same time frame.\n\nReturn _a list of all the people that have the secret after all the meetings\nhave taken place._ You may return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 6 meetings = [[125][238][1510]] firstPerson = 1\n    **Output:** [01235]\n    **Explanation:** At time 0 person 0 shares the secret with person 1.\n    At time 5 person 1 shares the secret with person 2.\n    At time 8 person 2 shares the secret with person 3.\n    At time 10 person 1 shares the secret with person 5.​​​​\n    Thus people 0 1 2 3 and 5 know the secret after all the meetings.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4 meetings = [[313][122][033]] firstPerson = 3\n    **Output:** [013]\n    **Explanation:**\n    At time 0 person 0 shares the secret with person 3.\n    At time 2 neither person 1 nor person 2 know the secret.\n    At time 3 person 3 shares the secret with person 0 and person 1.\n    Thus people 0 1 and 3 know the secret after all the meetings.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 5 meetings = [[342][121][231]] firstPerson = 1\n    **Output:** [01234]\n    **Explanation:**\n    At time 0 person 0 shares the secret with person 1.\n    At time 1 person 1 shares the secret with person 2 and person 2 shares the secret with person 3.\n    Note that person 2 can share the secret at the same time as receiving it.\n    At time 2 person 3 shares the secret with person 4.\n    Thus people 0 1 2 3 and 4 know the secret after all the meetings.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 105`\n  * `1 <= meetings.length <= 105`\n  * `meetings[i].length == 3`\n  * `0 <= xi yi <= n - 1`\n  * `xi != yi`\n  * `1 <= timei <= 105`\n  * `1 <= firstPerson <= n - 1`\n\n,# Runtime: 6190 ms (Top 5.05%) | Memory: 57.3 MB (Top 48.67%)\nclass Solution:\n    def findAllPeople(self n: int meetings: List[List[int]] firstPerson: int) -> List[int]:\n\n        class UnionFind:\n            def __init__(self):\n                self.parents = {}\n                self.ranks = {}\n\n            def insert(self x):\n                if x not in self.parents:\n                    self.parents[x] = x\n                    self.ranks[x] = 0\n\n            def find_parent(self x):\n                if self.parents[x] != x:\n                    self.parents[x] = self.find_parent(self.parents[x])\n                return self.parents[x]\n\n            def union(self x y):\n                self.insert(x)\n                self.insert(y)\n                x y = self.find_parent(x) self.find_parent(y)\n                if x == y:\n                    return\n                if self.ranks[x] > self.ranks[y]:\n                    self.parents[y] = x\n                else:\n                    self.parents[x] = y\n                    if self.ranks[x] == self.ranks[y]:\n                        self.ranks[y] += 1\n\n        time2meets = defaultdict(list)\n        for x y t in meetings:\n            time2meets[t].append((x y))\n        time2meets = sorted(time2meets.items())\n\n        curr_know = set([0 firstPerson])\n\n        for time meets in time2meets:\n            uf = UnionFind()\n            for x y in meets:\n                uf.union(x y)\n\n            groups = defaultdict(set)\n            for idx in uf.parents:\n                groups[uf.find_parent(idx)].add(idx)\n\n            for group in groups.values():\n                if group & curr_know:\n                    curr_know.update(group)\n\n        return list(curr_know)
Find All Possible Recipes from Given Supplies,"###  2115\. Find All Possible Recipes from Given Supplies\n\nYou have information about `n` different recipes. You are given a string array\n`recipes` and a 2D string array `ingredients`. The `ith` recipe has the name\n`recipes[i]` and you can **create** it if you have **all** the needed\ningredients from `ingredients[i]`. Ingredients to a recipe may need to be\ncreated from **other** recipes i.e. `ingredients[i]` may contain a string\nthat is in `recipes`.\n\nYou are also given a string array `supplies` containing all the ingredients\nthat you initially have and you have an infinite supply of all of them.\n\nReturn _a list of all the recipes that you can create._ You may return the\nanswer in **any order**.\n\nNote that two recipes may contain each other in their ingredients.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** recipes = [""bread""] ingredients = [[""yeast""""flour""]] supplies = [""yeast""""flour""""corn""]\n    **Output:** [""bread""]\n    **Explanation:**\n    We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** recipes = [""bread""""sandwich""] ingredients = [[""yeast""""flour""][""bread""""meat""]] supplies = [""yeast""""flour""""meat""]\n    **Output:** [""bread""""sandwich""]\n    **Explanation:**\n    We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".\n    We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** recipes = [""bread""""sandwich""""burger""] ingredients = [[""yeast""""flour""][""bread""""meat""][""sandwich""""meat""""bread""]] supplies = [""yeast""""flour""""meat""]\n    **Output:** [""bread""""sandwich""""burger""]\n    **Explanation:**\n    We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".\n    We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"".\n    We can create ""burger"" since we have the ingredient ""meat"" and can create the ingredients ""bread"" and ""sandwich"".\n    \n\n\n\n**Constraints:**\n\n  * `n == recipes.length == ingredients.length`\n  * `1 <= n <= 100`\n  * `1 <= ingredients[i].length supplies.length <= 100`\n  * `1 <= recipes[i].length ingredients[i][j].length supplies[k].length <= 10`\n  * `recipes[i] ingredients[i][j]` and `supplies[k]` consist only of lowercase English letters.\n  * All the values of `recipes` and `supplies` combined are unique.\n  * Each `ingredients[i]` does not contain any duplicate values.\n\n","class Solution:\n	def findAllRecipes(self recipes: List[str] ingredients: List[List[str]] supplies: List[str]) -> List[str]:\n\n		graph = defaultdict(list)\n		in_degree = defaultdict(int)\n		for ring in zip(recipesingredients):\n			for i in ing:\n				graph[i].append(r)\n				in_degree[r]+=1\n\n		queue = supplies[::]\n		res = []\n		while queue:\n			ing = queue.pop(0)\n			if ing in recipes:\n				res.append(ing)\n\n			for child in graph[ing]:\n				in_degree[child]-=1\n				if in_degree[child]==0:\n					queue.append(child)\n\n		return res\n"
Find And Replace in String,"###  833\. Find And Replace in String\n\nYou are given a **0-indexed** string `s` that you must perform `k` replacement\noperations on. The replacement operations are given as three **0-indexed**\nparallel arrays `indices` `sources` and `targets` all of length `k`.\n\nTo complete the `ith` replacement operation:\n\n  1. Check if the **substring** `sources[i]` occurs at index `indices[i]` in the **original string** `s`.\n  2. If it does not occur **do nothing**.\n  3. Otherwise if it does occur **replace** that substring with `targets[i]`.\n\nFor example if `s = ""_ab_ cd""` `indices[i] = 0` `sources[i] = ""ab""` and\n`targets[i] = ""eee""` then the result of this replacement will be `""_eee_\ncd""`.\n\nAll replacement operations must occur **simultaneously**  meaning the\nreplacement operations should not affect the indexing of each other. The\ntestcases will be generated such that the replacements will **not overlap**.\n\n  * For example a testcase with `s = ""abc""` `indices = [0 1]` and `sources = [""ab""""bc""]` will not be generated because the `""ab""` and `""bc""` replacements overlap.\n\nReturn _the**resulting string** after performing all replacement operations on\n_`s`.\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/12/833-ex1.png)\n\n    \n    \n    **Input:** s = ""abcd"" indices = [0 2] sources = [""a"" ""cd""] targets = [""eee"" ""ffff""]\n    **Output:** ""eeebffff""\n    **Explanation:**\n    ""a"" occurs at index 0 in s so we replace it with ""eee"".\n    ""cd"" occurs at index 2 in s so we replace it with ""ffff"".\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/12/833-ex2-1.png)\n\n    \n    \n    **Input:** s = ""abcd"" indices = [0 2] sources = [""ab""""ec""] targets = [""eee""""ffff""]\n    **Output:** ""eeecd""\n    **Explanation:**\n    ""ab"" occurs at index 0 in s so we replace it with ""eee"".\n    ""ec"" does not occur at index 2 in s so we do nothing.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `k == indices.length == sources.length == targets.length`\n  * `1 <= k <= 100`\n  * `0 <= indexes[i] < s.length`\n  * `1 <= sources[i].length targets[i].length <= 50`\n  * `s` consists of only lowercase English letters.\n  * `sources[i]` and `targets[i]` consist of only lowercase English letters.\n\n",class Solution:\n    def findReplaceString(self s: str indices: List[int] sources: List[str] targets: List[str]) -> str:\n        \n        inputs = list(zip(indicessourcestargets))\n        inputs.sort(key = lambda x: x[0])\n        \n        offset = 0\n        for idx src tgt in inputs:\n            idx += offset\n            if s[idx:idx + len(src)] != src:\n                print('hi')\n                print(idx)\n                continue\n                \n            offset += len(tgt) - len(src)\n            s = s[:idx] + tgt + s[idx+len(src):]\n            \n        return s\n
Find and Replace Pattern,"###  890\. Find and Replace Pattern\n\nGiven a list of strings `words` and a string `pattern` return _a list of_\n`words[i]` _that match_ `pattern`. You may return the answer in **any order**.\n\nA word matches the pattern if there exists a permutation of letters `p` so\nthat after replacing every letter `x` in the pattern with `p(x)` we get the\ndesired word.\n\nRecall that a permutation of letters is a bijection from letters to letters:\nevery letter maps to another letter and no two letters map to the same\nletter.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""abc""""deq""""mee""""aqq""""dkd""""ccc""] pattern = ""abb""\n    **Output:** [""mee""""aqq""]\n    **Explanation:** ""mee"" matches the pattern because there is a permutation {a -> m b -> e ...}. \n    ""ccc"" does not match the pattern because {a -> c b -> c ...} is not a permutation since a and b map to the same letter.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""a""""b""""c""] pattern = ""a""\n    **Output:** [""a""""b""""c""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= pattern.length <= 20`\n  * `1 <= words.length <= 50`\n  * `words[i].length == pattern.length`\n  * `pattern` and `words[i]` are lowercase English letters.\n\n",# Runtime: 47 ms (Top 36.0%) | Memory: 16.40 MB (Top 44.2%)\n\nclass Solution:\n    def findAndReplacePattern(self words: List[str] pattern: str) -> List[str]:\n        d={}\n        for iv in enumerate(pattern):\n            if v in d:\n                d[v].append(i)\n            else:\n                d|={v:[i]}\n        #DICTIONARY CONTAINING LETTERS AND THEIR INDICES\n        ans=[]\n        for i in words:\n            e={}\n            for jv in enumerate(i):\n                if v in e:\n                    e[v].append(j)\n                else:\n                    e|={v:[j]}\n        #DICTIONARY CONTAINING LETTERS OF INDICES OF CURRENT WORD\n            for uv in zip(d.values()e.values()):\n                #COMPARING EACH VALUE\n                if u!=v:\n                    break\n            #IF SUCCESSFUL APPEND TO ANS\n            else:ans.append(i)\n        return ans
Find Array Given Subset Sums,###  1982\. Find Array Given Subset Sums\n\nYou are given an integer `n` representing the length of an unknown array that\nyou are trying to recover. You are also given an array `sums` containing the\nvalues of all `2n` **subset sums** of the unknown array (in no particular\norder).\n\nReturn _the array_`ans` _of length_`n` _representing the unknown array.\nIf**multiple** answers exist return **any** of them_.\n\nAn array `sub` is a **subset** of an array `arr` if `sub` can be obtained from\n`arr` by deleting some (possibly zero or all) elements of `arr`. The sum of\nthe elements in `sub` is one possible **subset sum** of `arr`. The sum of an\nempty array is considered to be `0`.\n\n**Note:** Test cases are generated such that there will **always** be at least\none correct answer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 sums = [-3-2-100123]\n    **Output:** [12-3]\n    **Explanation:**[12-3] is able to achieve the given subset sums:\n    - []: sum is 0\n    - [1]: sum is 1\n    - [2]: sum is 2\n    - [12]: sum is 3\n    - [-3]: sum is -3\n    - [1-3]: sum is -2\n    - [2-3]: sum is -1\n    - [12-3]: sum is 0\n    Note that any permutation of [12-3] and also any permutation of [-1-23] will also be accepted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 sums = [0000]\n    **Output:** [00]\n    **Explanation:** The only correct answer is [00].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 4 sums = [00554-1499-1434838]\n    **Output:** [0-145]\n    **Explanation:** [0-145] is able to achieve the given subset sums.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 15`\n  * `sums.length == 2n`\n  * `-104 <= sums[i] <= 104`\n\n,# Runtime: 4011 ms (Top 18.39%) | Memory: 19.7 MB (Top 40.23%)\nclass Solution:\n    def recoverArray(self n: int sums: List[int]) -> List[int]:\n        res = [] # Result set\n        sums.sort()\n\n        while len(sums) > 1:\n            num = sums[-1] - sums[-2] # max - secondMax\n            countMap = Counter(sums) # Get count of each elements\n            excluding = [] # Subset sums that do NOT contain num\n            including = [] # Subset sums that contain num\n\n            for x in sums:\n                if countMap.get(x) > 0:\n                    excluding.append(x)\n                    including.append(x+num)\n                    countMap[x] -= 1\n                    countMap[x+num] -= 1\n\n            # Check validity of excluding set\n            if 0 in excluding:\n                sums = excluding\n                res.append(num)\n            else:\n                sums = including\n                res.append(-1*num)\n\n        return res
Find Bottom Left Tree Value,###  513\. Find Bottom Left Tree Value\n\nGiven the `root` of a binary tree return the leftmost value in the last row\nof the tree.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)\n\n    \n    \n    **Input:** root = [213]\n    **Output:** 1\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)\n\n    \n    \n    **Input:** root = [1234null56nullnull7]\n    **Output:** 7\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `-231 <= Node.val <= 231 - 1`\n\n,"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self root: Optional[TreeNode]) -> int:\n        \n        res = root.val\n        stack = [(0 root)]\n        prev_d = 0\n        \n        while stack:\n            \n            curr_d curr_v = stack.pop(0)\n            \n            if curr_v.left:\n                stack.append((curr_d+1 curr_v.left))\n                if prev_d != curr_d + 1:\n                    res = curr_v.left.val\n                    prev_d = curr_d+1\n            \n            if curr_v.right:\n                stack.append((curr_d+1 curr_v.right))\n                if prev_d != curr_d + 1:\n                    res = curr_v.right.val\n                    prev_d = curr_d+1\n        \n        return res\n		\n		# An Upvote will be encouraging\n"
Find Center of Star Graph,###  1791\. Find Center of Star Graph\n\nThere is an undirected **star** graph consisting of `n` nodes labeled from `1`\nto `n`. A star graph is a graph where there is one **center** node and\n**exactly** `n - 1` edges that connect the center node with every other node.\n\nYou are given a 2D integer array `edges` where each `edges[i] = [ui vi]`\nindicates that there is an edge between the nodes `ui` and `vi`. Return the\ncenter of the given star graph.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/24/star_graph.png)\n\n    \n    \n    **Input:** edges = [[12][23][42]]\n    **Output:** 2\n    **Explanation:** As shown in the figure above node 2 is connected to every other node so 2 is the center.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** edges = [[12][51][13][14]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `3 <= n <= 105`\n  * `edges.length == n - 1`\n  * `edges[i].length == 2`\n  * `1 <= ui vi <= n`\n  * `ui != vi`\n  * The given `edges` represent a valid star graph.\n\n,"class Solution:\n    def findCenter(self edges: List[List[int]]) -> int:\n        \n        """""" From the Constraints: A valid STAR GRAPH is confirmed. \n		That means the center will be common to every edges. \n		Therefore we can get the center by comparing only first 2 elements""""""\n        \n        for i in range (1):\n            \n            # Check if first element of first edge mathches with any element of second edges\n            \n            if edges[i][0] == edges [i+1][0] or edges[i][0] == edges[i+1][1]:\n                return edges[i][0]\n            \n            #Otherwise second element of first edge will be the answer\n            else:\n                return edges[i][1]\n"
Find Closest Node to Given Two Nodes,###  2359\. Find Closest Node to Given Two Nodes\n\nYou are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`\nwhere each node has **at most one** outgoing edge.\n\nThe graph is represented with a given **0-indexed** array `edges` of size `n`\nindicating that there is a directed edge from node `i` to node `edges[i]`. If\nthere is no outgoing edge from `i` then `edges[i] == -1`.\n\nYou are also given two integers `node1` and `node2`.\n\nReturn _the**index** of the node that can be reached from both _`node1`\n_and_`node2` _ such that the**maximum** between the distance from _`node1`\n_to that node and from_`node2` _to that node is**minimized**_. If there are\nmultiple answers return the node with the **smallest** index and if no\npossible answer exists return `-1`.\n\nNote that `edges` may contain cycles.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png)\n\n    \n    \n    **Input:** edges = [223-1] node1 = 0 node2 = 1\n    **Output:** 2\n    **Explanation:** The distance from node 0 to node 2 is 1 and the distance from node 1 to node 2 is 1.\n    The maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1 so we return node 2.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png)\n\n    \n    \n    **Input:** edges = [12-1] node1 = 0 node2 = 2\n    **Output:** 2\n    **Explanation:** The distance from node 0 to node 2 is 2 and the distance from node 2 to itself is 0.\n    The maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2 so we return node 2.\n    \n\n\n\n**Constraints:**\n\n  * `n == edges.length`\n  * `2 <= n <= 105`\n  * `-1 <= edges[i] < n`\n  * `edges[i] != i`\n  * `0 <= node1 node2 < n`\n\n,"# Runtime: 3032 ms (Top 5.02%) | Memory: 139.1 MB (Top 14.52%)\nclass Solution:\n    def closestMeetingNode(self edges: List[int] node1: int node2: int) -> int:\n\n        res = float(""inf"")\n\n        def dfs(node arr counter=0):\n\n            #making sure we haven't visited the node before (i.e. value in the array != -1)\n            while arr[node]==-1 and node!=-1:\n\n                #assigning how many moves it takes to reach node\n                arr[node] = counter\n                next_node = edges[node]\n\n                #going through each neighbor if exists and updating the counter\n                dfs(edges[node] arr counter+1)\n\n            return arr\n\n        #find moves to reach nodes from node1\n        n1 = [-1 for i in range(len(edges))]\n        dfs(node1 n1)\n\n        #find moves to reach nodes from node2\n        n2 = [-1 for i in range(len(edges))]\n        dfs(node2 n2)\n\n        answer = -1\n\n        for i in range(len(edges)):\n\n            #check if the end node is reachable from both starting nodes\n            if n1[i]!=-1 and n2[i]!=-1:\n                maximum_distance = max(n1[i] n2[i])\n\n                #update the distance and the final answer if relevant\n                if maximum_distance<res:\n                    res = maximum_distance\n                    answer = i\n\n        return answer\n"
Find Closest Number to Zero,###  2239\. Find Closest Number to Zero\n\nGiven an integer array `nums` of size `n` return _the number with the\nvalue**closest** to _`0` _in_`nums`. If there are multiple answers return\n_the number with the**largest** value_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [-4-2148]\n    **Output:** 1\n    **Explanation:**\n    The distance from -4 to 0 is |-4| = 4.\n    The distance from -2 to 0 is |-2| = 2.\n    The distance from 1 to 0 is |1| = 1.\n    The distance from 4 to 0 is |4| = 4.\n    The distance from 8 to 0 is |8| = 8.\n    Thus the closest number to 0 in the array is 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2-11]\n    **Output:** 1\n    **Explanation:** 1 and -1 are both the closest numbers to 0 so 1 being larger is returned.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n  * `-105 <= nums[i] <= 105`\n\n,"class Solution:\n    \n    def findClosestNumber1(self nums: List[int]) -> int:\n        return min(nums key=lambda x: (abs(x) -x))\n    \n    def findClosestNumber2(self nums: List[int]) -> int:\n        return min(nums key=lambda x: abs(x - .1))\n    \n    def findClosestNumber3(self nums: List[int]) -> int:\n        return max((-abs(x) x) for x in nums)[1]\n    \n    def findClosestNumber4(self nums: List[int]) -> int:\n        return -min(zip(map(abs nums) map(neg nums)))[1]\n\n    def findClosestNumber5(self nums: List[int]) -> int:\n        a = min(map(abs nums))\n        return a if a in nums else -a\n\n    def findClosestNumber6(self nums: List[int]) -> int:\n        a = abs(min(nums key=abs))\n        return a if a in nums else -a\n\n    def findClosestNumber7(self nums: List[int]) -> int:\n        x = min(nums key=abs)\n        return x if x >= 0 or -x not in nums else -x\n    \n    def findClosestNumber8(self nums: List[int]) -> int:\n        return min(sorted(nums reverse=True) key=abs)\n    \n    def findClosestNumber9(self nums: List[int]) -> int:        \n        a = abs(nums[0])\n        for x in nums:\n            if x < 0:\n                x = -x\n            if x < a:\n                a = x\n        return a if a in nums else -a\n        \n    def findClosestNumberA(self nums: List[int]) -> int:        \n        pos = 999999\n        neg = -pos\n        for x in nums:\n            if x < 0:\n                if x > neg:\n                    neg = x\n            elif x < pos:\n                pos = x\n        return pos if pos <= -neg else neg\n        \n    def findClosestNumberB(self nums: List[int]) -> int:        \n        pos = 999999\n        neg = -pos\n        for x in nums:\n            if x < pos and neg < x:\n                if x < 0:\n                    neg = x\n                else:\n                    pos = x\n        return pos if pos <= -neg else neg\n        \n    def findClosestNumberC(self nums: List[int]) -> int:        \n        pos = 999999\n        neg = -pos\n        for x in nums:\n            if neg < x and x < pos:\n                if x < 0:\n                    neg = x\n                else:\n                    pos = x\n        return pos if pos <= -neg else neg\n        \n    def findClosestNumberD(self nums: List[int]) -> int:        \n        pos = 999999\n        neg = -pos\n        for x in nums:\n            if neg < x < pos:\n                if x < 0:\n                    neg = x\n                else:\n                    pos = x\n        return pos if pos <= -neg else neg\n        \n    def findClosestNumber(self nums: List[int] timess=defaultdict(lambda: [0] * 10) testcase=[0]) -> int:\n        name = 'findClosestNumber'\n        solutions = [getattr(self s)\n                     for s in dir(self)\n                     if s.startswith(name)\n                     and s != name]\n        expect = dummy = object()\n        from time import perf_counter as time\n        for i in range(10):\n            shuffle(solutions)\n            for solution in solutions:\n                start = time()\n                result = solution(nums)\n                end = time()\n                if expect is dummy:\n                    expect = result\n                assert result == expect\n                timess[solution.__name__][i] += end - start\n        testcase[0] += 1\n        if testcase[0] == 224:\n            for name times in sorted(timess.items() key=lambda nt: sorted(nt[1])):\n                print(name *(f'{t*1e3:6.2f} ms' for t in sorted(times)[:3]))\n            return\n        return result\n		\n"
Find Common Characters,"###  1002\. Find Common Characters\n\nGiven a string array `words` return _an array of all characters that show up\nin all strings within the_`words` _(including duplicates)_. You may return the\nanswer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""bella""""label""""roller""]\n    **Output:** [""e""""l""""l""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""cool""""lock""""cook""]\n    **Output:** [""c""""o""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 100`\n  * `1 <= words[i].length <= 100`\n  * `words[i]` consists of lowercase English letters.\n\n","# Runtime: 87 ms (Top 42.12%) | Memory: 14.3 MB (Top 6.17%)\nclass Solution:\n    def _get_char_counts(self s: str) -> dict[str]:\n        """"""builds a dict of letters : count""""""\n        d = {}\n        for i in s:\n            d[i] = d.get(i0)+1\n        return d\n\n    def commonChars(self words: list[str]) -> list[str]:\n        """"""returns a string of letters common between a list of words (including duplicates)""""""\n        if not words:\n            return\n\n        # O(n^2)\n        words = [self._get_char_counts(word) for word in words]\n\n        # O(nm) set intersection\n        common = words[0].keys()\n        for other in words[1:]:\n            common &= other.keys()\n\n        # O(nm) number of common characters across the number of words\n        result = []\n        for c in common:\n            result += [c] * min(count[c] for count in words)\n\n        return result"
Find Duplicate Subtrees,###  652\. Find Duplicate Subtrees\n\nGiven the `root` of a binary tree return all **duplicate subtrees**.\n\nFor each kind of duplicate subtrees you only need to return the root node of\nany **one** of them.\n\nTwo trees are **duplicate** if they have the **same structure** with the\n**same node values**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/16/e1.jpg)\n\n    \n    \n    **Input:** root = [1234null24nullnull4]\n    **Output:** [[24][4]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/08/16/e2.jpg)\n\n    \n    \n    **Input:** root = [211]\n    **Output:** [[1]]\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/08/16/e33.jpg)\n\n    \n    \n    **Input:** root = [2223null3null]\n    **Output:** [[23][3]]\n    \n\n\n\n**Constraints:**\n\n  * The number of the nodes in the tree will be in the range `[1 10^4]`\n  * `-200 <= Node.val <= 200`\n\n,"class Solution:\n    def findDuplicateSubtrees(self root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\n        ans = []\n        path_map = {}\n        \n        def dfs(node):\n            if not node:\n                return ""#""\n            \n            path = """".join([str(node.val) dfs(node.left) dfs(node.right)])\n            \n            if path in path_map:\n                path_map[path] += 1\n                if  path_map[path] == 2:\n                    ans.append(node)\n            else:\n                path_map[path] = 1\n                \n            return path\n        \n        \n        dfs(root)\n        return ans\n"
Find Elements in a Contaminated Binary Tree,"###  1261\. Find Elements in a Contaminated Binary Tree\n\nGiven a binary tree with the following rules:\n\n  1. `root.val == 0`\n  2. If `treeNode.val == x` and `treeNode.left != null` then `treeNode.left.val == 2 * x + 1`\n  3. If `treeNode.val == x` and `treeNode.right != null` then `treeNode.right.val == 2 * x + 2`\n\nNow the binary tree is contaminated which means all `treeNode.val` have been\nchanged to `-1`.\n\nImplement the `FindElements` class:\n\n  * `FindElements(TreeNode* root)` Initializes the object with a contaminated binary tree and recovers it.\n  * `bool find(int target)` Returns `true` if the `target` value exists in the recovered binary tree.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4-1.jpg)\n\n    \n    \n    **Input**\n    [""FindElements""""find""""find""]\n    [[[-1null-1]][1][2]]\n    **Output**\n    [nullfalsetrue]\n    **Explanation**\n    FindElements findElements = new FindElements([-1null-1]); \n    findElements.find(1); // return False \n    findElements.find(2); // return True \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4.jpg)\n\n    \n    \n    **Input**\n    [""FindElements""""find""""find""""find""]\n    [[[-1-1-1-1-1]][1][3][5]]\n    **Output**\n    [nulltruetruefalse]\n    **Explanation**\n    FindElements findElements = new FindElements([-1-1-1-1-1]);\n    findElements.find(1); // return True\n    findElements.find(3); // return True\n    findElements.find(5); // return False\n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/11/07/untitled-diagram-4-1-1.jpg)\n\n    \n    \n    **Input**\n    [""FindElements""""find""""find""""find""""find""]\n    [[[-1null-1-1null-1]][2][3][4][5]]\n    **Output**\n    [nulltruefalsefalsetrue]\n    **Explanation**\n    FindElements findElements = new FindElements([-1null-1-1null-1]);\n    findElements.find(2); // return True\n    findElements.find(3); // return False\n    findElements.find(4); // return False\n    findElements.find(5); // return True\n    \n\n\n\n**Constraints:**\n\n  * `TreeNode.val == -1`\n  * The height of the binary tree is less than or equal to `20`\n  * The total number of nodes is between `[1 104]`\n  * Total calls of `find()` is between `[1 104]`\n  * `0 <= target <= 106`\n\n",# Runtime: 227 ms (Top 13.41%) | Memory: 18.1 MB (Top 62.12%)\n# Definition for a binary tree node.\n# class TreeNode:\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass FindElements:\n\n    def __init__(self root: Optional[TreeNode]):\n        def recoverTree(root):\n            if not root:\n                return None\n            self.vals.add(root.val)\n            if root.left:\n                root.left.val = 2 * root.val + 1\n                recoverTree(root.left)\n            if root.right:\n                root.right.val = 2 * root.val + 2\n                recoverTree(root.right)\n        self.vals = set()\n        root.val = 0\n        recoverTree(root)\n\n    def find(self target: int) -> bool:\n        return target in self.vals\n\n# Your FindElements object will be instantiated and called as such:\n# obj = FindElements(root)\n# param_1 = obj.find(target)
Find Eventual Safe States,###  802\. Find Eventual Safe States\n\nThere is a directed graph of `n` nodes with each node labeled from `0` to `n -\n1`. The graph is represented by a **0-indexed** 2D integer array `graph` where\n`graph[i]` is an integer array of nodes adjacent to node `i` meaning there is\nan edge from node `i` to each node in `graph[i]`.\n\nA node is a **terminal node** if there are no outgoing edges. A node is a\n**safe node** if every possible path starting from that node leads to a\n**terminal node** (or another safe node).\n\nReturn _an array containing all the**safe nodes** of the graph_. The answer\nshould be sorted in **ascending** order.\n\n\n\n**Example 1:**\n\n![Illustration of graph](https://s3-lc-\nupload.s3.amazonaws.com/uploads/2018/03/17/picture1.png)\n\n    \n    \n    **Input:** graph = [[12][23][5][0][5][][]]\n    **Output:** [2456]\n    **Explanation:** The given graph is shown above.\n    Nodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\n    Every path starting at nodes 2 4 5 and 6 all lead to either node 5 or 6.\n\n**Example 2:**\n\n    \n    \n    **Input:** graph = [[1234][12][34][04][]]\n    **Output:** [4]\n    **Explanation:**\n    Only node 4 is a terminal node and every path starting at node 4 leads to node 4.\n    \n\n\n\n**Constraints:**\n\n  * `n == graph.length`\n  * `1 <= n <= 104`\n  * `0 <= graph[i].length <= n`\n  * `0 <= graph[i][j] <= n - 1`\n  * `graph[i]` is sorted in a strictly increasing order.\n  * The graph may contain self-loops.\n  * The number of edges in the graph will be in the range `[1 4 * 104]`.\n\n,import collections\n\nclass Solution:\n    def eventualSafeNodes(self graph: list[list[int]]) -> list[int]:\n\n        n = len(graph)\n        ans = []\n        \n        for i in range(n):\n            if not graph[i]:\n                ans.append(i)\n        \n        def loop(key loops):\n    \n            loops.append(key)\n            for i in graph[key]:\n                if i in loops:\n                    return False\n                elif i in ans: \n                    continue\n                else:\n                    r = loop(i loops)\n                    if r == True: \n                        continue\n                    else: \n                        return False\n\n            idx = loops.index(key)\n            loops.pop(idx)\n            return True\n                    \n        for i in range(n):\n            loops = []\n            if i in ans:\n                continue\n            r = loop(i loops)\n            if r == True: ans.append(i)\n \n        return sorted(ans)\n
Find First and Last Position of Element in Sorted Array,###  34\. Find First and Last Position of Element in Sorted Array\n\nGiven an array of integers `nums` sorted in non-decreasing order find the\nstarting and ending position of a given `target` value.\n\nIf `target` is not found in the array return `[-1 -1]`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [5778810] target = 8\n    **Output:** [34]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [5778810] target = 6\n    **Output:** [-1-1]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [] target = 0\n    **Output:** [-1-1]\n    \n\n\n\n**Constraints:**\n\n  * `0 <= nums.length <= 105`\n  * `-109 <= nums[i] <= 109`\n  * `nums` is a non-decreasing array.\n  * `-109 <= target <= 109`\n\n,"class Solution:\n    def searchRange(self nums: List[int] target: int) -> List[int]:\n        # if target is not in nums list we simply return [-1-1]\n		if target not in nums:\n            return [-1-1]\n        \n		# create an empty list\n        result = []\n		# iterate nums for the first time if we found nums[i] matches with target\n		# append the index i to result break the for loop\n		# because we only care the first and last index of target in nums\n        for i in range(len(nums)):\n            if nums[i] == target:\n                result.append(i)\n                break\n        \n		# loop through nums backward if we found nums[j] matches target\n		# append j to result and break the for loop\n        for j in range(len(nums)-1 -1 -1):\n            if nums[j] == target:\n                result.append(j)\n                break\n        \n        return result\n		\n		\n"
Find First Palindromic String in the Array,"###  2108\. Find First Palindromic String in the Array\n\nGiven an array of strings `words` return _the first**palindromic** string in\nthe array_. If there is no such string return _an**empty string** _`""""`.\n\nA string is **palindromic** if it reads the same forward and backward.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""abc""""car""""ada""""racecar""""cool""]\n    **Output:** ""ada""\n    **Explanation:** The first string that is palindromic is ""ada"".\n    Note that ""racecar"" is also palindromic but it is not the first.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""notapalindrome""""racecar""]\n    **Output:** ""racecar""\n    **Explanation:** The first and only string that is palindromic is ""racecar"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""def""""ghi""]\n    **Output:** """"\n    **Explanation:** There are no palindromic strings so the empty string is returned.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 100`\n  * `1 <= words[i].length <= 100`\n  * `words[i]` consists only of lowercase English letters.\n\n","class Solution:\n    def firstPalindrome(self words):\n        for word in words:\n            if word == word[::-1]: return word\n        return """"\n"
Find Good Days to Rob the Bank,###  2100\. Find Good Days to Rob the Bank\n\nYou and a gang of thieves are planning on robbing a bank. You are given a\n**0-indexed** integer array `security` where `security[i]` is the number of\nguards on duty on the `ith` day. The days are numbered starting from `0`. You\nare also given an integer `time`.\n\nThe `ith` day is a good day to rob the bank if:\n\n  * There are at least `time` days before and after the `ith` day\n  * The number of guards at the bank for the `time` days **before** `i` are **non-increasing**  and\n  * The number of guards at the bank for the `time` days **after** `i` are **non-decreasing**.\n\nMore formally this means day `i` is a good day to rob the bank if and only if\n`security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <=\nsecurity[i + time - 1] <= security[i + time]`.\n\nReturn _a list of**all** days **(0-indexed)** that are good days to rob the\nbank_._The order that the days are returned in does******not** matter._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** security = [5333562] time = 2\n    **Output:** [23]\n    **Explanation:**\n    On day 2 we have security[0] >= security[1] >= security[2] <= security[3] <= security[4].\n    On day 3 we have security[1] >= security[2] >= security[3] <= security[4] <= security[5].\n    No other days satisfy this condition so days 2 and 3 are the only good days to rob the bank.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** security = [11111] time = 0\n    **Output:** [01234]\n    **Explanation:**\n    Since time equals 0 every day is a good day to rob the bank so return every day.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** security = [123456] time = 2\n    **Output:** []\n    **Explanation:**\n    No day has 2 days before it that have a non-increasing number of guards.\n    Thus no day is a good day to rob the bank so return an empty list.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= security.length <= 105`\n  * `0 <= security[i] time <= 105`\n\n,class Solution:\n    def goodDaysToRobBank(self security: List[int] time: int) -> List[int]:\n        decreasing = [0] * len(security)\n        increasing = [0] * len(security)\n        for i in range(len(security)):\n            if i > 0 and security[i - 1] >= security[i]:\n                decreasing[i] = decreasing[i - 1] + 1\n        for i in reversed(range(len(security))):\n            if i < len(security) - 1 and security[i] <= security[i + 1]:\n                increasing[i] = increasing[i + 1] + 1\n        return [i for i in range(len(security)) if increasing[i] >= time and decreasing[i] >= time]
Find Greatest Common Divisor of Array,###  1979\. Find Greatest Common Divisor of Array\n\nGiven an integer array `nums` return****_the**greatest common divisor** of\nthe smallest number and largest number in _`nums`.\n\nThe **greatest common divisor** of two numbers is the largest positive integer\nthat evenly divides both numbers.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [256910]\n    **Output:** 2\n    **Explanation:**\n    The smallest number in nums is 2.\n    The largest number in nums is 10.\n    The greatest common divisor of 2 and 10 is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [75683]\n    **Output:** 1\n    **Explanation:**\n    The smallest number in nums is 3.\n    The largest number in nums is 8.\n    The greatest common divisor of 3 and 8 is 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [33]\n    **Output:** 3\n    **Explanation:**\n    The smallest number in nums is 3.\n    The largest number in nums is 3.\n    The greatest common divisor of 3 and 3 is 3.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 1000`\n\n,# Runtime: 282 ms (Top 5.10%) | Memory: 13.9 MB (Top 81.34%)\nclass Solution:\n    def findGCD(self nums: List[int]) -> int:\n        i_min = min(nums)\n        i_max = max(nums)\n        greater = i_max\n        while True:\n            if greater % i_min == 0 and greater % i_max == 0:\n                lcm = greater\n                break\n            greater += 1\n        return int(i_min/(lcm/i_max))
Find if Path Exists in Graph,###  1971\. Find if Path Exists in Graph\n\nThere is a **bi-directional** graph with `n` vertices where each vertex is\nlabeled from `0` to `n - 1` (**inclusive**). The edges in the graph are\nrepresented as a 2D integer array `edges` where each `edges[i] = [ui vi]`\ndenotes a bi-directional edge between vertex `ui` and vertex `vi`. Every\nvertex pair is connected by **at most one** edge and no vertex has an edge to\nitself.\n\nYou want to determine if there is a **valid path** that exists from vertex\n`source` to vertex `destination`.\n\nGiven `edges` and the integers `n` `source` and `destination` return `true`\n_if there is a**valid path** from _`source` _to_`destination` _ or_`false`\n_otherwise_ _._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png)\n\n    \n    \n    **Input:** n = 3 edges = [[01][12][20]] source = 0 destination = 2\n    **Output:** true\n    **Explanation:** There are two paths from vertex 0 to vertex 2:\n    - 0 → 1 → 2\n    - 0 → 2\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png)\n\n    \n    \n    **Input:** n = 6 edges = [[01][02][35][54][43]] source = 0 destination = 5\n    **Output:** false\n    **Explanation:** There is no path from vertex 0 to vertex 5.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 2 * 105`\n  * `0 <= edges.length <= 2 * 105`\n  * `edges[i].length == 2`\n  * `0 <= ui vi <= n - 1`\n  * `ui != vi`\n  * `0 <= source destination <= n - 1`\n  * There are no duplicate edges.\n  * There are no self edges.\n\n,"# Runtime: 1647 ms (Top 68.5%) | Memory: 108.91 MB (Top 50.2%)\n\nclass Solution(object):\n    def validPath(self n edges start end):\n        """"""\n        :type n: int\n        :type edges: List[List[int]]\n        :type start: int\n        :type end: int\n        :rtype: bool\n        """"""\n        visited = [False]*n\n        d = {}\n		#store the undirected edges for both vertices\n        for i in edges:\n            if i[0] in d:\n                d[i[0]].append(i[1])\n            else:\n                d[i[0]] = [i[1]]\n                \n            if i[1] in d:\n                d[i[1]].append(i[0])\n            else:\n                d[i[1]] = [i[0]]\n        #create a queue as we will apply BFS\n        q = [start]\n        while q:\n            curr = q.pop(0)  #pop the first element as we do in queue\n            if curr == end:  #if its the end then we can return True\n                return True\n            elif curr in d and not visited[curr]: #else if it is not the end then check whether its visited or not\n                q.extend(d[curr])  #add the adjacent vertices of the current node to the queue\n            visited[curr] = True  #mark this curr vertex as visited = True so that we dont visit this vertex again\n        return False  #return False if the queue gets empty and we dont reach the end"
Find in Mountain Array,###  1095\. Find in Mountain Array\n\n_(This problem is an**interactive problem**.)_\n\nYou may recall that an array `arr` is a **mountain array** if and only if:\n\n  * `arr.length >= 3`\n  * There exists some `i` with `0 < i < arr.length - 1` such that: \n    * `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    * `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven a mountain array `mountainArr` return the **minimum** `index` such that\n`mountainArr.get(index) == target`. If such an `index` does not exist return\n`-1`.\n\n**You cannot access the mountain array directly.** You may only access the\narray using a `MountainArray` interface:\n\n  * `MountainArray.get(k)` returns the element of the array at index `k` (0-indexed).\n  * `MountainArray.length()` returns the length of the array.\n\nSubmissions making more than `100` calls to `MountainArray.get` will be judged\n_Wrong Answer_. Also any solutions that attempt to circumvent the judge will\nresult in disqualification.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** array = [1234531] target = 3\n    **Output:** 2\n    **Explanation:** 3 exists in the array at index=2 and index=5. Return the minimum index which is 2.\n\n**Example 2:**\n\n    \n    \n    **Input:** array = [012421] target = 3\n    **Output:** -1\n    **Explanation:** 3 does not exist in the array so we return -1.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= mountain_arr.length() <= 104`\n  * `0 <= target <= 109`\n  * `0 <= mountain_arr.get(index) <= 109`\n\n,"# """"""\n# This is MountainArray's API interface.\n# You should not implement it or speculate about its implementation\n# """"""\n#class MountainArray:\n#    def get(self index: int) -> int:\n#    def length(self) -> int:\n\nclass Solution:\n    def findInMountainArray(self target: int mountain_arr: 'MountainArray') -> int:\n        min_index = -1\n        peak = self.findpeak(mountain_arr)\n        \n        min_index = self.binary_search(0 peak mountain_arr target 1)\n        if min_index == -1:\n            min_index = self.binary_search(peak+1 mountain_arr.length() - 1 mountain_arr target -1)\n        return min_index\n\n    def findpeak(self mountain_arr):\n        start = 0\n        end = mountain_arr.length() - 1\n        while start < end:\n            mid = start + int((end - start)/2)\n            if mountain_arr.get(mid) < mountain_arr.get(mid + 1):\n                start = mid + 1\n            else:\n                end = mid\n        \n        return start\n    \n    def binary_search(self start end mountain_arr target asc):\n        while start <= end:\n            mid = start + int((end - start)/2)\n            mountain_arr_get_mid = mountain_arr.get(mid)\n            if target == mountain_arr_get_mid:\n                return mid\n            if asc == 1:\n                if target < mountain_arr_get_mid:\n                    end = mid - 1\n                elif target > mountain_arr_get_mid:\n                    start = mid + 1\n            else:\n                if target < mountain_arr_get_mid:\n                    start = mid + 1\n                elif target > mountain_arr_get_mid:\n                    end = mid - 1\n            \n        return -1\n\n\n\n\n\n\n"
Find K Closest Elements,###  658\. Find K Closest Elements\n\nGiven a **sorted** integer array `arr` two integers `k` and `x` return the\n`k` closest integers to `x` in the array. The result should also be sorted in\nascending order.\n\nAn integer `a` is closer to `x` than an integer `b` if:\n\n  * `|a - x| < |b - x|` or\n  * `|a - x| == |b - x|` and `a < b`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [12345] k = 4 x = 3\n    **Output:** [1234]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [12345] k = 4 x = -1\n    **Output:** [1234]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= arr.length`\n  * `1 <= arr.length <= 104`\n  * `arr` is sorted in **ascending** order.\n  * `-104 <= arr[i] x <= 104`\n\n,class Solution:\n    def findClosestElements(self arr: List[int] k: int x: int) -> List[int]:\n        \n        def sorted_distance(value static_input = x):\n            return abs(value - static_input)\n        \n        distances = []\n        result = []\n        heapq.heapify(distances)\n        \n        for lv in enumerate(arr):\n            distances.append((l sorted_distance(value = v)))\n        \n        for i in heapq.nsmallest(k distances key = lambda x: x[1]):\n            result.append(arr[i[0]])\n        \n        result.sort()\n        return result\n            \n            \n
Find K Pairs with Smallest Sums,###  373\. Find K Pairs with Smallest Sums\n\nYou are given two integer arrays `nums1` and `nums2` sorted in **ascending\norder** and an integer `k`.\n\nDefine a pair `(u v)` which consists of one element from the first array and\none element from the second array.\n\nReturn _the_ `k` _pairs_ `(u1 v1) (u2 v2) ... (uk vk)` _with the\nsmallest sums_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [1711] nums2 = [246] k = 3\n    **Output:** [[12][14][16]]\n    **Explanation:** The first 3 pairs are returned from the sequence: [12][14][16][72][74][112][76][114][116]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [112] nums2 = [123] k = 2\n    **Output:** [[11][11]]\n    **Explanation:** The first 2 pairs are returned from the sequence: [11][11][12][21][12][22][13][13][23]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [12] nums2 = [3] k = 3\n    **Output:** [[13][23]]\n    **Explanation:** All possible pairs are returned from the sequence: [13][23]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 105`\n  * `-109 <= nums1[i] nums2[i] <= 109`\n  * `nums1` and `nums2` both are sorted in **ascending order**.\n  * `1 <= k <= 104`\n\n,# Runtime: 1647 ms (Top 67.28%) | Memory: 34.4 MB (Top 27.52%)\nimport heapq\nclass Solution:\n    def kSmallestPairs(self nums1: List[int] nums2: List[int] k: int) -> List[List[int]]:\n\n        ans = []\n\n        heapq.heapify(ans)\n\n        for i in range(min(klen(nums1))):\n            for j in range(min(klen(nums2))):\n                pairs = [nums1[i]nums2[j]]\n                if len(ans)<k:\n                    heapq.heappush(ans[-(nums1[i]+nums2[j])pairs])\n                else:\n                    if nums1[i]+nums2[j]>-ans[0][0]:\n                        break\n                    heapq.heappush(ans[-(nums1[i]+nums2[j])pairs])\n                    heapq.heappop(ans)\n\n        res = []\n        for i in range(len(ans)):\n            res.append(ans[i][1])\n\n        return res
Find K-th Smallest Pair Distance,###  719\. Find K-th Smallest Pair Distance\n\nThe **distance of a pair** of integers `a` and `b` is defined as the absolute\ndifference between `a` and `b`.\n\nGiven an integer array `nums` and an integer `k` return _the_ `kth`\n_smallest**distance among all the pairs**_ `nums[i]` _and_ `nums[j]` _where_\n`0 <= i < j < nums.length`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [131] k = 1\n    **Output:** 0\n    **Explanation:** Here are all the pairs:\n    (13) -> 2\n    (11) -> 0\n    (31) -> 2\n    Then the 1st smallest distance pair is (11) and its distance is 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [111] k = 2\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [161] k = 3\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `2 <= n <= 104`\n  * `0 <= nums[i] <= 106`\n  * `1 <= k <= n * (n - 1) / 2`\n\n,from heapq import heappush heappop heapify\nclass Solution:\n    def smallestDistancePair(self nums: List[int] k: int) -> int:\n        # pairs = list(combinations(nums 2))\n        \n        maxHeap = []\n        heapify(maxHeap)\n        \n        for idx val1 in enumerate(nums):\n            for val2 in nums[idx + 1:]:\n                pair = [val1 val2]\n                heappush(maxHeap [-1*abs(pair[0] - pair[1]) pair])\n                if len(maxHeap) > k:\n                    heappop(maxHeap)\n        \n        return -1*maxHeap[0][0]\n
Find Kth Bit in Nth Binary String,"###  1545\. Find Kth Bit in Nth Binary String\n\nGiven two positive integers `n` and `k` the binary string `Sn` is formed as\nfollows:\n\n  * `S1 = ""0""`\n  * `Si = Si - 1 + ""1"" + reverse(invert(Si - 1))` for `i > 1`\n\nWhere `+` denotes the concatenation operation `reverse(x)` returns the\nreversed string `x` and `invert(x)` inverts all the bits in `x` (`0` changes\nto `1` and `1` changes to `0`).\n\nFor example the first four strings in the above sequence are:\n\n  * `S1 = ""0""`\n  * `S2 = ""0**1** 1""`\n  * `S3 = ""011**1** 001""`\n  * `S4 = ""0111001**1** 0110001""`\n\nReturn _the_ `kth` _bit_ _in_ `Sn`. It is guaranteed that `k` is valid for the\ngiven `n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 k = 1\n    **Output:** ""0""\n    **Explanation:** S3 is ""**_0_** 111001"".\n    The 1st bit is ""0"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4 k = 11\n    **Output:** ""1""\n    **Explanation:** S4 is ""0111001101** _1_** 0001"".\n    The 11th bit is ""1"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 20`\n  * `1 <= k <= 2n - 1`\n\n",class Solution:\n    def findKthBit(self n: int k: int) -> str:\n        i s hash_map = 1 '0' {'1': '0' '0': '1'}\n        for i in range(1 n):\n            s = s + '1' + ''.join((hash_map[i] for i in s))[::-1]\n        return s[k-1]
Find Kth Largest XOR Coordinate Value,###  1738\. Find Kth Largest XOR Coordinate Value\n\nYou are given a 2D `matrix` of size `m x n` consisting of non-negative\nintegers. You are also given an integer `k`.\n\nThe **value** of coordinate `(a b)` of the matrix is the XOR of all\n`matrix[i][j]` where `0 <= i <= a < m` and `0 <= j <= b < n` **(0-indexed)**.\n\nFind the `kth` largest value **(1-indexed)** of all the coordinates of\n`matrix`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** matrix = [[52][16]] k = 1\n    **Output:** 7\n    **Explanation:** The value of coordinate (01) is 5 XOR 2 = 7 which is the largest value.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matrix = [[52][16]] k = 2\n    **Output:** 5\n    **Explanation:** The value of coordinate (00) is 5 = 5 which is the 2nd largest value.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** matrix = [[52][16]] k = 3\n    **Output:** 4\n    **Explanation:** The value of coordinate (10) is 5 XOR 1 = 4 which is the 3rd largest value.\n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m n <= 1000`\n  * `0 <= matrix[i][j] <= 106`\n  * `1 <= k <= m * n`\n\n,class Solution:\n    def kthLargestValue(self matrix: List[List[int]] k: int) -> int:\n        temp=0\n        pq= []\n        n = len(matrix)\n        m = len(matrix[0])\n        \n        prefix= [  [0]*m for i in range(n) ]\n        \n        \n        for i in range(n):\n            for j in range(m):\n                if i==0 or j==0:\n                    if i==0 and j==0:\n                        prefix[i][j] = matrix[i][j]\n                    elif i==0 and j!=0:\n                        prefix[i][j] ^= prefix[i][j-1]^ matrix[i][j]\n                    else:\n                        prefix[i][j]^=prefix[i-1][j]^ matrix[i][j]\n                else:\n                    \n                    prefix[i][j] ^= prefix[i-1][j] ^ prefix[i][j-1]^matrix[i][j]^prefix[i-1][j-1]\n                if len(pq)<k:\n                    heappush(pqprefix[i][j])    \n                else:\n                    heappush(pq prefix[i][j])\n                    heappop(pq)\n                \n\n                  \n        return heappop(pq)\n                    \n
Find Latest Group of Size M,"###  1562\. Find Latest Group of Size M\n\nGiven an array `arr` that represents a permutation of numbers from `1` to `n`.\n\nYou have a binary string of size `n` that initially has all its bits set to\nzero. At each step `i` (assuming both the binary string and `arr` are\n1-indexed) from `1` to `n` the bit at position `arr[i]` is set to `1`.\n\nYou are also given an integer `m`. Find the latest step at which there exists\na group of ones of length `m`. A group of ones is a contiguous substring of\n`1`'s such that it cannot be extended in either direction.\n\nReturn _the latest step at which there exists a group of ones of\nlength**exactly**_ `m`. _If no such group exists return_ `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [35124] m = 1\n    **Output:** 4\n    **Explanation:** \n    Step 1: ""00 _1_ 00"" groups: [""1""]\n    Step 2: ""0010 _1_ "" groups: [""1"" ""1""]\n    Step 3: ""_1_ 0101"" groups: [""1"" ""1"" ""1""]\n    Step 4: ""1 _1_ 101"" groups: [""111"" ""1""]\n    Step 5: ""111 _1_ 1"" groups: [""11111""]\n    The latest step at which there exists a group of size 1 is step 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [31542] m = 2\n    **Output:** -1\n    **Explanation:** \n    Step 1: ""00 _1_ 00"" groups: [""1""]\n    Step 2: ""_1_ 0100"" groups: [""1"" ""1""]\n    Step 3: ""1010 _1_ "" groups: [""1"" ""1"" ""1""]\n    Step 4: ""101 _1_ 1"" groups: [""1"" ""111""]\n    Step 5: ""1 _1_ 111"" groups: [""11111""]\n    No group of size 2 exists during any step.\n    \n\n\n\n**Constraints:**\n\n  * `n == arr.length`\n  * `1 <= m <= n <= 105`\n  * `1 <= arr[i] <= n`\n  * All integers in `arr` are **distinct**.\n\n","class Solution:\n    def findLatestStep(self arr: List[int] m: int) -> int:\n        n = len(arr)\n        ans = -1\n        if n == m: return m #just in case\n        \n#       make in ""inverted"" array with artificial ends higher then everything between\n\n        sor= [0 for _ in range(n+2)]\n        for i in range(n):\n            sor[(arr[i])] = i+1 \n        sor[0] = sor[n+1] = n+1\n        \n#       scan and see if ones in the middle of space of length m appear \n#       before ones on its ends\n#       and find the latest of such spaces to disappear if exists\n\n        for i in range(1 n-m+2): \n            if all(sor[i-1]>sor[j] and sor[i+m]>sor[j] for j in range(ii+m)):\n                if min(sor[i-1]-1sor[i+m]-1)>ans: ans = min(sor[i-1]-1sor[i+m]-1) \n        return ans\n"
Find Longest Awesome Substring,"###  1542\. Find Longest Awesome Substring\n\nYou are given a string `s`. An **awesome** substring is a non-empty substring\nof `s` such that we can make any number of swaps in order to make it a\npalindrome.\n\nReturn _the length of the maximum length**awesome substring** of_ `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""3242415""\n    **Output:** 5\n    **Explanation:** ""24241"" is the longest awesome substring we can form the palindrome ""24142"" with some swaps.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""12345678""\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""213123""\n    **Output:** 6\n    **Explanation:** ""213123"" is the longest awesome substring we can form the palindrome ""231132"" with some swaps.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists only of digits.\n\n","// Runtime: 658 ms (Top 96.88%) | Memory: 18.30 MB (Top 28.13%)\n\nclass Solution:\n    def longestAwesome(self s: str) -> int:\n        # li = [1 2 4 8 16 32 64 128 256 512]\n        li = [2**i for i in range(10)]\n        # checker = {0 1 2 4 8 16 32 64 128 256 512}\n        checker = set(li)\n        checker.add(0)\n        # di: k = prefix xor v = the first idx I got a new prefix_xor_value.\n        di = collections.OrderedDict({0: -1})\n        maxLength = prefix_xor = 0\n        \n        for i in range(len(s)):\n            prefix_xor ^= li[int(s[i])]\n            # Found a new prefix_xor_value\n            if prefix_xor not in di:\n                di[prefix_xor] = i\n            \n            # XOR operation with previous prefix_xor_value\n            for key in di.keys():\n                if i - di[key] <= maxLength:\n                    break\n				# s[di[key] : i] is Awesome Substring\n                if key ^ prefix_xor in checker:\n                    maxLength = i - di[key]\n        return maxLength\n            \n"
Find Lucky Integer in an Array,###  1394\. Find Lucky Integer in an Array\n\nGiven an array of integers `arr` a **lucky integer** is an integer that has a\nfrequency in the array equal to its value.\n\nReturn _the largest**lucky integer** in the array_. If there is no **lucky\ninteger** return `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [2234]\n    **Output:** 2\n    **Explanation:** The only lucky number in the array is 2 because frequency[2] == 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [122333]\n    **Output:** 3\n    **Explanation:** 1 2 and 3 are all lucky numbers return the largest of them.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [22233]\n    **Output:** -1\n    **Explanation:** There are no lucky numbers in the array.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 500`\n  * `1 <= arr[i] <= 500`\n\n,class Solution:\n    def findLucky(self arr: List[int]) -> int:\n        dc = {}\n        \n        for i in range(len(arr)):\n            if arr[i] not in dc:\n                dc[arr[i]] = 1\n            else:\n                dc[arr[i]] = dc[arr[i]] + 1\n        mx = -1\n        for keyvalue in dc.items():\n            if key == value:\n                mx = max(key mx)\n        return mx\n
Find Minimum in Rotated Sorted Array,###  153\. Find Minimum in Rotated Sorted Array\n\nSuppose an array of length `n` sorted in ascending order is **rotated**\nbetween `1` and `n` times. For example the array `nums = [0124567]`\nmight become:\n\n  * `[4567012]` if it was rotated `4` times.\n  * `[0124567]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0] a[1] a[2] ... a[n-1]]` 1 time\nresults in the array `[a[n-1] a[0] a[1] a[2] ... a[n-2]]`.\n\nGiven the sorted rotated array `nums` of **unique** elements return _the\nminimum element of this array_.\n\nYou must write an algorithm that runs in `O(log n) time.`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [34512]\n    **Output:** 1\n    **Explanation:** The original array was [12345] rotated 3 times.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [4567012]\n    **Output:** 0\n    **Explanation:** The original array was [0124567] and it was rotated 4 times.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [11131517]\n    **Output:** 11\n    **Explanation:** The original array was [11131517] and it was rotated 4 times. \n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 5000`\n  * `-5000 <= nums[i] <= 5000`\n  * All the integers of `nums` are **unique**.\n  * `nums` is sorted and rotated between `1` and `n` times.\n\n,"class Solution:\n    def findMin(self nums: List[int]) -> int:\n        if len(nums) == 1 or nums[0] < nums[-1]:\n            return nums[0]\n        \n        l r = 0 len(nums) - 1\n        \n        while l <= r:\n            mid = l + (r - l) // 2\n            \n            if mid > 0 and nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n			# We compare the middle number and the right index number\n			# but why we cannot compare it with the left index number?\n            if nums[mid] > nums[r]:\n                l = mid + 1\n            else:\n                r = mid - 1\n"
Find Minimum in Rotated Sorted Array II,###  154\. Find Minimum in Rotated Sorted Array II\n\nSuppose an array of length `n` sorted in ascending order is **rotated**\nbetween `1` and `n` times. For example the array `nums = [0144567]`\nmight become:\n\n  * `[4567014]` if it was rotated `4` times.\n  * `[0144567]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0] a[1] a[2] ... a[n-1]]` 1 time\nresults in the array `[a[n-1] a[0] a[1] a[2] ... a[n-2]]`.\n\nGiven the sorted rotated array `nums` that may contain **duplicates**  return\n_the minimum element of this array_.\n\nYou must decrease the overall operation steps as much as possible.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [135]\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [22201]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 5000`\n  * `-5000 <= nums[i] <= 5000`\n  * `nums` is sorted and rotated between `1` and `n` times.\n\n\n\n**Follow up:** This problem is similar to [Find Minimum in Rotated Sorted\nArray](https://leetcode.com/problems/find-minimum-in-rotated-sorted-\narray/description/) but `nums` may contain **duplicates**. Would this affect\nthe runtime complexity? How and why?\n\n\n\n,class Solution:\n    def findMin(self nums: List[int]) -> int:\n        return min(nums)\n        \n
Find Minimum Time to Finish All Jobs,###  1723\. Find Minimum Time to Finish All Jobs\n\nYou are given an integer array `jobs` where `jobs[i]` is the amount of time\nit takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned\nto **exactly** one worker. The **working time** of a worker is the sum of the\ntime it takes to complete all jobs assigned to them. Your goal is to devise an\noptimal assignment such that the **maximum working time** of any worker is\n**minimized**.\n\n_Return the**minimum** possible **maximum working time** of any assignment. _\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** jobs = [323] k = 3\n    **Output:** 3\n    **Explanation:** By assigning each person one job the maximum time is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** jobs = [12478] k = 2\n    **Output:** 11\n    **Explanation:** Assign the jobs the following way:\n    Worker 1: 1 2 8 (working time = 1 + 2 + 8 = 11)\n    Worker 2: 4 7 (working time = 4 + 7 = 11)\n    The maximum working time is 11.\n\n\n\n**Constraints:**\n\n  * `1 <= k <= jobs.length <= 12`\n  * `1 <= jobs[i] <= 107`\n\n,// Runtime: 30 ms (Top 99.44%) | Memory: 16.50 MB (Top 63.13%)\n\nclass Solution:\n    def minimumTimeRequired(self jobs: List[int] k: int) -> int:\n        def branchAndBound(i: int):\n            nonlocal r\n            if i == n:\n                r = min(r max(a))\n                return\n            visited = set()\n            for j in range(k):\n                if a[j] in visited:\n                    continue\n                visited.add(a[j])\n                if a[j] + jobs[i] >= r:\n                    continue\n                a[j] += jobs[i]\n                branchAndBound(i+1)\n                a[j] -= jobs[i]\n\n        n = len(jobs)\n        if n <= k:\n            return max(jobs)\n\n        # use greed algorithm to get upper bound\n        jobs.sort(reverse=True)\n        a = list(jobs[:k])\n        for job in jobs[k:]:\n            m0 = min(a)\n            i = a.index(m0)\n            a[i] += job\n        r = max(a)\n\n        a = [0] * k\n        branchAndBound(0)\n        return r\n
Find Missing Observations,###  2028\. Find Missing Observations\n\nYou have observations of `n + m` **6-sided** dice rolls with each face\nnumbered from `1` to `6`. `n` of the observations went missing and you only\nhave the observations of `m` rolls. Fortunately you have also calculated the\n**average value** of the `n + m` rolls.\n\nYou are given an integer array `rolls` of length `m` where `rolls[i]` is the\nvalue of the `ith` observation. You are also given the two integers `mean` and\n`n`.\n\nReturn _an array of length_`n` _containing the missing observations such that\nthe**average value** of the _`n + m` _rolls is**exactly** _`mean`. If there\nare multiple valid answers return _any of them_. If no such array exists\nreturn _an empty array_.\n\nThe **average value** of a set of `k` numbers is the sum of the numbers\ndivided by `k`.\n\nNote that `mean` is an integer so the sum of the `n + m` rolls should be\ndivisible by `n + m`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rolls = [3243] mean = 4 n = 2\n    **Output:** [66]\n    **Explanation:** The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rolls = [156] mean = 3 n = 4\n    **Output:** [2322]\n    **Explanation:** The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** rolls = [1234] mean = 6 n = 4\n    **Output:** []\n    **Explanation:** It is impossible for the mean to be 6 no matter what the 4 missing rolls are.\n    \n\n\n\n**Constraints:**\n\n  * `m == rolls.length`\n  * `1 <= n m <= 105`\n  * `1 <= rolls[i] mean <= 6`\n\n,class Solution:\n    def missingRolls(self rolls: List[int] mean: int n: int) -> List[int]:\n        missing_val rem = divmod(mean * (len(rolls) + n) - sum(rolls) n)\n        if rem == 0:\n            if 1 <= missing_val <= 6:\n                return [missing_val] * n\n        elif 1 <= missing_val < 6:\n            return [missing_val + 1] * rem + [missing_val] * (n - rem)\n        return []
Find Mode in Binary Search Tree,###  501\. Find Mode in Binary Search Tree\n\nGiven the `root` of a binary search tree (BST) with duplicates return _all\nthe[mode(s)](https://en.wikipedia.org/wiki/Mode_\(statistics\)) (i.e. the\nmost frequently occurred element) in it_.\n\nIf the tree has more than one mode return them in **any order**.\n\nAssume a BST is defined as follows:\n\n  * The left subtree of a node contains only nodes with keys **less than or equal to** the node's key.\n  * The right subtree of a node contains only nodes with keys **greater than or equal to** the node's key.\n  * Both the left and right subtrees must also be binary search trees.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg)\n\n    \n    \n    **Input:** root = [1null22]\n    **Output:** [2]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [0]\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `-105 <= Node.val <= 105`\n\n\n\n**Follow up:** Could you do that without using any extra space? (Assume that\nthe implicit stack space incurred due to recursion does not count).\n\n,"// Runtime: 31 ms (Top 99.88%) | Memory: 19.20 MB (Top 96.36%)\n\nclass Solution:\n    def findMode(self root):\n        curr_node = root\n        result = []\n        curr_streak = 0\n        curr_num = float(""inf"")\n        max_streak = 0\n\n        while curr_node:\n            if curr_node.left:\n                neighbor = curr_node.left\n                while neighbor.right is not None:\n                    neighbor = neighbor.right\n                neighbor.right = curr_node\n                \n                tmp = curr_node.left\n                curr_node.left = None\n                curr_node = tmp\n            else: \n                # since we deleted the left pointer when we were done processing in the previous if-block \n                # we know that we only reach this else case \n                # if we've already processed this node. \n                # Therefore do the value processing here \n                # and move to the right neighbor afterward\n                if curr_node.val == curr_num:\n                    curr_streak += 1\n                else:\n                    curr_streak = 0\n                    curr_num = curr_node.val\n                \n                if curr_streak == max_streak:\n                    result.append(curr_num)\n                elif curr_streak > max_streak:\n                    max_streak = curr_streak\n                    result = [curr_num]\n        \n                curr_node = curr_node.right\n        \n        return result\n"
Find N Unique Integers Sum up to Zero,###  1304\. Find N Unique Integers Sum up to Zero\n\nGiven an integer `n` return **any** array containing `n` **unique** integers\nsuch that they add up to `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** [-7-1134]\n    **Explanation:** These arrays also are accepted [-5-1123]  [-3-12-24].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** [-101]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n\n,class Solution:\n    def sumZero(self n: int) -> List[int]:\n        qp=divmod(n2)\n        if p:\n            return list(range(-q q+1))\n        else:\n            return list(range(-q0))+list(range(1q+1))
Find Nearest Point That Has the Same X or Y Coordinate,###  1779\. Find Nearest Point That Has the Same X or Y Coordinate\n\nYou are given two integers `x` and `y` which represent your current location\non a Cartesian grid: `(x y)`. You are also given an array `points` where each\n`points[i] = [ai bi]` represents that a point exists at `(ai bi)`. A point\nis **valid** if it shares the same x-coordinate or the same y-coordinate as\nyour location.\n\nReturn _the index**(0-indexed)** of the **valid** point with the smallest\n**Manhattan distance** from your current location_. If there are multiple\nreturn _the valid point with the**smallest** index_. If there are no valid\npoints return `-1`.\n\nThe **Manhattan distance** between two points `(x1 y1)` and `(x2 y2)` is\n`abs(x1 - x2) + abs(y1 - y2)`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** x = 3 y = 4 points = [[12][31][24][23][44]]\n    **Output:** 2\n    **Explanation:** Of all the points only [31] [24] and [44] are valid. Of the valid points [24] and [44] have the smallest Manhattan distance from your current location with a distance of 1. [24] has the smallest index so return 2.\n\n**Example 2:**\n\n    \n    \n    **Input:** x = 3 y = 4 points = [[34]]\n    **Output:** 0\n    **Explanation:** The answer is allowed to be on the same location as your current location.\n\n**Example 3:**\n\n    \n    \n    **Input:** x = 3 y = 4 points = [[23]]\n    **Output:** -1\n    **Explanation:** There are no valid points.\n\n\n\n**Constraints:**\n\n  * `1 <= points.length <= 104`\n  * `points[i].length == 2`\n  * `1 <= x y ai bi <= 104`\n\n,# Runtime: 689 ms (Top 99.93%) | Memory: 19.5 MB (Top 5.79%)\nclass Solution:\n    def nearestValidPoint(self x: int y: int points: List[List[int]]) -> int:\n        minDist = math.inf\n        ans = -1\n        for i in range(len(points)):\n            if points[i][0]==x or points[i][1]==y:\n                manDist = abs(points[i][0]-x)+abs(points[i][1]-y)\n                if manDist<minDist:\n                    ans = i\n                    minDist = manDist\n        return ans\n
Find Numbers with Even Number of Digits,###  1295\. Find Numbers with Even Number of Digits\n\nGiven an array `nums` of integers return how many of them contain an **even\nnumber** of digits.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12345267896]\n    **Output:** 2\n    **Explanation:** 12 contains 2 digits (even number of digits). \n    345 contains 3 digits (odd number of digits). \n    2 contains 1 digit (odd number of digits). \n    6 contains 1 digit (odd number of digits). \n    7896 contains 4 digits (even number of digits). \n    Therefore only 12 and 7896 contain an even number of digits.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [5559014821771]\n    **Output:** 1 \n    **Explanation:**\n    Only 1771 contains an even number of digits.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 500`\n  * `1 <= nums[i] <= 105`\n\n,class Solution:\n    def findNumbers(self nums: List[int]) -> int:\n        even_count = 0\n        for elem in nums:\n            if(len(str(elem))%2 == 0):\n                even_count += 1\n        return even_count\n        \n
Find Original Array From Doubled Array,###  2007\. Find Original Array From Doubled Array\n\nAn integer array `original` is transformed into a **doubled** array `changed`\nby appending **twice the value** of every element in `original` and then\nrandomly **shuffling** the resulting array.\n\nGiven an array `changed` return `original` _if_`changed` _is a**doubled**\narray. If _`changed` _is not a**doubled** array return an empty array. The\nelements in_ `original` _may be returned in**any** order_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** changed = [134268]\n    **Output:** [134]\n    **Explanation:** One possible original array could be [134]:\n    - Twice the value of 1 is 1 * 2 = 2.\n    - Twice the value of 3 is 3 * 2 = 6.\n    - Twice the value of 4 is 4 * 2 = 8.\n    Other original arrays could be [431] or [314].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** changed = [6301]\n    **Output:** []\n    **Explanation:** changed is not a doubled array.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** changed = [1]\n    **Output:** []\n    **Explanation:** changed is not a doubled array.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= changed.length <= 105`\n  * `0 <= changed[i] <= 105`\n\n,class Solution:\n    def findOriginalArray(self changed: List[int]) -> List[int]:\n        counter = collections.Counter(changed)\n        res = []\n        for k in counter.keys():\n            \n            if k == 0:\n                # handle zero as special case\n                if counter[k] % 2 > 0:\n                    return []\n                res += [0] * (counter[k] // 2)\n                \n            elif counter[k] > 0:\n                x = k\n                \n                # walk down the chain\n                while x % 2 == 0 and x // 2 in counter:\n                    x = x // 2\n                    \n                # walk up and process all numbers within the chain. mark the counts as 0\n                while x in counter:\n                    if counter[x] > 0:\n                        res += [x] * counter[x]\n                        if counter[x+x] < counter[x]:\n                            return []\n                        counter[x+x] -= counter[x]\n                        counter[x] = 0\n                    x += x\n        return res\n
Find Palindrome With Fixed Length,###  2217\. Find Palindrome With Fixed Length\n\nGiven an integer array `queries` and a **positive** integer `intLength`\nreturn _an array_ `answer` _where_ `answer[i]` _is either the_`queries[i]th`\n_smallest**positive palindrome** of length_ `intLength` _or_ `-1` _if no such\npalindrome exists_.\n\nA **palindrome** is a number that reads the same backwards and forwards.\nPalindromes cannot have leading zeros.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** queries = [1234590] intLength = 3\n    **Output:** [101111121131141999]\n    **Explanation:**\n    The first few palindromes of length 3 are:\n    101 111 121 131 141 151 161 171 181 191 202 ...\n    The 90th palindrome of length 3 is 999.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** queries = [246] intLength = 4\n    **Output:** [111113311551]\n    **Explanation:**\n    The first six palindromes of length 4 are:\n    1001 1111 1221 1331 1441 and 1551.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= queries.length <= 5 * 104`\n  * `1 <= queries[i] <= 109`\n  * `1 <= intLength <= 15`\n\n,class Solution:\n    def kthPalindrome(self queries: List[int] intLength: int) -> List[int]:\n        ogLength = intLength\n        isOdd = intLength & 1\n        if isOdd:\n            intLength += 1\n        k = intLength // 2\n        k = 10 ** (k - 1)\n        op = []\n        for q in queries:\n            pal = str(k + q - 1)\n            if isOdd:\n                pal += pal[::-1][1:]\n            else:\n                pal += pal[::-1]\n            if len(pal) == ogLength:\n                op.append(int(pal))\n            else:\n                op.append(-1)\n        return op\n
Find Peak Element,###  162\. Find Peak Element\n\nA peak element is an element that is strictly greater than its neighbors.\n\nGiven a **0-indexed** integer array `nums` find a peak element and return\nits index. If the array contains multiple peaks return the index to **any of\nthe peaks**.\n\nYou may imagine that `nums[-1] = nums[n] = -∞`. In other words an element\nis always considered to be strictly greater than a neighbor that is outside\nthe array.\n\nYou must write an algorithm that runs in `O(log n)` time.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1231]\n    **Output:** 2\n    **Explanation:** 3 is a peak element and your function should return the index number 2.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1213564]\n    **Output:** 5\n    **Explanation:** Your function can return either index number 1 where the peak element is 2 or index number 5 where the peak element is 6.\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `-231 <= nums[i] <= 231 - 1`\n  * `nums[i] != nums[i + 1]` for all valid `i`.\n\n,"class Solution(object):\n    def findPeakElement(self nums):\n        """"""\n        :type nums: List[int]\n        :rtype: int\n        """"""\n        nums = [-2**32]+nums+[-2**32]\n        lr = 0len(nums)-1\n        while l <=r:\n            m = (l+r)//2\n			# we find the target:\n            if nums[m] > nums[m-1] and nums[m] > nums[m+1]:\n                return m -1\n            else:\n                if nums[m] <nums[m+1]:\n                    l = m + 1\n                else:\n                    r = m - 1\n        return -1"
Find Pivot Index,###  724\. Find Pivot Index\n\nGiven an array of integers `nums` calculate the **pivot index** of this\narray.\n\nThe **pivot index** is the index where the sum of all the numbers **strictly**\nto the left of the index is equal to the sum of all the numbers **strictly**\nto the index's right.\n\nIf the index is on the left edge of the array then the left sum is `0`\nbecause there are no elements to the left. This also applies to the right edge\nof the array.\n\nReturn _the**leftmost pivot index**_. If no such index exists return -1.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [173656]\n    **Output:** 3\n    **Explanation:**\n    The pivot index is 3.\n    Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\n    Right sum = nums[4] + nums[5] = 5 + 6 = 11\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** -1\n    **Explanation:**\n    There is no index that satisfies the conditions in the problem statement.\n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [21-1]\n    **Output:** 0\n    **Explanation:**\n    The pivot index is 0.\n    Left sum = 0 (no elements to the left of index 0)\n    Right sum = nums[1] + nums[2] = 1 + -1 = 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-1000 <= nums[i] <= 1000`\n\n\n\n**Note:** This question is the same as 1991:\n<https://leetcode.com/problems/find-the-middle-index-in-array/>\n\n,# Runtime: 342 ms (Top 15.25%) | Memory: 15.2 MB (Top 92.14%)\nclass Solution:\n    def pivotIndex(self nums: List[int]) -> int:\n        right = sum(nums)\n        left = 0\n\n        for i in range(len(nums)):\n            right -= nums[i]\n            left += nums[i - 1] if i > 0 else 0\n\n            if right == left: return i\n\n        return -1
Find Players With Zero or One Losses,###  2225\. Find Players With Zero or One Losses\n\nYou are given an integer array `matches` where `matches[i] = [winneri\nloseri]` indicates that the player `winneri` defeated player `loseri` in a\nmatch.\n\nReturn _a list_`answer` _of size_`2` _where:_\n\n  * `answer[0]` is a list of all players that have **not** lost any matches.\n  * `answer[1]` is a list of all players that have lost exactly **one** match.\n\nThe values in the two lists should be returned in **increasing** order.\n\n**Note:**\n\n  * You should only consider the players that have played **at least one** match.\n  * The testcases will be generated such that **no** two matches will have the **same** outcome.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** matches = [[13][23][36][56][57][45][48][49][104][109]]\n    **Output:** [[1210][4578]]\n    **Explanation:**\n    Players 1 2 and 10 have not lost any matches.\n    Players 4 5 7 and 8 each have lost one match.\n    Players 3 6 and 9 each have lost two matches.\n    Thus answer[0] = [1210] and answer[1] = [4578].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matches = [[23][13][54][64]]\n    **Output:** [[1256][]]\n    **Explanation:**\n    Players 1 2 5 and 6 have not lost any matches.\n    Players 3 and 4 each have lost two matches.\n    Thus answer[0] = [1256] and answer[1] = [].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= matches.length <= 105`\n  * `matches[i].length == 2`\n  * `1 <= winneri loseri <= 105`\n  * `winneri != loseri`\n  * All `matches[i]` are **unique**.\n\n,# Runtime: 5248 ms (Top 5.11%) | Memory: 68.3 MB (Top 89.11%)\nclass Solution:\n    def findWinners(self matches: List[List[int]]) -> List[List[int]]:\n        winners losers table = [] [] {}\n        for winner loser in matches:\n            # map[key] = map.get(key 0) + change . This format ensures that KEY NOT FOUND error is always prevented.\n            # map.get(key 0) returns map[key] if key exists and 0 if it does not.\n            table[winner] = table.get(winner 0) # Winner\n            table[loser] = table.get(loser 0) + 1\n        for k v in table.items(): # Player k with losses v\n            if v == 0:\n                winners.append(k) # If player k has no loss ie v == 0\n            if v == 1:\n                losers.append(k) # If player k has one loss ie v == 1\n        return [sorted(winners) sorted(losers)] # Problem asked to return sorted arrays.
Find Right Interval,###  436\. Find Right Interval\n\nYou are given an array of `intervals` where `intervals[i] = [starti endi]`\nand each `starti` is **unique**.\n\nThe **right interval** for an interval `i` is an interval `j` such that\n`startj >= endi` and `startj` is **minimized**. Note that `i` may equal `j`.\n\nReturn _an array of**right interval** indices for each interval `i`_. If no\n**right interval** exists for interval `i` then put `-1` at index `i`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** intervals = [[12]]\n    **Output:** [-1]\n    **Explanation:** There is only one interval in the collection so it outputs -1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** intervals = [[34][23][12]]\n    **Output:** [-101]\n    **Explanation:** There is no right interval for [34].\n    The right interval for [23] is [34] since start0 = 3 is the smallest start that is >= end1 = 3.\n    The right interval for [12] is [23] since start1 = 2 is the smallest start that is >= end2 = 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** intervals = [[14][23][34]]\n    **Output:** [-12-1]\n    **Explanation:** There is no right interval for [14] and [34].\n    The right interval for [23] is [34] since start2 = 3 is the smallest start that is >= end1 = 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= intervals.length <= 2 * 104`\n  * `intervals[i].length == 2`\n  * `-106 <= starti <= endi <= 106`\n  * The start point of each interval is **unique**.\n\n,// Runtime: 229 ms (Top 99.26%) | Memory: 22.50 MB (Top 16.77%)\n\nclass Solution:\n    def findRightInterval(self intervals):\n        ints = sorted([[jki] for i[jk] in enumerate(intervals)])\n        begs = [i for i__ in ints]\n        out = [-1]*len(begs)\n        for ijk in ints:\n            t = bisect.bisect_left(begs j)\n            if t < len(begs):\n                out[k] = ints[t][2]\n        \n        return out\n
Find Servers That Handled Most Number of Requests,###  1606\. Find Servers That Handled Most Number of Requests\n\nYou have `k` servers numbered from `0` to `k-1` that are being used to handle\nmultiple requests simultaneously. Each server has infinite computational\ncapacity but **cannot handle more than one request at a time**. The requests\nare assigned to servers according to a specific algorithm:\n\n  * The `ith` (0-indexed) request arrives.\n  * If all servers are busy the request is dropped (not handled at all).\n  * If the `(i % k)th` server is available assign the request to that server.\n  * Otherwise assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example if the `ith` server is busy try to assign the request to the `(i+1)th` server then the `(i+2)th` server and so on.\n\nYou are given a **strictly increasing** array `arrival` of positive integers\nwhere `arrival[i]` represents the arrival time of the `ith` request and\nanother array `load` where `load[i]` represents the load of the `ith` request\n(the time it takes to complete). Your goal is to find the **busiest\nserver(s)**. A server is considered **busiest** if it handled the most number\nof requests successfully among all the servers.\n\nReturn _a list containing the IDs (0-indexed) of the**busiest server(s)**_.\nYou may return the IDs in any order.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/08/load-1.png)\n\n    \n    \n    **Input:** k = 3 arrival = [12345] load = [52333] \n    **Output:** [1] \n    **Explanation:** \n    All of the servers start out available.\n    The first 3 requests are handled by the first 3 servers in order.\n    Request 3 comes in. Server 0 is busy so it's assigned to the next available server which is 1.\n    Request 4 comes in. It cannot be handled since all servers are busy so it is dropped.\n    Servers 0 and 2 handled one request each while server 1 handled two requests. Hence server 1 is the busiest server.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** k = 3 arrival = [1234] load = [1212]\n    **Output:** [0]\n    **Explanation:** \n    The first 3 requests are handled by first 3 servers.\n    Request 3 comes in. It is handled by server 0 since the server is available.\n    Server 0 handled two requests while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** k = 3 arrival = [123] load = [101211]\n    **Output:** [012]\n    **Explanation:** Each server handles a single request so they are all considered the busiest.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= 105`\n  * `1 <= arrival.length load.length <= 105`\n  * `arrival.length == load.length`\n  * `1 <= arrival[i] load[i] <= 109`\n  * `arrival` is **strictly increasing**.\n\n,class Solution:\n    def busiestServers(self k: int A: List[int] B: List[int]) -> List[int]:\n        available = list(range(k)) # already a min-heap\n        busy = [] \n        res = [0] * k\n        for i a in enumerate(A):\n            while busy and busy[0][0] <= a: # these are done put them back as available\n                _ x = heapq.heappop(busy)\n                heapq.heappush(available i + (x-i)%k) # invariant: min(available) is at least i at most i+k-1\n            if available: \n                j = heapq.heappop(available) % k\n                heapq.heappush(busy (a+B[i]j))\n                res[j] += 1\n        a = max(res)\n        return [i for i in range(k) if res[i] == a]\n
Find Smallest Letter Greater Than Target,"###  744\. Find Smallest Letter Greater Than Target\n\nGiven a characters array `letters` that is sorted in **non-decreasing** order\nand a character `target` return _the smallest character in the array that is\nlarger than_`target`.\n\n**Note** that the letters wrap around.\n\n  * For example if `target == 'z'` and `letters == ['a' 'b']` the answer is `'a'`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** letters = [""c""""f""""j""] target = ""a""\n    **Output:** ""c""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** letters = [""c""""f""""j""] target = ""c""\n    **Output:** ""f""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** letters = [""c""""f""""j""] target = ""d""\n    **Output:** ""f""\n    \n\n\n\n**Constraints:**\n\n  * `2 <= letters.length <= 104`\n  * `letters[i]` is a lowercase English letter.\n  * `letters` is sorted in **non-decreasing** order.\n  * `letters` contains at least two different characters.\n  * `target` is a lowercase English letter.\n\n",class Solution:\n    def nextGreatestLetter(self letters: List[str] target: str) -> str:\n        beg = 0\n        end = len(letters)-1\n        while beg <= end:\n            mid = (beg+end)//2\n            if letters[mid]>target:\n                end = mid -1\n            else:\n                beg = mid +1\n        return letters[beg] if beg<len(letters) else letters[0]\n
Find Subsequence of Length K With the Largest Sum,###  2099\. Find Subsequence of Length K With the Largest Sum\n\nYou are given an integer array `nums` and an integer `k`. You want to find a\n**subsequence** of `nums` of length `k` that has the **largest** sum.\n\nReturn ___**any** such subsequence as an integer array of length _`k`.\n\nA **subsequence** is an array that can be derived from another array by\ndeleting some or no elements without changing the order of the remaining\nelements.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [2133] k = 2\n    **Output:** [33]\n    **Explanation:**\n    The subsequence has the largest sum of 3 + 3 = 6.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-1-234] k = 3\n    **Output:** [-134]\n    **Explanation:** \n    The subsequence has the largest sum of -1 + 3 + 4 = 6.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [3433] k = 2\n    **Output:** [34]\n    **Explanation:**\n    The subsequence has the largest sum of 3 + 4 = 7. \n    Another possible subsequence is [4 3].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `-105 <= nums[i] <= 105`\n  * `1 <= k <= nums.length`\n\n,class Solution(object):\n    def maxSubsequence(self nums k):\n        ret max_k = [] sorted(nums reverse=True)[:k]\n        for num in nums:\n            if num in max_k:\n                ret.append(num)\n                max_k.remove(num)\n                if len(max_k) == 0:\n                    return ret\n
Find Substring With Given Hash Value,"###  2156\. Find Substring With Given Hash Value\n\nThe hash of a **0-indexed** string `s` of length `k` given integers `p` and\n`m` is computed using the following function:\n\n  * `hash(s p m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m`.\n\nWhere `val(s[i])` represents the index of `s[i]` in the alphabet from\n`val('a') = 1` to `val('z') = 26`.\n\nYou are given a string `s` and the integers `power` `modulo` `k` and\n`hashValue.` Return `sub`_the**first** **substring** of _`s` _of length_`k`\n_such that_`hash(sub power modulo) == hashValue`.\n\nThe test cases will be generated such that an answer always **exists**.\n\nA **substring** is a contiguous non-empty sequence of characters within a\nstring.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""leetcode"" power = 7 modulo = 20 k = 2 hashValue = 0\n    **Output:** ""ee""\n    **Explanation:** The hash of ""ee"" can be computed to be hash(""ee"" 7 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. \n    ""ee"" is the first substring of length 2 with hashValue 0. Hence we return ""ee"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""fbxzaad"" power = 31 modulo = 100 k = 3 hashValue = 32\n    **Output:** ""fbx""\n    **Explanation:** The hash of ""fbx"" can be computed to be hash(""fbx"" 31 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. \n    The hash of ""bxz"" can be computed to be hash(""bxz"" 31 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. \n    ""fbx"" is the first substring of length 3 with hashValue 32. Hence we return ""fbx"".\n    Note that ""bxz"" also has a hash of 32 but it appears later than ""fbx"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= s.length <= 2 * 104`\n  * `1 <= power modulo <= 109`\n  * `0 <= hashValue < modulo`\n  * `s` consists of lowercase English letters only.\n  * The test cases are generated such that an answer always **exists**.\n\n","# Runtime: 996 ms (Top 33.98%) | Memory: 14.1 MB (Top 94.23%)\nclass Solution:\n    def subStrHash(self s: str power: int mod: int k: int hashValue: int) -> str:\n        val = lambda ch : ord(ch) - ord(""a"") + 1\n        hash res power_k = 0 0 pow(power k mod)\n        for i in reversed(range(len(s))):\n            hash = (hash * power + val(s[i])) % mod\n            if i < len(s) - k:\n                hash = (mod + hash - power_k * val(s[i + k]) % mod) % mod\n            res = i if hash == hashValue else res\n        return s[res:res + k]"
Find Target Indices After Sorting Array,###  2089\. Find Target Indices After Sorting Array\n\nYou are given a **0-indexed** integer array `nums` and a target element\n`target`.\n\nA **target index** is an index `i` such that `nums[i] == target`.\n\nReturn _a list of the target indices of_ `nums` after _sorting_`nums`\n_in**non-decreasing** order_. If there are no target indices return\n_an**empty** list_. The returned list must be sorted in **increasing** order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12523] target = 2\n    **Output:** [12]\n    **Explanation:** After sorting nums is [1_**2**_ _**2**_ 35].\n    The indices where nums[i] == 2 are 1 and 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12523] target = 3\n    **Output:** [3]\n    **Explanation:** After sorting nums is [122_**3**_ 5].\n    The index where nums[i] == 3 is 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [12523] target = 5\n    **Output:** [4]\n    **Explanation:** After sorting nums is [1223_**5**_].\n    The index where nums[i] == 5 is 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `1 <= nums[i] target <= 100`\n\n,class Solution:\n    def targetIndices(self nums target):\n        ans = []\n        for inum in enumerate(sorted(nums)):\n            if num == target: ans.append(i)\n        return ans\n
Find the Difference,"###  389\. Find the Difference\n\nYou are given two strings `s` and `t`.\n\nString `t` is generated by random shuffling string `s` and then add one more\nletter at a random position.\n\nReturn the letter that was added to `t`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcd"" t = ""abcde""\n    **Output:** ""e""\n    **Explanation:** 'e' is the letter that was added.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = """" t = ""y""\n    **Output:** ""y""\n    \n\n\n\n**Constraints:**\n\n  * `0 <= s.length <= 1000`\n  * `t.length == s.length + 1`\n  * `s` and `t` consist of lowercase English letters.\n\n",class Solution:\n    def findTheDifference(self s: str t: str) -> str:\n        c = 0\n        for cs in s: c ^= ord(cs) #ord is ASCII value\n        for ct in t: c ^= ord(ct)\n        return chr(c) #chr = convert ASCII into character\n
Find the Difference of Two Arrays,###  2215\. Find the Difference of Two Arrays\n\nGiven two **0-indexed** integer arrays `nums1` and `nums2` return _a list_\n`answer` _of size_ `2` _where:_\n\n  * `answer[0]` _is a list of all**distinct** integers in_ `nums1` _which are**not** present in_ `nums2` _._\n  * `answer[1]` _is a list of all**distinct** integers in_ `nums2` _which are**not** present in_ `nums1`.\n\n**Note** that the integers in the lists may be returned in **any** order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [123] nums2 = [246]\n    **Output:** [[13][46]]\n    **Explanation:** For nums1 nums1[1] = 2 is present at index 0 of nums2 whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore answer[0] = [13].\n    For nums2 nums2[0] = 2 is present at index 1 of nums1 whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore answer[1] = [46].\n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [1233] nums2 = [1122]\n    **Output:** [[3][]]\n    **Explanation:** For nums1 nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3] their value is only included once and answer[0] = [3].\n    Every integer in nums2 is present in nums1. Therefore answer[1] = [].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 1000`\n  * `-1000 <= nums1[i] nums2[i] <= 1000`\n\n,"# Runtime: 953 ms (Top 29.31%) | Memory: 14.3 MB (Top 52.22%)\nclass Solution(object):\n    def findDifference(self nums1 nums2):\n        """"""\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[List[int]]\n        """"""\n        a = []\n        for i in range(len(nums1)):\n            if nums1[i] not in nums2:\n                a.append(nums1[i])\n        b = []\n        for i in range(len(nums2)):\n            if nums2[i] not in nums1:\n                b.append(nums2[i])\n\n        c = [list(set(a))] + [list(set(b))]\n\n        return c"
Find the Distance Value Between Two Arrays,###  1385\. Find the Distance Value Between Two Arrays\n\nGiven two integer arrays `arr1` and `arr2` and the integer `d` _return the\ndistance value between the two arrays_.\n\nThe distance value is defined as the number of elements `arr1[i]` such that\nthere is not any element `arr2[j]` where `|arr1[i]-arr2[j]| <= d`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr1 = [458] arr2 = [10918] d = 2\n    **Output:** 2\n    **Explanation:** \n    For arr1[0]=4 we have: \n    |4-10|=6 > d=2 \n    |4-9|=5 > d=2 \n    |4-1|=3 > d=2 \n    |4-8|=4 > d=2 \n    For arr1[1]=5 we have: \n    |5-10|=5 > d=2 \n    |5-9|=4 > d=2 \n    |5-1|=4 > d=2 \n    |5-8|=3 > d=2\n    For arr1[2]=8 we have:\n    **|8-10|=2 <= d=2**\n    **|8-9|=1 <= d=2**\n    |8-1|=7 > d=2\n    **|8-8|=0 <= d=2**\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr1 = [1423] arr2 = [-4-36102030] d = 3\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr1 = [211003] arr2 = [-5-210-37] d = 6\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr1.length arr2.length <= 500`\n  * `-1000 <= arr1[i] arr2[j] <= 1000`\n  * `0 <= d <= 100`\n\n,"class Solution:\n	def findTheDistanceValue(self array1: List[int] array2: List[int] d: int) -> int:\n\n		result = 0\n\n		array2 = sorted(array2)\n\n		for num in array1:\n\n			flag = True\n\n			low = 0\n			high = len(array2)-1\n\n			while low <= high:\n\n				mid = (low + high) // 2\n\n				if abs(array2[mid] - num) <= d:\n					flag = False\n					break\n\n				elif array2[mid] > num:\n					high = mid - 1\n\n				else:\n					low = mid + 1;\n\n			if flag == True:\n\n				result = result + 1\n\n		return result\n"
Find the Duplicate Number,###  287\. Find the Duplicate Number\n\nGiven an array of integers `nums` containing `n + 1` integers where each\ninteger is in the range `[1 n]` inclusive.\n\nThere is only **one repeated number** in `nums` return _this  repeated\nnumber_.\n\nYou must solve the problem **without** modifying the array `nums` and uses\nonly constant extra space.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13422]\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [31342]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `nums.length == n + 1`\n  * `1 <= nums[i] <= n`\n  * All the integers in `nums` appear only **once** except for **precisely one integer** which appears **two or more** times.\n\n\n\n**Follow up:**\n\n  * How can we prove that at least one duplicate number must exist in `nums`?\n  * Can you solve the problem in linear runtime complexity?\n\n,# Runtime: 1523 ms (Top 9.74%) | Memory: 34 MB (Top 8.51%)\nclass Solution:\n    def findDuplicate(self nums: List[int]) -> int:\n\n        dictx = {}\n\n        for each in nums:\n            if each not in dictx:\n                dictx[each] = 1\n            else:\n                return each\n
Find the Highest Altitude,###  1732\. Find the Highest Altitude\n\nThere is a biker going on a road trip. The road trip consists of `n + 1`\npoints at different altitudes. The biker starts his trip on point `0` with\naltitude equal `0`.\n\nYou are given an integer array `gain` of length `n` where `gain[i]` is the\n**net gain in altitude** between points `i`​​​​​​ and `i + 1` for\nall (`0 <= i < n)`. Return _the**highest altitude** of a point._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** gain = [-5150-7]\n    **Output:** 1\n    **Explanation:** The altitudes are [0-5-411-6]. The highest is 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** gain = [-4-3-2-1432]\n    **Output:** 0\n    **Explanation:** The altitudes are [0-4-7-9-10-6-3-1]. The highest is 0.\n    \n\n\n\n**Constraints:**\n\n  * `n == gain.length`\n  * `1 <= n <= 100`\n  * `-100 <= gain[i] <= 100`\n\n,# Runtime: 50 ms (Top 25.7%) | Memory: 16.17 MB (Top 90.4%)\n\nclass Solution:\n    def largestAltitude(self gain: List[int]) -> int:\n        return max(accumulate([0]+gain))
Find the Kth Smallest Sum of a Matrix With Sorted Rows,###  1439\. Find the Kth Smallest Sum of a Matrix With Sorted Rows\n\nYou are given an `m x n` matrix `mat` that has its rows sorted in non-\ndecreasing order and an integer `k`.\n\nYou are allowed to choose **exactly one element** from each row to form an\narray.\n\nReturn _the_`kth` _smallest array sum among all possible arrays_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** mat = [[1311][246]] k = 5\n    **Output:** 7\n    **Explanation:** Choosing one element from each row the first k smallest sum are:\n    [12] [14] [32] [34] [16]. Where the 5th sum is 7.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mat = [[1311][246]] k = 9\n    **Output:** 17\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** mat = [[11010][145][236]] k = 7\n    **Output:** 9\n    **Explanation:** Choosing one element from each row the first k smallest sum are:\n    [112] [113] [142] [143] [116] [152] [153]. Where the 7th sum is 9.  \n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat.length[i]`\n  * `1 <= m n <= 40`\n  * `1 <= mat[i][j] <= 5000`\n  * `1 <= k <= min(200 nm)`\n  * `mat[i]` is a non-decreasing array.\n\n,class Solution:\n    def kthSmallest(self mat: List[List[int]] k: int) -> int:\n        def kSmallestPairs(nums1: List[int] nums2: List[int] k: int) -> List[List[int]]:\n            h = [(nums1[0]+nums2[0]00)]\n            visited = set()\n            res = []\n            while h and k > 0:\n                e i j = heappop(h)\n                if (ij) in visited: continue\n                res.append(e)\n                visited.add((ij))\n                if j+1 < len(nums2):\n                    heappush(h(nums1[i]+nums2[j+1]ij+1))\n                if i+1 < len(nums1):\n                    heappush(h(nums1[i+1]+nums2[j]i+1j))\n                k -= 1\n            return res\n        res = mat[0]\n        for i in range(1 len(mat)):\n            res = kSmallestPairs(res mat[i] k)\n        return res[-1]
Find the Longest Valid Obstacle Course at Each Position,###  1964\. Find the Longest Valid Obstacle Course at Each Position\n\nYou want to build some obstacle courses. You are given a **0-indexed** integer\narray `obstacles` of length `n` where `obstacles[i]` describes the height of\nthe `ith` obstacle.\n\nFor every index `i` between `0` and `n - 1` (**inclusive**) find the length\nof the **longest obstacle course** in `obstacles` such that:\n\n  * You choose any number of obstacles between `0` and `i` **inclusive**.\n  * You must include the `ith` obstacle in the course.\n  * You must put the chosen obstacles in the **same order** as they appear in `obstacles`.\n  * Every obstacle (except the first) is **taller** than or the **same height** as the obstacle immediately before it.\n\nReturn _an array_ `ans` _of length_ `n` _where_ `ans[i]` _is the length of\nthe**longest obstacle course** for index_ `i` _as described above_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** obstacles = [1232]\n    **Output:** [1233]\n    **Explanation:** The longest valid obstacle course at each position is:\n    - i = 0: [_1_] [1] has length 1.\n    - i = 1: [_1_ _2_] [12] has length 2.\n    - i = 2: [_1_ _2_ _3_] [123] has length 3.\n    - i = 3: [_1_ _2_ 3_2_] [122] has length 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** obstacles = [221]\n    **Output:** [121]\n    **Explanation:** The longest valid obstacle course at each position is:\n    - i = 0: [_2_] [2] has length 1.\n    - i = 1: [_2_ _2_] [22] has length 2.\n    - i = 2: [22_1_] [1] has length 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** obstacles = [315642]\n    **Output:** [112322]\n    **Explanation:** The longest valid obstacle course at each position is:\n    - i = 0: [_3_] [3] has length 1.\n    - i = 1: [3_1_] [1] has length 1.\n    - i = 2: [_3_ 1_5_] [35] has length 2. [15] is also valid.\n    - i = 3: [_3_ 1_5_ _6_] [356] has length 3. [156] is also valid.\n    - i = 4: [_3_ 156_4_] [34] has length 2. [14] is also valid.\n    - i = 5: [3_1_ 564_2_] [12] has length 2.\n    \n\n\n\n**Constraints:**\n\n  * `n == obstacles.length`\n  * `1 <= n <= 105`\n  * `1 <= obstacles[i] <= 107`\n\n,from bisect import bisect_right\nclass Solution:\n    def longestObstacleCourseAtEachPosition(self obstacles: List[int]) -> List[int]:\n        longest res = [] []\n        for i in range(len(obstacles)):\n            idx = bisect_right(longest obstacles[i])\n            if idx == len(longest):\n                longest.append(obstacles[i])\n            else:\n                longest[idx] = obstacles[i]\n            res.append(idx+1)\n        return res\n
Find the Minimum and Maximum Number of Nodes Between Critical Points,###  2058\. Find the Minimum and Maximum Number of Nodes Between Critical\nPoints\n\nA **critical point** in a linked list is defined as **either** a **local\nmaxima** or a **local minima**.\n\nA node is a **local maxima** if the current node has a value **strictly\ngreater** than the previous node and the next node.\n\nA node is a **local minima** if the current node has a value **strictly\nsmaller** than the previous node and the next node.\n\nNote that a node can only be a local maxima/minima if there exists **both** a\nprevious node and a next node.\n\nGiven a linked list `head` return _an array of length 2\ncontaining_`[minDistance maxDistance]`_where_`minDistance` _is the**minimum\ndistance** between **any  two distinct** critical points and _`maxDistance`\n_is the**maximum distance** between **any  two distinct** critical points. If\nthere are **fewer** than two critical points return _`[-1 -1]`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/10/13/a1.png)\n\n    \n    \n    **Input:** head = [31]\n    **Output:** [-1-1]\n    **Explanation:** There are no critical points in [31].\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/10/13/a2.png)\n\n    \n    \n    **Input:** head = [5312512]\n    **Output:** [13]\n    **Explanation:** There are three critical points:\n    - [53**_1_** 2512]: The third node is a local minima because 1 is less than 3 and 2.\n    - [5312_**5**_ 12]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n    - [53125_**1**_ 2]: The sixth node is a local minima because 1 is less than 5 and 2.\n    The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\n    The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/10/14/a5.png)\n\n    \n    \n    **Input:** head = [132232227]\n    **Output:** [33]\n    **Explanation:** There are two critical points:\n    - [1_**3**_ 2232227]: The second node is a local maxima because 3 is greater than 1 and 2.\n    - [1322_**3**_ 2227]: The fifth node is a local maxima because 3 is greater than 2 and 2.\n    Both the minimum and maximum distances are between the second and the fifth node.\n    Thus minDistance and maxDistance is 5 - 2 = 3.\n    Note that the last node is not considered a local maxima because it does not have a next node.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[2 105]`.\n  * `1 <= Node.val <= 105`\n\n,# Runtime: 687 ms (Top 71.4%) | Memory: 56.78 MB (Top 82.0%)\n\nclass Solution:\n    def nodesBetweenCriticalPoints(self head: Optional[ListNode]) -> List[int]:\n        idx i = [] 1\n        prev cur = head head.next\n        while cur and cur.next:\n            if prev.val < cur.val > cur.next.val or prev.val > cur.val < cur.next.val:\n                idx.append(i)\n            prev = cur\n            cur = cur.next\n            i += 1\n\n        if len(idx) < 2:\n            return [-1 -1]\n        \n        minDist = min(j - i for i j in pairwise(idx))\n        maxDist = idx[-1] - idx[0]\n\n        return [minDist maxDist]\n
Find the Minimum Number of Fibonacci Numbers Whose Sum Is K,###  1414\. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K\n\nGiven an integer `k` _return the minimum number of Fibonacci numbers whose\nsum is equal to_`k`. The same Fibonacci number can be used multiple times.\n\nThe Fibonacci numbers are defined as:\n\n  * `F1 = 1`\n  * `F2 = 1`\n  * `Fn = Fn-1 + Fn-2` for `n > 2.`\n\nIt is guaranteed that for the given constraints we can always find such\nFibonacci numbers that sum up to `k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** k = 7\n    **Output:** 2 \n    **Explanation:** The Fibonacci numbers are: 1 1 2 3 5 8 13 ... \n    For k = 7 we can use 2 + 5 = 7.\n\n**Example 2:**\n\n    \n    \n    **Input:** k = 10\n    **Output:** 2 \n    **Explanation:** For k = 10 we can use 2 + 8 = 10.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** k = 19\n    **Output:** 3 \n    **Explanation:** For k = 19 we can use 1 + 5 + 13 = 19.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= 109`\n\n,class Solution:\n    def findMinFibonacciNumbers(self k: int) -> int:\n        fib_sq = [1 1]\n        while fib_sq[-1] + fib_sq[-2] <= k:\n            fib_sq.append(fib_sq[-1]+fib_sq[-2])\n        counter = 0\n        for i in range(len(fib_sq)-1 -1 -1):\n            if fib_sq[i] <= k:\n                counter += 1\n                k -= fib_sq[i]\n        return counter\n
Find the Smallest Divisor Given a Threshold,###  1283\. Find the Smallest Divisor Given a Threshold\n\nGiven an array of integers `nums` and an integer `threshold` we will choose a\npositive integer `divisor` divide all the array by it and sum the division's\nresult. Find the **smallest** `divisor` such that the result mentioned above\nis less than or equal to `threshold`.\n\nEach result of the division is rounded to the nearest integer greater than or\nequal to that element. (For example: `7/3 = 3` and `10/2 = 5`).\n\nThe test cases are generated so that there will be an answer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1259] threshold = 6\n    **Output:** 5\n    **Explanation:** We can get a sum to 17 (1+2+5+9) if the divisor is 1. \n    If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [442233111] threshold = 5\n    **Output:** 44\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5 * 104`\n  * `1 <= nums[i] <= 106`\n  * `nums.length <= threshold <= 106`\n\n,class Solution:\n    def helper(selfnumsm):\n        Sum = 0\n        for n in nums:\n            Sum += math.ceil(n/m)\n        return Sum\n    \n    def smallestDivisor(self nums: List[int] threshold: int) -> int:\n        lr = 1 max(nums)\n        while l < r:\n            mid = (l+r)//2\n            Sum = self.helper(numsmid)\n            if Sum > threshold:\n                l = mid + 1\n            else:\n                r = mid     \n        return r\n
Find the Winner of the Circular Game,###  1823\. Find the Winner of the Circular Game\n\nThere are `n` friends that are playing a game. The friends are sitting in a\ncircle and are numbered from `1` to `n` in **clockwise order**. More formally\nmoving clockwise from the `ith` friend brings you to the `(i+1)th` friend for\n`1 <= i < n` and moving clockwise from the `nth` friend brings you to the\n`1st` friend.\n\nThe rules of the game are as follows:\n\n  1. **Start** at the `1st` friend.\n  2. Count the next `k` friends in the clockwise direction **including** the friend you started at. The counting wraps around the circle and may count some friends more than once.\n  3. The last friend you counted leaves the circle and loses the game.\n  4. If there is still more than one friend in the circle go back to step `2` **starting** from the friend **immediately clockwise** of the friend who just lost and repeat.\n  5. Else the last friend in the circle wins the game.\n\nGiven the number of friends `n` and an integer `k` return _the winner of\nthe game_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png)\n\n    \n    \n    **Input:** n = 5 k = 2\n    **Output:** 3\n    **Explanation:** Here are the steps of the game:\n    1) Start at friend 1.\n    2) Count 2 friends clockwise which are friends 1 and 2.\n    3) Friend 2 leaves the circle. Next start is friend 3.\n    4) Count 2 friends clockwise which are friends 3 and 4.\n    5) Friend 4 leaves the circle. Next start is friend 5.\n    6) Count 2 friends clockwise which are friends 5 and 1.\n    7) Friend 1 leaves the circle. Next start is friend 3.\n    8) Count 2 friends clockwise which are friends 3 and 5.\n    9) Friend 5 leaves the circle. Only friend 3 is left so they are the winner.\n\n**Example 2:**\n\n    \n    \n    **Input:** n = 6 k = 5\n    **Output:** 1\n    **Explanation:** The friends leave in this order: 5 4 6 2 3. The winner is friend 1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= n <= 500`\n\n\n\n**Follow up:**\n\nCould you solve this problem in linear time with constant space?\n\n,class Solution:\ndef findTheWinner(self n: int k: int) -> int:\n    ls=list(range(1n+1))\n    while len(ls)>1:\n        i=(k-1)%len(ls)\n        ls.pop(i)\n        ls=ls[i:]+ls[:i]\n    \n    return ls[0]\n
Find Three Consecutive Integers That Sum to a Given Number,###  2177\. Find Three Consecutive Integers That Sum to a Given Number\n\nGiven an integer `num` return _three consecutive integers (as a sorted\narray)__that**sum** to _`num`. If `num` cannot be expressed as the sum of\nthree consecutive integers return _an**empty** array._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 33\n    **Output:** [101112]\n    **Explanation:** 33 can be expressed as 10 + 11 + 12 = 33.\n    10 11 12 are 3 consecutive integers so we return [10 11 12].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 4\n    **Output:** []\n    **Explanation:** There is no way to express 4 as the sum of 3 consecutive integers.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= num <= 1015`\n\n,// Runtime: 35 ms (Top 76.35%) | Memory: 17.40 MB (Top 18.24%)\n\nclass Solution:\n    def sumOfThree(self num: int) -> List[int]:\n        temp=(num-3)/3\n        if floor(temp)==ceil(temp):\n            return [int(temp)int(temp)+1int(temp)+2]\n        else:\n            return []\n
Find Triangular Sum of an Array,###  2221\. Find Triangular Sum of an Array\n\nYou are given a **0-indexed** integer array `nums` where `nums[i]` is a digit\nbetween `0` and `9` (**inclusive**).\n\nThe **triangular sum** of `nums` is the value of the only element present in\n`nums` after the following process terminates:\n\n  1. Let `nums` comprise of `n` elements. If `n == 1` **end** the process. Otherwise **create** a new **0-indexed** integer array `newNums` of length `n - 1`.\n  2. For each index `i` where `0 <= i < n - 1` **assign** the value of `newNums[i]` as `(nums[i] + nums[i+1]) % 10` where `%` denotes modulo operator.\n  3. **Replace** the array `nums` with `newNums`.\n  4. **Repeat** the entire process starting from step 1.\n\nReturn _the triangular sum of_ `nums`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/02/22/ex1drawio.png)\n\n    \n    \n    **Input:** nums = [12345]\n    **Output:** 8\n    **Explanation:**\n    The above diagram depicts the process from which we obtain the triangular sum of the array.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [5]\n    **Output:** 5\n    **Explanation:**\n    Since there is only one element in nums the triangular sum is the value of that element itself.\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `0 <= nums[i] <= 9`\n\n,class Solution(object):\n    def triangularSum(self nums):\n        while len(nums) > 1:\n            arr = []\n            for i in range(len(nums)-1):\n                arr.append((nums[i] + nums[i+1]) % 10)\n            nums = arr\n        return nums[0]\n
Find Two Non-overlapping Sub-arrays Each With Target Sum,###  1477\. Find Two Non-overlapping Sub-arrays Each With Target Sum\n\nYou are given an array of integers `arr` and an integer `target`.\n\nYou have to find **two non-overlapping sub-arrays** of `arr` each with a sum\nequal `target`. There can be multiple answers so you have to find an answer\nwhere the sum of the lengths of the two sub-arrays is **minimum**.\n\nReturn _the minimum sum of the lengths_ of the two required sub-arrays or\nreturn `-1` if you cannot find such two sub-arrays.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [32243] target = 3\n    **Output:** 2\n    **Explanation:** Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [7347] target = 7\n    **Output:** 2\n    **Explanation:** Although we have three non-overlapping sub-arrays of sum = 7 ([7] [34] and [7]) but we will choose the first and third sub-arrays as the sum of their lengths is 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [4326234] target = 6\n    **Output:** -1\n    **Explanation:** We have only one sub-array of sum = 6.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 105`\n  * `1 <= arr[i] <= 1000`\n  * `1 <= target <= 108`\n\n,"class Solution:\n    def minSumOfLengths(self arr: List[int] target: int) -> int:\n        l windowSum res = 0 0 float('inf')\n        min_till = [float('inf')] * len(arr) # records smallest lenth of subarry with target sum up till index i.\n        for r num in enumerate(arr): # r:right pointer and index of num in arr\n            windowSum += num\n            while windowSum > target: \n			# when the sum of current window is larger then target shrink the left end of the window one by one until windowSum <= target\n                windowSum -= arr[l]\n                l += 1\n			# the case when we found a new target sub-array i.e. current window\n            if windowSum == target:\n			   # length of current window\n                curLen = r - l + 1\n				# min_till[l - 1]: the subarray with min len up till the previous position of left end of the current window: \n				# avoid overlap with cur window\n				# new_sum_of_two_subarray = length of current window + the previous min length of target subarray without overlapping\n				#  if < res update res.\n                res = min(res curLen + min_till[l - 1])\n				# Everytime we found a target window update the min_till of current right end of the window \n				# for future use when sum up to new length of sum_of_two_subarray and update the res.\n                min_till[r] = min(curLen min_till[r - 1])\n            else:\n			# If windowSum < target: window with current arr[r] as right end does not have any target subarry \n			# the min_till[r] doesn't get any new minimum update i.e it equals to previous min_till at index r - 1. \n                min_till[r] = min_till[r - 1]\n        return res if res < float('inf') else -1\n	\nTime = O(n): when sliding the window left and right pointers traverse the array once.\nSpace = O(n): we use one additional list min_till[] to record min length of target subarray till index i."
Find Valid Matrix Given Row and Column Sums,###  1605\. Find Valid Matrix Given Row and Column Sums\n\nYou are given two arrays `rowSum` and `colSum` of non-negative integers where\n`rowSum[i]` is the sum of the elements in the `ith` row and `colSum[j]` is the\nsum of the elements of the `jth` column of a 2D matrix. In other words you do\nnot know the elements of the matrix but you do know the sums of each row and\ncolumn.\n\nFind any matrix of **non-negative** integers of size `rowSum.length x\ncolSum.length` that satisfies the `rowSum` and `colSum` requirements.\n\nReturn _a 2D array representing**any** matrix that fulfills the requirements_.\nIt's guaranteed that **at least one** matrix that fulfills the requirements\nexists.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rowSum = [38] colSum = [47]\n    **Output:** [[30]\n             [17]]\n    **Explanation:** \n    0th row: 3 + 0 = 3 == rowSum[0]\n    1st row: 1 + 7 = 8 == rowSum[1]\n    0th column: 3 + 1 = 4 == colSum[0]\n    1st column: 0 + 7 = 7 == colSum[1]\n    The row and column sums match and all matrix elements are non-negative.\n    Another possible matrix is: [[12]\n                                 [35]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rowSum = [5710] colSum = [868]\n    **Output:** [[050]\n             [610]\n             [208]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rowSum.length colSum.length <= 500`\n  * `0 <= rowSum[i] colSum[i] <= 108`\n  * `sum(rows) == sum(columns)`\n\n,class Solution:\n    def restoreMatrix(self rowSum: List[int] colSum: List[int]) -> List[List[int]]:\n        matrix = []\n        for row in range(len(rowSum)):\n            data array = rowSum[row] []\n            for col in range(len(colSum)):\n                if data == 0 or colSum[col] == 0:\n                    array.append(0)\n                elif data > colSum[col]:\n                    data -= colSum[col]\n                    array.append(colSum[col])\n                    colSum[col] = 0\n                else:\n                    array.append(data)\n                    colSum[col] -= data\n                    data = 0\n            matrix.append(array)\n\n        return matrix\n                    \n                    \n\n\n\n\n\n\n\n
Find Winner on a Tic Tac Toe Game,"###  1275\. Find Winner on a Tic Tac Toe Game\n\n**Tic-tac-toe** is played by two players `A` and `B` on a `3 x 3` grid. The\nrules of Tic-Tac-Toe are:\n\n  * Players take turns placing characters into empty squares `' '`.\n  * The first player `A` always places `'X'` characters while the second player `B` always places `'O'` characters.\n  * `'X'` and `'O'` characters are always placed into empty squares never on filled ones.\n  * The game ends when there are **three** of the same (non-empty) character filling any row column or diagonal.\n  * The game also ends if all squares are non-empty.\n  * No more moves can be played if the game is over.\n\nGiven a 2D integer array `moves` where `moves[i] = [rowi coli]` indicates\nthat the `ith` move will be played on `grid[rowi][coli]`. return _the winner\nof the game if it exists_ (`A` or `B`). In case the game ends in a draw return\n`""Draw""`. If there are still movements to play return `""Pending""`.\n\nYou can assume that `moves` is valid (i.e. it follows the rules of **Tic-Tac-\nToe**) the grid is initially empty and `A` will play first.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/09/22/xo1-grid.jpg)\n\n    \n    \n    **Input:** moves = [[00][20][11][21][22]]\n    **Output:** ""A""\n    **Explanation:** A wins they always play first.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/09/22/xo2-grid.jpg)\n\n    \n    \n    **Input:** moves = [[00][11][01][02][10][20]]\n    **Output:** ""B""\n    **Explanation:** B wins.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/09/22/xo3-grid.jpg)\n\n    \n    \n    **Input:** moves = [[00][11][20][10][12][21][01][02][22]]\n    **Output:** ""Draw""\n    **Explanation:** The game ends in a draw since there are no moves to make.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= moves.length <= 9`\n  * `moves[i].length == 2`\n  * `0 <= rowi coli <= 2`\n  * There are no repeated elements on `moves`.\n  * `moves` follow the rules of tic tac toe.\n\n","class Solution:\n    def tictactoe(self moves: List[List[int]]) -> str:\n        wins = [\n            [(0 0) (0 1) (0 2)]\n            [(1 0) (1 1) (1 2)]\n            [(2 0) (2 1) (2 2)]\n            [(0 0) (1 0) (2 0)]\n            [(0 1) (1 1) (2 1)]\n            [(0 2) (1 2) (2 2)]\n            [(0 0) (1 1) (2 2)]\n            [(0 2) (1 1) (2 0)]\n        ]\n    \n        def checkWin(S):\n            for win in wins:\n                flag = True\n                for pos in win:\n                    if pos not in S:\n                        flag = False\n                        break\n                if flag:\n                    return True\n            return False\n        \n        A B = set() set()\n        for i (x y) in enumerate(moves):\n            if i % 2 == 0:\n                A.add((x y))\n            else:\n                B.add((x y))\n        \n        if checkWin(A):\n            return 'A'\n        elif checkWin(B):\n            return 'B'\n        \n        return ""Draw"" if len(moves) == 9 else ""Pending""\n"
Find Words That Can Be Formed by Characters,"###  1160\. Find Words That Can Be Formed by Characters\n\nYou are given an array of strings `words` and a string `chars`.\n\nA string is **good** if it can be formed by characters from chars (each\ncharacter can only be used once).\n\nReturn _the sum of lengths of all good strings in words_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""cat""""bt""""hat""""tree""] chars = ""atach""\n    **Output:** 6\n    **Explanation:** The strings that can be formed are ""cat"" and ""hat"" so the answer is 3 + 3 = 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""hello""""world""""leetcode""] chars = ""welldonehoneyr""\n    **Output:** 10\n    **Explanation:** The strings that can be formed are ""hello"" and ""world"" so the answer is 5 + 5 = 10.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 1000`\n  * `1 <= words[i].length chars.length <= 100`\n  * `words[i]` and `chars` consist of lowercase English letters.\n\n","class Solution(object):\n    def countCharacters(self words chars):\n        """"""\n        :type words: List[str]\n        :type chars: str\n        :rtype: int\n        """"""\n        b = set(chars)\n        anwser = 0\n        for i in words:\n            a = set(i)\n            if a.issubset(b):\n                test = [o for o in a if chars.count(o) < i.count(o)]\n                if len(test) == 0:    \n                    anwser += len(i)\n        return anwser\n"
Find XOR Sum of All Pairs Bitwise AND,###  1835\. Find XOR Sum of All Pairs Bitwise AND\n\nThe **XOR sum** of a list is the bitwise `XOR` of all its elements. If the\nlist only contains one element then its **XOR sum** will be equal to this\nelement.\n\n  * For example the **XOR sum** of `[1234]` is equal to `1 XOR 2 XOR 3 XOR 4 = 4` and the **XOR sum** of `[3]` is equal to `3`.\n\nYou are given two **0-indexed** arrays `arr1` and `arr2` that consist only of\nnon-negative integers.\n\nConsider the list containing the result of `arr1[i] AND arr2[j]` (bitwise\n`AND`) for every `(i j)` pair where `0 <= i < arr1.length` and `0 <= j <\narr2.length`.\n\nReturn _the**XOR sum** of the aforementioned list_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr1 = [123] arr2 = [65]\n    **Output:** 0\n    **Explanation:** The list = [1 AND 6 1 AND 5 2 AND 6 2 AND 5 3 AND 6 3 AND 5] = [012021].\n    The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr1 = [12] arr2 = [4]\n    **Output:** 4\n    **Explanation:** The list = [12 AND 4] = [4]. The XOR sum = 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr1.length arr2.length <= 105`\n  * `0 <= arr1[i] arr2[j] <= 109`\n\n,# Runtime: 2209 ms (Top 51.91%) | Memory: 30.3 MB (Top 21.37%)\nclass Solution:\n    def getXORSum(self arr1: List[int] arr2: List[int]) -> int:\n        def xor_lis(lis): return functools.reduce(lambda ab : a^blis)\n        return xor_lis(arr1) & xor_lis(arr2)
Finding Pairs With a Certain Sum,"###  1865\. Finding Pairs With a Certain Sum\n\nYou are given two integer arrays `nums1` and `nums2`. You are tasked to\nimplement a data structure that supports queries of two types:\n\n  1. **Add** a positive integer to an element of a given index in the array `nums2`.\n  2. **Count** the number of pairs `(i j)` such that `nums1[i] + nums2[j]` equals a given value (`0 <= i < nums1.length` and `0 <= j < nums2.length`).\n\nImplement the `FindSumPairs` class:\n\n  * `FindSumPairs(int[] nums1 int[] nums2)` Initializes the `FindSumPairs` object with two integer arrays `nums1` and `nums2`.\n  * `void add(int index int val)` Adds `val` to `nums2[index]` i.e. apply `nums2[index] += val`.\n  * `int count(int tot)` Returns the number of pairs `(i j)` such that `nums1[i] + nums2[j] == tot`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""FindSumPairs"" ""count"" ""add"" ""count"" ""count"" ""add"" ""add"" ""count""]\n    [[[1 1 2 2 2 3] [1 4 5 2 5 4]] [7] [3 2] [8] [4] [0 1] [1 1] [7]]\n    **Output**\n    [null 8 null 2 1 null null 11]\n    \n    **Explanation**\n    FindSumPairs findSumPairs = new FindSumPairs([1 1 2 2 2 3] [1 4 5 2 5 4]);\n    findSumPairs.count(7);  // return 8; pairs (22) (32) (42) (24) (34) (44) make 2 + 5 and pairs (51) (55) make 3 + 4\n    findSumPairs.add(3 2); // now nums2 = [145**_4_**54]\n    findSumPairs.count(8);  // return 2; pairs (52) (54) make 3 + 5\n    findSumPairs.count(4);  // return 1; pair (50) makes 3 + 1\n    findSumPairs.add(0 1); // now nums2 = [**_2_** 45454]\n    findSumPairs.add(1 1); // now nums2 = [2**_5_** 5454]\n    findSumPairs.count(7);  // return 11; pairs (21) (22) (24) (31) (32) (34) (41) (42) (44) make 2 + 5 and pairs (53) (55) make 3 + 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length <= 1000`\n  * `1 <= nums2.length <= 105`\n  * `1 <= nums1[i] <= 109`\n  * `1 <= nums2[i] <= 105`\n  * `0 <= index < nums2.length`\n  * `1 <= val <= 105`\n  * `1 <= tot <= 109`\n  * At most `1000` calls are made to `add` and `count` **each**.\n\n",// Runtime: 1039 ms (Top 5.41%) | Memory: 80.00 MB (Top 22.7%)\n\nclass FindSumPairs:\n\n    def __init__(self nums1: List[int] nums2: List[int]):\n        self.nums1 = sorted(nums1)\n        self.nums2 = nums2\n        self.hash2 = defaultdict(int)\n        for n in nums2:\n            self.hash2[n] += 1\n\n    def add(self index: int val: int) -> None:\n        self.hash2[self.nums2[index]] -= 1\n        self.nums2[index] += val\n        self.hash2[self.nums2[index]] += 1\n\n    def count(self tot: int) -> int:\n        result = 0\n        for n in self.nums1:\n            if n >= tot:\n                break\n            result += self.hash2[tot - n]\n        return result\n
Finding the Users Active Minutes,###  1817\. Finding the Users Active Minutes\n\nYou are given the logs for users' actions on LeetCode and an integer `k`. The\nlogs are represented by a 2D integer array `logs` where each `logs[i] = [IDi\ntimei]` indicates that the user with `IDi` performed an action at the minute\n`timei`.\n\n**Multiple users** can perform actions simultaneously and a single user can\nperform **multiple actions** in the same minute.\n\nThe **user active minutes (UAM)** for a given user is defined as the **number\nof unique minutes** in which the user performed an action on LeetCode. A\nminute can only be counted once even if multiple actions occur during it.\n\nYou are to calculate a **1-indexed** array `answer` of size `k` such that for\neach `j` (`1 <= j <= k`) `answer[j]` is the **number of users** whose **UAM**\nequals `j`.\n\nReturn _the array_`answer` _as described above_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** logs = [[05][12][02][05][13]] k = 5\n    **Output:** [02000]\n    **Explanation:**\n    The user with ID=0 performed actions at minutes 5 2 and 5 again. Hence they have a UAM of 2 (minute 5 is only counted once).\n    The user with ID=1 performed actions at minutes 2 and 3. Hence they have a UAM of 2.\n    Since both users have a UAM of 2 answer[2] is 2 and the remaining answer[j] values are 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** logs = [[11][22][23]] k = 4\n    **Output:** [1100]\n    **Explanation:**\n    The user with ID=1 performed a single action at minute 1. Hence they have a UAM of 1.\n    The user with ID=2 performed actions at minutes 2 and 3. Hence they have a UAM of 2.\n    There is one user with a UAM of 1 and one with a UAM of 2.\n    Hence answer[1] = 1 answer[2] = 1 and the remaining values are 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= logs.length <= 104`\n  * `0 <= IDi <= 109`\n  * `1 <= timei <= 105`\n  * `k` is in the range `[The maximum **UAM** for a user 105]`.\n\n,"class Solution:\n    def findingUsersActiveMinutes(self logs: List[List[int]] k: int) -> List[int]:\n        ret = [0] * k  # UAM store\n        user_acts = {}  # User minutes store\n        \n        # Adding user minutes to hash table\n		for log in logs:\n            if user_acts.get(log[0] 0):\n                user_acts[log[0]].append(log[1])\n            else:\n                user_acts[log[0]] = [log[1]]\n                \n        # Calculating UAM\n		for k v in user_acts.items():\n            l = len(set(v))\n            ret[l-1] += 1\n    \n        return ret\n"
First Bad Version,###  278\. First Bad Version\n\nYou are a product manager and currently leading a team to develop a new\nproduct. Unfortunately the latest version of your product fails the quality\ncheck. Since each version is developed based on the previous version all the\nversions after a bad version are also bad.\n\nSuppose you have `n` versions `[1 2 ... n]` and you want to find out the\nfirst bad one which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether\n`version` is bad. Implement a function to find the first bad version. You\nshould minimize the number of calls to the API.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5 bad = 4\n    **Output:** 4\n    **Explanation:**\n    call isBadVersion(3) -> false\n    call isBadVersion(5) -> true\n    call isBadVersion(4) -> true\n    Then 4 is the first bad version.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1 bad = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= bad <= n <= 231 - 1`\n\n,class Solution:\n    def firstBadVersion(self n: int) -> int:\n        fast slow = int(n/2) n\n        diff = abs(fast-slow)\n        while isBadVersion(fast) == isBadVersion(slow) or diff > 1:\n            fast slow = fast + (-1)**isBadVersion(fast) * (int(diff/2) or 1) fast\n            diff = abs(fast-slow)\n        return fast if isBadVersion(fast) else slow\n
First Letter to Appear Twice,"###  2351\. First Letter to Appear Twice\n\nGiven a string `s` consisting of lowercase English letters return _the first\nletter to appear**twice**_.\n\n**Note** :\n\n  * A letter `a` appears twice before another letter `b` if the **second** occurrence of `a` is before the **second** occurrence of `b`.\n  * `s` will contain at least one letter that appears twice.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abccbaacz""\n    **Output:** ""c""\n    **Explanation:**\n    The letter 'a' appears on the indexes 0 5 and 6.\n    The letter 'b' appears on the indexes 1 and 4.\n    The letter 'c' appears on the indexes 2 3 and 7.\n    The letter 'z' appears on the index 8.\n    The letter 'c' is the first letter to appear twice because out of all the letters the index of its second occurrence is the smallest.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcdd""\n    **Output:** ""d""\n    **Explanation:**\n    The only letter that appears twice is 'd' so we return 'd'.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 100`\n  * `s` consists of lowercase English letters.\n  * `s` has at least one repeated letter.\n\n",class Solution:\n    def repeatedCharacter(self s: str) -> str:\n        occurences = defaultdict(int)\n        for char in s:\n            occurences[char] += 1\n            if occurences[char] == 2:\n                return char\n
First Missing Positive,###  41\. First Missing Positive\n\nGiven an unsorted integer array `nums` return the smallest missing positive\ninteger.\n\nYou must implement an algorithm that runs in `O(n)` time and uses constant\nextra space.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [120]\n    **Output:** 3\n    **Explanation:** The numbers in the range [12] are all in the array.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [34-11]\n    **Output:** 2\n    **Explanation:** 1 is in the array but 2 is missing.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [7891112]\n    **Output:** 1\n    **Explanation:** The smallest positive integer 1 is missing.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-231 <= nums[i] <= 231 - 1`\n\n,# Runtime: 295 ms (Top 90.42%) | Memory: 28 MB (Top 72.11%)\nclass Solution:\n    def firstMissingPositive(self nums: List[int]) -> int:\n        mn = float('inf')\n        mx = 0\n        numsSet = set()\n\n        for i in range(len(nums) - 1 -1 -1):\n            if nums[i] > 0:\n                if nums[i] < mn:\n                    mn = nums[i]\n                if nums[i] > mx:\n                    mx = nums[i]\n                numsSet.add(nums[i])\n            del nums[i]\n\n        if mn >= 2:\n            return 1\n        if len(numsSet) == mx:\n            return mx + 1\n        for i in range(2 len(numsSet) + 1):\n            if i not in numsSet:\n                return i
First Unique Character in a String,"###  387\. First Unique Character in a String\n\nGiven a string `s` _find the first non-repeating character in it and return\nits index_. If it does not exist return `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""leetcode""\n    **Output:** 0\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""loveleetcode""\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""aabb""\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of only lowercase English letters.\n\n",class Solution:\n    def firstUniqChar(self s: str) -> int:\n        ls=[]\n        for i in range(len(s)):\n            x=s.count(s[i])\n            if x==1:\n                return i\n        return -1\n
Fizz Buzz,"###  412\. Fizz Buzz\n\nGiven an integer `n` return _a string array_`answer` _(**1-indexed**) where_:\n\n  * `answer[i] == ""FizzBuzz""` if `i` is divisible by `3` and `5`.\n  * `answer[i] == ""Fizz""` if `i` is divisible by `3`.\n  * `answer[i] == ""Buzz""` if `i` is divisible by `5`.\n  * `answer[i] == i` (as a string) if none of the above conditions are true.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** [""1""""2""""Fizz""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** [""1""""2""""Fizz""""4""""Buzz""]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 15\n    **Output:** [""1""""2""""Fizz""""4""""Buzz""""Fizz""""7""""8""""Fizz""""Buzz""""11""""Fizz""""13""""14""""FizzBuzz""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n\n",class Solution:\n    def fizzBuzz(self n: int) -> List[str]:\n        result = []\n        for i in range(1 n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append('FizzBuzz')\n            elif i % 3 == 0:\n                result.append('Fizz')\n            elif i % 5 == 0:\n                result.append('Buzz')\n            else:\n                result.append(str(i))\n        return result\n
Flatten a Multilevel Doubly Linked List,###  430\. Flatten a Multilevel Doubly Linked List\n\nYou are given a doubly linked list which contains nodes that have a next\npointer a previous pointer and an additional **child pointer**. This child\npointer may or may not point to a separate doubly linked list also containing\nthese special nodes. These child lists may have one or more children of their\nown and so on to produce a **multilevel data structure** as shown in the\nexample below.\n\nGiven the `head` of the first level of the list **flatten** the list so that\nall the nodes appear in a single-level doubly linked list. Let `curr` be a\nnode with a child list. The nodes in the child list should appear **after**\n`curr` and **before** `curr.next` in the flattened list.\n\nReturn _the_`head` _of the flattened list. The nodes in the list must\nhave**all** of their child pointers set to _`null`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/11/09/flatten11.jpg)\n\n    \n    \n    **Input:** head = [123456nullnullnull78910nullnull1112]\n    **Output:** [123781112910456]\n    **Explanation:** The multilevel linked list in the input is shown.\n    After flattening the multilevel linked list it becomes:\n    ![](https://assets.leetcode.com/uploads/2021/11/09/flatten12.jpg)\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/11/09/flatten2.1jpg)\n\n    \n    \n    **Input:** head = [12null3]\n    **Output:** [132]\n    **Explanation:** The multilevel linked list in the input is shown.\n    After flattening the multilevel linked list it becomes:\n    ![](https://assets.leetcode.com/uploads/2021/11/24/list.jpg)\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** head = []\n    **Output:** []\n    **Explanation:** There could be empty list in the input.\n    \n\n\n\n**Constraints:**\n\n  * The number of Nodes will not exceed `1000`.\n  * `1 <= Node.val <= 105`\n\n\n\n**How the multilevel linked list is represented in test cases:**\n\nWe use the multilevel linked list from **Example 1** above:\n\n    \n    \n     1---2---3---4---5---6--NULL\n             |\n             7---8---9---10--NULL\n                 |\n                 11--12--NULL\n\nThe serialization of each level is as follows:\n\n    \n    \n    [123456null]\n    [78910null]\n    [1112null]\n    \n\nTo serialize all levels together we will add nulls in each level to signify\nno node connects to the upper node of the previous level. The serialization\nbecomes:\n\n    \n    \n    [1    2    3 4 5 6 null]\n                 |\n    [null null 7    8 9 10 null]\n                       |\n    [            null 11 12 null]\n    \n\nMerging the serialization of each level and removing trailing nulls we obtain:\n\n    \n    \n    [123456nullnullnull78910nullnull1112]\n    \n\n,"""\n# Definition for a Node.\nclass Node:\n    def __init__(self val prev next child):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n""\n\nclass Solution:\n    def flatten(self head: 'Optional[Node]') -> 'Optional[Node]':    \n        node = head\n        while node:\n            if node.child: # If there is a child travel to last node of the child\n                child = node.child\n                while child.next:\n                    child = child.next\n                child.next = node.next # Update the next of child to the the next of the current node\n                if node.next: # update the prev of the next node to chile to make it valid doubly linked list\n                    node.next.prev = child\n                node.next = node.child # Update the child to become the next of the current\n                node.next.prev = node # update the prev of the next node to chile to make it valid doubly linked list\n                node.child = None # Make the child of the current node None to fulfill the requirements\n            node = node.next\n        return head\n\n# time and space complexity\n# time: O(n)\n# space: O(1)\n"
Flatten Binary Tree to Linked List,"###  114\. Flatten Binary Tree to Linked List\n\nGiven the `root` of a binary tree flatten the tree into a ""linked list"":\n\n  * The ""linked list"" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.\n  * The ""linked list"" should be in the same order as a [**pre-order****traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_NLR) of the binary tree.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)\n\n    \n    \n    **Input:** root = [12534null6]\n    **Output:** [1null2null3null4null5null6]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [0]\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 2000]`.\n  * `-100 <= Node.val <= 100`\n\n\n\n**Follow up:** Can you flatten the tree in-place (with `O(1)` extra space)?\n\n","# Runtime: 59 ms (Top 52.37%) | Memory: 15.1 MB (Top 89.03%)\n#Call the right of the tree node till the node root left and right is not None\n#After reaching the bottom of the tree make the root.right = prev and\n#root.left = None and then prev = None\n#Initially prev will point to None but this is used to point the previously visited root node\n#Prev pointer helps us to change the values from left to right\nclass Solution:\n    def flatten(self root: Optional[TreeNode]) -> None:\n        """"""\n        Do not return anything modify root in-place instead.\n        """"""\n        prev = None #You can also define that variable inside the init function using self keyword\n        def dfs(root):\n            nonlocal prev\n\n            if not root:\n                return\n\n            dfs(root.right)\n            dfs(root.left)\n\n            root.right = prev\n            root.left = None\n            prev = root\n\n        dfs(root)\n# If the above solution is hard to understand than one can do level order traversal\n#Using Stack DS but this will increase the space complexity to O(N)."
Flatten Nested List Iterator,###  341\. Flatten Nested List Iterator\n\nYou are given a nested list of integers `nestedList`. Each element is either\nan integer or a list whose elements may also be integers or other lists.\nImplement an iterator to flatten it.\n\nImplement the `NestedIterator` class:\n\n  * `NestedIterator(List<NestedInteger> nestedList)` Initializes the iterator with the nested list `nestedList`.\n  * `int next()` Returns the next integer in the nested list.\n  * `boolean hasNext()` Returns `true` if there are still some integers in the nested list and `false` otherwise.\n\nYour code will be tested with the following pseudocode:\n\n    \n    \n    initialize iterator with nestedList\n    res = []\n    while iterator.hasNext()\n        append iterator.next() to the end of res\n    return res\n    \n\nIf `res` matches the expected flattened list then your code will be judged as\ncorrect.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nestedList = [[11]2[11]]\n    **Output:** [11211]\n    **Explanation:** By calling next repeatedly until hasNext returns false the order of elements returned by next should be: [11211].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nestedList = [1[4[6]]]\n    **Output:** [146]\n    **Explanation:** By calling next repeatedly until hasNext returns false the order of elements returned by next should be: [146].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nestedList.length <= 500`\n  * The values of the integers in the nested list is in the range `[-106 106]`.\n\n,"class NestedIterator:\n    def __init__(self nestedList: [NestedInteger]):\n        self.flattened_lst = self.flattenList(nestedList)\n        self.idx = 0\n    \n    def next(self) -> int:\n        if self.idx >= len(self.flattened_lst):\n            raise Exception(""Index out of bound"")\n        self.idx += 1\n        return self.flattened_lst[self.idx-1]\n    \n    def hasNext(self) -> bool:\n        return self.idx < len(self.flattened_lst)\n    \n    def flattenList(self lst):\n        flattened_lst = []\n        for ele in lst:\n            if ele.isInteger():\n                flattened_lst.append(ele.getInteger())\n            else:\n                flattened_lst.extend(self.flattenList(ele.getList()))\n        return flattened_lst"
Flip Binary Tree To Match Preorder Traversal,###  971\. Flip Binary Tree To Match Preorder Traversal\n\nYou are given the `root` of a binary tree with `n` nodes where each node is\nuniquely assigned a value from `1` to `n`. You are also given a sequence of\n`n` values `voyage` which is the **desired** [**pre-order\ntraversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order) of the\nbinary tree.\n\nAny node in the binary tree can be **flipped** by swapping its left and right\nsubtrees. For example flipping node 1 will have the following effect:\n\n![](https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg)\n\nFlip the **smallest** number of nodes so that the **pre-order traversal** of\nthe tree **matches** `voyage`.\n\nReturn _a list of the values of all**flipped** nodes. You may return the\nanswer in **any order**. If it is **impossible** to flip the nodes in the tree\nto make the pre-order traversal match _`voyage` _ return the list_`[-1]`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/01/02/1219-01.png)\n\n    \n    \n    **Input:** root = [12] voyage = [21]\n    **Output:** [-1]\n    **Explanation:** It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/01/02/1219-02.png)\n\n    \n    \n    **Input:** root = [123] voyage = [132]\n    **Output:** [1]\n    **Explanation:** Flipping node 1 swaps nodes 2 and 3 so the pre-order traversal matches voyage.\n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/01/02/1219-02.png)\n\n    \n    \n    **Input:** root = [123] voyage = [123]\n    **Output:** []\n    **Explanation:** The tree's pre-order traversal already matches voyage so no nodes need to be flipped.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is `n`.\n  * `n == voyage.length`\n  * `1 <= n <= 100`\n  * `1 <= Node.val voyage[i] <= n`\n  * All the values in the tree are **unique**.\n  * All the values in `voyage` are **unique**.\n\n,"# Runtime: 50 ms (Top 21.2%) | Memory: 16.23 MB (Top 89.3%)\n\nclass Solution:\n    def flipMatchVoyage(self root voyage):\n        \n        # ------------------------------\n        \n        def dfs(root):\n            \n            if not root:\n                # base case aka stop condition\n				# empty node or empty tree\n                return True\n            \n            \n            ## general cases\n            if root.val != voyage[dfs.idx]:\n                \n                # current node mismatch no chance to make correction by flip\n                return False\n            \n            # voyage index moves forward\n            dfs.idx += 1\n            \n            if root.left and (root.left.val != voyage[dfs.idx]):\n                \n                # left child mismatch flip with right child if right child exists\n                root.right and result.append( root.val )\n                \n                # check subtree in preorder DFS with child node flip\n                return dfs(root.right) and dfs(root.left)\n                \n            else:\n                \n                # left child match check subtree in preorder DFS\n                return dfs(root.left) and dfs(root.right)\n                \n      \n        # --------------------------\n        \n        # flip sequence\n        result = []\n        \n        # voyage index during dfs\n        dfs.idx = 0\n        \n        # start checking from root node\n        good = dfs(root)\n        \n        return result if good else [-1]"
Flip Columns For Maximum Number of Equal Rows,###  1072\. Flip Columns For Maximum Number of Equal Rows\n\nYou are given an `m x n` binary matrix `matrix`.\n\nYou can choose any number of columns in the matrix and flip every cell in that\ncolumn (i.e. Change the value of the cell from `0` to `1` or vice versa).\n\nReturn _the maximum number of rows that have all values equal after some\nnumber of flips_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** matrix = [[01][11]]\n    **Output:** 1\n    **Explanation:** After flipping no values 1 row has all values equal.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matrix = [[01][10]]\n    **Output:** 2\n    **Explanation:** After flipping values in the first column both rows have equal values.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** matrix = [[000][001][110]]\n    **Output:** 2\n    **Explanation:** After flipping values in the first two columns the last two rows have equal values.\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m n <= 300`\n  * `matrix[i][j]` is either `0` or `1`.\n\n,from typing import List\nfrom collections import Counter\n\n\nclass Solution:\n    def maxEqualRowsAfterFlips(self matrix: List[List[int]]) -> int:\n        counter = Counter()\n        max_val = 2 ** len(matrix[0]) - 1\n        for row in matrix:\n            v = self.calculate_binary(row)\n            counter[v] += 1\n            counter[max_val - v] += 1\n            # print(f'counter: {counter}')\n\n        return counter.most_common(1)[0][1]\n\n    def calculate_binary(self row: List[int]) -> int:\n        val = 0\n        for r in row:\n            val = val * 2 + r\n        return val\n
Flip Equivalent Binary Trees,###  951\. Flip Equivalent Binary Trees\n\nFor a binary tree **T**  we can define a **flip operation** as follows:\nchoose any node and swap the left and right child subtrees.\n\nA binary tree **X**  is _flip equivalent_ to a binary tree **Y** if and only\nif we can make **X** equal to **Y** after some number of flip operations.\n\nGiven the roots of two binary trees `root1` and `root2` return `true` if the\ntwo trees are flip equivalent or `false` otherwise.\n\n\n\n**Example 1:**\n\n![Flipped Trees\nDiagram](https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png)\n\n    \n    \n    **Input:** root1 = [123456nullnullnull78] root2 = [132null645nullnullnullnull87]\n    **Output:** true\n    **Explanation:** We flipped at nodes with values 1 3 and 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root1 = [] root2 = []\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root1 = [] root2 = [1]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in each tree is in the range `[0 100]`.\n  * Each tree will have **unique node values** in the range `[0 99]`.\n\n,// Runtime: 32 ms (Top 89.57%) | Memory: 16.70 MB (Top 53.69%)\n\nclass Solution:\n    def flipEquiv(self root1: TreeNode root2: TreeNode) -> bool:\n        queue = deque([(root1 root2)])\n        while queue:\n            node1 node2 = queue.pop()\n            if (not node1) and (not node2):\n                continue\n            elif (not node1) or (not node2) or (node1.val != node2.val):\n                return False\n            L1 R1 L2 R2 = node1.left node1.right node2.left node2.right\n            if (L1 and L2 and L1.val == L2.val) or (R1 and R2 and R1.val == R2.val):\n                queue.append((L1 L2))\n                queue.append((R1 R2))\n            else:\n                queue.append((L1 R2))\n                queue.append((L2 R1))\n        return True\n
Flip String to Monotone Increasing,"###  926\. Flip String to Monotone Increasing\n\nA binary string is monotone increasing if it consists of some number of `0`'s\n(possibly none) followed by some number of `1`'s (also possibly none).\n\nYou are given a binary string `s`. You can flip `s[i]` changing it from `0` to\n`1` or from `1` to `0`.\n\nReturn _the minimum number of flips to make_`s` _monotone increasing_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""00110""\n    **Output:** 1\n    **Explanation:** We flip the last digit to get 00111.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""010110""\n    **Output:** 2\n    **Explanation:** We flip to get 011111 or alternatively 000111.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""00011000""\n    **Output:** 2\n    **Explanation:** We flip to get 00000000.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is either `'0'` or `'1'`.\n\n","class Solution:\n    def minFlipsMonoIncr(self s: str) -> int:\n        n = len(s)\n        min_flip = n\n        one_left = 0\n        # zero_right = 0\n        # for c in s:\n        #     if c == ""0"":\n        #         zero_right += 1\n        \n        zero_right = s.count(""0"") # since we will start with 11...11 then every zero in s will be on the right side of the border\n        \n        # for each i imagine that we have the borderline at i index any index >= i will be 1 and index < i will be 0.\n        # i = 0 n = 5 -> 11111\n        # i = 1 n = 5 -> 01111\n        # i = 5        -> 00000\n        for i in range(n + 1):\n            # the number of flip will be equal number of 1 on the left side of the border + number of zero on the right side of the border\n            # from example     00110\n            #                    v \n            # comparing with   00111  : i = 2 one_left = 0 zero_right = 1 then we have to do 0 + 1 flip in this i\n            min_flip = min(min_flipone_left+zero_right)\n            \n            # edge case for i = n or all zero (00...00)\n            if i == len(s):\n                continue\n            # reduce count of zero_right when 0 is moving to the 0-zone or left side of border\n            if s[i] == ""0"":\n                zero_right -= 1\n            else:\n                one_left += 1 # increase one on the left side when we move 1 into the left side\n        \n        return min_flip\n            \n            \n"
Flipping an Image,###  832\. Flipping an Image\n\nGiven an `n x n` binary matrix `image` flip the image **horizontally**  then\ninvert it and return _the resulting image_.\n\nTo flip an image horizontally means that each row of the image is reversed.\n\n  * For example flipping `[110]` horizontally results in `[011]`.\n\nTo invert an image means that each `0` is replaced by `1` and each `1` is\nreplaced by `0`.\n\n  * For example inverting `[011]` results in `[100]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** image = [[110][101][000]]\n    **Output:** [[100][010][111]]\n    **Explanation:** First reverse each row: [[011][101][000]].\n    Then invert the image: [[100][010][111]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** image = [[1100][1001][0111][1010]]\n    **Output:** [[1100][0110][0001][1010]]\n    **Explanation:** First reverse each row: [[0011][1001][1110][0101]].\n    Then invert the image: [[1100][0110][0001][1010]]\n    \n\n\n\n**Constraints:**\n\n  * `n == image.length`\n  * `n == image[i].length`\n  * `1 <= n <= 20`\n  * `images[i][j]` is either `0` or `1`.\n\n,class Solution:\n    def flipAndInvertImage(self image: List[List[int]]) -> List[List[int]]:\n        return [[(1 - i) for i in row[::-1]] for row in image]\n
Flood Fill,###  733\. Flood Fill\n\nAn image is represented by an `m x n` integer grid `image` where `image[i][j]`\nrepresents the pixel value of the image.\n\nYou are also given three integers `sr` `sc` and `color`. You should perform\na **flood fill** on the image starting from the pixel `image[sr][sc]`.\n\nTo perform a **flood fill**  consider the starting pixel plus any pixels\nconnected **4-directionally** to the starting pixel of the same color as the\nstarting pixel plus any pixels connected **4-directionally** to those pixels\n(also with the same color) and so on. Replace the color of all of the\naforementioned pixels with `color`.\n\nReturn _the modified image after performing the flood fill_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg)\n\n    \n    \n    **Input:** image = [[111][110][101]] sr = 1 sc = 1 color = 2\n    **Output:** [[222][220][201]]\n    **Explanation:** From the center of the image with position (sr sc) = (1 1) (i.e. the red pixel) all pixels connected by a path of the same color as the starting pixel (i.e. the blue pixels) are colored with the new color.\n    Note the bottom corner is not colored 2 because it is not 4-directionally connected to the starting pixel.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** image = [[000][000]] sr = 0 sc = 0 color = 0\n    **Output:** [[000][000]]\n    **Explanation:** The starting pixel is already colored 0 so no changes are made to the image.\n    \n\n\n\n**Constraints:**\n\n  * `m == image.length`\n  * `n == image[i].length`\n  * `1 <= m n <= 50`\n  * `0 <= image[i][j] color < 216`\n  * `0 <= sr < m`\n  * `0 <= sc < n`\n\n,"class Solution:\n    def floodFill(self image: List[List[int]] sr: int sc: int color: int) -> List[List[int]]:\n        queue = deque()\n        rows = len(image)\n        cols = len(image[0])\n        \n        targetColor = image[sr][sc]\n        \n        if color == targetColor:\n		    # in this case we don't need to do anything\n            return image\n\n        rDirs = [1 0 -1 0]\n        cDirs = [0 1 0 -1]\n        \n        queue.append((sr sc))\n        \n        while len(queue) > 0:\n            r c = queue.pop()\n            \n            image[r][c] = color\n            for rd cd in zip(rDirs cDirs):\n                newRow = r + rd\n                newCol = c + cd\n                \n                isValidCoordinate = newRow >= 0 and newRow < rows and newCol >= 0 and newCol < cols\n                \n                if isValidCoordinate and image[newRow][newCol] == targetColor:\n                    queue.append((newRow newCol))\n        \n        return image\n            \n    \n"
Flower Planting With No Adjacent,###  1042\. Flower Planting With No Adjacent\n\nYou have `n` gardens labeled from `1` to `n` and an array `paths` where\n`paths[i] = [xi yi]` describes a bidirectional path between garden `xi` to\ngarden `yi`. In each garden you want to plant one of 4 types of flowers.\n\nAll gardens have **at most 3** paths coming into or leaving it.\n\nYour task is to choose a flower type for each garden such that for any two\ngardens connected by a path they have different types of flowers.\n\nReturn _**any** such a choice as an array _`answer` _ where_`answer[i]`_is\nthe type of flower planted in the_`(i+1)th` _garden. The flower types are\ndenoted_`1` __`2` __`3` _ or_`4` _. It is guaranteed an answer exists._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 paths = [[12][23][31]]\n    **Output:** [123]\n    **Explanation:**\n    Gardens 1 and 2 have different types.\n    Gardens 2 and 3 have different types.\n    Gardens 3 and 1 have different types.\n    Hence [123] is a valid answer. Other valid answers include [124] [142] and [321].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4 paths = [[12][34]]\n    **Output:** [1212]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 4 paths = [[12][23][34][41][13][24]]\n    **Output:** [1234]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n  * `0 <= paths.length <= 2 * 104`\n  * `paths[i].length == 2`\n  * `1 <= xi yi <= n`\n  * `xi != yi`\n  * Every garden has **at most 3** paths coming into or leaving it.\n\n,"class Solution:\n	def gardenNoAdj(self n: int paths: List[List[int]]) -> List[int]:\n		g = defaultdict(list)\n		for uv in paths:\n			g[u-1].append(v-1)            \n			g[v-1].append(u-1) \n		ans = [0]*n\n		for i in range(n):\n			c = [1234]\n			for j in g[i]:\n				if ans[j] in c: c.remove(ans[j])\n			ans[i] = c.pop()\n		return ans"
Form Array by Concatenating Subarrays of Another Array,###  1764\. Form Array by Concatenating Subarrays of Another Array\n\nYou are given a 2D integer array `groups` of length `n`. You are also given an\ninteger array `nums`.\n\nYou are asked if you can choose `n` **disjoint** subarrays from the array\n`nums` such that the `ith` subarray is equal to `groups[i]` (**0-indexed**)\nand if `i > 0` the `(i-1)th` subarray appears **before** the `ith` subarray\nin `nums` (i.e. the subarrays must be in the same order as `groups`).\n\nReturn `true` _if you can do this task and_ `false` _otherwise_.\n\nNote that the subarrays are **disjoint** if and only if there is no index `k`\nsuch that `nums[k]` belongs to more than one subarray. A subarray is a\ncontiguous sequence of elements within an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** groups = [[1-1-1][3-20]] nums = [1-101-1-13-20]\n    **Output:** true\n    **Explanation:** You can choose the 0th subarray as [1-10_**1-1-1**_ 3-20] and the 1st one as [1-101-1-1_**3-20**_].\n    These subarrays are disjoint as they share no common nums[k] element.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** groups = [[10-2][1234]] nums = [123410-2]\n    **Output:** false\n    **Explanation:** Note that choosing the subarrays [_**1234**_ 10-2] and [1234_**10-2**_] is incorrect because they are not in the same order as in groups.\n    [10-2] must come before [1234].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** groups = [[123][34]] nums = [77123477]\n    **Output:** false\n    **Explanation:** Note that choosing the subarrays [77_**123**_ 477] and [7712_**34**_ 77] is invalid because they are not disjoint.\n    They share a common elements nums[4] (0-indexed).\n    \n\n\n\n**Constraints:**\n\n  * `groups.length == n`\n  * `1 <= n <= 103`\n  * `1 <= groups[i].length sum(groups[i].length) <= 103`\n  * `1 <= nums.length <= 103`\n  * `-107 <= groups[i][j] nums[k] <= 107`\n\n,class Solution:\n    def canChoose(self groups: List[List[int]] nums: List[int]) -> bool:\n        groups = ['-'.join(str(s) for s in group) for group in groups]\n        nums = '-'.join(str(s) for s in nums)\n        j = k = 0\n        while k < len(groups):\n            group = groups[k]\n            i = nums.find(group j)\n            if i == -1: return False\n            if i == 0 or i > 0 and nums[i-1] == '-':\n                j = i + len(group)\n                k += 1\n            else: j += 1\n        return True    \n
Form Largest Integer With Digits That Add up to Target,"###  1449\. Form Largest Integer With Digits That Add up to Target\n\nGiven an array of integers `cost` and an integer `target` return\n_the**maximum** integer you can paint under the following rules_:\n\n  * The cost of painting a digit `(i + 1)` is given by `cost[i]` (**0-indexed**).\n  * The total cost used must be equal to `target`.\n  * The integer does not have `0` digits.\n\nSince the answer may be very large return it as a string. If there is no way\nto paint any integer given the condition return `""0""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** cost = [432567255] target = 9\n    **Output:** ""7772""\n    **Explanation:** The cost to paint the digit '7' is 2 and the digit '2' is 3. Then cost(""7772"") = 2*3+ 3*1 = 9. You could also paint ""977"" but ""7772"" is the largest number.\n    **Digit    cost**\n      1  ->   4\n      2  ->   3\n      3  ->   2\n      4  ->   5\n      5  ->   6\n      6  ->   7\n      7  ->   2\n      8  ->   5\n      9  ->   5\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cost = [765556878] target = 12\n    **Output:** ""85""\n    **Explanation:** The cost to paint the digit '8' is 7 and the digit '5' is 5. Then cost(""85"") = 7 + 5 = 12.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** cost = [246246444] target = 5\n    **Output:** ""0""\n    **Explanation:** It is impossible to paint any integer with total cost equal to target.\n    \n\n\n\n**Constraints:**\n\n  * `cost.length == 9`\n  * `1 <= cost[i] target <= 5000`\n\n","from functools import lru_cache\nclass Solution:\n    def largestNumber(self cost: List[int] target: int) -> str:\n        @lru_cache(None)\n        def dfs(t):\n            if t == 0: return 0\n            res = float('-inf')\n            for digit in range(110):\n                if t - cost[digit-1] >= 0:\n                    res = max(res dfs(t - cost[digit-1])*10+digit)\n            return res\n        res = dfs(target)\n        return ""0"" if res == float('-inf') else str(res)"
Fraction Addition and Subtraction,"###  592\. Fraction Addition and Subtraction\n\nGiven a string `expression` representing an expression of fraction addition\nand subtraction return the calculation result in string format.\n\nThe final result should be an [irreducible\nfraction](https://en.wikipedia.org/wiki/Irreducible_fraction). If your final\nresult is an integer change it to the format of a fraction that has a\ndenominator `1`. So in this case `2` should be converted to `2/1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** expression = ""-1/2+1/2""\n    **Output:** ""0/1""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** expression = ""-1/2+1/2+1/3""\n    **Output:** ""1/3""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** expression = ""1/3-1/2""\n    **Output:** ""-1/6""\n    \n\n\n\n**Constraints:**\n\n  * The input string only contains `'0'` to `'9'` `'/'` `'+'` and `'-'`. So does the output.\n  * Each fraction (input and output) has the format `±numerator/denominator`. If the first input fraction or the output is positive then `'+'` will be omitted.\n  * The input only contains valid **irreducible fractions**  where the **numerator** and **denominator** of each fraction will always be in the range `[1 10]`. If the denominator is `1` it means this fraction is actually an integer in a fraction format defined above.\n  * The number of given fractions will be in the range `[1 10]`.\n  * The numerator and denominator of the **final result** are guaranteed to be valid and in the range of **32-bit** int.\n\n","# Runtime: 35 ms (Top 88.02%) | Memory: 14.1 MB (Top 5.79%)\n""""""\napproach:\nfirst replace - with +- in the string so that implementation gets\na little easy\n""""""\nclass Solution:\n    def fractionAddition(self expression: str) -> str:\n        expression = expression.replace('-' '+-')\n        parts = [item for item in expression.split('+') if item != '']\n        numes denoms denom_set lcm = [] [] set() 1\n        def get_lcm(a b):\n            if a == 1:\n                return b\n            if b == 1:\n                return a\n            if a < b:\n                if b % a == 0:\n                    return a * get_lcm(1 b/a)\n                else:\n                    return a * get_lcm(1 b)\n            else:\n                if a % b == 0:\n                    return b * get_lcm(a/b 1)\n                else:\n                    return b * get_lcm(a 1)\n\n        for part in parts:\n            num den = part.split('/')\n            numes.append(int(num))\n            denoms.append(int(den))\n            lcm = get_lcm(lcm int(den))\n\n        result = 0\n        for num den in zip(numes denoms):\n             result +=num * int(lcm/den)\n\n        def get_gcd(a b):\n            if a == 0:\n                return b\n            if b == 0:\n                return a\n            if a == b:\n                return a\n            elif a < b:\n                return get_gcd(a b-a)\n            else:\n                return get_gcd(a-b b)\n\n        gcd = get_gcd(abs(result) lcm)\n        return str(int(result/gcd)) + '/' + str(int(lcm/gcd))"
Fraction to Recurring Decimal,"###  166\. Fraction to Recurring Decimal\n\nGiven two integers representing the `numerator` and `denominator` of a\nfraction return _the fraction in string format_.\n\nIf the fractional part is repeating enclose the repeating part in\nparentheses.\n\nIf multiple answers are possible return **any of them**.\n\nIt is **guaranteed** that the length of the answer string is less than `104`\nfor all the given inputs.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** numerator = 1 denominator = 2\n    **Output:** ""0.5""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** numerator = 2 denominator = 1\n    **Output:** ""2""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** numerator = 4 denominator = 333\n    **Output:** ""0.(012)""\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= numerator denominator <= 231 - 1`\n  * `denominator != 0`\n\n","from collections import defaultdict\nclass Solution:\n    def fractionToDecimal(self numerator: int denominator: int) -> str:\n        sign = """" if numerator*denominator >= 0 else ""-""\n        numerator denominator = abs(numerator) abs(denominator)\n        a = numerator//denominator\n        numerator %= denominator\n        if not numerator: return sign+str(a)\n        fractions = []\n        index = defaultdict(int)\n        while 10*numerator not in index:\n            numerator *= 10\n            index[numerator] = len(fractions)\n            fractions.append(str(numerator//denominator))\n            numerator %= denominator\n        i = index[10*numerator]\n        return sign+str(a)+"".""+"""".join(fractions[:i])+""(""+"""".join(fractions[i:])+"")"" if numerator else sign+str(a)+"".""+"""".join(fractions[:i])"
Freedom Trail,"###  514\. Freedom Trail\n\nIn the video game Fallout 4 the quest **""Road to Freedom""** requires players\nto reach a metal dial called the **""Freedom Trail Ring""** and use the dial to\nspell a specific keyword to open the door.\n\nGiven a string `ring` that represents the code engraved on the outer ring and\nanother string `key` that represents the keyword that needs to be spelled\nreturn _the minimum number of steps to spell all the characters in the\nkeyword_.\n\nInitially the first character of the ring is aligned at the `""12:00""`\ndirection. You should spell all the characters in `key` one by one by rotating\n`ring` clockwise or anticlockwise to make each character of the string key\naligned at the `""12:00""` direction and then by pressing the center button.\n\nAt the stage of rotating the ring to spell the key character `key[i]`:\n\n  1. You can rotate the ring clockwise or anticlockwise by one place which counts as **one step**. The final purpose of the rotation is to align one of `ring`'s characters at the `""12:00""` direction where this character must equal `key[i]`.\n  2. If the character `key[i]` has been aligned at the `""12:00""` direction press the center button to spell which also counts as **one step**. After the pressing you could begin to spell the next character in the key (next stage). Otherwise you have finished all the spelling.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/22/ring.jpg)\n\n    \n    \n    **Input:** ring = ""godding"" key = ""gd""\n    **Output:** 4\n    **Explanation:**\n    For the first key character 'g' since it is already in place we just need 1 step to spell this character. \n    For the second key character 'd' we need to rotate the ring ""godding"" anticlockwise by two steps to make it become ""ddinggo"".\n    Also we need 1 more step for spelling.\n    So the final output is 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** ring = ""godding"" key = ""godding""\n    **Output:** 13\n    \n\n\n\n**Constraints:**\n\n  * `1 <= ring.length key.length <= 100`\n  * `ring` and `key` consist of only lower case English letters.\n  * It is guaranteed that `key` could always be spelled by rotating `ring`.\n\n","// Runtime: 85 ms (Top 95.51%) | Memory: 18.10 MB (Top 37.18%)\n\nclass Solution:\n    def findRotateSteps(self ring: str key: str) -> int:\n        locs = {}\n        for i ch in enumerate(ring): locs.setdefault(ch []).append(i)\n            \n        @cache \n        def fn(i j): \n            """"""Return turns to finish key[j:] startin from ith position on ring.""""""\n            if j == len(key): return 0 \n            loc = locs[key[j]]\n            k = bisect_left(loc i) % len(loc)\n            ans = min(abs(i-loc[k]) len(ring) - abs(i-loc[k])) + fn(loc[k] j+1)\n            k = (k-1) % len(loc)\n            ans = min(ans min(abs(i-loc[k]) len(ring) - abs(i-loc[k])) + fn(loc[k] j+1))\n            return ans \n        \n        return fn(0 0) + len(key)\n"
Frequency of the Most Frequent Element,###  1838\. Frequency of the Most Frequent Element\n\nThe **frequency** of an element is the number of times it occurs in an array.\n\nYou are given an integer array `nums` and an integer `k`. In one operation\nyou can choose an index of `nums` and increment the element at that index by\n`1`.\n\nReturn _the**maximum possible frequency** of an element after performing **at\nmost** _`k` _operations_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [124] k = 5\n    **Output:** 3**Explanation:** Increment the first element three times and the second element two times to make nums = [444].\n    4 has a frequency of 3.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [14813] k = 5\n    **Output:** 2\n    **Explanation:** There are multiple optimal solutions:\n    - Increment the first element three times to make nums = [44813]. 4 has a frequency of 2.\n    - Increment the second element four times to make nums = [18813]. 8 has a frequency of 2.\n    - Increment the third element five times to make nums = [141313]. 13 has a frequency of 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [396] k = 2\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 105`\n  * `1 <= k <= 105`\n\n,class Solution:\n    def maxFrequency(self nums: List[int] k: int) -> int:\n        nums.sort()\n        sums i ans = 0 0 0\n        for j in range(len(nums)):\n            sums += nums[j]\n            while nums[j]*(j-i+1) > sums+k:\n                sums -= nums[i]\n                i = i+1\n            ans = max(ans j-i+1)\n        return ans
Frog Jump,###  403\. Frog Jump\n\nA frog is crossing a river. The river is divided into some number of units\nand at each unit there may or may not exist a stone. The frog can jump on a\nstone but it must not jump into the water.\n\nGiven a list of `stones`' positions (in units) in sorted **ascending order** \ndetermine if the frog can cross the river by landing on the last stone.\nInitially the frog is on the first stone and assumes the first jump must be\n`1` unit.\n\nIf the frog's last jump was `k` units its next jump must be either `k - 1`\n`k` or `k + 1` units. The frog can only jump in the forward direction.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** stones = [0135681217]\n    **Output:** true\n    **Explanation:** The frog can jump to the last stone by jumping 1 unit to the 2nd stone then 2 units to the 3rd stone then 2 units to the 4th stone then 3 units to the 6th stone 4 units to the 7th stone and 5 units to the 8th stone.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** stones = [012348911]\n    **Output:** false\n    **Explanation:** There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= stones.length <= 2000`\n  * `0 <= stones[i] <= 231 - 1`\n  * `stones[0] == 0`\n  * `stones` is sorted in a strictly increasing order.\n\n,# Runtime: 231 ms (Top 72.60%) | Memory: 19.2 MB (Top 61.18%)\nclass Solution:\n    def possible(self i n stones pos allowedJumps):\n        if i == n - 1:\n            return True\n        key = tuple([i] + allowedJumps)\n        if key in self.cache:\n            return self.cache[key]\n        for jump in allowedJumps:\n            if jump > 0 and stones[i] + jump in pos:\n                if self.possible(pos[stones[i] + jump] n stones pos [jump - 1 jump jump + 1]):\n                    self.cache[key] = True\n                    return True\n        self.cache[key] = False\n        return False\n\n    def canCross(self stones: List[int]) -> bool:\n        n = len(stones)\n        pos = {}\n        for i stone in enumerate(stones):\n            pos[stone] = i\n        self.cache = {}\n        return self.possible(0 n stones pos [1])
Frog Position After T Seconds,###  1377\. Frog Position After T Seconds\n\nGiven an undirected tree consisting of `n` vertices numbered from `1` to `n`.\nA frog starts jumping from **vertex 1**. In one second the frog jumps from\nits current vertex to another **unvisited** vertex if they are directly\nconnected. The frog can not jump back to a visited vertex. In case the frog\ncan jump to several vertices it jumps randomly to one of them with the same\nprobability. Otherwise when the frog can not jump to any unvisited vertex it\njumps forever on the same vertex.\n\nThe edges of the undirected tree are given in the array `edges` where\n`edges[i] = [ai bi]` means that exists an edge connecting the vertices `ai`\nand `bi`.\n\n_Return the probability that after`t` seconds the frog is on the vertex\n`target`. _Answers within `10-5` of the actual answer will be accepted.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg)\n\n    \n    \n    **Input:** n = 7 edges = [[12][13][17][24][26][35]] t = 2 target = 4\n    **Output:** 0.16666666666666666 \n    **Explanation:** The figure above shows the given graph. The frog starts at vertex 1 jumping with 1/3 probability to the vertex 2 after **second 1** and then jumping with 1/2 probability to vertex 4 after **second 2**. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg)**\n\n    \n    \n    **Input:** n = 7 edges = [[12][13][17][24][26][35]] t = 1 target = 7\n    **Output:** 0.3333333333333333\n    **Explanation:** The figure above shows the given graph. The frog starts at vertex 1 jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after **second 1**. \n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 100`\n  * `edges.length == n - 1`\n  * `edges[i].length == 2`\n  * `1 <= ai bi <= n`\n  * `1 <= t <= 50`\n  * `1 <= target <= n`\n\n,// Runtime: 118 ms (Top 25.36%) | Memory: 17.90 MB (Top 5.07%)\n\nclass Solution:\n    def frogPosition(self n: int edges: List[List[int]] t: int target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited res = set() 0.\n        def dfs(leaf_id p time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n p / (len(neighbors) or 1) time + 1)\n        dfs(1 1 0)\n        return res\n
Fruit Into Baskets,###  904\. Fruit Into Baskets\n\nYou are visiting a farm that has a single row of fruit trees arranged from\nleft to right. The trees are represented by an integer array `fruits` where\n`fruits[i]` is the **type** of fruit the `ith` tree produces.\n\nYou want to collect as much fruit as possible. However the owner has some\nstrict rules that you must follow:\n\n  * You only have **two** baskets and each basket can only hold a **single type** of fruit. There is no limit on the amount of fruit each basket can hold.\n  * Starting from any tree of your choice you must pick **exactly one fruit** from **every** tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\n  * Once you reach a tree with fruit that cannot fit in your baskets you must stop.\n\nGiven the integer array `fruits` return _the**maximum** number of fruits you\ncan pick_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** fruits = [_121_]\n    **Output:** 3\n    **Explanation:** We can pick from all 3 trees.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** fruits = [0_122_]\n    **Output:** 3\n    **Explanation:** We can pick from trees [122].\n    If we had started at the first tree we would only pick from trees [01].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** fruits = [1_2322_]\n    **Output:** 4\n    **Explanation:** We can pick from trees [2322].\n    If we had started at the first tree we would only pick from trees [12].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= fruits.length <= 105`\n  * `0 <= fruits[i] < fruits.length`\n\n,class Solution:\n    def totalFruit(self fruits: List[int]) -> int:\n        ans=0\n        fruitdict=defaultdict()\n        stack=[]\n        ij=00\n\n        while j<len(fruits):\n            if fruits[j] not in fruitdict and len(fruitdict)<2:\n                stack.append(fruits[j])\n                fruitdict[fruits[j]]=j\n                j+=1\n\n            elif  fruits[j] in fruitdict:\n                fruitdict[fruits[j]]=j\n                j+=1\n\n            else:  \n                if fruitdict[stack[0]]>fruitdict[stack[1]]  :\n                    i = fruitdict[stack[1]]+1\n                    del fruitdict[stack[1]]\n                    stack.pop()\n                else:\n                    i = fruitdict[stack[0]]+1\n                    del fruitdict[stack[0]] \n                    stack.pop(0)              \n            \n            ans=max(ansj-i)\n        return ans
Furthest Building You Can Reach,###  1642\. Furthest Building You Can Reach\n\nYou are given an integer array `heights` representing the heights of\nbuildings some `bricks` and some `ladders`.\n\nYou start your journey from building `0` and move to the next building by\npossibly using bricks or ladders.\n\nWhile moving from building `i` to building `i+1` (**0-indexed**)\n\n  * If the current building's height is **greater than or equal** to the next building's height you do **not** need a ladder or bricks.\n  * If the current building's height is **less than** the next building's height you can either use **one ladder** or `(h[i+1] - h[i])` **bricks**.\n\n_Return the furthest building index (0-indexed) you can reach if you use the\ngiven ladders and bricks optimally._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/27/q4.gif)\n\n    \n    \n    **Input:** heights = [427691412] bricks = 5 ladders = 1\n    **Output:** 4\n    **Explanation:** Starting at building 0 you can follow these steps:\n    - Go to building 1 without using ladders nor bricks since 4 >= 2.\n    - Go to building 2 using 5 bricks. You must use either bricks or ladders because 2 < 7.\n    - Go to building 3 without using ladders nor bricks since 7 >= 6.\n    - Go to building 4 using your only ladder. You must use either bricks or ladders because 6 < 9.\n    It is impossible to go beyond building 4 because you do not have any more bricks or ladders.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** heights = [4122731820319] bricks = 10 ladders = 2\n    **Output:** 7\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** heights = [143193] bricks = 17 ladders = 0\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= heights.length <= 105`\n  * `1 <= heights[i] <= 106`\n  * `0 <= bricks <= 109`\n  * `0 <= ladders <= heights.length`\n\n,class Solution:\n    def furthestBuilding(self H: List[int] B: int L: int) -> int:\n        heap = []\n        for i in range(len(H) - 1):\n            diff = H[i+1] - H[i]\n            if diff > 0:\n                if L > 0:\n                    heappush(heap diff)\n                    L -= 1\n                elif heap and diff > heap[0]:\n                    heappush(heap diff)\n                    B -= heappop(heap)\n                else: B -= diff\n                if B < 0: return i\n        return len(H) - 1\n
Gas Station,###  134\. Gas Station\n\nThere are `n` gas stations along a circular route where the amount of gas at\nthe `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to\ntravel from the `ith` station to its next `(i + 1)th` station. You begin the\njourney with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost` return _the starting gas station's\nindex if you can travel around the circuit once in the clockwise direction\notherwise return_ `-1`. If there exists a solution it is **guaranteed** to be\n**unique**\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** gas = [12345] cost = [34512]\n    **Output:** 3\n    **Explanation:**\n    Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n    Travel to station 4. Your tank = 4 - 1 + 5 = 8\n    Travel to station 0. Your tank = 8 - 2 + 1 = 7\n    Travel to station 1. Your tank = 7 - 3 + 2 = 6\n    Travel to station 2. Your tank = 6 - 4 + 3 = 5\n    Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\n    Therefore return 3 as the starting index.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** gas = [234] cost = [343]\n    **Output:** -1\n    **Explanation:**\n    You can't start at station 0 or 1 as there is not enough gas to travel to the next station.\n    Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\n    Travel to station 0. Your tank = 4 - 3 + 2 = 3\n    Travel to station 1. Your tank = 3 - 3 + 3 = 3\n    You cannot travel back to station 2 as it requires 4 unit of gas but you only have 3.\n    Therefore you can't travel around the circuit once no matter where you start.\n    \n\n\n\n**Constraints:**\n\n  * `n == gas.length == cost.length`\n  * `1 <= n <= 105`\n  * `0 <= gas[i] cost[i] <= 104`\n\n,class Solution:\n    def canCompleteCircuit(self gas: List[int] cost: List[int]) -> int:\n        deltas = [x-y for x y in zip(gas cost)]\n        n = len(deltas)\n        deltas = deltas + deltas\n        cursum curi = 0 0\n        maxsum maxi = 0 0\n        for i delta in enumerate(deltas):\n            cursum = max(0 cursum + delta)\n            if cursum == 0:\n                curi = i+1\n            if cursum > maxsum:\n                maxi = curi\n                maxsum = cursum\n        cursum = 0\n        for i in range(n):\n            cursum += deltas[(maxi+i)%n]\n            if cursum < 0: return -1\n        return maxi
Generate Parentheses,"###  22\. Generate Parentheses\n\nGiven `n` pairs of parentheses write a function to _generate all combinations\nof well-formed parentheses_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** [""((()))""""(()())""""(())()""""()(())""""()()()""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** [""()""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 8`\n\n","class Solution:\n    def generateParenthesis(self n: int) -> list[str]:\n\n        # Initialize the result\n        res = []\n\n        # Recursively go through all possible combinations\n        def add(open close partialRes):\n\n            nonlocal res\n\n            # If we have added opening and closing parentheses n times we reaches a solution\n            if open == close == n:\n                res.append("""".join(partialRes))\n                return\n\n            # Add a closing parenthesis to the partial result if we have at least 1 opening parenthesis\n            if close < open:\n                add(open close + 1 partialRes + ["")""])\n\n            # Add an opening parenthesis to the partial result if we haven't added n parenthesis yet\n            if open < n:\n                add(open + 1 close partialRes + [""(""])\n\n        add(0 0 [])\n\n        return res\n"
Generate Random Point in a Circle,"###  478\. Generate Random Point in a Circle\n\nGiven the radius and the position of the center of a circle implement the\nfunction `randPoint` which generates a uniform random point inside the circle.\n\nImplement the `Solution` class:\n\n  * `Solution(double radius double x_center double y_center)` initializes the object with the radius of the circle `radius` and the position of the center `(x_center y_center)`.\n  * `randPoint()` returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array `[x y]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Solution"" ""randPoint"" ""randPoint"" ""randPoint""]\n    [[1.0 0.0 0.0] [] [] []]\n    **Output**\n    [null [-0.02493 -0.38077] [0.82314 0.38945] [0.36572 0.17248]]\n    \n    **Explanation**\n    Solution solution = new Solution(1.0 0.0 0.0);\n    solution.randPoint(); // return [-0.02493 -0.38077]\n    solution.randPoint(); // return [0.82314 0.38945]\n    solution.randPoint(); // return [0.36572 0.17248]\n    \n\n\n\n**Constraints:**\n\n  * `0 < radius <= 108`\n  * `-107 <= x_center y_center <= 107`\n  * At most `3 * 104` calls will be made to `randPoint`.\n\n",class Solution:\n\n    def __init__(self radius: float x_center: float y_center: float):\n        self.rad = radius\n        self.xc = x_center\n        self.yc = y_center\n\n    def randPoint(self) -> List[float]:\n        while True:\n            xg=self.xc+random.uniform(-1 1)*self.rad*2\n            yg=self.yc+random.uniform(-1 1)*self.rad*2\n            if (xg-self.xc)**2 + (yg-self.yc)**2 <= self.rad**2:\n                return [xg yg]\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius x_center y_center)\n# param_1 = obj.randPoint()\n
Get Biggest Three Rhombus Sums in a Grid,###  1878\. Get Biggest Three Rhombus Sums in a Grid\n\nYou are given an `m x n` integer matrix `grid`​​​.\n\nA **rhombus sum** is the sum of the elements that form **the** **border** of a\nregular rhombus shape in `grid`​​​. The rhombus must have the shape of a\nsquare rotated 45 degrees with each of the corners centered in a grid cell.\nBelow is an image of four valid rhombus shapes with the corresponding colored\ncells that should be included in each **rhombus sum** :\n\n![](https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-desc-2.png)\n\nNote that the rhombus can have an area of 0 which is depicted by the purple\nrhombus in the bottom right corner.\n\nReturn _the biggest three**distinct rhombus sums** in the _`grid`\n_in**descending order**_ _. If there are less than three distinct values\nreturn all of them_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex1.png)\n\n    \n    \n    **Input:** grid = [[34513][33423][20302004010][15541][43225]]\n    **Output:** [228216211]\n    **Explanation:** The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n    - Blue: 20 + 3 + 200 + 5 = 228\n    - Red: 200 + 2 + 10 + 4 = 216\n    - Green: 5 + 200 + 4 + 2 = 211\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/23/pc73-q4-ex2.png)\n\n    \n    \n    **Input:** grid = [[123][456][789]]\n    **Output:** [2098]\n    **Explanation:** The rhombus shapes for the three biggest distinct rhombus sums are depicted above.\n    - Blue: 4 + 2 + 6 + 8 = 20\n    - Red: 9 (area 0 rhombus in the bottom right corner)\n    - Green: 8 (area 0 rhombus in the bottom middle)\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[777]]\n    **Output:** [7]\n    **Explanation:** All three possible rhombus sums are the same so return [7].\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 50`\n  * `1 <= grid[i][j] <= 105`\n\n,class Solution:\ndef getBiggestThree(self grid: List[List[int]]) -> List[int]:\n    \n    def calc(lrud):\n        sc=0\n        c1=c2=(l+r)//2\n        expand=True\n        for row in range(ud+1):\n            if c1==c2:\n                sc+=grid[row][c1]\n            else:\n                sc+=grid[row][c1]+grid[row][c2]\n            \n            if c1==l:\n                expand=False\n            \n            if expand:\n                c1-=1\n                c2+=1\n            else:\n                c1+=1\n                c2-=1\n        return sc\n        \n    \n    m=len(grid)\n    n=len(grid[0])\n    heap=[]\n    for i in range(m):\n        for j in range(n):\n            l=r=j\n            d=i\n            while l>=0 and r<=n-1 and d<=m-1:\n                sc=calc(lrid)\n                l-=1\n                r+=1\n                d+=2\n                if len(heap)<3:\n                    if sc not in heap:\n                        heapq.heappush(heapsc)\n                else:\n                    if sc not in heap and sc>heap[0]:\n                        heapq.heappop(heap)\n                        heapq.heappush(heapsc)\n    \n    heap.sort(reverse=True)\n    return heap\n
Get Equal Substrings Within Budget,"###  1208\. Get Equal Substrings Within Budget\n\nYou are given two strings `s` and `t` of the same length and an integer\n`maxCost`.\n\nYou want to change `s` to `t`. Changing the `ith` character of `s` to `ith`\ncharacter of `t` costs `|s[i] - t[i]|` (i.e. the absolute difference between\nthe ASCII values of the characters).\n\nReturn _the maximum length of a substring of_`s` _that can be changed to be\nthe same as the corresponding substring of_`t` _with a cost less than or equal\nto_`maxCost`. If there is no substring from `s` that can be changed to its\ncorresponding substring from `t` return `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcd"" t = ""bcdf"" maxCost = 3\n    **Output:** 3\n    **Explanation:** ""abc"" of s can change to ""bcd"".\n    That costs 3 so the maximum length is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcd"" t = ""cdef"" maxCost = 3\n    **Output:** 1\n    **Explanation:** Each character in s costs 2 to change to character in t  so the maximum length is 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""abcd"" t = ""acde"" maxCost = 0\n    **Output:** 1\n    **Explanation:** You cannot make any change so the maximum length is 1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `t.length == s.length`\n  * `0 <= maxCost <= 106`\n  * `s` and `t` consist of only lowercase English letters.\n\n","class Solution(object):\n    def equalSubstring(self s t maxCost):\n        """"""\n        :type s: str\n        :type t: str\n        :type maxCost: int\n        :rtype: int\n        """"""\n        \n        \n        \n        \n        best = 0\n        \n        windowCost = 0\n        l = 0\n        for r in range(len(s)):\n            \n            windowCost += abs(ord(s[r]) - ord(t[r]))\n            \n            while windowCost > maxCost:\n                \n                windowCost -= abs(ord(s[l]) - ord(t[l]))\n                l+=1\n                \n            best = max(bestr-l+1)\n            \n        return best\n                \n            \n            \n\n"
Get Maximum in Generated Array,###  1646\. Get Maximum in Generated Array\n\nYou are given an integer `n`. A **0-indexed** integer array `nums` of length\n`n + 1` is generated in the following way:\n\n  * `nums[0] = 0`\n  * `nums[1] = 1`\n  * `nums[2 * i] = nums[i]` when `2 <= 2 * i <= n`\n  * `nums[2 * i + 1] = nums[i] + nums[i + 1]` when `2 <= 2 * i + 1 <= n`\n\nReturn****_the**maximum** integer in the array _`nums`​​​.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 7\n    **Output:** 3\n    **Explanation:** According to the given rules:\n      nums[0] = 0\n      nums[1] = 1\n      nums[(1 * 2) = 2] = nums[1] = 1\n      nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\n      nums[(2 * 2) = 4] = nums[2] = 1\n      nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\n      nums[(3 * 2) = 6] = nums[3] = 2\n      nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\n    Hence nums = [01121323] and the maximum is max(01121323) = 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 1\n    **Explanation:** According to the given rules nums = [011]. The maximum is max(011) = 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** 2\n    **Explanation:** According to the given rules nums = [0112]. The maximum is max(0112) = 2.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 100`\n\n,// Runtime: 34 ms (Top 84.4%) | Memory: 17.50 MB (Top 12.64%)\n\nfrom queue import deque\n\nclass Solution:\n    def getMaximumGenerated(self n: int) -> int:\n        \n        def arrgen(n):\n            yield 0\n            q = deque([1])\n            while True:\n                yield q[0]\n                q.append(q[0])\n                q.append(q[0]+q[1])\n                q.popleft()\n                \n        g = arrgen(n)\n        return max(next(g) for _ in range(n+1))
Get the Maximum Score,###  1537\. Get the Maximum Score\n\nYou are given two **sorted** arrays of distinct integers `nums1` and `nums2.`\n\nA **valid** __** path** is defined as follows:\n\n  * Choose array `nums1` or `nums2` to traverse (from index-0).\n  * Traverse the current array from left to right.\n  * If you are reading any value that is present in `nums1` and `nums2` you are allowed to change your path to the other array. (Only one repeated value is considered in the valid path).\n\nThe **score** is defined as the sum of uniques values in a valid path.\n\nReturn _the maximum score you can obtain of all possible**valid paths**_.\nSince the answer may be too large return it modulo `109 + 7`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/07/16/sample_1_1893.png)\n\n    \n    \n    **Input:** nums1 = [245810] nums2 = [4689]\n    **Output:** 30\n    **Explanation:** Valid paths:\n    [245810] [24589] [24689] [246810]  (starting from nums1)\n    [4689] [45810] [4589] [46810]    (starting from nums2)\n    The maximum is obtained with the path in green **[246810]**.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [13579] nums2 = [35100]\n    **Output:** 109\n    **Explanation:** Maximum sum is obtained with the path **[135100]**.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [12345] nums2 = [678910]\n    **Output:** 40\n    **Explanation:** There are no common elements between nums1 and nums2.\n    Maximum sum is obtained with the path [678910].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 105`\n  * `1 <= nums1[i] nums2[i] <= 107`\n  * `nums1` and `nums2` are strictly increasing.\n\n,from itertools import accumulate\nclass Solution:\n    def maxSum(self nums1: List[int] nums2: List[int]) -> int:\n        acc1 = list(accumulate(nums1 initial = 0))\n        acc2 = list(accumulate(nums2 initial = 0))\n        i j = len(nums1)-1 len(nums2)-1\n        previ prevj = len(nums1) len(nums2)\n        prev_maxscore = 0\n        while i >= 0 and j >= 0:\n            while i >= 0 and j >= 0 and nums1[i] < nums2[j]:\n                j -= 1\n            if i >= 0 and j >= 0 and nums1[i] == nums2[j]:\n                prev_maxscore += max(acc1[previ]-acc1[i] acc2[prevj]-acc2[j])\n                previ prevj = i j\n                i -= 1\n                j -= 1\n            while i >= 0 and j >= 0 and nums2[j] < nums1[i]:\n                i -= 1\n            if  i >= 0 and j >= 0 and nums1[i] == nums2[j]:\n                prev_maxscore += max(acc1[previ]-acc1[i] acc2[prevj]-acc2[j])\n                previ prevj = i j\n                i -= 1\n                j -= 1\n        prev_maxscore += max(acc1[previ]-acc1[0] acc2[prevj]-acc2[0])\n        return prev_maxscore % (10**9 + 7)\n
Get Watched Videos by Your Friends,"###  1311\. Get Watched Videos by Your Friends\n\nThere are `n` people each person has a unique _id_ between `0` and `n-1`.\nGiven the arrays `watchedVideos` and `friends` where `watchedVideos[i]` and\n`friends[i]` contain the list of watched videos and the list of friends\nrespectively for the person with `id = i`.\n\nLevel **1** of videos are all watched videos by your friends level **2** of\nvideos are all watched videos by the friends of your friends and so on. In\ngeneral the level `k` of videos are all watched videos by people with the\nshortest path **exactly** equal to `k` with you. Given your `id` and the\n`level` of videos return the list of videos ordered by their frequencies\n(increasing). For videos with the same frequency order them alphabetically\nfrom least to greatest.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/01/02/leetcode_friends_1.png)**\n\n    \n    \n    **Input:** watchedVideos = [[""A""""B""][""C""][""B""""C""][""D""]] friends = [[12][03][03][12]] id = 0 level = 1\n    **Output:** [""B""""C""] \n    **Explanation:** \n    You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):\n    Person with id = 1 -> watchedVideos = [""C""] \n    Person with id = 2 -> watchedVideos = [""B""""C""] \n    The frequencies of watchedVideos by your friends are: \n    B -> 1 \n    C -> 2\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2020/01/02/leetcode_friends_2.png)**\n\n    \n    \n    **Input:** watchedVideos = [[""A""""B""][""C""][""B""""C""][""D""]] friends = [[12][03][03][12]] id = 0 level = 2\n    **Output:** [""D""]\n    **Explanation:** \n    You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).\n    \n\n\n\n**Constraints:**\n\n  * `n == watchedVideos.length == friends.length`\n  * `2 <= n <= 100`\n  * `1 <= watchedVideos[i].length <= 100`\n  * `1 <= watchedVideos[i][j].length <= 8`\n  * `0 <= friends[i].length < n`\n  * `0 <= friends[i][j] < n`\n  * `0 <= id < n`\n  * `1 <= level < n`\n  * if `friends[i]` contains `j` then `friends[j]` contains `i`\n\n","class Solution:\n	def watchedVideosByFriends(self watchedVideos: List[List[str]] friends: List[List[int]] id: int level: int) -> List[str]:\n		q=[id]\n		vis=set([id])\n		l=0\n		while l<level:\n			new_q=[]\n			for x in q:\n				for friend in friends[x]:\n					if not friend in vis:\n						vis.add(friend)\n						new_q.append(friend)\n			q=new_q\n			l+=1\n		a=Counter()\n		for x in q:\n			for vids in watchedVideos[x]:\n				a[vids]+=1\n		A=sorted([[a[x]x] for x in a])\n		return [x[1] for x in A]"
Global and Local Inversions,###  775\. Global and Local Inversions\n\nYou are given an integer array `nums` of length `n` which represents a\npermutation of all the integers in the range `[0 n - 1]`.\n\nThe number of **global inversions** is the number of the different pairs `(i\nj)` where:\n\n  * `0 <= i < j < n`\n  * `nums[i] > nums[j]`\n\nThe number of **local inversions** is the number of indices `i` where:\n\n  * `0 <= i < n - 1`\n  * `nums[i] > nums[i + 1]`\n\nReturn `true` _if the number of**global inversions** is equal to the number of\n**local inversions**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [102]\n    **Output:** true\n    **Explanation:** There is 1 global inversion and 1 local inversion.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [120]\n    **Output:** false\n    **Explanation:** There are 2 global inversions and 1 local inversion.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 105`\n  * `0 <= nums[i] < n`\n  * All the integers of `nums` are **unique**.\n  * `nums` is a permutation of all the numbers in the range `[0 n - 1]`.\n\n,// Runtime: 620 ms (Top 99.42%) | Memory: 31.10 MB (Top 5.81%)\n\nclass Solution:\n    def isIdealPermutation(self A: List[int]) -> bool:\n        for i in range(len(A)):\n            if i - A[i] > 1 or i - A[i] < -1: return False\n        return True\n
Goal Parser Interpretation,"###  1678\. Goal Parser Interpretation\n\nYou own a **Goal Parser** that can interpret a string `command`. The `command`\nconsists of an alphabet of `""G""` `""()""` and/or `""(al)""` in some order. The\nGoal Parser will interpret `""G""` as the string `""G""` `""()""` as the string\n`""o""` and `""(al)""` as the string `""al""`. The interpreted strings are then\nconcatenated in the original order.\n\nGiven the string `command` return _the**Goal Parser** 's interpretation of\n_`command`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** command = ""G()(al)""\n    **Output:** ""Goal""\n    **Explanation:**  The Goal Parser interprets the command as follows:\n    G -> G\n    () -> o\n    (al) -> al\n    The final concatenated result is ""Goal"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** command = ""G()()()()(al)""\n    **Output:** ""Gooooal""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** command = ""(al)G(al)()()G""\n    **Output:** ""alGalooG""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= command.length <= 100`\n  * `command` consists of `""G""` `""()""` and/or `""(al)""` in some order.\n\n",class Solution:\n    def interpret(self command: str) -> str:\n        return command.replace('()''o').replace('(al)''al')\n
Goat Latin,"###  824\. Goat Latin\n\nYou are given a string `sentence` that consist of words separated by spaces.\nEach word consists of lowercase and uppercase letters only.\n\nWe would like to convert the sentence to ""Goat Latin"" (a made-up language\nsimilar to Pig Latin.) The rules of Goat Latin are as follows:\n\n  * If a word begins with a vowel (`'a'` `'e'` `'i'` `'o'` or `'u'`) append `""ma""` to the end of the word. \n    * For example the word `""apple""` becomes `""applema""`.\n  * If a word begins with a consonant (i.e. not a vowel) remove the first letter and append it to the end then add `""ma""`. \n    * For example the word `""goat""` becomes `""oatgma""`.\n  * Add one letter `'a'` to the end of each word per its word index in the sentence starting with `1`. \n    * For example the first word gets `""a""` added to the end the second word gets `""aa""` added to the end and so on.\n\nReturn _the final sentence representing the conversion from sentence to Goat\nLatin_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** sentence = ""I speak Goat Latin""\n    **Output:** ""Imaa peaksmaaa oatGmaaaa atinLmaaaaa""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** sentence = ""The quick brown fox jumped over the lazy dog""\n    **Output:** ""heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= sentence.length <= 150`\n  * `sentence` consists of English letters and spaces.\n  * `sentence` has no leading or trailing spaces.\n  * All the words in `sentence` are separated by a single space.\n\n","class Solution:\n    def toGoatLatin(self sentence: str) -> str:\n        wordList result index = sentence.split(' ') """" 1\n        for word in wordList:\n            if index > 1:\n                result += "" ""\n            firstLetter = word[0]\n            if firstLetter in 'aeiouAEIOU':\n                result += word + ""ma""\n            else:\n                result += word[1:] + firstLetter + ""ma""\n            for i in range(index):\n                result += 'a'\n            index += 1\n        return result\n"
Graph Connectivity With Threshold,###  1627\. Graph Connectivity With Threshold\n\nWe have `n` cities labeled from `1` to `n`. Two different cities with labels\n`x` and `y` are directly connected by a bidirectional road if and only if `x`\nand `y` share a common divisor **strictly greater** than some `threshold`.\nMore formally cities with labels `x` and `y` have a road between them if\nthere exists an integer `z` such that all of the following are true:\n\n  * `x % z == 0`\n  * `y % z == 0` and\n  * `z > threshold`.\n\nGiven the two integers `n` and `threshold` and an array of `queries` you\nmust determine for each `queries[i] = [ai bi]` if cities `ai` and `bi` are\nconnected directly or indirectly. (i.e. there is some path between them).\n\nReturn _an array_`answer` _ where_`answer.length == queries.length`\n_and_`answer[i]`_is_`true` _if for the_`ith` _query there is a path\nbetween_`ai` _and_`bi` _ or_`answer[i]`_is_`false` _if there is no path._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/09/ex1.jpg)\n\n    \n    \n    **Input:** n = 6 threshold = 2 queries = [[14][25][36]]\n    **Output:** [falsefalsetrue]\n    **Explanation:** The divisors for each number:\n    1:   1\n    2:   1 2\n    3:   1 _3_\n    4:   1 2 _4_\n    5:   1 _5_\n    6:   1 2 _3_  _6_\n    Using the underlined divisors above the threshold only cities 3 and 6 share a common divisor so they are the\n    only ones directly connected. The result of each query:\n    [14]   1 is not connected to 4\n    [25]   2 is not connected to 5\n    [36]   3 is connected to 6 through path 3--6\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/10/tmp.jpg)\n\n    \n    \n    **Input:** n = 6 threshold = 0 queries = [[45][34][32][26][13]]\n    **Output:** [truetruetruetruetrue]\n    **Explanation:** The divisors for each number are the same as the previous example. However since the threshold is 0\n    all divisors can be used. Since all numbers share 1 as a divisor all cities are connected.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/10/17/ex3.jpg)\n\n    \n    \n    **Input:** n = 5 threshold = 1 queries = [[45][45][32][23][34]]\n    **Output:** [falsefalsefalsefalsefalse]\n    **Explanation:** Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1 so they are the only ones directly connected.\n    Please notice that there can be multiple queries for the same pair of nodes [x y] and that the query [x y] is equivalent to the query [y x].\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 104`\n  * `0 <= threshold <= n`\n  * `1 <= queries.length <= 105`\n  * `queries[i].length == 2`\n  * `1 <= ai bi <= cities`\n  * `ai != bi`\n\n,# Runtime: 881 ms (Top 97.89%) | Memory: 49.3 MB (Top 35.92%)\nclass Solution:\n    def areConnected(self n: int threshold: int queries: List[List[int]]) -> List[bool]:\n        parent = list(range(n+1))\n        def find(i):\n            if parent[i] != i:\n                parent[i] = find(parent[i])\n            return parent[i]\n        def union(ij):\n            parent[find(i)] = find(j)\n        if not threshold: return [True]*len(queries)\n        for i in range(1 n+1):\n            for j in range(2*i n+1 i):\n                if i > threshold: union(ij)\n        return [find(i) == find(j) for ij in queries]
Gray Code,###  89\. Gray Code\n\nAn **n-bit gray code sequence** is a sequence of `2n` integers where:\n\n  * Every integer is in the **inclusive** range `[0 2n - 1]`\n  * The first integer is `0`\n  * An integer appears **no more than once** in the sequence\n  * The binary representation of every pair of **adjacent** integers differs by **exactly one bit**  and\n  * The binary representation of the **first** and **last** integers differs by **exactly one bit**.\n\nGiven an integer `n` return _any valid**n-bit gray code sequence**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** [0132]\n    **Explanation:**\n    The binary representation of [0132] is [00011110].\n    - 0 _0_ and 0 _1_ differ by one bit\n    - _0_ 1 and _1_ 1 differ by one bit\n    - 1 _1_ and 1 _0_ differ by one bit\n    - _1_ 0 and _0_ 0 differ by one bit\n    [0231] is also a valid gray code sequence whose binary representation is [00101101].\n    - _0_ 0 and _1_ 0 differ by one bit\n    - 1 _0_ and 1 _1_ differ by one bit\n    - _1_ 1 and _0_ 1 differ by one bit\n    - 0 _1_ and 0 _0_ differ by one bit\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** [01]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 16`\n\n,"import math\nclass Solution(object):\n    def grayCode(self n):\n        """"""\n        :type n: int\n        :rtype: List[int]\n        """"""\n        allowedDiffs = [int(1*math.pow(2i)) for i in range(0n)]\n        grayCodes = [0]\n        for diff in allowedDiffs:\n            grayCodes += [code + diff for code in reversed(grayCodes)]\n        return grayCodes\n"
Greatest Common Divisor of Strings,"###  1071\. Greatest Common Divisor of Strings\n\nFor two strings `s` and `t` we say ""`t` divides `s`"" if and only if `s = t +\n... + t` (i.e. `t` is concatenated with itself one or more times).\n\nGiven two strings `str1` and `str2` return _the largest string_`x` _such\nthat_`x` _divides both_`str1` _and_`str2`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** str1 = ""ABCABC"" str2 = ""ABC""\n    **Output:** ""ABC""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** str1 = ""ABABAB"" str2 = ""ABAB""\n    **Output:** ""AB""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** str1 = ""LEET"" str2 = ""CODE""\n    **Output:** """"\n    \n\n\n\n**Constraints:**\n\n  * `1 <= str1.length str2.length <= 1000`\n  * `str1` and `str2` consist of English uppercase letters.\n\n","# Runtime: 85 ms (Top 15.89%) | Memory: 14 MB (Top 5.19%)\nclass Solution:\n    def gcdOfStrings(self str1: str str2: str) -> str:\n\n        if len(str2) > len(str1):\n            str1 str2 = str2 str1\n\n        curr_str2 = str2\n        while True:\n\n            rep = len(str1)//len(curr_str2)\n\n            if curr_str2*rep == str1:\n                return curr_str2\n\n            found = False\n            for i in range(len(curr_str2)-1 1 -1):\n                try_str2 = curr_str2[:i]\n                rep2 = len(str2)//len(try_str2)\n\n                if try_str2*rep2 == str2:\n                    curr_str2 = try_str2\n                    found = True\n                    break\n\n            if not found:\n                break\n        return """""
Greatest Sum Divisible by Three,###  1262\. Greatest Sum Divisible by Three\n\nGiven an integer array `nums` return _the**maximum possible sum** of elements\nof the array such that it is divisible by three_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [36518]\n    **Output:** 18\n    **Explanation:** Pick numbers 3 6 1 and 8 their sum is 18 (maximum sum divisible by 3).\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [4]\n    **Output:** 0\n    **Explanation:** Since 4 is not divisible by 3 do not pick any number.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [12344]\n    **Output:** 12\n    **Explanation:** Pick numbers 1 3 4 and 4 their sum is 12 (maximum sum divisible by 3).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 4 * 10^4`\n  * `1 <= nums[i] <= 10^4`\n\n,// Runtime: 190 ms (Top 92.53%) | Memory: 22.10 MB (Top 78.57%)\n\nfrom math import inf\n\n\nclass Solution:\n    def maxSumDivThree(self nums: List[int]) -> int:\n        res = 0\n        r1_min1 = inf\n        r1_min2 = inf\n        r2_min1 = inf\n        r2_min2 = inf\n\n        for v in nums:\n            res += v\n            if v % 3 == 1:\n                if v < r1_min1:\n                    r1_min2 = r1_min1\n                    r1_min1 = v\n                elif v < r1_min2:\n                    r1_min2 = v\n            elif v % 3 == 2:\n                if v < r2_min1:\n                    r2_min2 = r2_min1\n                    r2_min1 = v\n                elif v < r2_min2:\n                    r2_min2 = v\n\n        if res % 3 == 1:\n            res -= min(r1_min1 r2_min1 + r2_min2)\n        elif res % 3 == 2:\n            res -= min(r2_min1 r1_min1 + r1_min2)\n\n        return res\n
Grid Game,###  2017\. Grid Game\n\nYou are given a **0-indexed** 2D array `grid` of size `2 x n` where\n`grid[r][c]` represents the number of points at position `(r c)` on the\nmatrix. Two robots are playing a game on this matrix.\n\nBoth robots initially start at `(0 0)` and want to reach `(1 n-1)`. Each\nrobot may only move to the **right** (`(r c)` to `(r c + 1)`) or\n**down**(`(r c)` to `(r + 1 c)`).\n\nAt the start of the game the **first** robot moves from `(0 0)` to `(1\nn-1)` collecting all the points from the cells on its path. For all cells\n`(r c)` traversed on the path `grid[r][c]` is set to `0`. Then the\n**second** robot moves from `(0 0)` to `(1 n-1)` collecting the points on\nits path. Note that their paths may intersect with one another.\n\nThe **first** robot wants to **minimize** the number of points collected by\nthe **second** robot. In contrast the **second** robot wants to **maximize**\nthe number of points it collects. If both robots play **optimally**  return\n_the**number of points** collected by the **second** robot._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/09/08/a1.png)\n\n    \n    \n    **Input:** grid = [[254][151]]\n    **Output:** 4\n    **Explanation:** The optimal path taken by the first robot is shown in red and the optimal path taken by the second robot is shown in blue.\n    The cells visited by the first robot are set to 0.\n    The second robot will collect 0 + 0 + 4 + 0 = 4 points.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/09/08/a2.png)\n\n    \n    \n    **Input:** grid = [[331][852]]\n    **Output:** 4\n    **Explanation:** The optimal path taken by the first robot is shown in red and the optimal path taken by the second robot is shown in blue.\n    The cells visited by the first robot are set to 0.\n    The second robot will collect 0 + 3 + 1 + 0 = 4 points.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/09/08/a3.png)\n\n    \n    \n    **Input:** grid = [[13115][1331]]\n    **Output:** 7\n    **Explanation:** The optimal path taken by the first robot is shown in red and the optimal path taken by the second robot is shown in blue.\n    The cells visited by the first robot are set to 0.\n    The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.\n    \n\n\n\n**Constraints:**\n\n  * `grid.length == 2`\n  * `n == grid[r].length`\n  * `1 <= n <= 5 * 104`\n  * `1 <= grid[r][c] <= 105`\n\n,# Runtime: 2175 ms (Top 21.39%) | Memory: 30.5 MB (Top 29.48%)\n\nclass Solution:\n    def gridGame(self g: List[List[int]]) -> int:\n        top bottom res = sum(g[0]) 0 math.inf\n        for g0 g1 in zip(g[0] g[1]):\n            top -= g0\n            res = min(res max(top bottom))\n            bottom += g1\n        return res
Grid Illumination,###  1001\. Grid Illumination\n\nThere is a 2D `grid` of size `n x n` where each cell of this grid has a lamp\nthat is initially **turned off**.\n\nYou are given a 2D array of lamp positions `lamps` where `lamps[i] = [rowi\ncoli]` indicates that the lamp at `grid[rowi][coli]` is **turned on**. Even if\nthe same lamp is listed more than once it is turned on.\n\nWhen a lamp is turned on it **illuminates its cell** and **all other cells**\nin the same **row column or diagonal**.\n\nYou are also given another 2D array `queries` where `queries[j] = [rowj\ncolj]`. For the `jth` query determine whether `grid[rowj][colj]` is\nilluminated or not. After answering the `jth` query **turn off** the lamp at\n`grid[rowj][colj]` and its **8 adjacent lamps** if they exist. A lamp is\nadjacent if its cell shares either a side or corner with `grid[rowj][colj]`.\n\nReturn _an array of integers_`ans` ___where_`ans[j]`_should be_`1` _if the\ncell in the_`jth` _query was illuminated or_`0` _if the lamp was not._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/19/illu_1.jpg)\n\n    \n    \n    **Input:** n = 5 lamps = [[00][44]] queries = [[11][10]]\n    **Output:** [10]\n    **Explanation:** We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid[0][0] then turning on the lamp at grid[4][4].\n    The 0th query asks if the lamp at grid[1][1] is illuminated or not (the blue square). It is illuminated so set ans[0] = 1. Then we turn off all lamps in the red square.\n    ![](https://assets.leetcode.com/uploads/2020/08/19/illu_step1.jpg)\n    The 1st query asks if the lamp at grid[1][0] is illuminated or not (the blue square). It is not illuminated so set ans[1] = 0. Then we turn off all lamps in the red rectangle.\n    ![](https://assets.leetcode.com/uploads/2020/08/19/illu_step2.jpg)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 5 lamps = [[00][44]] queries = [[11][11]]\n    **Output:** [11]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 5 lamps = [[00][04]] queries = [[04][01][14]]\n    **Output:** [110]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n  * `0 <= lamps.length <= 20000`\n  * `0 <= queries.length <= 20000`\n  * `lamps[i].length == 2`\n  * `0 <= rowi coli < n`\n  * `queries[j].length == 2`\n  * `0 <= rowj colj < n`\n\n,class Solution:\n    def gridIllumination(self n: int lamps: List[List[int]] queries: List[List[int]]) -> List[int]:\n        rows = collections.Counter()\n        cols = collections.Counter()\n        diags1 = collections.Counter()\n        diags2 = collections.Counter()\n        lamps = {tuple(lamp) for lamp in lamps}\n        \n        for i j in lamps:\n            rows[i] += 1\n            cols[j] += 1\n            diags1[i + j] += 1\n            diags2[i - j] += 1\n        \n        ans = []\n        directions = ((-1 -1) (-1 0) (-1 1)\n                      (0 -1) (0 0) (0 1)\n                      (1 -1) (1 0) (1 1))\n        \n        for i j in queries:\n            if rows[i] or cols[j] or diags1[i + j] or diags2[i - j]:\n                ans.append(1)\n            else:\n                ans.append(0)\n            \n            for di dj in directions:\n                newI newJ = i + di j + dj\n                if (newI newJ) not in lamps:\n                    continue\n                lamps.remove((newI newJ))\n                rows[newI] -= 1\n                cols[newJ] -= 1\n                diags1[newI + newJ] -= 1\n                diags2[newI - newJ] -= 1\n        \n        return ans
Group Anagrams,"###  49\. Group Anagrams\n\nGiven an array of strings `strs` group **the anagrams** together. You can\nreturn the answer in **any order**.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a\ndifferent word or phrase typically using all the original letters exactly\nonce.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** strs = [""eat""""tea""""tan""""ate""""nat""""bat""]\n    **Output:** [[""bat""][""nat""""tan""][""ate""""eat""""tea""]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** strs = [""""]\n    **Output:** [[""""]]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** strs = [""a""]\n    **Output:** [[""a""]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= strs.length <= 104`\n  * `0 <= strs[i].length <= 100`\n  * `strs[i]` consists of lowercase English letters.\n\n",class Solution:\n    def groupAnagrams(self strs: List[str]) -> List[List[str]]:\n        strs_table = {}\n\n        for string in strs:\n            sorted_string = ''.join(sorted(string))\n\n            if sorted_string not in strs_table:\n                strs_table[sorted_string] = []\n\n            strs_table[sorted_string].append(string)\n\n        return list(strs_table.values())\n
Group the People Given the Group Size They Belong To,###  1282\. Group the People Given the Group Size They Belong To\n\nThere are `n` people that are split into some unknown number of groups. Each\nperson is labeled with a **unique ID**  from `0` to `n - 1`.\n\nYou are given an integer array `groupSizes` where `groupSizes[i]` is the size\nof the group that person `i` is in. For example if `groupSizes[1] = 3` then\nperson `1` must be in a group of size `3`.\n\nReturn _a list of groups  such that each person `i` is in a group of size\n`groupSizes[i]`_.\n\nEach person should appear in **exactly one group**  and every person must be\nin a group. If there are multiple answers **return any of them**. It is\n**guaranteed** that there will be **at least one** valid solution for the\ngiven input.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** groupSizes = [3333313]\n    **Output:** [[5][012][346]]\n    **Explanation:** \n    The first group is [5]. The size is 1 and groupSizes[5] = 1.\n    The second group is [012]. The size is 3 and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.\n    The third group is [346]. The size is 3 and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.\n    Other possible solutions are [[216][5][043]] and [[5][062][431]].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** groupSizes = [213332]\n    **Output:** [[1][05][234]]\n    \n\n\n\n**Constraints:**\n\n  * `groupSizes.length == n`\n  * `1 <= n <= 500`\n  * `1 <= groupSizes[i] <= n`\n\n,"# Runtime: 75 ms (Top 97.76%) | Memory: 14 MB (Top 88.55%)\nclass Solution(object):\n    def groupThePeople(self groupSizes):\n        """"""\n        :type groupSizes: List[int]\n        :rtype: List[List[int]]\n        """"""\n        dict_group={}\n        for i in range(len(groupSizes)):\n            if groupSizes[i] not in dict_group:\n                dict_group[groupSizes[i]]=[i]\n            else:\n                dict_group[groupSizes[i]].append(i)\n        return_list=[]\n        for i in dict_group:\n            num_list=dict_group[i]\n            for j in range(0len(num_list)i):\n                return_list.append(num_list[j:j+i])\n        return return_list"
Groups of Special-Equivalent Strings,"###  893\. Groups of Special-Equivalent Strings\n\nYou are given an array of strings of the same length `words`.\n\nIn one **move**  you can swap any two even indexed characters or any two odd\nindexed characters of a string `words[i]`.\n\nTwo strings `words[i]` and `words[j]` are **special-equivalent** if after any\nnumber of moves `words[i] == words[j]`.\n\n  * For example `words[i] = ""zzxy""` and `words[j] = ""xyzz""` are **special-equivalent** because we may make the moves `""zzxy"" -> ""xzzy"" -> ""xyzz""`.\n\nA **group of special-equivalent strings** from `words` is a non-empty subset\nof words such that:\n\n  * Every pair of strings in the group are special equivalent and\n  * The group is the largest size possible (i.e. there is not a string `words[i]` not in the group such that `words[i]` is special-equivalent to every string in the group).\n\nReturn _the number of**groups of special-equivalent strings** from _`words`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""abcd""""cdab""""cbad""""xyzz""""zzxy""""zzyx""]\n    **Output:** 3\n    **Explanation:** \n    One group is [""abcd"" ""cdab"" ""cbad""] since they are all pairwise special equivalent and none of the other strings is all pairwise special equivalent to these.\n    The other two groups are [""xyzz"" ""zzxy""] and [""zzyx""].\n    Note that in particular ""zzxy"" is not special equivalent to ""zzyx"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""abc""""acb""""bac""""bca""""cab""""cba""]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 1000`\n  * `1 <= words[i].length <= 20`\n  * `words[i]` consist of lowercase English letters.\n  * All the strings are of the same length.\n\n",class Solution:\n    def numSpecialEquivGroups(self words) -> int:\n        return len(set([(''.join(sorted(i[::2]))''.join(sorted(i[1::2]))) for i in words]))
Grumpy Bookstore Owner,###  1052\. Grumpy Bookstore Owner\n\nThere is a bookstore owner that has a store open for `n` minutes. Every\nminute some number of customers enter the store. You are given an integer\narray `customers` of length `n` where `customers[i]` is the number of the\ncustomer that enters the store at the start of the `ith` minute and all those\ncustomers leave after the end of that minute.\n\nOn some minutes the bookstore owner is grumpy. You are given a binary array\ngrumpy where `grumpy[i]` is `1` if the bookstore owner is grumpy during the\n`ith` minute and is `0` otherwise.\n\nWhen the bookstore owner is grumpy the customers of that minute are not\nsatisfied otherwise they are satisfied.\n\nThe bookstore owner knows a secret technique to keep themselves not grumpy for\n`minutes` consecutive minutes but can only use it once.\n\nReturn _the maximum number of customers that can be satisfied throughout the\nday_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** customers = [10121175] grumpy = [01010101] minutes = 3\n    **Output:** 16\n    **Explanation:** The bookstore owner keeps themselves not grumpy for the last 3 minutes. \n    The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** customers = [1] grumpy = [0] minutes = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `n == customers.length == grumpy.length`\n  * `1 <= minutes <= n <= 2 * 104`\n  * `0 <= customers[i] <= 1000`\n  * `grumpy[i]` is either `0` or `1`.\n\n,class Solution:\n    def recursion(selfindexused):\n        # base case\n        if index == self.n: return 0\n        \n        #check in dp\n        if (indexused) in self.dp: return self.dp[(indexused)]\n        #choice1 is using the secret technique\n        choice1 = -float('inf')\n        \n        # we can only use secret technique once and consecutively\n        if used == True :\n            # use the secret technique\n            end = index + self.minutes if index + self.minutes < self.n else self.n\n            to_substract = self.prefix_sum[index - 1] if index != 0 else 0\n            val = self.prefix_sum[end - 1] - to_substract\n            choice1 = self.recursion(endFalse) + val\n        \n        # Do not use the secret tehcnique and play simple \n        choice2 = self.recursion(index+1used) + (self.customers[index] if self.grumpy[index] == 0 else 0)\n        ans = choice1 if choice1 > choice2 else choice2\n        \n        # Memoization is done here\n        self.dp[(indexused)] = ans\n        return ans\n    \n    def maxSatisfied(self customers: List[int] grumpy: List[int] minutes: int) -> int:\n        self.n = len(customers)\n        self.customers = customers\n        self.grumpy = grumpy\n        self.minutes = minutes\n        self.dp = {}\n        self.prefix_sum = [x for x in customers]\n        for i in range(1self.n): self.prefix_sum[i] += self.prefix_sum[i-1]\n        return self.recursion(0True)\n        \n
Guess Number Higher or Lower,###  374\. Guess Number Higher or Lower\n\nWe are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong I will tell you whether the number I picked is\nhigher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)` which returns three possible\nresults:\n\n  * `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n  * `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n  * `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 10 pick = 6\n    **Output:** 6\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1 pick = 1\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 2 pick = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 231 - 1`\n  * `1 <= pick <= n`\n\n,class Solution:\n    def guessNumber(self n: int) -> int:\n        l=1\n        h=n\n        while l<=h:\n            mid=(l+h)//2\n            x =guess(mid)\n            if(x==0):\n                return mid\n            elif(x==1):\n                l = mid+1\n            else:\n                h = mid-1\n
Guess Number Higher or Lower II,###  375\. Guess Number Higher or Lower II\n\nWe are playing the Guessing Game. The game will work as follows:\n\n  1. I pick a number between `1` and `n`.\n  2. You guess a number.\n  3. If you guess the right number **you win the game**.\n  4. If you guess the wrong number then I will tell you whether the number I picked is **higher or lower**  and you will continue guessing.\n  5. Every time you guess a wrong number `x` you will pay `x` dollars. If you run out of money **you lose the game**.\n\nGiven a particular `n` return _the minimum amount of money you need to\n**guarantee a win regardless of what number I pick**_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/10/graph.png)\n\n    \n    \n    **Input:** n = 10\n    **Output:** 16\n    **Explanation:** The winning strategy is as follows:\n    - The range is [110]. Guess 7.\n        - If this is my number your total is $0. Otherwise you pay $7.\n        - If my number is higher the range is [810]. Guess 9.\n            - If this is my number your total is $7. Otherwise you pay $9.\n            - If my number is higher it must be 10. Guess 10. Your total is $7 + $9 = $16.\n            - If my number is lower it must be 8. Guess 8. Your total is $7 + $9 = $16.\n        - If my number is lower the range is [16]. Guess 3.\n            - If this is my number your total is $7. Otherwise you pay $3.\n            - If my number is higher the range is [46]. Guess 5.\n                - If this is my number your total is $7 + $3 = $10. Otherwise you pay $5.\n                - If my number is higher it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n                - If my number is lower it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower the range is [12]. Guess 1.\n                - If this is my number your total is $7 + $3 = $10. Otherwise you pay $1.\n                - If my number is higher it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\n    The worst case in all these scenarios is that you pay $16. Hence you only need $16 to guarantee a win.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 0\n    **Explanation:**  There is only one possible number so you can guess 1 and not have to pay anything.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 1\n    **Explanation:**  There are two possible numbers 1 and 2.\n    - Guess 1.\n        - If this is my number your total is $0. Otherwise you pay $1.\n        - If my number is higher it must be 2. Guess 2. Your total is $1.\n    The worst case is that you pay $1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 200`\n\n,class Solution:\n    def getMoneyAmount(self n):\n                        # For an interval [lr] we choose a num which if incorrect still\n                        # allows us to know whether the secret# is in either [lnum-1] or\n                        # [num+1r]. So the worst-case (w-c) cost is\n                        #\n                        #      num + max(w-c cost in [lnum-1] w-c cost in [num+1r])\n                        # \n                        # We do this by recursion and binary search starting with [1n].\n\n        @lru_cache(None)              # <-- we cache function results to avoid recomputing them\n        def dp(l = 1 r = n)-> int:\n            if r-l < 1: return 0      # <-- base case for the recursion; one number in [lr]       \n            ans = 1000                # <-- the answer for n = 200 is 952\n            \n            for choice in range((l+r)//2r):\n                ans = min(anschoice+max(dp(lchoice-1)dp(choice+1r)))\n\n            return ans\n\n        return dp()
Guess the Word,"###  843\. Guess the Word\n\nYou are given an array of unique strings `words` where `words[i]` is six\nletters long. One word of `words` was chosen as a secret word.\n\nYou are also given the helper object `Master`. You may call\n`Master.guess(word)` where `word` is a six-letter-long string and it must be\nfrom `words`. `Master.guess(word)` returns:\n\n  * `-1` if `word` is not from `words` or\n  * an integer representing the number of exact matches (value and position) of your guess to the secret word.\n\nThere is a parameter `allowedGuesses` for each test case where\n`allowedGuesses` is the maximum number of times you can call\n`Master.guess(word)`.\n\nFor each test case you should call `Master.guess` with the secret word\nwithout exceeding the maximum number of allowed guesses. You will get:\n\n  * **`""Either you took too many guesses or you did not find the secret word.""`** if you called `Master.guess` more than `allowedGuesses` times or if you did not call `Master.guess` with the secret word or\n  * **`""You guessed the secret word correctly.""`** if you called `Master.guess` with the secret word with the number of calls to `Master.guess` less than or equal to `allowedGuesses`.\n\nThe test cases are generated such that you can guess the secret word with a\nreasonable strategy (other than using the bruteforce method).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** secret = ""acckzz"" words = [""acckzz""""ccbazz""""eiowzz""""abcczz""] allowedGuesses = 10\n    **Output:** You guessed the secret word correctly.\n    **Explanation:**\n    master.guess(""aaaaaa"") returns -1 because ""aaaaaa"" is not in wordlist.\n    master.guess(""acckzz"") returns 6 because ""acckzz"" is secret and has all 6 matches.\n    master.guess(""ccbazz"") returns 3 because ""ccbazz"" has 3 matches.\n    master.guess(""eiowzz"") returns 2 because ""eiowzz"" has 2 matches.\n    master.guess(""abcczz"") returns 4 because ""abcczz"" has 4 matches.\n    We made 5 calls to master.guess and one of them was the secret so we pass the test case.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** secret = ""hamada"" words = [""hamada""""khaled""] allowedGuesses = 10\n    **Output:** You guessed the secret word correctly.\n    **Explanation:** Since there are two words you can guess both.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 100`\n  * `words[i].length == 6`\n  * `words[i]` consist of lowercase English letters.\n  * All the strings of `wordlist` are **unique**.\n  * `secret` exists in `words`.\n  * `10 <= allowedGuesses <= 30`\n\n",class Solution:\n    def findSecretWord(self words: List[str] master: 'Master') -> None:        \n        k = 1 # for tracing the number of loops\n        matches = 0\n        blacklists = [[] for i in range(6)]\n        \n        while matches != 6:\n            n = len(words)\n            r = random.randint(0 n - 1)\n            matches = master.guess(words[r])\n            key = words[r]\n            # print(k n r matches key)\n            \n            words.pop(r)\n            \n            if matches == 0:\n                for i in range(6):\n                    blacklists[i].append(key[i])\n                # print(blacklists)\n            \n            elif matches > 0 and matches < 6:\n                candidates = []\n                for i in range(n - 1):\n                    count = 0\n                    for j in range(6):\n                        if words[i][j] not in blacklists[j] and words[i][j] == key[j]:\n                            count += 1\n                    if count >= matches:\n                        candidates.append(words[i])\n                            \n                words = candidates.copy()\n                # print(words)\n            \n            k += 1\n
H-Index,###  274\. H-Index\n\nGiven an array of integers `citations` where `citations[i]` is the number of\ncitations a researcher received for their `ith` paper return compute the\nresearcher's `h`**-index**.\n\nAccording to the [definition of h-index on\nWikipedia](https://en.wikipedia.org/wiki/H-index): A scientist has an index\n`h` if `h` of their `n` papers have at least `h` citations each and the other\n`n − h` papers have no more than `h` citations each.\n\nIf there are several possible values for `h` the maximum one is taken as the\n`h`**-index**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** citations = [30615]\n    **Output:** 3\n    **Explanation:** [30615] means the researcher has 5 papers in total and each of them had received 3 0 6 1 5 citations respectively.\n    Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each their h-index is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** citations = [131]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `n == citations.length`\n  * `1 <= n <= 5000`\n  * `0 <= citations[i] <= 1000`\n\n,class Solution:\n    def hIndex(self citations: List[int]) -> int:\n        num = sorted(citations)\n        h = 0\n        j = len(num)-1\n        for i in range(len(num)):\n            if i+1 <=num[i] and j-i+1>=num[i]:\n                h =max(num[i]h)\n            elif i+1 <= num[i] and j-i+1<num[i]:\n                h = max(hj-i+1)\n            elif i+1 > num[i] and j-i+1 >=num[i]:\n                h = max(h num[i])\n            \n        return h\n
H-Index II,###  275\. H-Index II\n\nGiven an array of integers `citations` where `citations[i]` is the number of\ncitations a researcher received for their `ith` paper and `citations` is\nsorted in an **ascending order**  return compute the researcher's\n`h`**-index**.\n\nAccording to the [definition of h-index on\nWikipedia](https://en.wikipedia.org/wiki/H-index): A scientist has an index\n`h` if `h` of their `n` papers have at least `h` citations each and the other\n`n − h` papers have no more than `h` citations each.\n\nIf there are several possible values for `h` the maximum one is taken as the\n`h`**-index**.\n\nYou must write an algorithm that runs in logarithmic time.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** citations = [01356]\n    **Output:** 3\n    **Explanation:** [01356] means the researcher has 5 papers in total and each of them had received 0 1 3 5 6 citations respectively.\n    Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each their h-index is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** citations = [12100]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `n == citations.length`\n  * `1 <= n <= 105`\n  * `0 <= citations[i] <= 1000`\n  * `citations` is sorted in **ascending order**.\n\n,import bisect\n\nclass Solution:\n    def hIndex(self citations: List[int]) -> int:\n        n = len(citations)\n        for h in range(n -1 -1):\n            if h <= n - bisect.bisect_left(citations h):\n                return h\n
Hamming Distance,###  461\. Hamming Distance\n\nThe [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between\ntwo integers is the number of positions at which the corresponding bits are\ndifferent.\n\nGiven two integers `x` and `y` return _the**Hamming distance** between them_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** x = 1 y = 4\n    **Output:** 2\n    **Explanation:**\n    1   (0 0 0 1)\n    4   (0 1 0 0)\n           ↑   ↑\n    The above arrows point to positions where the corresponding bits are different.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** x = 3 y = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `0 <= x y <= 231 - 1`\n\n,"class Solution:\n    def hammingDistance(self x: int y: int) -> int:\n		# First using XOR Bitwise Operator we take all distinct set bits.\n        z = x ^ y\n		# We inicialize our answer with zero.\n        ans = 0\n		# Iterate while our z is not zero.\n        while z:\n			# Every iteration we add one to our answer.\n            ans += 1\n			# Using the expression z & (z - 1) we erase the lowest set bit in z.\n            z &= z - 1\n        return ans\n"
Hand of Straights,###  846\. Hand of Straights\n\nAlice has some number of cards and she wants to rearrange the cards into\ngroups so that each group is of size `groupSize` and consists of `groupSize`\nconsecutive cards.\n\nGiven an integer array `hand` where `hand[i]` is the value written on the\n`ith` card and an integer `groupSize` return `true` if she can rearrange the\ncards or `false` otherwise.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** hand = [123623478] groupSize = 3\n    **Output:** true\n    **Explanation:** Alice's hand can be rearranged as [123][234][678]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** hand = [12345] groupSize = 4\n    **Output:** false\n    **Explanation:** Alice's hand can not be rearranged into groups of 4.\n    \n    \n\n\n\n**Constraints:**\n\n  * `1 <= hand.length <= 104`\n  * `0 <= hand[i] <= 109`\n  * `1 <= groupSize <= hand.length`\n\n\n\n**Note:** This question is the same as 1296:\n<https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/>\n\n,# Runtime: 304 ms (Top 61.38%) | Memory: 15.7 MB (Top 75.38%)\n\n#####################################################################################################################\n# Problem: Hand of Straights\n# Solution : Hash Table Min Heap\n# Time Complexity : O(n logn)\n# Space Complexity : O(n)\n#####################################################################################################################\n\nclass Solution:\n    def isNStraightHand(self hand: List[int] groupSize: int) -> bool:\n        if len(hand) % groupSize:\n            return False\n\n        freq = collections.defaultdict(int)\n\n        for num in hand:\n            freq[num] += 1\n\n        min_heap = list(freq.keys())\n        heapq.heapify(min_heap)\n\n        while min_heap:\n            smallest = min_heap[0]\n            for num in range(smallest smallest + groupSize):\n                if num not in freq:\n                    return False\n                freq[num] -= 1\n\n                if freq[num] == 0:\n                    if num != min_heap[0]:\n                        return False\n                    heapq.heappop(min_heap)\n        return True
Heaters,###  475\. Heaters\n\nWinter is coming! During the contest your first job is to design a standard\nheater with a fixed warm radius to warm all the houses.\n\nEvery house can be warmed as long as the house is within the heater's warm\nradius range.\n\nGiven the positions of `houses` and `heaters` on a horizontal line return\n_the minimum radius standard of heaters  so that those heaters could cover all\nhouses._\n\n**Notice** that all the `heaters` follow your radius standard and the warm\nradius will the same.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** houses = [123] heaters = [2]\n    **Output:** 1\n    **Explanation:** The only heater was placed in the position 2 and if we use the radius 1 standard then all the houses can be warmed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** houses = [1234] heaters = [14]\n    **Output:** 1\n    **Explanation:** The two heater was placed in the position 1 and 4. We need to use radius 1 standard then all the houses can be warmed.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** houses = [15] heaters = [2]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= houses.length heaters.length <= 3 * 104`\n  * `1 <= houses[i] heaters[i] <= 109`\n\n,"# Runtime: 766 ms (Top 22.98%) | Memory: 17.7 MB (Top 39.36%)\nclass Solution:\n    def findRadius(self houses: List[int] heaters: List[int]) -> int:\n        """"""\n\n        """"""\n\n        houses.sort()\n        heaters.sort()\n\n        max_radius = -inf\n\n        for house in houses:\n            i = bisect_left(heaters house)\n\n            if i == len(heaters):\n                max_radius = max(max_radius house - heaters[-1])\n            elif i == 0:\n                max_radius = max(max_radius heaters[i] - house)\n            else:\n                curr = heaters[i]\n                prev = heaters[i-1]\n                max_radius = max(max_radiusmin(abs(house - curr) abs(house-prev)))\n\n        return max_radius\n\n    # O(NLOGN)"
Height Checker,###  1051\. Height Checker\n\nA school is trying to take an annual photo of all the students. The students\nare asked to stand in a single file line in **non-decreasing order** by\nheight. Let this ordering be represented by the integer array `expected` where\n`expected[i]` is the expected height of the `ith` student in line.\n\nYou are given an integer array `heights` representing the **current order**\nthat the students are standing in. Each `heights[i]` is the height of the\n`ith` student in line (**0-indexed**).\n\nReturn _the**number of indices** where _`heights[i] != expected[i]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** heights = [114213]\n    **Output:** 3\n    **Explanation:** \n    heights:  [11_4_ 2_1_ _3_]\n    expected: [11_1_ 2_3_ _4_]\n    Indices 2 4 and 5 do not match.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** heights = [51234]\n    **Output:** 5\n    **Explanation:**\n    heights:  [_5_ _1_ _2_ _3_ _4_]\n    expected: [_1_ _2_ _3_ _4_ _5_]\n    All indices do not match.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** heights = [12345]\n    **Output:** 0\n    **Explanation:**\n    heights:  [12345]\n    expected: [12345]\n    All indices match.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= heights.length <= 100`\n  * `1 <= heights[i] <= 100`\n\n,class Solution:\n    def heightChecker(self heights: List[int]) -> int:\n        heightssort = sorted(heights)\n        import numpy as np\n        diff = list(np.array(heightssort) - np.array(heights))\n        return (len(diff) - diff.count(0))\n
House Robber II,###  213\. House Robber II\n\nYou are a professional robber planning to rob houses along a street. Each\nhouse has a certain amount of money stashed. All houses at this place are\n**arranged in a circle.** That means the first house is the neighbor of the\nlast one. Meanwhile adjacent houses have a security system connected and\n**it will automatically contact the police if two adjacent houses were broken\ninto on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house\nreturn _the maximum amount of money you can rob tonight**without alerting the\npolice**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [232]\n    **Output:** 3\n    **Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2) because they are adjacent houses.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1231]\n    **Output:** 4\n    **Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\n    Total amount you can rob = 1 + 3 = 4.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `0 <= nums[i] <= 1000`\n\n,"class Solution(object):\n    def rob(self nums):\n        """"""\n        :type nums: List[int]\n        :rtype: int\n        """"""\n        if len(nums) == 1:\n            return nums[0]\n        def helper(nums):\n            one two = 0 0\n            for i in nums:\n                temp = max(i + one two)\n                one = two\n                two = temp\n            return two\n        \n        return max(helper(nums[:-1]) helper(nums[1:]))\n"
House Robber III,###  337\. House Robber III\n\nThe thief has found himself a new place for his thievery again. There is only\none entrance to this area called `root`.\n\nBesides the `root` each house has one and only one parent house. After a\ntour the smart thief realized that all houses in this place form a binary\ntree. It will automatically contact the police if **two directly-linked houses\nwere broken into on the same night**.\n\nGiven the `root` of the binary tree return _the maximum amount of money the\nthief can rob**without alerting the police**_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)\n\n    \n    \n    **Input:** root = [323null3null1]\n    **Output:** 7\n    **Explanation:** Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)\n\n    \n    \n    **Input:** root = [34513null1]\n    **Output:** 9\n    **Explanation:** Maximum amount of money the thief can rob = 4 + 5 = 9.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `0 <= Node.val <= 104`\n\n,class Solution:\n    def rob(self root: Optional[TreeNode]) -> int:\n        hashMap = {}\n        \n        def helper(root: Optional[TreeNode]) -> int:\n            if not root:\n                return 0\n            if root in hashMap:\n                return hashMap[root]\n            ansOption1 = root.val\n            if root.left is not None:\n                ansOption1 += (helper(root.left.left) + helper(root.left.right))\n            if root.right is not None:\n                ansOption1 += (helper(root.right.left) + helper(root.right.right))\n            ansOption2 = helper(root.left) + helper(root.right)\n            ansFinal = max(ansOption1 ansOption2)\n            hashMap[root] = ansFinal\n            return ansFinal\n        \n        return helper(root)\n                \n
HTML Entity Parser,"###  1410\. HTML Entity Parser\n\n**HTML entity parser** is the parser that takes HTML code as input and replace\nall the entities of the special characters by the characters itself.\n\nThe special characters and their entities for HTML are:\n\n  * **Quotation Mark:** the entity is `&quot;` and symbol character is `""`.\n  * **Single Quote Mark:** the entity is `&apos;` and symbol character is `'`.\n  * **Ampersand:** the entity is `&amp;` and symbol character is `&`.\n  * **Greater Than Sign:** the entity is `&gt;` and symbol character is `>`.\n  * **Less Than Sign:** the entity is `&lt;` and symbol character is `<`.\n  * **Slash:** the entity is `&frasl;` and symbol character is `/`.\n\nGiven the input `text` string to the HTML parser you have to implement the\nentity parser.\n\nReturn _the text after replacing the entities by the special characters_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text = ""&amp; is an HTML entity but &ambassador; is not.""\n    **Output:** ""& is an HTML entity but &ambassador; is not.""\n    **Explanation:** The parser will replace the &amp; entity by &\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text = ""and I quote: &quot;...&quot;""\n    **Output:** ""and I quote: \""...\""""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length <= 105`\n  * The string may contain any possible characters out of all the 256 ASCII characters.\n\n","class Solution:\n    def entityParser(self text: str) -> str:\n        d = {""&quot;"" : '""'  ""&apos;"":""'""  ""&amp;"" : ""&""  ""&gt;"" : "">""  ""&lt;"":""<""  ""&frasl;"" : ""/""}\n        \n        \n        \n        ans = """"\n        i = 0\n        while i < len(text):\n            bag = """"\n            \n            #condition if find & and next char is not & also and handdling index out of range for i + 1\n            if i+1 < len(text) and text[i] == ""&"" and text[i+1] != ""&"":\n                \n                #create subtring for speacial char till "";""\n                for j in range(i  len(text)):\n                    if text[j] == "";"":\n                        bag += text[j]\n                        break\n                    else:\n                        bag += text[j]\n                        \n                #if that not present in dict we added same as it is\n                if bag not in d:\n                    ans += bag\n                else:\n                    ans += d[bag]\n                    \n                #increment by length of bag \n                i += len(bag)\n             \n            #otherwise increment by 1\n            else:\n                ans += text[i]\n                i += 1\n        return ans\n        \n"
Image Overlap,###  835\. Image Overlap\n\nYou are given two images `img1` and `img2` represented as binary square\nmatrices of size `n x n`. A binary matrix has only `0`s and `1`s as values.\n\nWe **translate** one image however we choose by sliding all the `1` bits left\nright up and/or down any number of units. We then place it on top of the\nother image. We can then calculate the **overlap** by counting the number of\npositions that have a `1` in **both** images.\n\nNote also that a translation does **not** include any kind of rotation. Any\n`1` bits that are translated outside of the matrix borders are erased.\n\nReturn _the largest possible overlap_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/09/overlap1.jpg)\n\n    \n    \n    **Input:** img1 = [[110][010][010]] img2 = [[000][011][001]]\n    **Output:** 3\n    **Explanation:** We translate img1 to right by 1 unit and down by 1 unit.\n    ![](https://assets.leetcode.com/uploads/2020/09/09/overlap_step1.jpg)\n    The number of positions that have a 1 in both images is 3 (shown in red).\n    ![](https://assets.leetcode.com/uploads/2020/09/09/overlap_step2.jpg)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** img1 = [[1]] img2 = [[1]]\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** img1 = [[0]] img2 = [[0]]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `n == img1.length == img1[i].length`\n  * `n == img2.length == img2[i].length`\n  * `1 <= n <= 30`\n  * `img1[i][j]` is either `0` or `1`.\n  * `img2[i][j]` is either `0` or `1`.\n\n,# Runtime: 593 ms (Top 76.00%) | Memory: 14.7 MB (Top 44.00%)\nclass Solution:\n    def largestOverlap(self img1: List[List[int]] img2: List[List[int]]) -> int:\n        n = len(img1)\n        list1 list2 = [] []\n        res = 0\n        for r in range(n):\n            for c in range(n):\n                if img1[r][c]:\n                    list1.append((r c))\n                if img2[r][c]:\n                    list2.append((r c))\n\n        shiftDict = defaultdict(int)\n        for x1 y1 in list1:\n            for x2 y2 in list2:\n                dx dy = x2 - x1 y2 - y1\n                shiftDict[(dx dy)] += 1\n\n        return max(shiftDict.values()) if shiftDict else 0
Image Smoother,###  661\. Image Smoother\n\nAn **image smoother** is a filter of the size `3 x 3` that can be applied to\neach cell of an image by rounding down the average of the cell and the eight\nsurrounding cells (i.e. the average of the nine cells in the blue smoother).\nIf one or more of the surrounding cells of a cell is not present we do not\nconsider it in the average (i.e. the average of the four cells in the red\nsmoother).\n\n![](https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg)\n\nGiven an `m x n` integer matrix `img` representing the grayscale of an image\nreturn _the image after applying the smoother on each cell of it_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg)\n\n    \n    \n    **Input:** img = [[111][101][111]]\n    **Output:** [[000][000][000]]\n    **Explanation:**\n    For the points (00) (02) (20) (22): floor(3/4) = floor(0.75) = 0\n    For the points (01) (10) (12) (21): floor(5/6) = floor(0.83333333) = 0\n    For the point (11): floor(8/9) = floor(0.88888889) = 0\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg)\n\n    \n    \n    **Input:** img = [[100200100][20050200][100200100]]\n    **Output:** [[137141137][141138141][137141137]]\n    **Explanation:**\n    For the points (00) (02) (20) (22): floor((100+200+200+50)/4) = floor(137.5) = 137\n    For the points (01) (10) (12) (21): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\n    For the point (11): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n    \n\n\n\n**Constraints:**\n\n  * `m == img.length`\n  * `n == img[i].length`\n  * `1 <= m n <= 200`\n  * `0 <= img[i][j] <= 255`\n\n,# Runtime: 1147 ms (Top 25.09%) | Memory: 14.8 MB (Top 29.59%)\nclass Solution:\n    def imageSmoother(self img: List[List[int]]) -> List[List[int]]:\n        m n = len(img) len(img[0])\n\n        def avg(i j):\n            s = squares = 0\n            top bottom = max(0 i - 1) min(m i + 2)\n            left right = max(0 j - 1) min(n j + 2)\n\n            for x in range(top bottom):\n                for y in range(left right):\n                    s += img[x][y]\n                    squares += 1\n\n            return s // squares\n\n        return [[avg(i j) for j in range(n)] for i in range(m)]
Implement Magic Dictionary,"###  676\. Implement Magic Dictionary\n\nDesign a data structure that is initialized with a list of **different**\nwords. Provided a string you should determine if you can change exactly one\ncharacter in this string to match any word in the data structure.\n\nImplement the `MagicDictionary` class:\n\n  * `MagicDictionary()` Initializes the object.\n  * `void buildDict(String[] dictionary)` Sets the data structure with an array of distinct strings `dictionary`.\n  * `bool search(String searchWord)` Returns `true` if you can change **exactly one character** in `searchWord` to match any string in the data structure otherwise returns `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MagicDictionary"" ""buildDict"" ""search"" ""search"" ""search"" ""search""]\n    [[] [[""hello"" ""leetcode""]] [""hello""] [""hhllo""] [""hell""] [""leetcoded""]]\n    **Output**\n    [null null false true false false]\n    \n    **Explanation**\n    MagicDictionary magicDictionary = new MagicDictionary();\n    magicDictionary.buildDict([""hello"" ""leetcode""]);\n    magicDictionary.search(""hello""); // return False\n    magicDictionary.search(""hhllo""); // We can change the second 'h' to 'e' to match ""hello"" so we return True\n    magicDictionary.search(""hell""); // return False\n    magicDictionary.search(""leetcoded""); // return False\n    \n\n\n\n**Constraints:**\n\n  * `1 <= dictionary.length <= 100`\n  * `1 <= dictionary[i].length <= 100`\n  * `dictionary[i]` consists of only lower-case English letters.\n  * All the strings in `dictionary` are **distinct**.\n  * `1 <= searchWord.length <= 100`\n  * `searchWord` consists of only lower-case English letters.\n  * `buildDict` will be called only once before `search`.\n  * At most `100` calls will be made to `search`.\n\n","class MagicDictionary:\n\n	def __init__(self):\n		TrieNode = lambda : defaultdict(TrieNode)\n		self.root = TrieNode()\n\n	def buildDict(self dictionary: List[str]) -> None:\n		for s in dictionary:\n			cur = self.root\n			for c in s: cur = cur[ord(c)-ord('a')]\n			cur['$']=True\n\n	def search(self searchWord: str) -> bool:\n		def find(icurmis):\n			if i==len(searchWord) and mis==0: return('$' in cur)\n			if mis < 0: return False\n			if i==len(searchWord) and mis!=0: return False\n			ind = ord(searchWord[i])-ord('a')\n			ans = False\n			for j in range(26):\n				if j in cur:\n					if(j!=ind):\n						ans |= find(i+1cur[j]mis-1)\n					else: ans |= find(i+1cur[j]mis)\n			return ans\n			\n		return find(0self.root1)\n"
Implement Queue using Stacks,"###  232\. Implement Queue using Stacks\n\nImplement a first in first out (FIFO) queue using only two stacks. The\nimplemented queue should support all the functions of a normal queue (`push`\n`peek` `pop` and `empty`).\n\nImplement the `MyQueue` class:\n\n  * `void push(int x)` Pushes element x to the back of the queue.\n  * `int pop()` Removes the element from the front of the queue and returns it.\n  * `int peek()` Returns the element at the front of the queue.\n  * `boolean empty()` Returns `true` if the queue is empty `false` otherwise.\n\n**Notes:**\n\n  * You must use **only** standard operations of a stack which means only `push to top` `peek/pop from top` `size` and `is empty` operations are valid.\n  * Depending on your language the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MyQueue"" ""push"" ""push"" ""peek"" ""pop"" ""empty""]\n    [[] [1] [2] [] [] []]\n    **Output**\n    [null null null 1 1 false]\n    \n    **Explanation**\n    MyQueue myQueue = new MyQueue();\n    myQueue.push(1); // queue is: [1]\n    myQueue.push(2); // queue is: [1 2] (leftmost is front of the queue)\n    myQueue.peek(); // return 1\n    myQueue.pop(); // return 1 queue is [2]\n    myQueue.empty(); // return false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= x <= 9`\n  * At most `100` calls will be made to `push` `pop` `peek` and `empty`.\n  * All the calls to `pop` and `peek` are valid.\n\n\n\n**Follow-up:** Can you implement the queue such that each operation is\n**[amortized](https://en.wikipedia.org/wiki/Amortized_analysis)** `O(1)` time\ncomplexity? In other words performing `n` operations will take overall `O(n)`\ntime even if one of those operations may take longer.\n\n",# Runtime: 53 ms (Top 33.00%) | Memory: 13.9 MB (Top 98.49%)\nclass MyStack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self x):\n        self.stack.append(x)\n\n    def top(self):\n        return self.stack[-1]\n\n    def pop(self):\n        return self.stack.pop()\n\n    def size(self):\n        return len(self.stack)\n\n    def isEmpty(self):\n        return len(self.stack) == 0\n\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = MyStack()\n        self.stack2 = MyStack()\n\n    def push(self x: int) -> None:\n        self.stack1.push(x)\n\n    def pop(self) -> int:\n        while not self.stack1.isEmpty():\n            self.stack2.push(self.stack1.pop())\n        out = self.stack2.pop()\n        while not self.stack2.isEmpty():\n            self.stack1.push(self.stack2.pop())\n        return out\n\n    def peek(self) -> int:\n        while not self.stack1.isEmpty():\n            self.stack2.push(self.stack1.pop())\n        out = self.stack2.top()\n        while not self.stack2.isEmpty():\n            self.stack1.push(self.stack2.pop())\n        return out\n\n    def empty(self) -> bool:\n        return self.stack1.isEmpty()\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()
Implement Stack using Queues,"###  225\. Implement Stack using Queues\n\nImplement a last-in-first-out (LIFO) stack using only two queues. The\nimplemented stack should support all the functions of a normal stack (`push`\n`top` `pop` and `empty`).\n\nImplement the `MyStack` class:\n\n  * `void push(int x)` Pushes element x to the top of the stack.\n  * `int pop()` Removes the element on the top of the stack and returns it.\n  * `int top()` Returns the element on the top of the stack.\n  * `boolean empty()` Returns `true` if the stack is empty `false` otherwise.\n\n**Notes:**\n\n  * You must use **only** standard operations of a queue which means that only `push to back` `peek/pop from front` `size` and `is empty` operations are valid.\n  * Depending on your language the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MyStack"" ""push"" ""push"" ""top"" ""pop"" ""empty""]\n    [[] [1] [2] [] [] []]\n    **Output**\n    [null null null 2 2 false]\n    \n    **Explanation**\n    MyStack myStack = new MyStack();\n    myStack.push(1);\n    myStack.push(2);\n    myStack.top(); // return 2\n    myStack.pop(); // return 2\n    myStack.empty(); // return False\n    \n\n\n\n**Constraints:**\n\n  * `1 <= x <= 9`\n  * At most `100` calls will be made to `push` `pop` `top` and `empty`.\n  * All the calls to `pop` and `top` are valid.\n\n\n\n**Follow-up:** Can you implement the stack using only one queue?\n\n",class MyStack(object):\n\n    def __init__(self):\n        self.stack=[]\n\n    def push(self x):\n        self.stack.append(x)\n        return None\n        \n    def pop(self):\n        return self.stack.pop(-1)\n        \n\n    def top(self):\n        return self.stack[-1]\n\n    def empty(self):\n        if self.stack==[]:\n            return True\n        return False\n\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()\n
Implement strStr(),"###  28\. Implement strStr()\n\nImplement [strStr()](http://www.cplusplus.com/reference/cstring/strstr/).\n\nGiven two strings `needle` and `haystack` return the index of the first\noccurrence of `needle` in `haystack` or `-1` if `needle` is not part of\n`haystack`.\n\n**Clarification:**\n\nWhat should we return when `needle` is an empty string? This is a great\nquestion to ask during an interview.\n\nFor the purpose of this problem we will return 0 when `needle` is an empty\nstring. This is consistent to C's\n[strstr()](http://www.cplusplus.com/reference/cstring/strstr/) and Java's\n[indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf\(java.lang.String\)).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** haystack = ""hello"" needle = ""ll""\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** haystack = ""aaaaa"" needle = ""bba""\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= haystack.length needle.length <= 104`\n  * `haystack` and `needle` consist of only lowercase English characters.\n\n",class Solution(object):\n    def strStr(self haystack needle):\n        if needle == '':\n            return 0\n        else:\n            return self.search_substring(haystack needle)\n\n    def search_substring(self haystack needle):\n        len_substring = len(needle)\n        for i in range(len(haystack)):\n            if haystack[i: i + len_substring] == needle:\n                return i\n        return -1\n
Implement Trie (Prefix Tree),"###  208\. Implement Trie (Prefix Tree)\n\nA [**trie**](https://en.wikipedia.org/wiki/Trie) (pronounced as ""try"") or\n**prefix tree** is a tree data structure used to efficiently store and\nretrieve keys in a dataset of strings. There are various applications of this\ndata structure such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\n  * `Trie()` Initializes the trie object.\n  * `void insert(String word)` Inserts the string `word` into the trie.\n  * `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e. was inserted before) and `false` otherwise.\n  * `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix` and `false` otherwise.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Trie"" ""insert"" ""search"" ""search"" ""startsWith"" ""insert"" ""search""]\n    [[] [""apple""] [""apple""] [""app""] [""app""] [""app""] [""app""]]\n    **Output**\n    [null null true false true null true]\n    \n    **Explanation**\n    Trie trie = new Trie();\n    trie.insert(""apple"");\n    trie.search(""apple"");   // return True\n    trie.search(""app"");     // return False\n    trie.startsWith(""app""); // return True\n    trie.insert(""app"");\n    trie.search(""app"");     // return True\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word.length prefix.length <= 2000`\n  * `word` and `prefix` consist only of lowercase English letters.\n  * At most `3 * 104` calls **in total** will be made to `insert` `search` and `startsWith`.\n\n",class Node : \n    def __init__(self ):\n        self.child = {} # to hold the nodes.\n        self.end = False # to mark a node if it is the end node or not.\n\nclass Trie:\n    \n    def __init__(self):\n        self.root = Node()\n\n    def insert(self word:str) -> None:\n        # time compl len(word)\n        \n        sz = len(word) \n        temp = self.root # to hold the root node.\n        \n        for ind  i in enumerate( word ) :\n            if i in temp.child.keys() : # if this curr char in the current node.\n                temp = temp.child[i] #another node.\n                \n            else:\n                temp.child[i] = Node()\n                temp = temp.child[i]\n\n                \n            if ind  == sz - 1 :\n                temp.end = True \n                \n                \n\n    def search(self word: str) -> bool:\n        \n        temp = self.root \n        for i in word : \n            if i in temp.child.keys():\n                temp = temp.child[i]\n            else:\n                return 0\n            \n        return temp.end == True  \n         \n    def startsWith(self prefix: str) -> bool:\n        temp  = self.root \n        for i in prefix :\n            if i in temp.child.keys():\n                temp = temp.child[i]\n            else:\n                return 0\n        return 1 \n\n\n
Increasing Decreasing String,"###  1370\. Increasing Decreasing String\n\nYou are given a string `s`. Reorder the string using the following algorithm:\n\n  1. Pick the **smallest** character from `s` and **append** it to the result.\n  2. Pick the **smallest** character from `s` which is greater than the last appended character to the result and **append** it.\n  3. Repeat step 2 until you cannot pick more characters.\n  4. Pick the **largest** character from `s` and **append** it to the result.\n  5. Pick the **largest** character from `s` which is smaller than the last appended character to the result and **append** it.\n  6. Repeat step 5 until you cannot pick more characters.\n  7. Repeat the steps from 1 to 6 until you pick all characters from `s`.\n\nIn each step If the smallest or the largest character appears more than once\nyou can choose any occurrence and append it to the result.\n\nReturn _the result string after sorting_`s` _with this algorithm_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aaaabbbbcccc""\n    **Output:** ""abccbaabccba""\n    **Explanation:** After steps 1 2 and 3 of the first iteration result = ""abc""\n    After steps 4 5 and 6 of the first iteration result = ""abccba""\n    First iteration is done. Now s = ""aabbcc"" and we go back to step 1\n    After steps 1 2 and 3 of the second iteration result = ""abccbaabc""\n    After steps 4 5 and 6 of the second iteration result = ""abccbaabccba""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""rat""\n    **Output:** ""art""\n    **Explanation:** The word ""rat"" becomes ""art"" after re-ordering it with the mentioned algorithm.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 500`\n  * `s` consists of only lowercase English letters.\n\n",// Runtime: 72 ms (Top 48.8%) | Memory: 17.70 MB (Top 9.21%)\n\nclass Solution:\n    def sortString(self s: str) -> str:\n        s = list(s)\n        result = ''\n        while s:\n            for letter in sorted(set(s)):\n                s.remove(letter)\n                result += letter\n            for letter in sorted(set(s) reverse=True):\n                s.remove(letter)\n                result += letter\n        return result\n
Increasing Order Search Tree,###  897\. Increasing Order Search Tree\n\nGiven the `root` of a binary search tree rearrange the tree in **in-order**\nso that the leftmost node in the tree is now the root of the tree and every\nnode has no left child and only one right child.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg)\n\n    \n    \n    **Input:** root = [53624null81nullnullnull79]\n    **Output:** [1null2null3null4null5null6null7null8null9]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg)\n\n    \n    \n    **Input:** root = [517]\n    **Output:** [1null5null7]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the given tree will be in the range `[1 100]`.\n  * `0 <= Node.val <= 1000`\n\n,// Runtime: 44 ms (Top 21.66%) | Memory: 17.30 MB (Top 23.65%)\n\nclass Solution:\n    def increasingBST(self node: TreeNode) -> TreeNode:\n        dummy = tail = TreeNode()\n        while node is not None:\n            if node.left is not None:\n                predecessor = node.left\n                while predecessor.right is not None:\n                    predecessor = predecessor.right\n                \n                predecessor.right = node\n                left node.left = node.left None\n                node = left\n            else:\n                tail.right = tail = node\n                node = node.right\n        \n        return dummy.right\n
Increasing Subsequences,###  491\. Increasing Subsequences\n\nGiven an integer array `nums` return all the different possible increasing\nsubsequences of the given array with **at least two elements**. You may return\nthe answer in **any order**.\n\nThe given array may contain duplicates and two equal integers should also be\nconsidered a special case of increasing sequence.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [4677]\n    **Output:** [[46][467][4677][47][477][67][677][77]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [44321]\n    **Output:** [[44]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 15`\n  * `-100 <= nums[i] <= 100`\n\n,# Runtime: 750 ms (Top 10.08%) | Memory: 22.4 MB (Top 30.72%)\nclass Solution:\n    def findSubsequences(self nums: List[int]) -> List[List[int]]:\n        def backtracking(numspath):\n           # to ensure that the base array has at least 2 elements\n            if len(path)>=2:\n                res.add(tuple(path))\n            for i in range(len(nums)):\n                # to ensure that every element to be added is equal or larger than the former\n                if not path or path[-1] <= nums[i]:\n                    backtracking(nums[i+1:]path+[nums[i]])\n\n        res=set()\n        backtracking(nums[])\n        return res
Increasing Triplet Subsequence,###  334\. Increasing Triplet Subsequence\n\nGiven an integer array `nums` return `true` _if there exists a triple of\nindices_`(i j k)`_such that_`i < j < k` _and_`nums[i] < nums[j] < nums[k]`.\nIf no such indices exists return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12345]\n    **Output:** true\n    **Explanation:** Any triplet where i < j < k is valid.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [54321]\n    **Output:** false\n    **Explanation:** No triplet exists.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [215046]\n    **Output:** true\n    **Explanation:** The triplet (3 4 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5 * 105`\n  * `-231 <= nums[i] <= 231 - 1`\n\n\n\n**Follow up:** Could you implement a solution that runs in `O(n)` time\ncomplexity and `O(1)` space complexity?\n\n,class Solution:\n    def increasingTriplet(self nums: List[int]) -> bool:\n        first = second = float('inf')\n        for n in nums:\n            if n <= first:\n                first = n\n            elif n <= second:\n                second = n\n            else:\n                return True\n        return False\n
Insert Delete GetRandom O(1),"###  380\. Insert Delete GetRandom O(1)\n\nImplement the `RandomizedSet` class:\n\n  * `RandomizedSet()` Initializes the `RandomizedSet` object.\n  * `bool insert(int val)` Inserts an item `val` into the set if not present. Returns `true` if the item was not present `false` otherwise.\n  * `bool remove(int val)` Removes an item `val` from the set if present. Returns `true` if the item was present `false` otherwise.\n  * `int getRandom()` Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the **same probability** of being returned.\n\nYou must implement the functions of the class such that each function works in\n**average**  `O(1)` time complexity.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""RandomizedSet"" ""insert"" ""remove"" ""insert"" ""getRandom"" ""remove"" ""insert"" ""getRandom""]\n    [[] [1] [2] [2] [] [1] [2] []]\n    **Output**\n    [null true false true 2 true false 2]\n    \n    **Explanation**\n    RandomizedSet randomizedSet = new RandomizedSet();\n    randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\n    randomizedSet.remove(2); // Returns false as 2 does not exist in the set.\n    randomizedSet.insert(2); // Inserts 2 to the set returns true. Set now contains [12].\n    randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\n    randomizedSet.remove(1); // Removes 1 from the set returns true. Set now contains [2].\n    randomizedSet.insert(2); // 2 was already in the set so return false.\n    randomizedSet.getRandom(); // Since 2 is the only number in the set getRandom() will always return 2.\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= val <= 231 - 1`\n  * At most `2 * ``105` calls will be made to `insert` `remove` and `getRandom`.\n  * There will be **at least one** element in the data structure when `getRandom` is called.\n\n",class RandomizedSet:\n\n    def __init__(self):\n        self.data = set() \n\n    def insert(self val: int) -> bool:\n      if val not in self.data:\n        self.data.add(val)\n        return True \n      return False \n        \n    def remove(self val: int) -> bool:\n        if val in self.data:\n          self.data.remove(val)\n          return True \n        return False \n\n    def getRandom(self) -> int:\n        return  random.choice(list(self.data))\n
Insert Delete GetRandom O(1) - Duplicates allowed,"###  381\. Insert Delete GetRandom O(1) - Duplicates allowed\n\n`RandomizedCollection` is a data structure that contains a collection of\nnumbers possibly duplicates (i.e. a multiset). It should support inserting\nand removing specific elements and also removing a random element.\n\nImplement the `RandomizedCollection` class:\n\n  * `RandomizedCollection()` Initializes the empty `RandomizedCollection` object.\n  * `bool insert(int val)` Inserts an item `val` into the multiset even if the item is already present. Returns `true` if the item is not present `false` otherwise.\n  * `bool remove(int val)` Removes an item `val` from the multiset if present. Returns `true` if the item is present `false` otherwise. Note that if `val` has multiple occurrences in the multiset we only remove one of them.\n  * `int getRandom()` Returns a random element from the current multiset of elements. The probability of each element being returned is **linearly related** to the number of same values the multiset contains.\n\nYou must implement the functions of the class such that each function works on\n**average** `O(1)` time complexity.\n\n**Note:** The test cases are generated such that `getRandom` will only be\ncalled if there is **at least one** item in the `RandomizedCollection`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""RandomizedCollection"" ""insert"" ""insert"" ""insert"" ""getRandom"" ""remove"" ""getRandom""]\n    [[] [1] [1] [2] [] [1] []]\n    **Output**\n    [null true false true 2 true 1]\n    \n    **Explanation**\n    RandomizedCollection randomizedCollection = new RandomizedCollection();\n    randomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                      // Inserts 1 into the collection.\n    randomizedCollection.insert(1);   // return false since the collection contains 1.\n                                      // Inserts another 1 into the collection. Collection now contains [11].\n    randomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                      // Inserts 2 into the collection. Collection now contains [112].\n    randomizedCollection.getRandom(); // getRandom should:\n                                      // - return 1 with probability 2/3 or\n                                      // - return 2 with probability 1/3.\n    randomizedCollection.remove(1);   // return true since the collection contains 1.\n                                      // Removes 1 from the collection. Collection now contains [12].\n    randomizedCollection.getRandom(); // getRandom should return 1 or 2 both equally likely.\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= val <= 231 - 1`\n  * At most `2 * 105` calls **in total** will be made to `insert` `remove` and `getRandom`.\n  * There will be **at least one** element in the data structure when `getRandom` is called.\n\n",class RandomizedCollection:\n\n    def __init__(self):\n        self.items = []\n\n    def insert(self val: int) -> bool:\n        self.items.append(val)\n        if self.items.count(val) > 1:\n            return False\n        else:\n            return True\n\n    def remove(self val: int) -> bool:\n        if val in self.items:\n            flag = True\n            self.items.remove(val)\n        else:\n            flag = False\n        \n        return flag\n\n    def getRandom(self) -> int:\n        return choice(self.items)\n            \n
Insert into a Binary Search Tree,###  701\. Insert into a Binary Search Tree\n\nYou are given the `root` node of a binary search tree (BST) and a `value` to\ninsert into the tree. Return _the root node of the BST after the insertion_.\nIt is **guaranteed** that the new value does not exist in the original BST.\n\n**Notice**  that there may exist multiple valid ways for the insertion as\nlong as the tree remains a BST after insertion. You can return **any of\nthem**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)\n\n    \n    \n    **Input:** root = [42713] val = 5\n    **Output:** [427135]\n    **Explanation:** Another accepted tree is:\n    ![](https://assets.leetcode.com/uploads/2020/10/05/bst.jpg)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [40206010305070] val = 25\n    **Output:** [40206010305070nullnull25]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [42713nullnullnullnullnullnull] val = 5\n    **Output:** [427135]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree will be in the range `[0 104]`.\n  * `-108 <= Node.val <= 108`\n  * All the values `Node.val` are **unique**.\n  * `-108 <= val <= 108`\n  * It's **guaranteed** that `val` does not exist in the original BST.\n\n,class Solution:\n    def insertIntoBST(self root val):\n        if not root:\n            return TreeNode(val)\n      \n        if val<root.val:\n            root.left = self.insertIntoBST(root.left val)\n        else:\n            root.right = self.insertIntoBST(root.right val)\n  \n        return root
Insertion Sort List,###  147\. Insertion Sort List\n\nGiven the `head` of a singly linked list sort the list using **insertion\nsort**  and return _the sorted list's head_.\n\nThe steps of the **insertion sort** algorithm:\n\n  1. Insertion sort iterates consuming one input element each repetition and growing a sorted output list.\n  2. At each iteration insertion sort removes one element from the input data finds the location it belongs within the sorted list and inserts it there.\n  3. It repeats until no input elements remain.\n\nThe following is a graphical example of the insertion sort algorithm. The\npartially sorted list (black) initially contains only the first element in the\nlist. One element (red) is removed from the input data and inserted in-place\ninto the sorted list with each iteration.\n\n![](https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-\nexample-300px.gif)\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg)\n\n    \n    \n    **Input:** head = [4213]\n    **Output:** [1234]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg)\n\n    \n    \n    **Input:** head = [-15340]\n    **Output:** [-10345]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[1 5000]`.\n  * `-5000 <= Node.val <= 5000`\n\n,/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction insertionSortList(head: ListNode | null): ListNode | null {\n  if (!head) return null\n  if (!head.next) return head\n\n  let output = head\n  let curr = head.next\n\n  head.next = null\n\n  while (curr) {\n    const next = curr.next\n    const insertion = curr\n\n    output = insert(output insertion)\n    curr = next as ListNode\n  }\n\n  return output\n}\n\nfunction insert(head: ListNode other: ListNode) {\n  let curr = head\n  const val = other.val\n\n  if (val <= head.val) {\n    other.next = head\n    return other\n  }\n\n  while (curr) {\n    if ((val > curr.val && curr.next && val <= curr.next.val) || !curr.next) {\n      other.next = curr.next\n      curr.next = other\n\n      return head\n    }\n\n    curr = curr.next as ListNode\n  }\n\n  return head\n}\n
Insufficient Nodes in Root to Leaf Paths,###  1080\. Insufficient Nodes in Root to Leaf Paths\n\nGiven the `root` of a binary tree and an integer `limit` delete all\n**insufficient nodes** in the tree simultaneously and return _the root of the\nresulting binary tree_.\n\nA node is **insufficient** if every root to **leaf** path intersecting this\nnode has a sum strictly less than `limit`.\n\nA **leaf** is a node with no children.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/06/05/insufficient-11.png)\n\n    \n    \n    **Input:** root = [1234-99-99789-99-991213-9914] limit = 1\n    **Output:** [1234nullnull789null14]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/06/05/insufficient-3.png)\n\n    \n    \n    **Input:** root = [54811null17471nullnull53] limit = 22\n    **Output:** [54811null1747nullnullnull5]\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/06/11/screen-\nshot-2019-06-11-at-83301-pm.png)\n\n    \n    \n    **Input:** root = [12-3-5null4null] limit = -1\n    **Output:** [1null-34]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 5000]`.\n  * `-105 <= Node.val <= 105`\n  * `-109 <= limit <= 109`\n\n,"class Solution:\n    """"""\n    we can try to solve this problem using depth first traversal\n    """"""\n    def dfs(self root sum_so_far limit):\n        if root is None:\n            return None 0\n        \n        x left  = self.dfs(root.left sum_so_far + root.val limit)\n        y right = self.dfs(root.right sum_so_far + root.val limit)\n        # print('for node= {} sum_so_far= {} left= {} right= {}'.format(root.val sum_so_far left right))\n        if root.left is None and root.right is None:\n            # it is leaf left and right should be 0\n            if sum_so_far + root.val < limit:\n                # node is insufficient\n                return None root.val\n            else:\n                # node is sufficient\n                return root root.val\n        elif root.left is not None and root.right is None:\n            root.left = x\n            if sum_so_far + root.val + left < limit:\n                # node is insufficient\n                return None root.val + left\n            else:\n                return root root.val + left\n            \n        elif root.left is None and root.right is not None:\n            root.right = y\n            if sum_so_far + root.val + right < limit:\n                return None root.val + right\n            else:\n                return root root.val + right\n            \n        elif root.left is not None and root.right is not None:\n            root.left = x\n            root.right = y\n            if sum_so_far + root.val + left < limit and sum_so_far + root.val + right < limit:\n                return None max(root.val + left root.val + right)\n            elif sum_so_far + root.val + left < limit and sum_so_far + root.val + right > limit:\n                return root root.val + right\n            elif sum_so_far + root.val + left > limit and sum_so_far + root.val + right < limit:\n                return root root.val + left\n            else:\n                return root max(root.val + left root.val + right)\n        \n    def sufficientSubset(self root: Optional[TreeNode] limit: int) -> Optional[TreeNode]:\n        root _ = self.dfs(root 0 limit)\n        return root\n"
Integer Break,###  343\. Integer Break\n\nGiven an integer `n` break it into the sum of `k` **positive integers** \nwhere `k >= 2` and maximize the product of those integers.\n\nReturn _the maximum product you can get_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 1\n    **Explanation:** 2 = 1 + 1 1 × 1 = 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 36\n    **Explanation:** 10 = 3 + 3 + 4 3 × 3 × 4 = 36.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 58`\n\n,class Solution:\n    def integerBreak(self n: int) -> int:\n        dp = [0 for _ in range(n+1)]\n        dp[1] = 1\n        for i in range(2 n+1):\n            for j in range(1 i//2+1):\n                dp[i] = max(j * (i-j) j * dp[i-j] dp[i])\n        return dp[-1]\n
Integer Replacement,###  397\. Integer Replacement\n\nGiven a positive integer `n` you can apply one of the following operations:\n\n  1. If `n` is even replace `n` with `n / 2`.\n  2. If `n` is odd replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 8\n    **Output:** 3\n    **Explanation:** 8 -> 4 -> 2 -> 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 7\n    **Output:** 4\n    **Explanation:** 7 -> 8 -> 4 -> 2 -> 1\n    or 7 -> 6 -> 3 -> 2 -> 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 231 - 1`\n\n,# Runtime: 42 ms (Top 77.23%) | Memory: 14 MB (Top 29.19%)\n\nclass Solution:\n    def integerReplacement(self n: int) -> int:\n        dp = {}\n        def dfs(num):\n            if num == 1:\n                return 0\n\n            if num in dp:\n                return dp[num]\n\n            # if num is even we have only one option -> n / 2\n            even = odd = 0\n            if num % 2 == 0:\n                even = 1 + dfs(num // 2)\n            else:\n                # if num is odd we have two option either we increment the num or decrement the num\n                odd1 = 1 + dfs(num - 1)\n                odd2 = 1 + dfs(num + 1)\n                # take the min of both operation\n                odd = min(odd1 odd2)\n\n            dp[num] = even + odd\n            return dp[num]\n\n        return dfs(n)
Integer to English Words,"###  273\. Integer to English Words\n\nConvert a non-negative integer `num` to its English words representation.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 123\n    **Output:** ""One Hundred Twenty Three""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 12345\n    **Output:** ""Twelve Thousand Three Hundred Forty Five""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = 1234567\n    **Output:** ""One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven""\n    \n\n\n\n**Constraints:**\n\n  * `0 <= num <= 231 - 1`\n\n","class Solution:\n    def numberToWords(self num: int) -> str:\n        \n        if num == 0:\n            return ""Zero""\n        \n        dic1 = {1000000000: ""Billion"" 1000000: ""Million"" 1000: ""Thousand"" 1: """"}\n        dic2 = {90: ""Ninety"" 80: ""Eighty"" 70: ""Seventy"" 60: ""Sixty"" 50: ""Fifty"" 40: ""Forty"" 30: ""Thirty"" 20: ""Twenty"" 19: 'Nineteen' 18: ""Eighteen"" 17: ""Seventeen"" 16: ""Sixteen"" 15: ""Fifteen"" 14: ""Fourteen"" 13: ""Thirteen"" 12: ""Twelve"" 11: ""Eleven"" 10: ""Ten"" 9: ""Nine"" 8: ""Eight"" 7: ""Seven"" 6: ""Six"" 5: ""Five"" 4: ""Four"" 3: ""Three"" 2: ""Two"" 1: ""One""}\n        \n        def construct_num(num):\n            ans = ''\n            d num = divmod(num 100)\n            if d > 0:\n                ans += dic2[d] + "" "" + ""Hundred""\n            for k v in dic2.items():\n                d num = divmod(num k)\n                if d > 0:\n                    ans += "" "" + v\n            return ans.lstrip()                               \n        \n        ans = """"\n        for k v in dic1.items():\n            d num = divmod(num k)\n            if d > 0:\n                ans += "" "" + construct_num(d) + "" "" + v\n                \n        return ans.strip()\n"
Integer to Roman,"###  12\. Integer to Roman\n\nRoman numerals are represented by seven different symbols: `I` `V` `X` `L`\n`C` `D` and `M`.\n\n    \n    \n    **Symbol**       **Value**\n    I             1\n    V             5\n    X             10\n    L             50\n    C             100\n    D             500\n    M             1000\n\nFor example `2` is written as `II` in Roman numeral just two one's added\ntogether. `12` is written as `XII` which is simply `X + II`. The number `27`\nis written as `XXVII` which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right.\nHowever the numeral for four is not `IIII`. Instead the number four is\nwritten as `IV`. Because the one is before the five we subtract it making\nfour. The same principle applies to the number nine which is written as `IX`.\nThere are six instances where subtraction is used:\n\n  * `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n  * `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n  * `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven an integer convert it to a roman numeral.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 3\n    **Output:** ""III""\n    **Explanation:** 3 is represented as 3 ones.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 58\n    **Output:** ""LVIII""\n    **Explanation:** L = 50 V = 5 III = 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = 1994\n    **Output:** ""MCMXCIV""\n    **Explanation:** M = 1000 CM = 900 XC = 90 and IV = 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num <= 3999`\n\n","# Runtime: 47 ms (Top 86.4%) | Memory: 16.42 MB (Top 14.9%)\n\nclass Solution:\n    def intToRoman(self num: int) -> str:\n        # Creating Dictionary for Lookup\n        num_map = {\n            1: ""I""\n            5: ""V""    4: ""IV""\n            10: ""X""   9: ""IX""\n            50: ""L""   40: ""XL""\n            100: ""C""  90: ""XC""\n            500: ""D""  400: ""CD""\n            1000: ""M"" 900: ""CM""\n        }\n        \n        # Result Variable\n        r = ''\n        \n        \n        for n in [1000 900 500 400 100 90 50 40 10 9 5 4 1]:\n            # If n in list then add the roman value to result variable\n            while n <= num:\n                r += num_map[n]\n                num-=n\n        return r"
Interleaving String,"###  97\. Interleaving String\n\nGiven strings `s1` `s2` and `s3` find whether `s3` is formed by an\n**interleaving** of `s1` and `s2`.\n\nAn **interleaving** of two strings `s` and `t` is a configuration where `s`\nand `t` are divided into `n` and `m` **non-empty** substrings respectively\nsuch that:\n\n  * `s = s1 + s2 + ... + sn`\n  * `t = t1 + t2 + ... + tm`\n  * `|n - m| <= 1`\n  * The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n**Note:** `a + b` is the concatenation of strings `a` and `b`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)\n\n    \n    \n    **Input:** s1 = ""aabcc"" s2 = ""dbbca"" s3 = ""aadbbcbcac""\n    **Output:** true\n    **Explanation:** One way to obtain s3 is:\n    Split s1 into s1 = ""aa"" + ""bc"" + ""c"" and s2 into s2 = ""dbbc"" + ""a"".\n    Interleaving the two splits we get ""aa"" + ""dbbc"" + ""bc"" + ""a"" + ""c"" = ""aadbbcbcac"".\n    Since s3 can be obtained by interleaving s1 and s2 we return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""aabcc"" s2 = ""dbbca"" s3 = ""aadbbbaccc""\n    **Output:** false\n    **Explanation:** Notice how it is impossible to interleave s2 with any other string to obtain s3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s1 = """" s2 = """" s3 = """"\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `0 <= s1.length s2.length <= 100`\n  * `0 <= s3.length <= 200`\n  * `s1` `s2` and `s3` consist of lowercase English letters.\n\n\n\n**Follow up:** Could you solve it using only `O(s2.length)` additional memory\nspace?\n\n",class Solution:\n    def isInterleave(self s1: str s2: str s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3) :\n            return False\n        dp = [[False] * (len(s2) + 1) for i in range(len(s1) + 1)]\n        dp[len(s1)][len(s2)] = True\n        \n        for i in range(len(s1) -1 -1):\n            for j in range(len(s2) -1 -1):\n                if i < len(s1) and s1[i] == s3[i + j] and dp[i + 1][j]:\n                    dp[i][j] = True\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\n                    dp[i][j] = True\n        return dp[0][0]\n
Intersection of Multiple Arrays,###  2248\. Intersection of Multiple Arrays\n\nGiven a 2D integer array `nums` where `nums[i]` is a non-empty array of\n**distinct** positive integers return _the list of integers that are present\nin**each array** of_ `nums` _sorted in**ascending order**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [[_**3**_ 12_**4**_ 5][12_**3**_ _**4**_][_**3**_ _**4**_ 56]]\n    **Output:** [34]\n    **Explanation:** \n    The only integers present in each of nums[0] = [_**3**_ 12_**4**_ 5] nums[1] = [12_**3**_ _**4**_] and nums[2] = [_**3**_ _**4**_ 56] are 3 and 4 so we return [34].\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [[123][456]]\n    **Output:** []\n    **Explanation:** \n    There does not exist any integer present both in nums[0] and nums[1] so we return an empty list [].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `1 <= sum(nums[i].length) <= 1000`\n  * `1 <= nums[i][j] <= 1000`\n  * All the values of `nums[i]` are **unique**.\n\n,"// Runtime: 55 ms (Top 98.76%) | Memory: 17.70 MB (Top 35.84%)\n\nclass Solution:\n    def intersection(self A: List[List[int]]) -> List[int]:\n        return sorted([k for kv in Counter([x for l in A for x in l]).items() if v==len(A)])\n		\n"
Intersection of Two Arrays,###  349\. Intersection of Two Arrays\n\nGiven two integer arrays `nums1` and `nums2` return _an array of their\nintersection_. Each element in the result must be **unique** and you may\nreturn the result in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [1221] nums2 = [22]\n    **Output:** [2]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [495] nums2 = [94984]\n    **Output:** [94]\n    **Explanation:** [49] is also accepted.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 1000`\n  * `0 <= nums1[i] nums2[i] <= 1000`\n\n,# Runtime: 65 ms (Top 73.60%) | Memory: 14 MB (Top 91.27%)\nclass Solution:\n    def intersection(self nums1: List[int] nums2: List[int]) -> List[int]:\n        nums1.sort()\n        nums2.sort()\n        ans = []\n        i j = 0 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                if len(ans) == 0 or nums1[i] != ans[-1]:\n                    ans.append(nums1[i])\n                i += 1\n                j += 1\n        return ans
Intersection of Two Arrays II,###  350\. Intersection of Two Arrays II\n\nGiven two integer arrays `nums1` and `nums2` return _an array of their\nintersection_. Each element in the result must appear as many times as it\nshows in both arrays and you may return the result in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [1221] nums2 = [22]\n    **Output:** [22]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [495] nums2 = [94984]\n    **Output:** [49]\n    **Explanation:** [94] is also accepted.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 1000`\n  * `0 <= nums1[i] nums2[i] <= 1000`\n\n\n\n**Follow up:**\n\n  * What if the given array is already sorted? How would you optimize your algorithm?\n  * What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?\n  * What if elements of `nums2` are stored on disk and the memory is limited such that you cannot load all elements into the memory at once?\n\n,class Solution:\n    def intersect(self nums1: List[int] nums2: List[int]) -> List[int]:\n        nums1.sort()\n        nums2.sort()\n        ans = []\n        i j = 0 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                ans.append(nums1[i])\n                i += 1\n                j += 1\n        return ans\n
Intersection of Two Linked Lists,###  160\. Intersection of Two Linked Lists\n\nGiven the heads of two singly linked-lists `headA` and `headB` return _the\nnode at which the two lists intersect_. If the two linked lists have no\nintersection at all return `null`.\n\nFor example the following two linked lists begin to intersect at node `c1`:\n\n![](https://assets.leetcode.com/uploads/2021/03/05/160_statement.png)\n\nThe test cases are generated such that there are no cycles anywhere in the\nentire linked structure.\n\n**Note** that the linked lists must **retain their original structure** after\nthe function returns.\n\n**Custom Judge:**\n\nThe inputs to the **judge** are given as follows (your program is **not**\ngiven these inputs):\n\n  * `intersectVal` \- The value of the node where the intersection occurs. This is `0` if there is no intersected node.\n  * `listA` \- The first linked list.\n  * `listB` \- The second linked list.\n  * `skipA` \- The number of nodes to skip ahead in `listA` (starting from the head) to get to the intersected node.\n  * `skipB` \- The number of nodes to skip ahead in `listB` (starting from the head) to get to the intersected node.\n\nThe judge will then create the linked structure based on these inputs and pass\nthe two heads `headA` and `headB` to your program. If you correctly return\nthe intersected node then your solution will be **accepted**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)\n\n    \n    \n    **Input:** intersectVal = 8 listA = [41845] listB = [561845] skipA = 2 skipB = 3\n    **Output:** Intersected at '8'\n    **Explanation:** The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\n    From the head of A it reads as [41845]. From the head of B it reads as [561845]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\n    - Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words they point to two different locations in memory while the nodes with value 8 in A and B (3rd node in A and 4th node in B) point to the same location in memory.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)\n\n    \n    \n    **Input:** intersectVal = 2 listA = [19124] listB = [324] skipA = 3 skipB = 1\n    **Output:** Intersected at '2'\n    **Explanation:** The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\n    From the head of A it reads as [19124]. From the head of B it reads as [324]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/03/05/160_example_3.png)\n\n    \n    \n    **Input:** intersectVal = 0 listA = [264] listB = [15] skipA = 3 skipB = 2\n    **Output:** No intersection\n    **Explanation:** From the head of A it reads as [264]. From the head of B it reads as [15]. Since the two lists do not intersect intersectVal must be 0 while skipA and skipB can be arbitrary values.\n    Explanation: The two lists do not intersect so return null.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes of `listA` is in the `m`.\n  * The number of nodes of `listB` is in the `n`.\n  * `1 <= m n <= 3 * 104`\n  * `1 <= Node.val <= 105`\n  * `0 <= skipA < m`\n  * `0 <= skipB < n`\n  * `intersectVal` is `0` if `listA` and `listB` do not intersect.\n  * `intersectVal == listA[skipA] == listB[skipB]` if `listA` and `listB` intersect.\n\n\n\n**Follow up:** Could you write a solution that runs in `O(m + n)` time and use\nonly `O(1)` memory?\n\n,class Solution:\n    def getIntersectionNode(self headA: ListNode headB: ListNode) -> Optional[ListNode]:\n        m = 0\n        n = 0\n        temp = headA\n        while temp != None:\n            m+=1\n            temp = temp.next\n        temp = headB\n        while temp != None:\n            n+=1\n            temp = temp.next\n        diff = 0\n        if m>=n : \n            diff = m-n\n        else:\n            diff = n-m\n        p1 = headA\n        p2 = headB\n        if max(mn) == m:\n            while diff > 0:\n                p1 = p1.next\n                diff-=1\n        else:\n            while diff > 0:\n                p2 = p2.next\n                diff-=1\n        while p1 != None and p2!=None:\n            if p1 == p2:\n                return p1\n            p1 = p1.next\n            p2 = p2.next\n        return None\n
Interval List Intersections,###  986\. Interval List Intersections\n\nYou are given two lists of closed intervals `firstList` and `secondList`\nwhere `firstList[i] = [starti endi]` and `secondList[j] = [startj endj]`.\nEach list of intervals is pairwise **disjoint** and in **sorted order**.\n\nReturn _the intersection of these two interval lists_.\n\nA **closed interval** `[a b]` (with `a <= b`) denotes the set of real numbers\n`x` with `a <= x <= b`.\n\nThe **intersection** of two closed intervals is a set of real numbers that are\neither empty or represented as a closed interval. For example the\nintersection of `[1 3]` and `[2 4]` is `[2 3]`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/01/30/interval1.png)\n\n    \n    \n    **Input:** firstList = [[02][510][1323][2425]] secondList = [[15][812][1524][2526]]\n    **Output:** [[12][55][810][1523][2424][2525]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** firstList = [[13][59]] secondList = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * `0 <= firstList.length secondList.length <= 1000`\n  * `firstList.length + secondList.length >= 1`\n  * `0 <= starti < endi <= 109`\n  * `endi < starti+1`\n  * `0 <= startj < endj <= 109 `\n  * `endj < startj+1`\n\n,# Runtime: 325 ms (Top 13.56%) | Memory: 15.2 MB (Top 15.52%)\nfrom collections import deque\n\nclass Solution:\n    def intervalIntersection(self firstList: List[List[int]] secondList: List[List[int]]) -> List[List[int]]:\n\n        answer = []\n\n        if len(firstList) == 0 or len(secondList) == 0:\n            return answer\n\n        first_queue= deque(firstList)\n        second_queue = deque(secondList )\n\n        first = first_queue.popleft()\n        second = second_queue.popleft()\n\n        while first_queue or second_queue:\n\n            if first[1] < second[0]:\n                if len(first_queue):\n                    first = first_queue.popleft()\n                    continue\n                break\n            if second[1] < first[0]:\n                if len(second_queue) > 0:\n                    second = second_queue.popleft()\n                    continue\n                break\n\n            if first[0] <= second[0] and second[0] <= first[1]:\n                if first[1] <= second[1]:\n                    answer.append([second[0] first[1]])\n                    if len(first_queue) > 0:\n                        first = first_queue.popleft()\n                        continue\n                    break\n\n                else:\n                    answer.append(second)\n                    if len(second_queue) > 0:\n                        second = second_queue.popleft()\n                        continue\n                    break\n            if second[0] <= first[0] and first[0] <= second[1]:\n                if second[1] <= first[1]:\n                    answer.append([first[0] second[1]])\n                    if len(second_queue) > 0:\n                        second = second_queue.popleft()\n                        continue\n                    break\n\n                else:\n                    answer.append(first)\n                    if len(first_queue) > 0:\n                        first = first_queue.popleft()\n                        continue\n                    break\n\n        if first[0] <= second[0] and second[0] <= first[1]:\n            if first[1] <= second[1]:\n\n                if len(answer) > 0:\n\n                    if answer[-1] != [second[0] first[1]]:\n                        answer.append([second[0] first[1]])\n                elif not answer:\n                    answer.append([second[0] first[1]])\n            else:\n                if len(answer) > 0:\n                    if answer[-1] != second:\n                        answer.append(second)\n                elif not answer:\n                    answer.append(second)\n        elif second[0] <= first[0] and first[0] <= second[1]:\n            if second[1] <= first[1]:\n                if len(answer) > 0:\n                    if answer[-1] != [first[0] second[1]]:\n                        answer.append([first[0] second[1]])\n                elif not answer:\n                    answer.append([first[0] second[1]])\n            else:\n                if len(answer) > 0:\n                    if answer[-1] != first:\n                        answer.append(first)\n                elif not answer:\n\n                    answer.append(first)\n\n        return answer
Intervals Between Identical Elements,###  2121\. Intervals Between Identical Elements\n\nYou are given a **0-indexed** array of `n` integers `arr`.\n\nThe **interval** between two elements in `arr` is defined as the **absolute\ndifference** between their indices. More formally the **interval** between\n`arr[i]` and `arr[j]` is `|i - j|`.\n\nReturn _an array_ `intervals` _of length_ `n` _where_ `intervals[i]` _is**the\nsum of intervals** between _`arr[i]`_and each element in_`arr` _with the same\nvalue as_`arr[i]`_._\n\n**Note:** `|x|` is the absolute value of `x`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [2131233]\n    **Output:** [4272445]\n    **Explanation:**\n    - Index 0: Another 2 is found at index 4. |0 - 4| = 4\n    - Index 1: Another 1 is found at index 3. |1 - 3| = 2\n    - Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7\n    - Index 3: Another 1 is found at index 1. |3 - 1| = 2\n    - Index 4: Another 2 is found at index 0. |4 - 0| = 4\n    - Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4\n    - Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [1051010]\n    **Output:** [5034]\n    **Explanation:**\n    - Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5\n    - Index 1: There is only one 5 in the array so its sum of intervals to identical elements is 0.\n    - Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3\n    - Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4\n    \n\n\n\n**Constraints:**\n\n  * `n == arr.length`\n  * `1 <= n <= 105`\n  * `1 <= arr[i] <= 105`\n\n,"\n# helper data structure Scout\nclass Scout:\n    \n    def __init__(self prev_idx=-1 count_of_equal=0):\n        \n        # record of index of last identical element\n        self.prev_idx = prev_idx\n        \n        # count of identical elements so far\n        self.count_of_equal = count_of_equal\n    \n    def __iter__(self):\n		# ouput previous index and count of equal in order\n        return iter( (self.prev_idx self.count_of_equal) )\n    \n    \n        \nclass Solution:\n    def getDistances(self arr: List[int]) -> List[int]:\n        \n        size = len(arr)\n        \n        pre_scout = defaultdict( Scout )\n        pre_dist_sum = [0 for _ in range(size)]\n        \n        post_scout = defaultdict( Scout )\n        post_dist_sum = [0 for _ in range(size)]\n        \n        \n        ## Step_1:\n        # update for pre_dist_sum table direction is from left to right\n        for i element in enumerate(arr):\n            \n            prev_equal_idx prev_count_of_equal = pre_scout[element]\n            \n            # update pre_dist_sum table if we have identical elements before index i\n            if prev_count_of_equal:\n                pre_dist_sum[i] += pre_dist_sum[ prev_equal_idx ] + (i - prev_equal_idx) * prev_count_of_equal\n            \n            # update Scout information for current element\n            pre_scout[element] = i prev_count_of_equal+1\n            \n        # --------------------------------------------------------------\n        \n        ## Step_2:\n        # update for pos_dist_sum table direction is from right to left\n        for i element in reversed( [*enumerate(arr)] ):\n            \n            post_equal_idx post_count_of_equal = post_scout[element]\n\n            # update post_dist_sum table if we have identical elements after index i\n            if post_count_of_equal:\n                post_dist_sum[i] += post_dist_sum[ post_equal_idx ] + (post_equal_idx - i) * post_count_of_equal\n            \n            # update Scout information for current element\n            post_scout[element] = i post_count_of_equal+1\n            \n            \n        ## Step_3:\n        # Generate final output by definition\n        return [ pre_dist_sum[i] + post_dist_sum[i] for i in range(size) ]\n        \n        \n"
Invalid Transactions,"###  1169\. Invalid Transactions\n\nA transaction is possibly invalid if:\n\n  * the amount exceeds `$1000` or;\n  * if it occurs within (and including) `60` minutes of another transaction with the **same name** in a **different city**.\n\nYou are given an array of strings `transaction` where `transactions[i]`\nconsists of comma-separated values representing the name time (in minutes)\namount and city of the transaction.\n\nReturn a list of `transactions` that are possibly invalid. You may return the\nanswer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** transactions = [""alice20800mtv""""alice50100beijing""]\n    **Output:** [""alice20800mtv""""alice50100beijing""]\n    **Explanation:** The first transaction is invalid because the second transaction occurs within a difference of 60 minutes have the same name and is in a different city. Similarly the second one is invalid too.\n\n**Example 2:**\n\n    \n    \n    **Input:** transactions = [""alice20800mtv""""alice501200mtv""]\n    **Output:** [""alice501200mtv""]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** transactions = [""alice20800mtv""""bob501200mtv""]\n    **Output:** [""bob501200mtv""]\n    \n\n\n\n**Constraints:**\n\n  * `transactions.length <= 1000`\n  * Each `transactions[i]` takes the form `""{name}{time}{amount}{city}""`\n  * Each `{name}` and `{city}` consist of lowercase English letters and have lengths between `1` and `10`.\n  * Each `{time}` consist of digits and represent an integer between `0` and `1000`.\n  * Each `{amount}` consist of digits and represent an integer between `0` and `2000`.\n\n","// Runtime: 51 ms (Top 99.79%) | Memory: 18.10 MB (Top 5.19%)\n\nclass Transaction:\n    def __init__(self name time amount city):\n        self.name = name\n        self.time = int(time)\n        self.amount = int(amount)\n        self.city = city\n\nfrom collections import defaultdict\nclass Solution:\n    def invalidTransactions(self transactions):\n        transactions = [Transaction(*transaction.split('')) for transaction in transactions]\n        transactions.sort(key=lambda t: t.time) # O(nlogn) time\n\n        trans_indexes = defaultdict(list)\n        for i t in enumerate(transactions): # O(n) time\n            trans_indexes[t.name].append(i)\n\n        res = []\n        for name indexes in trans_indexes.items(): # O(n) time\n            left = right = 0\n            for i t_index in enumerate(indexes):\n                t = transactions[t_index]\n                if (t.amount > 1000):\n                    res.append(""{}{}{}{}"".format(t.name t.time t.amount t.city))\n                    continue\n                while left <= len(indexes)-2 and transactions[indexes[left]].time < t.time - 60: # O(60) time\n                    left += 1\n                while right <= len(indexes)-2 and transactions[indexes[right+1]].time <= t.time + 60: # O(60) time\n                    right += 1\n                for i in range(leftright+1): # O(120) time\n                    if transactions[indexes[i]].city != t.city:\n                        res.append(""{}{}{}{}"".format(t.name t.time t.amount t.city))\n                        break\n\n        return res\n"
Invert Binary Tree,###  226\. Invert Binary Tree\n\nGiven the `root` of a binary tree invert the tree and return _its root_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)\n\n    \n    \n    **Input:** root = [4271369]\n    **Output:** [4729631]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)\n\n    \n    \n    **Input:** root = [213]\n    **Output:** [231]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 100]`.\n  * `-100 <= Node.val <= 100`\n\n,# Runtime: 7 ms (Top 98.3%) | Memory: 13.26 MB (Top 67.3%)\n\nclass Solution(object):\n    def invertTree(self root):\n        # Base case...\n        if root == None:\n            return root\n        # swapping process...\n        root.left root.right = root.right root.left\n        # Call the function recursively for the left subtree...\n        self.invertTree(root.left)\n        # Call the function recursively for the right subtree...\n        self.invertTree(root.right)\n        return root     # Return the root...
IPO,###  502\. IPO\n\nSuppose LeetCode will start its **IPO** soon. In order to sell a good price of\nits shares to Venture Capital LeetCode would like to work on some projects to\nincrease its capital before the **IPO**. Since it has limited resources it\ncan only finish at most `k` distinct projects before the **IPO**. Help\nLeetCode design the best way to maximize its total capital after finishing at\nmost `k` distinct projects.\n\nYou are given `n` projects where the `ith` project has a pure profit\n`profits[i]` and a minimum capital of `capital[i]` is needed to start it.\n\nInitially you have `w` capital. When you finish a project you will obtain\nits pure profit and the profit will be added to your total capital.\n\nPick a list of **at most** `k` distinct projects from given projects to\n**maximize your final capital**  and return _the final maximized capital_.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** k = 2 w = 0 profits = [123] capital = [011]\n    **Output:** 4\n    **Explanation:** Since your initial capital is 0 you can only start the project indexed 0.\n    After finishing it you will obtain profit 1 and your capital becomes 1.\n    With capital 1 you can either start the project indexed 1 or the project indexed 2.\n    Since you can choose at most 2 projects you need to finish the project indexed 2 to get the maximum capital.\n    Therefore output the final maximized capital which is 0 + 1 + 3 = 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** k = 3 w = 0 profits = [123] capital = [012]\n    **Output:** 6\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= 105`\n  * `0 <= w <= 109`\n  * `n == profits.length`\n  * `n == capital.length`\n  * `1 <= n <= 105`\n  * `0 <= profits[i] <= 104`\n  * `0 <= capital[i] <= 109`\n\n,from heapq import heappush heappop nlargest\nclass Solution:\n    def findMaximizedCapital(self k: int w: int profits: List[int] capital: List[int]) -> int:\n        if w >= max(capital):\n            return w + sum(nlargest(k profits))\n        \n        projects = [[capital[i]profits[i]] for i in range(len(profits))]\n        projects.sort(key=lambda x: x[0])\n        \n        heap = []\n        \n        for i in range(k):\n            while projects and projects[0][0] <= w:\n                heappush(heap -1*projects.pop(0)[1])\n            \n            if not heap:\n                break\n            p = -heappop(heap)\n            w += p\n        return w\n
Island Perimeter,"###  463\. Island Perimeter\n\nYou are given `row x col` `grid` representing a map where `grid[i][j] = 1`\nrepresents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The\n`grid` is completely surrounded by water and there is exactly one island\n(i.e. one or more connected land cells).\n\nThe island doesn't have ""lakes"" meaning the water inside isn't connected to\nthe water around the island. One cell is a square with side length 1. The grid\nis rectangular width and height don't exceed 100. Determine the perimeter of\nthe island.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/12/island.png)\n\n    \n    \n    **Input:** grid = [[0100][1110][0100][1100]]\n    **Output:** 16\n    **Explanation:** The perimeter is the 16 yellow stripes in the image above.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[1]]\n    **Output:** 4\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[10]]\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `row == grid.length`\n  * `col == grid[i].length`\n  * `1 <= row col <= 100`\n  * `grid[i][j]` is `0` or `1`.\n  * There is exactly one island in `grid`.\n\n",# Runtime: 382 ms (Top 98.7%) | Memory: 16.57 MB (Top 93.9%)\n\nclass Solution:\n    def islandPerimeter(self grid: List[List[int]]) -> int:\n        perimeter = 0\n\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    perimeter += 4\n                    if i != 0 and grid[i-1][j] == 1:\n                        perimeter -= 2\n                    if j != 0 and grid[i][j-1] == 1:\n                        perimeter -= 2 \n            \n        return perimeter\n
Isomorphic Strings,"###  205\. Isomorphic Strings\n\nGiven two strings `s` and `t` _determine if they are isomorphic_.\n\nTwo strings `s` and `t` are isomorphic if the characters in `s` can be\nreplaced to get `t`.\n\nAll occurrences of a character must be replaced with another character while\npreserving the order of characters. No two characters may map to the same\ncharacter but a character may map to itself.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""egg"" t = ""add""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""foo"" t = ""bar""\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""paper"" t = ""title""\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 5 * 104`\n  * `t.length == s.length`\n  * `s` and `t` consist of any valid ascii character.\n\n","class Solution:\n    def isIsomorphic(self s: str t: str) -> bool:\n        dict1={}\n        m=""""\n		#creating a dictionary by mapping each element from string S to string T\n        for ij in zip(st):\n		# this for the cases like ""badc"" and ""baba"" so we dont want two keys mapping to same value hence we can reject directly\n            if j in dict1.values() and i not in dict1.keys():\n                return False\n            dict1[i]=j          \n        \n		#now take each letter from string s and using dictionary values replace it with that specific character\n        for k in s:\n            m=m+dict1[k]\n			\n		#now if newly formed string m == T is same then the strings are Isomorphic\n        if(m==t):\n            return True\n        else:\n            return False\n"
Iterator for Combination,"###  1286\. Iterator for Combination\n\nDesign the `CombinationIterator` class:\n\n  * `CombinationIterator(string characters int combinationLength)` Initializes the object with a string `characters` of **sorted distinct** lowercase English letters and a number `combinationLength` as arguments.\n  * `next()` Returns the next combination of length `combinationLength` in **lexicographical order**.\n  * `hasNext()` Returns `true` if and only if there exists a next combination.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""CombinationIterator"" ""next"" ""hasNext"" ""next"" ""hasNext"" ""next"" ""hasNext""]\n    [[""abc"" 2] [] [] [] [] [] []]\n    **Output**\n    [null ""ab"" true ""ac"" true ""bc"" false]\n    \n    **Explanation**\n    CombinationIterator itr = new CombinationIterator(""abc"" 2);\n    itr.next();    // return ""ab""\n    itr.hasNext(); // return True\n    itr.next();    // return ""ac""\n    itr.hasNext(); // return True\n    itr.next();    // return ""bc""\n    itr.hasNext(); // return False\n    \n\n\n\n**Constraints:**\n\n  * `1 <= combinationLength <= characters.length <= 15`\n  * All the characters of `characters` are **unique**.\n  * At most `104` calls will be made to `next` and `hasNext`.\n  * It is guaranteed that all calls of the function `next` are valid.\n\n","// Runtime: 54 ms (Top 68.38%) | Memory: 20.00 MB (Top 5.53%)\n\nclass CombinationIterator:\n\n    def __init__(self characters: str combinationLength: int):\n        self.characters = characters\n        self.n = len(characters)\n        self.combinations = gen_combinations(self.n combinationLength)\n        self.ind = len(self.combinations) - 1\n\n    def next(self) -> str:\n        s = """"\n        for i in range(self.n):\n            if self.combinations[self.ind][i] != ""0"":\n                s += self.characters[i]\n        self.ind -= 1\n        return s\n\n    def hasNext(self) -> bool:\n        return self.ind > -1 \n    \ndef gen_combinations(l n):\n    end = int(""1"" * l 2)\n    ans = []\n    for i in range(end + 1):\n        b = bin(i)[2:]\n        if b.count('1') == n:\n            ans.append(b.zfill(l))\n    return ans\n"
Jewels and Stones,"###  771\. Jewels and Stones\n\nYou're given strings `jewels` representing the types of stones that are\njewels and `stones` representing the stones you have. Each character in\n`stones` is a type of stone you have. You want to know how many of the stones\nyou have are also jewels.\n\nLetters are case sensitive so `""a""` is considered a different type of stone\nfrom `""A""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** jewels = ""aA"" stones = ""aAAbbbb""\n    **Output:** 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** jewels = ""z"" stones = ""ZZ""\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= jewels.length stones.length <= 50`\n  * `jewels` and `stones` consist of only English letters.\n  * All the characters of `jewels` are **unique**.\n\n","class Solution:\n    def numJewelsInStones(self jewels: str stones: str) -> int:\n		# 1 : One line solution My best runtime 38 with 13.9 MB\n        return sum(1 for k in stones if k in jewels)\n		\n		# 2 : Traditional solution\n		x=0\n		for k in stones:\n			if k in jewels:\n				x+=1\n		return x\n"
Jump Game,###  55\. Jump Game\n\nYou are given an integer array `nums`. You are initially positioned at the\narray's **first index**  and each element in the array represents your\nmaximum jump length at that position.\n\nReturn `true` _if you can reach the last index or_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [23114]\n    **Output:** true\n    **Explanation:** Jump 1 step from index 0 to 1 then 3 steps to the last index.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [32104]\n    **Output:** false\n    **Explanation:** You will always arrive at index 3 no matter what. Its maximum jump length is 0 which makes it impossible to reach the last index.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `0 <= nums[i] <= 105`\n\n,"# Runtime: 1132 ms (Top 16.52%) | Memory: 15.2 MB (Top 81.46%)\nclass Solution:\n    def canJump(self nums: List[int]) -> bool:\n        """"""\n        # Memoization + DFS Solution\n        # TLE as we have as much as n decisions depending on nums[i] which could be\n        # 10^5 as an uppercase according to problem constraints\n        # better off with a greedy approach\n\n        cache = {} # i : bool\n\n        def dfs(i):\n            if i == len(nums) -1:\n                return True\n            if nums[i] == 0:\n                return False\n            if i in cache:\n                return cache[i]\n            for j in range(1 nums[i] + 1):\n                res = dfs(i + j)\n                if res:\n                    cache[i] = True\n                    return cache[i]\n            cache[i] = False\n            return cache[i]\n\n        return dfs(0)\n        """"""\n        # Greedy Solution\n        # Key with greedy is to find a local and gobal optimum\n        # here we find the furthest distance we can travel with each index\n\n        # futhest index reachable\n        reachable = 0\n\n        # iterate through all indexes and if the current index is futher than what we can travel return fasle\n        for i in range(len(nums)):\n            if i > reachable:\n                return False\n\n            reachable = max(reachable nums[i] + i)\n            # if the futherest distance we can jump to is greater or equal than the last index break\n            if reachable >= len(nums) - 1:\n                break\n\n        return True"
Jump Game II,###  45\. Jump Game II\n\nGiven an array of non-negative integers `nums` you are initially positioned\nat the first index of the array.\n\nEach element in the array represents your maximum jump length at that\nposition.\n\nYour goal is to reach the last index in the minimum number of jumps.\n\nYou can assume that you can always reach the last index.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [23114]\n    **Output:** 2\n    **Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1 then 3 steps to the last index.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [23014]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `0 <= nums[i] <= 1000`\n\n,# Runtime: 305 ms (Top 40.77%) | Memory: 15 MB (Top 90.04%)\nclass Solution(object):\n    def jump(self nums):\n        ans = l = r = 0\n\n        while r < len(nums) - 1:\n            farthestJump = 0\n\n            for i in range(l r + 1):\n                farthestJump = max(farthestJump i + nums[i])\n\n            l = r + 1\n            r = farthestJump\n            ans += 1\n\n        return ans
Jump Game III,###  1306\. Jump Game III\n\nGiven an array of non-negative integers `arr` you are initially positioned at\n`start` index of the array. When you are at index `i` you can jump to `i +\narr[i]` or `i - arr[i]` check if you can reach to **any** index with value 0.\n\nNotice that you can not jump outside of the array at any time.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [4230312] start = 5\n    **Output:** true\n    **Explanation:** \n    All possible ways to reach at index 3 with value 0 are: \n    index 5 -> index 4 -> index 1 -> index 3 \n    index 5 -> index 6 -> index 4 -> index 1 -> index 3 \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [4230312] start = 0\n    **Output:** true \n    **Explanation:** One possible way to reach at index 3 with value 0 is: \n    index 0 -> index 4 -> index 1 -> index 3\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [30212] start = 2\n    **Output:** false\n    **Explanation:** There is no way to reach at index 1 with value 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 5 * 104`\n  * `0 <= arr[i] < arr.length`\n  * `0 <= start < arr.length`\n\n,class Solution:\n    def canReach(self arr: List[int] start: int) -> bool:\n        vis = [0]*len(arr)\n        q = deque() \n        q.append(start) \n        while q:\n            cur = q.popleft() \n            print(cur)\n            vis[cur] = 1\n            if arr[cur] == 0:\n                return True\n            if cur+arr[cur]<len(arr) and vis[cur+arr[cur]] == 0:\n                q.append(cur+arr[cur]) \n            if cur-arr[cur]>=0 and vis[cur-arr[cur]] == 0: \n                q.append(cur-arr[cur])  \n        return False\n\n            
Jump Game IV,###  1345\. Jump Game IV\n\nGiven an array of integers `arr` you are initially positioned at the first\nindex of the array.\n\nIn one step you can jump from index `i` to index:\n\n  * `i + 1` where: `i + 1 < arr.length`.\n  * `i - 1` where: `i - 1 >= 0`.\n  * `j` where: `arr[i] == arr[j]` and `i != j`.\n\nReturn _the minimum number of steps_ to reach the **last index** of the array.\n\nNotice that you can not jump outside of the array at any time.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [100-23-234041002323233404]\n    **Output:** 3\n    **Explanation:** You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [7]\n    **Output:** 0\n    **Explanation:** Start index is the last index. You do not need to jump.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [76969697]\n    **Output:** 1\n    **Explanation:** You can jump directly from index 0 to index 7 which is last index of the array.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 5 * 104`\n  * `-108 <= arr[i] <= 108`\n\n,"from collections import deque\nclass Solution:\n    def minJumps(self arr: List[int]) -> int:\n        minSteps = 0\n        queue = deque()\n        queue.append(0)\n        n = len(arr)\n        visited = set()\n        visited.add(0)\n        \n		d = {i:[] for i in arr}\n        \n        for i val in enumerate(arr):\n            d[val].append(i)\n        \n        while queue:\n            for _ in range(len(queue)):\n                idx = queue.popleft()\n                if idx == n - 1:\n                    return minSteps\n                \n                for i in [*d[arr[idx]] idx - 1 idx + 1]:\n                    if i not in visited and 0 <= i < n:\n                        visited.add(i)\n                        queue.append(i)\n                d[arr[idx]].clear()\n            minSteps += 1\n"
Jump Game V,###  1340\. Jump Game V\n\nGiven an array of integers `arr` and an integer `d`. In one step you can jump\nfrom index `i` to index:\n\n  * `i + x` where: `i + x < arr.length` and ` 0 < x <= d`.\n  * `i - x` where: `i - x >= 0` and ` 0 < x <= d`.\n\nIn addition you can only jump from index `i` to index `j` if `arr[i] >\narr[j]` and `arr[i] > arr[k]` for all indices `k` between `i` and `j` (More\nformally `min(i j) < k < max(i j)`).\n\nYou can choose any index of the array and start jumping. Return _the maximum\nnumber of indices_  you can visit.\n\nNotice that you can not jump outside of the array at any time.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/01/23/meta-chart.jpeg)\n\n    \n    \n    **Input:** arr = [641468139710612] d = 2\n    **Output:** 4\n    **Explanation:** You can start at index 10. You can jump 10 --> 8 --> 6 --> 7 as shown.\n    Note that if you start at index 6 you can only jump to index 7. You cannot jump to index 5 because 13 > 9. You cannot jump to index 4 because index 5 is between index 4 and 6 and 13 > 9.\n    Similarly You cannot jump from index 3 to index 2 or index 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [33333] d = 3\n    **Output:** 1\n    **Explanation:** You can start at any index. You always cannot jump to any index.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [7654321] d = 1\n    **Output:** 7\n    **Explanation:** Start at index 0. You can visit all the indicies. \n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 1000`\n  * `1 <= arr[i] <= 105`\n  * `1 <= d <= arr.length`\n\n,class Solution:\n    def maxJumps(self arr: List[int] d: int) -> int:\n        n = len(arr)\n        sorted_arr = []\n        for i in range(n):\n            sorted_arr.append((arr[i] i))\n        sorted_arr.sort(reverse = True)\n        depth = [1 for i in range(n)]\n        while(sorted_arr):\n            val i = sorted_arr.pop()\n            for j in range(i-1 max(-1 i-d-1) -1):\n                if(arr[j] >= arr[i]):\n                    break\n                depth[i] = max(depth[j] + 1 depth[i])\n            for j in range(i+1 min(n i+d+1)):\n                if(arr[j] >= arr[i]):\n                    break\n                depth[i] = max(depth[j] + 1 depth[i])\n        return max(depth)\n
Jump Game VI,###  1696\. Jump Game VI\n\nYou are given a **0-indexed** integer array `nums` and an integer `k`.\n\nYou are initially standing at index `0`. In one move you can jump at most `k`\nsteps forward without going outside the boundaries of the array. That is you\ncan jump from index `i` to any index in the range `[i + 1 min(n - 1 i + k)]`\n**inclusive**.\n\nYou want to reach the last index of the array (index `n - 1`). Your **score**\nis the **sum** of all `nums[j]` for each index `j` you visited in the array.\n\nReturn _the**maximum score** you can get_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [_1_ _-1_ -2_4_ -7_3_] k = 2\n    **Output:** 7\n    **Explanation:** You can choose your jumps forming the subsequence [1-143] (underlined above). The sum is 7.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [_10_ -5-2_4_ 0_3_] k = 3\n    **Output:** 17\n    **Explanation:** You can choose your jumps forming the subsequence [1043] (underlined above). The sum is 17.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1-5-204-13-6-3] k = 2\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length k <= 105`\n  * `-104 <= nums[i] <= 104`\n\n,// Runtime: 791 ms (Top 67.87%) | Memory: 30.60 MB (Top 42.3%)\n\nclass Solution:\n    def maxResult(self nums k):\n        deq n = deque([0]) len(nums)\n\n        for i in range(1 n):\n            while deq and deq[0] < i - k: deq.popleft()\n            nums[i] += nums[deq[0]]   \n            while deq and nums[i] >= nums[deq[-1]]: deq.pop()\n            deq.append(i)\n            \n        return nums[-1]\n
Jump Game VII,"###  1871\. Jump Game VII\n\nYou are given a **0-indexed** binary string `s` and two integers `minJump` and\n`maxJump`. In the beginning you are standing at index `0` which is equal to\n`'0'`. You can move from index `i` to index `j` if the following conditions\nare fulfilled:\n\n  * `i + minJump <= j <= min(i + maxJump s.length - 1)` and\n  * `s[j] == '0'`.\n\nReturn `true` _if you can reach index_`s.length - 1` _in_`s` _ or_`false`\n_otherwise._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""_0_ 11 _0_ 1 _0_ "" minJump = 2 maxJump = 3\n    **Output:** true\n    **Explanation:**\n    In the first step move from index 0 to index 3. \n    In the second step move from index 3 to index 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""01101110"" minJump = 2 maxJump = 3\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 105`\n  * `s[i]` is either `'0'` or `'1'`.\n  * `s[0] == '0'`\n  * `1 <= minJump <= maxJump < s.length`\n\n","class Solution:\n    def canReach(self s: str minJump: int maxJump: int) -> bool:\n		# dp[i] represents whether i is reachable\n        dp = [False for _ in s]\n        dp[0] = True\n\n        for i in range(1 len(s)):\n            if s[i] == ""1"":\n                continue\n\n			# iterate through the solutions in range [i - maxJump i - minJump]\n			# and if any previous spot in range is reachable then i is also reachable\n            window_start = max(0 i - maxJump)\n            window_end = i - minJump\n            for j in range(window_start window_end + 1):\n                if dp[j]:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]       \n\n"
K Closest Points to Origin,###  973\. K Closest Points to Origin\n\nGiven an array of `points` where `points[i] = [xi yi]` represents a point on\nthe **X-Y** plane and an integer `k` return the `k` closest points to the\norigin `(0 0)`.\n\nThe distance between two points on the **X-Y** plane is the Euclidean distance\n(i.e. `√(x1 - x2)2 + (y1 - y2)2`).\n\nYou may return the answer in **any order**. The answer is **guaranteed** to be\n**unique** (except for the order that it is in).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg)\n\n    \n    \n    **Input:** points = [[13][-22]] k = 1\n    **Output:** [[-22]]\n    **Explanation:**\n    The distance between (1 3) and the origin is sqrt(10).\n    The distance between (-2 2) and the origin is sqrt(8).\n    Since sqrt(8) < sqrt(10) (-2 2) is closer to the origin.\n    We only want the closest k = 1 points from the origin so the answer is just [[-22]].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** points = [[33][5-1][-24]] k = 2\n    **Output:** [[33][-24]]\n    **Explanation:** The answer [[-24][33]] would also be accepted.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= points.length <= 104`\n  * `-104 < xi yi < 104`\n\n,# Runtime: 2003 ms (Top 6.82%) | Memory: 20.5 MB (Top 21.33%)\n\ndef cal(ele):\n    return ele[0]**2 +ele[1]**2\n\ndef partition(arrstartend):\n    # We must take a pivot element randomly to make Quick select work faster\n    rdIdx = randint(startend)\n    arr[rdIdx]arr[end] = arr[end]arr[rdIdx]\n    pivot = arr[end]\n    i = start-1\n    pivot_dis = cal(pivot)\n    for j in range(startend):\n        if cal(arr[j]) <= pivot_dis:\n            i+=1\n            arr[j]arr[i] = arr[i]arr[j]\n\n    arr[i+1]arr[end] = arr[end]arr[i+1]\n    return i+1\ndef qSelect(arrkthstartend):\n    if start < end:\n        pv= partition(arrstartend)\n        # _______________________\n        # | Left |ele| Right|\n        # ------------------------\n        # pv\n        # after partition function call pv is the index that sacrify:\n        # all elements in Left will smaller than ele\n        # all elements in Right side will greater than ele\n        if pv == kth:#\n            return\n        if kth < pv:\n            return qSelect(arrkthstartpv-1)\n        else:\n            return qSelect(arrkthpv+1end)\n# Space O (logn) because of using recursion\n# Time: Average case: O(N)\n# Worst case: O(N**2)\nclass Solution:\n    def kClosest(self points k):\n        # print(points)\n        qSelect(pointsk-10len(points)-1)# kth smallest number will be at (k-1) index in sorted array\n        return points[:k]
K Divisible Elements Subarrays,###  2261\. K Divisible Elements Subarrays\n\nGiven an integer array `nums` and two integers `k` and `p` return _the number\nof**distinct subarrays** which have **at most**_ `k` _elements divisible by_\n`p`.\n\nTwo arrays `nums1` and `nums2` are said to be **distinct** if:\n\n  * They are of **different** lengths or\n  * There exists **at least** one index `i` where `nums1[i] != nums2[i]`.\n\nA **subarray** is defined as a **non-empty** contiguous sequence of elements\nin an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [_**2**_ 33_**2**_ _**2**_] k = 2 p = 2\n    **Output:** 11\n    **Explanation:**\n    The elements at indices 0 3 and 4 are divisible by p = 2.\n    The 11 distinct subarrays which have at most k = 2 elements divisible by 2 are:\n    [2] [23] [233] [2332] [3] [33] [332] [3322] [32] [322] and [22].\n    Note that the subarrays [2] and [3] occur more than once in nums but they should each be counted only once.\n    The subarray [23322] should not be counted because it has 3 elements that are divisible by 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234] k = 4 p = 1\n    **Output:** 10\n    **Explanation:**\n    All element of nums are divisible by p = 1.\n    Also every subarray of nums will have at most 4 elements that are divisible by 1.\n    Since all subarrays are distinct the total number of subarrays satisfying all the constraints is 10.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 200`\n  * `1 <= nums[i] p <= 200`\n  * `1 <= k <= nums.length`\n\n\n\n**Follow up:**\n\nCan you solve this problem in O(n2) time complexity?\n\n,"class Solution:\n    def countDistinct(self nums: List[int] k: int p: int) -> int:\n        n = len(nums)                        \n        sub_arrays = set()\n        \n		# generate all combinations of subarray\n        for start in range(n):\n            cnt = 0\n            temp = ''\n            for i in range(start n):\n                if nums[i]%p == 0:\n                    cnt+=1                 \n                temp+=str(nums[i]) + '' # build the sequence subarray in CSV format          \n                if cnt>k: # check for termination \n                    break\n                sub_arrays.add(temp)                                    \n                \n        return len(sub_arrays)\n"
K Highest Ranked Items Within a Price Range,###  2146\. K Highest Ranked Items Within a Price Range\n\nYou are given a **0-indexed** 2D integer array `grid` of size `m x n` that\nrepresents a map of the items in a shop. The integers in the grid represent\nthe following:\n\n  * `0` represents a wall that you cannot pass through.\n  * `1` represents an empty cell that you can freely move to and from.\n  * All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.\n\nIt takes `1` step to travel between adjacent grid cells.\n\nYou are also given integer arrays `pricing` and `start` where `pricing = [low\nhigh]` and `start = [row col]` indicates that you start at the position\n`(row col)` and are interested only in items with a price in the range of\n`[low high]` (**inclusive**). You are further given an integer `k`.\n\nYou are interested in the **positions** of the `k` **highest-ranked** items\nwhose prices are **within** the given price range. The rank is determined by\nthe **first** of these criteria that is different:\n\n  1. Distance defined as the length of the shortest path from the `start` (**shorter** distance has a higher rank).\n  2. Price (**lower** price has a higher rank but it must be **in the price range**).\n  3. The row number (**smaller** row number has a higher rank).\n  4. The column number (**smaller** column number has a higher rank).\n\nReturn _the_`k` _highest-ranked items within the price range**sorted** by\ntheir rank (highest to lowest)_. If there are fewer than `k` reachable items\nwithin the price range return _**all** of them_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/16/example1drawio.png)\n\n    \n    \n    **Input:** grid = [[1201][1301][0251]] pricing = [25] start = [00] k = 3\n    **Output:** [[01][11][21]]\n    **Explanation:** You start at (00).\n    With a price range of [25] we can take items from (01) (11) (21) and (22).\n    The ranks of these items are:\n    - (01) with distance 1\n    - (11) with distance 2\n    - (21) with distance 3\n    - (22) with distance 4\n    Thus the 3 highest ranked items in the price range are (01) (11) and (21).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/16/example2drawio1.png)\n\n    \n    \n    **Input:** grid = [[1201][1331][0251]] pricing = [23] start = [23] k = 2\n    **Output:** [[21][12]]\n    **Explanation:** You start at (23).\n    With a price range of [23] we can take items from (01) (11) (12) and (21).\n    The ranks of these items are:\n    - (21) with distance 2 price 2\n    - (12) with distance 2 price 3\n    - (11) with distance 3\n    - (01) with distance 4\n    Thus the 2 highest ranked items in the price range are (21) and (12).\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/12/30/example3.png)\n\n    \n    \n    **Input:** grid = [[111][001][234]] pricing = [23] start = [00] k = 3\n    **Output:** [[21][20]]\n    **Explanation:** You start at (00).\n    With a price range of [23] we can take items from (20) and (21). \n    The ranks of these items are: \n    - (21) with distance 5\n    - (20) with distance 6\n    Thus the 2 highest ranked items in the price range are (21) and (20). \n    Note that k = 3 but there are only 2 reachable items within the price range.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 105`\n  * `1 <= m * n <= 105`\n  * `0 <= grid[i][j] <= 105`\n  * `pricing.length == 2`\n  * `2 <= low <= high <= 105`\n  * `start.length == 2`\n  * `0 <= row <= m - 1`\n  * `0 <= col <= n - 1`\n  * `grid[row][col] > 0`\n  * `1 <= k <= m * n`\n\n,# Runtime: 3258 ms (Top 98.66%) | Memory: 66 MB (Top 18.12%)\nclass Solution:\n    def highestRankedKItems(self G pricing start k):\n        m n = len(G) len(G[0])\n        row col = start\n        node = (0 G[row][col] row col)\n        visited = set()\n        visited.add((row col))\n        d = deque([node])\n        ans = []\n\n        while d:\n            dist cost row col = d.popleft()\n            if pricing[0] <= cost <= pricing[1]:\n                ans += [(dist cost row col)]\n\n            for x y in (row - 1 col) (row + 1 col) (row col - 1) (row col + 1):\n                if 0 <= x <= m-1 and 0 <= y <= n-1 and (x y) not in visited and G[x][y] != 0:\n                    d.append((dist + 1 G[x][y] x y))\n                    visited.add((x y))\n\n        ans = sorted(ans)\n\n        return [[x y] for _ _ x y in ans[:k]]
K Inverse Pairs Array,###  629\. K Inverse Pairs Array\n\nFor an integer array `nums` an **inverse pair** is a pair of integers `[i\nj]` where `0 <= i < j < nums.length` and `nums[i] > nums[j]`.\n\nGiven two integers n and k return the number of different arrays consist of\nnumbers from `1` to `n` such that there are exactly `k` **inverse pairs**.\nSince the answer can be huge return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 k = 0\n    **Output:** 1\n    **Explanation:** Only the array [123] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3 k = 1\n    **Output:** 2\n    **Explanation:** The array [132] and [213] have exactly 1 inverse pair.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n  * `0 <= k <= 1000`\n\n,"// Runtime: 185 ms (Top 92.81%) | Memory: 17.30 MB (Top 67.63%)\n\nclass Solution:\n                        # A very good description of the dp solution is at\n                        # https://leetcode.com/problems/k-inverse-pairs-array/solution/ \n                        # The code below uses two 1D arrays--dp and tmp--instead if a \n                        # 2D array. tmp replaces dp after each i-iteration.\n    def kInversePairs(self n: int k: int) -> int:\n        dp mod = [1]+[0] * k 1000000007\n        \n        for i in range(n):\n            tmp sm = [] 0\n            for j in range(k + 1):\n                sm+= dp[j]\n                if j-i >= 1: sm-= dp[j-i-1]\n                sm%= mod\n                tmp.append(sm)\n            dp = tmp\n            #print(dp)       # <-- uncomment this line to get a sense of dp from the print output\n			                 #     try n = 6 k = 4; your answer should be 49.\n        return dp[k]"
K-Concatenation Maximum Sum,###  1191\. K-Concatenation Maximum Sum\n\nGiven an integer array `arr` and an integer `k` modify the array by repeating\nit `k` times.\n\nFor example if `arr = [1 2]` and `k = 3 `then the modified array will be\n`[1 2 1 2 1 2]`.\n\nReturn the maximum sub-array sum in the modified array. Note that the length\nof the sub-array can be `0` and its sum in that case is `0`.\n\nAs the answer can be very large return the answer **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [12] k = 3\n    **Output:** 9\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [1-21] k = 5\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [-1-2] k = 7\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 105`\n  * `1 <= k <= 105`\n  * `-104 <= arr[i] <= 104`\n\n,class Solution:\n    def kConcatenationMaxSum(self arr: List[int] k: int) -> int:\n        \n        dp = [0] * len(arr) # sum of the best subarry ends at i\n        dp[0] = arr[0]\n        total = arr[0] # total sum \n        right = arr[0] # sum of the best subarray starts at 0\n        \n        p = 1 \n        while p < len(arr):\n            dp[p] = max(arr[p] dp[p-1] + arr[p])\n            total += arr[p] \n            right = max(right total)\n            \n            p += 1\n        \n        isolated = max(dp + [0]) # max sum\n        left = dp[-1] # sum of the best subarray ends at n-1\n        \n        if k == 1:\n            \n            return isolated  % (10**9 + 7)\n        \n        return max(left + right + max(0(k-2) * total) isolated) % (10**9 + 7)\n
K-diff Pairs in an Array,###  532\. K-diff Pairs in an Array\n\nGiven an array of integers `nums` and an integer `k` return _the number\nof**unique** k-diff pairs in the array_.\n\nA **k-diff** pair is an integer pair `(nums[i] nums[j])` where the following\nare true:\n\n  * `0 <= i j < nums.length`\n  * `i != j`\n  * `nums[i] - nums[j] == k`\n\n**Notice** that `|val|` denotes the absolute value of `val`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [31415] k = 2\n    **Output:** 2\n    **Explanation:** There are two 2-diff pairs in the array (1 3) and (3 5).\n    Although we have two 1s in the input we should only return the number of **unique** pairs.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12345] k = 1\n    **Output:** 4\n    **Explanation:** There are four 1-diff pairs in the array (1 2) (2 3) (3 4) and (4 5).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [13154] k = 0\n    **Output:** 1\n    **Explanation:** There is one 0-diff pair in the array (1 1).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-107 <= nums[i] <= 107`\n  * `0 <= k <= 107`\n\n,class Solution:\n    def findPairs(self nums: List[int] k: int) -> int:\n        nums.sort()\n        dict1={}\n        s=0\n        res=[]\n        for n in nums:\n            if dict1.get(nNone) is not None:\n                res.append(n)\n            dict1[n+k]=n\n        res=list(set(res))\n        return len(res)\n
K-Similar Strings,"###  854\. K-Similar Strings\n\nStrings `s1` and `s2` are `k`**-similar** (for some non-negative integer `k`)\nif we can swap the positions of two letters in `s1` exactly `k` times so that\nthe resulting string equals `s2`.\n\nGiven two anagrams `s1` and `s2` return the smallest `k` for which `s1` and\n`s2` are `k`**-similar**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s1 = ""ab"" s2 = ""ba""\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""abc"" s2 = ""bca""\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s1.length <= 20`\n  * `s2.length == s1.length`\n  * `s1` and `s2` contain only lowercase letters from the set `{'a' 'b' 'c' 'd' 'e' 'f'}`.\n  * `s2` is an anagram of `s1`.\n\n",class Solution:\n    def kSimilarity(self s1: str s2: str) -> int:\n        n = len(s1)\n        \n        def helper(i curr dp):\n            if curr == s2:\n                return 0\n            \n            if curr not in dp[i]:\n                if curr[i] == s2[i]:\n                    dp[i][curr] = helper(i+1 curr dp)\n                else:\n                    temp = sys.maxsize\n                    for j in range(i+1 n):\n                        if curr[j] == s2[i]:\n                            temp = min(temp 1+helper(i+1 curr[:i]+curr[j]+curr[i+1:j]+curr[i]+curr[j+1:] dp))\n\n                    dp[i][curr] = temp\n            return dp[i][curr]\n        \n        dp = [{} for _ in range(n)]\n        return helper(0 s1 dp)\n
K-th Smallest in Lexicographical Order,###  440\. K-th Smallest in Lexicographical Order\n\nGiven two integers `n` and `k` return _the_ `kth` _lexicographically smallest\ninteger in the range_ `[1 n]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 13 k = 2\n    **Output:** 10\n    **Explanation:** The lexicographical order is [1 10 11 12 13 2 3 4 5 6 7 8 9] so the second smallest number is 10.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1 k = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= n <= 109`\n\n,class Solution:\n    def findKthNumber(self n: int k: int) -> int:\n        \n        def prefix(opn):\n            if op==n: return 1\n            if int(op)>int(n): return 0\n            for i in range(len(op)):\n                if int(op[i])>int(n[i]): \n                    rem = len(n)-1-len(op)\n                    if not rem: return 1\n                    return 1+int(10*((1-10**rem)/-9))\n                elif int(op[i])<int(n[i]): \n                    rem = len(n)-len(op)\n                    if not rem: return 1\n                    return 1+int(10*((1-10**rem)/-9))\n                \n            res = 1\n            for i in range(10):\n                res += prefix(op+str(i)n)\n            return res\n    \n        ans = 1\n        while k>1:\n            pref = prefix(str(ans)str(n)) \n            if pref >= k:\n                ans*=10; k-=1\n            else: \n                ans += 1; k-= pref\n        \n        return ans\n    \n    \n
K-th Smallest Prime Fraction,###  786\. K-th Smallest Prime Fraction\n\nYou are given a sorted integer array `arr` containing `1` and **prime**\nnumbers where all the integers of `arr` are unique. You are also given an\ninteger `k`.\n\nFor every `i` and `j` where `0 <= i < j < arr.length` we consider the\nfraction `arr[i] / arr[j]`.\n\nReturn _the_ `kth` _smallest fraction considered_. Return your answer as an\narray of integers of size `2` where `answer[0] == arr[i]` and `answer[1] ==\narr[j]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [1235] k = 3\n    **Output:** [25]\n    **Explanation:** The fractions to be considered in sorted order are:\n    1/5 1/3 2/5 1/2 3/5 and 2/3.\n    The third fraction is 2/5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [17] k = 1\n    **Output:** [17]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= arr.length <= 1000`\n  * `1 <= arr[i] <= 3 * 104`\n  * `arr[0] == 1`\n  * `arr[i]` is a **prime** number for `i > 0`.\n  * All the numbers of `arr` are **unique** and sorted in **strictly increasing** order.\n  * `1 <= k <= arr.length * (arr.length - 1) / 2`\n\n\n\n**Follow up:** Can you solve the problem with better than `O(n2)` complexity?\n\n,"class Solution {\npublic:\n    vector<int> kthSmallestPrimeFraction(vector<int>& arr int k) {\n        priority_queue<pair<double pair<int int>> vector<pair<double pair<int int>>> greater<pair<double pair<int int>>>> myHeap;\n        for (int i=0; i<arr.size(); ++i) {\n            for (int j=i + 1; j < arr.size(); ++j) {\n                myHeap.push({(double)arr[i] / (double)arr[j] {arr[i] arr[j]}});\n				// Add all pair of numbers in the heap\n            }\n        }\n        for (int i=1; i<k; ++i) {\n            myHeap.pop();\n        }\n        return {myHeap.top().second.first myHeap.top().second.second};\n    }\n};\n// Time : O(n^2 + klogn)\n// Space : O(m^2)\n"
K-th Symbol in Grammar,###  779\. K-th Symbol in Grammar\n\nWe build a table of `n` rows (**1-indexed**). We start by writing `0` in the\n`1st` row. Now in every subsequent row we look at the previous row and\nreplace each occurrence of `0` with `01` and each occurrence of `1` with\n`10`.\n\n  * For example for `n = 3` the `1st` row is `0` the `2nd` row is `01` and the `3rd` row is `0110`.\n\nGiven two integer `n` and `k` return the `kth` (**1-indexed**) symbol in the\n`nth` row of a table of `n` rows.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1 k = 1\n    **Output:** 0\n    **Explanation:** row 1: _0_\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 k = 1\n    **Output:** 0\n    **Explanation:** \n    row 1: 0\n    row 2: _0_ 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 2 k = 2\n    **Output:** 1\n    **Explanation:** \n    row 1: 0\n    row 2: 0 _1_\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 30`\n  * `1 <= k <= 2n - 1`\n\n,class Solution:\n  def solve(selfnk):\n    if n==1 and k==1:\n      return 0 \n    mid = pow(2n-1)//2 \n    if k<=mid:\n      return self.solve(n-1k) \n    \n    return not self.solve(n-1k-mid)\n    \n      \n  def kthGrammar(selfnk):\n    if self.solve(nk):\n      return 1 \n    else:\n      return 0 \n      \n    \n   \n    \n    \n    \n    \n    \n    \n    \n
Keyboard Row,"###  500\. Keyboard Row\n\nGiven an array of strings `words` return _the words that can be typed using\nletters of the alphabet on only one row of American keyboard like the image\nbelow_.\n\nIn the **American keyboard** :\n\n  * the first row consists of the characters `""qwertyuiop""`\n  * the second row consists of the characters `""asdfghjkl""` and\n  * the third row consists of the characters `""zxcvbnm""`.\n\n![](https://assets.leetcode.com/uploads/2018/10/12/keyboard.png)\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""Hello""""Alaska""""Dad""""Peace""]\n    **Output:** [""Alaska""""Dad""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""omk""]\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""adsdf""""sfd""]\n    **Output:** [""adsdf""""sfd""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 20`\n  * `1 <= words[i].length <= 100`\n  * `words[i]` consists of English letters (both lowercase and uppercase). \n\n",// Runtime: 34 ms (Top 77.79%) | Memory: 17.40 MB (Top 7.9%)\n\nclass Solution:\n    def findWords(self words: List[str]) -> List[str]:\n        #\n        set1 = {'q''w''e''r''t''y''u''i''o''p'}\n        set2 = {'a''s''d''f''g''h''j''k''l'}\n        set3 = {'z''x''c''v''b''n''m'}\n        \n        res = []\n        for i in words:\n            wordset = set(i.lower())\n            if (wordset&set1 == wordset) or (wordset&set2 == wordset) or (wordset&set3 == wordset):\n                res.append(i)\n        return res\n
Keys and Rooms,###  841\. Keys and Rooms\n\nThere are `n` rooms labeled from `0` to `n - 1` and all the rooms are locked\nexcept for room `0`. Your goal is to visit all the rooms. However you cannot\nenter a locked room without having its key.\n\nWhen you visit a room you may find a set of **distinct keys** in it. Each key\nhas a number on it denoting which room it unlocks and you can take all of\nthem with you to unlock the other rooms.\n\nGiven an array `rooms` where `rooms[i]` is the set of keys that you can obtain\nif you visited room `i` return `true` _if you can visit**all** the rooms or_\n`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rooms = [[1][2][3][]]\n    **Output:** true\n    **Explanation:** \n    We visit room 0 and pick up key 1.\n    We then visit room 1 and pick up key 2.\n    We then visit room 2 and pick up key 3.\n    We then visit room 3.\n    Since we were able to visit every room we return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rooms = [[13][301][2][0]]\n    **Output:** false\n    **Explanation:** We can not enter room number 2 since the only key that unlocks it is in that room.\n    \n\n\n\n**Constraints:**\n\n  * `n == rooms.length`\n  * `2 <= n <= 1000`\n  * `0 <= rooms[i].length <= 1000`\n  * `1 <= sum(rooms[i].length) <= 3000`\n  * `0 <= rooms[i][j] < n`\n  * All the values of `rooms[i]` are **unique**.\n\n,class Solution:\n    def canVisitAllRooms(self rooms: List[List[int]]) -> bool:\n        # Create a set of for rooms visited\n        visited_rooms = set()\n        \n        # Create a queue to do a breadth first search visiting rooms\n        # Append the first room 0 to the queue to begin the search\n        queue = collections.deque()\n        queue.append(0)\n        \n        # Perform the breadth first search with the queue\n        while queue:\n            for _ in range(0 len(queue)):\n                # Search the room\n                room_number = queue.popleft()\n                \n                # If we haven't visited the room get the keys from the room\n                if room_number not in visited_rooms:\n                \n                    # Collect the keys from the room\n                    found_keys = rooms[room_number]\n                    \n                    # Add the keys to the queue so they can be tested\n                    for key in found_keys:\n                        queue.append(key)\n                        \n                    # Add the current room to the visited set\n                    visited_rooms.add(room_number)\n        \n        # If we visited all of the rooms then the number of visited rooms should be\n        # equal to the number of total rooms\n        if len(visited_rooms) == len(rooms):\n            return True\n        \n        return False\n
Kids With the Greatest Number of Candies,###  1431\. Kids With the Greatest Number of Candies\n\nThere are `n` kids with candies. You are given an integer array `candies`\nwhere each `candies[i]` represents the number of candies the `ith` kid has\nand an integer `extraCandies` denoting the number of extra candies that you\nhave.\n\nReturn _a boolean array_`result` _of length_`n` _ where_`result[i]`_is_`true`\n_if after giving the_`ith` _kid all the_`extraCandies` _ they will have\nthe**greatest** number of candies among all the kids_ _ or_`false`\n_otherwise_.\n\nNote that **multiple** kids can have the **greatest** number of candies.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** candies = [23513] extraCandies = 3\n    **Output:** [truetruetruefalsetrue] \n    **Explanation:** If you give all extraCandies to:\n    - Kid 1 they will have 2 + 3 = 5 candies which is the greatest among the kids.\n    - Kid 2 they will have 3 + 3 = 6 candies which is the greatest among the kids.\n    - Kid 3 they will have 5 + 3 = 8 candies which is the greatest among the kids.\n    - Kid 4 they will have 1 + 3 = 4 candies which is not the greatest among the kids.\n    - Kid 5 they will have 3 + 3 = 6 candies which is the greatest among the kids.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** candies = [42112] extraCandies = 1\n    **Output:** [truefalsefalsefalsefalse] \n    **Explanation:** There is only 1 extra candy.\n    Kid 1 will always have the greatest number of candies even if a different kid is given the extra candy.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** candies = [12112] extraCandies = 10\n    **Output:** [truefalsetrue]\n    \n\n\n\n**Constraints:**\n\n  * `n == candies.length`\n  * `2 <= n <= 100`\n  * `1 <= candies[i] <= 100`\n  * `1 <= extraCandies <= 50`\n\n,class Solution:\n    def kidsWithCandies(self candy extra):\n        #create an array(res) with all values as True and it's lenght is same as candies\n        res = [True]*len(candy)\n        #iterate over the elements in the array candy\n        for i in range(len(candy)):\n            #if the no. of canides at curr position + extra is greater than or equal to the maximum of candies then continue \n            if (candy[i] + extra) >= max(candy):\n                continue\n            #if not \n            else:\n                #change the value of that position in res as false\n                res[i] = False\n        #return the res list\n        return res   
Knight Dialer,###  935\. Knight Dialer\n\nThe chess knight has a **unique movement**  it may move two squares\nvertically and one square horizontally or two squares horizontally and one\nsquare vertically (with both forming the shape of an **L**). The possible\nmovements of chess knight are shown in this diagaram:\n\nA chess knight can move as indicated in the chess diagram below:\n\n![](https://assets.leetcode.com/uploads/2020/08/18/chess.jpg)\n\nWe have a chess knight and a phone pad as shown below the knight **can only\nstand on a numeric cell**  (i.e. blue cell).\n\n![](https://assets.leetcode.com/uploads/2020/08/18/phone.jpg)\n\nGiven an integer `n` return how many distinct phone numbers of length `n` we\ncan dial.\n\nYou are allowed to place the knight **on any numeric cell** initially and then\nyou should perform `n - 1` jumps to dial a number of length `n`. All jumps\nshould be **valid** knight jumps.\n\nAs the answer may be very large **return the answer modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 10\n    **Explanation:** We need to dial a number of length 1 so placing the knight over any numeric cell of the 10 cells is sufficient.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 20\n    **Explanation:** All the valid number we can dial are [04 06 16 18 27 29 34 38 40 43 49 60 61 67 72 76 81 83 92 94]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3131\n    **Output:** 136006598\n    **Explanation:** Please take care of the mod.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 5000`\n\n,// Runtime: 226 ms (Top 89.51%) | Memory: 16.80 MB (Top 56.81%)\n\nclass Solution:\n    MOD = 10**9 + 7\n\n    def knightDialer(self n: int) -> int:\n        # Initialize an array to store the possible positions of the knight on the phone pad\n        cur_pos = [1] * 10\n\n        # Loop through the number of jumps required\n        for jump in range(2 n + 1):\n            # Create a new list to store the updated positions after each jump\n            new_pos = [0] * 10\n\n            # Calculate the new positions based on the valid knight moves\n            new_pos[0] = (cur_pos[6] + cur_pos[4]) % self.MOD\n            new_pos[1] = (cur_pos[6] + cur_pos[8]) % self.MOD\n            new_pos[2] = (cur_pos[7] + cur_pos[9]) % self.MOD\n            new_pos[3] = (cur_pos[4] + cur_pos[8]) % self.MOD\n            new_pos[4] = (cur_pos[0] + cur_pos[3] + cur_pos[9]) % self.MOD\n            new_pos[5] = 0  # Knight cannot move to position 5\n            new_pos[6] = (cur_pos[0] + cur_pos[1] + cur_pos[7]) % self.MOD\n            new_pos[7] = (cur_pos[2] + cur_pos[6]) % self.MOD\n            new_pos[8] = (cur_pos[1] + cur_pos[3]) % self.MOD\n            new_pos[9] = (cur_pos[2] + cur_pos[4]) % self.MOD\n\n            # Update the current positions list for the next iteration\n            cur_pos = new_pos\n\n        # Calculate the total count of distinct phone numbers\n        total_count = sum(cur_pos) % self.MOD\n\n        return total_count\n
Knight Probability in Chessboard,###  688\. Knight Probability in Chessboard\n\nOn an `n x n` chessboard a knight starts at the cell `(row column)` and\nattempts to make exactly `k` moves. The rows and columns are **0-indexed** \nso the top-left cell is `(0 0)` and the bottom-right cell is `(n - 1 n -\n1)`.\n\nA chess knight has eight possible moves it can make as illustrated below.\nEach move is two cells in a cardinal direction then one cell in an orthogonal\ndirection.\n\n![](https://assets.leetcode.com/uploads/2018/10/12/knight.png)\n\nEach time the knight is to move it chooses one of eight possible moves\nuniformly at random (even if the piece would go off the chessboard) and moves\nthere.\n\nThe knight continues moving until it has made exactly `k` moves or has moved\noff the chessboard.\n\nReturn _the probability that the knight remains on the board after it has\nstopped moving_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 k = 2 row = 0 column = 0\n    **Output:** 0.06250\n    **Explanation:** There are two moves (to (12) (21)) that will keep the knight on the board.\n    From each of those positions there are also two moves that will keep the knight on the board.\n    The total probability the knight stays on the board is 0.0625.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1 k = 0 row = 0 column = 0\n    **Output:** 1.00000\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 25`\n  * `0 <= k <= 100`\n  * `0 <= row column <= n`\n\n,class Solution:\n    def knightProbability(self n: int k: int row: int column: int) -> float:\n        \n        x_dir = [2 1 -1 -2 -2 -1 1 2]\n        y_dir = [1 2 2 1 -1 -2 -2 -1]\n        \n        cache = {}\n        \n        def kMoves(i j moves):\n            if i >= n or j >= n or i < 0 or j < 0:\n                return 0\n            \n            if moves == k:\n                return 1\n            \n            if (i j moves) in cache:\n                return cache[(i j moves)]\n            \n            totMoves = 0\n            for ind in range(8):\n                totMoves += kMoves(i+x_dir[ind] j+y_dir[ind] moves+1)*(1/8)\n            \n            cache[(i j moves)] = totMoves\n            return totMoves\n        \n        return kMoves(row column 0)\n
Koko Eating Bananas,###  875\. Koko Eating Bananas\n\nKoko loves to eat bananas. There are `n` piles of bananas the `ith` pile has\n`piles[i]` bananas. The guards have gone and will come back in `h` hours.\n\nKoko can decide her bananas-per-hour eating speed of `k`. Each hour she\nchooses some pile of bananas and eats `k` bananas from that pile. If the pile\nhas less than `k` bananas she eats all of them instead and will not eat any\nmore bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas\nbefore the guards return.\n\nReturn _the minimum integer_ `k` _such that she can eat all the bananas\nwithin_ `h` _hours_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** piles = [36711] h = 8\n    **Output:** 4\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** piles = [301123420] h = 5\n    **Output:** 30\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** piles = [301123420] h = 6\n    **Output:** 23\n    \n\n\n\n**Constraints:**\n\n  * `1 <= piles.length <= 104`\n  * `piles.length <= h <= 109`\n  * `1 <= piles[i] <= 109`\n\n,# Runtime: 308 ms (Top 92.4%) | Memory: 17.82 MB (Top 76.3%)\n\nclass Solution:\n    def minEatingSpeed(self piles: List[int] h: int) -> int:\n        def check(x):\n            return sum(ceil(ele/x) for ele in piles) <= h\n\n        l = 1\n        r = max(piles)\n        while l < r:\n            mid = (l+r) >> 1\n            if not check(mid):\n                l=mid+1\n            else:\n                r=mid\n        return l
Kth Distinct String in an Array,"###  2053\. Kth Distinct String in an Array\n\nA **distinct string** is a string that is present only **once** in an array.\n\nGiven an array of strings `arr` and an integer `k` return _the_`kth`\n_**distinct string** present in _`arr`. If there are **fewer** than `k`\ndistinct strings return _an**empty string**_`""""`.\n\nNote that the strings are considered in the **order in which they appear** in\nthe array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [""d""""b""""c""""b""""c""""a""] k = 2\n    **Output:** ""a""\n    **Explanation:**\n    The only distinct strings in arr are ""d"" and ""a"".\n    ""d"" appears 1st so it is the 1st distinct string.\n    ""a"" appears 2nd so it is the 2nd distinct string.\n    Since k == 2 ""a"" is returned. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [""aaa""""aa""""a""] k = 1\n    **Output:** ""aaa""\n    **Explanation:**\n    All strings in arr are distinct so the 1st string ""aaa"" is returned.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [""a""""b""""a""] k = 3\n    **Output:** """"\n    **Explanation:**\n    The only distinct string is ""b"". Since there are fewer than 3 distinct strings we return an empty string """".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= arr.length <= 1000`\n  * `1 <= arr[i].length <= 5`\n  * `arr[i]` consists of lowercase English letters.\n\n","class Solution:\n    def kthDistinct(self arr: List[str] k: int) -> str:\n        hash_map = {}\n        for string in arr:\n            hash_map[string] = hash_map.get(string 0) + 1\n        for string in arr:\n            if hash_map[string] == 1:\n                k -= 1\n                if k == 0:\n                    return string\n        return """"\n"
Kth Largest Element in a Stream,"###  703\. Kth Largest Element in a Stream\n\nDesign a class to find the `kth` largest element in a stream. Note that it is\nthe `kth` largest element in the sorted order not the `kth` distinct element.\n\nImplement `KthLargest` class:\n\n  * `KthLargest(int k int[] nums)` Initializes the object with the integer `k` and the stream of integers `nums`.\n  * `int add(int val)` Appends the integer `val` to the stream and returns the element representing the `kth` largest element in the stream.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""KthLargest"" ""add"" ""add"" ""add"" ""add"" ""add""]\n    [[3 [4 5 8 2]] [3] [5] [10] [9] [4]]\n    **Output**\n    [null 4 5 5 8 8]\n    \n    **Explanation**\n    KthLargest kthLargest = new KthLargest(3 [4 5 8 2]);\n    kthLargest.add(3);   // return 4\n    kthLargest.add(5);   // return 5\n    kthLargest.add(10);  // return 5\n    kthLargest.add(9);   // return 8\n    kthLargest.add(4);   // return 8\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= 104`\n  * `0 <= nums.length <= 104`\n  * `-104 <= nums[i] <= 104`\n  * `-104 <= val <= 104`\n  * At most `104` calls will be made to `add`.\n  * It is guaranteed that there will be at least `k` elements in the array when you search for the `kth` element.\n\n",# Runtime: 143 ms (Top 61.21%) | Memory: 18.3 MB (Top 46.75%)\nclass KthLargest:\n    def __init__(self k: int nums: List[int]):\n        self.k = k\n        self.hp = []\n        for x in nums:\n            self.add(x)\n\n        return None\n\n    def add(self val: int) -> int:\n        heapq.heappush(self.hp (val))\n        if len(self.hp) > self.k:\n            heapq.heappop(self.hp)\n\n        return self.get_kth_largest()\n\n    def get_kth_largest(self):\n        return self.hp[0]
Kth Largest Element in an Array,###  215\. Kth Largest Element in an Array\n\nGiven an integer array `nums` and an integer `k` return _the_ `kth` _largest\nelement in the array_.\n\nNote that it is the `kth` largest element in the sorted order not the `kth`\ndistinct element.\n\nYou must solve it in `O(n)` time complexity.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [321564] k = 2\n    **Output:** 5\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [323124556] k = 4\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= nums.length <= 105`\n  * `-104 <= nums[i] <= 104`\n\n,class Solution:\n    def findKthLargest(self nums: List[int] k: int) -> int:\n        nums.sort(reverse = True)\n        return nums[k-1]
Kth Smallest Element in a BST,###  230\. Kth Smallest Element in a BST\n\nGiven the `root` of a binary search tree and an integer `k` return _the_\n`kth` _smallest value (**1-indexed**) of all the values of the nodes in the\ntree_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)\n\n    \n    \n    **Input:** root = [314null2] k = 1\n    **Output:** 1\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)\n\n    \n    \n    **Input:** root = [53624nullnull1] k = 3\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is `n`.\n  * `1 <= k <= n <= 104`\n  * `0 <= Node.val <= 104`\n\n\n\n**Follow up:** If the BST is modified often (i.e. we can do insert and delete\noperations) and you need to find the kth smallest frequently how would you\noptimize?\n\n,# Runtime: 86 ms (Top 42.71%) | Memory: 18.1 MB (Top 15.27%)\n\n# Definition for a binary tree node.\n# class TreeNode:\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass Solution:\n    def kthSmallest(self root: Optional[TreeNode] k: int) -> int:\n        n=0\n        stack=[] # to store the elements\n        cur=root # pointer to iterate\n        while cur or stack:\n            while cur: # used to find the left most element\n                stack.append(cur)\n                cur=cur.left\n            cur=stack.pop() # pop the most recent element which will be the least value at that moment\n            n+=1\n            if n==k:\n                return cur.val\n            cur=cur.right
Kth Smallest Element in a Sorted Matrix,###  378\. Kth Smallest Element in a Sorted Matrix\n\nGiven an `n x n` `matrix` where each of the rows and columns is sorted in\nascending order return _the_ `kth` _smallest element in the matrix_.\n\nNote that it is the `kth` smallest element **in the sorted order**  not the\n`kth` **distinct** element.\n\nYou must find a solution with a memory complexity better than `O(n2)`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** matrix = [[159][101113][121315]] k = 8\n    **Output:** 13\n    **Explanation:** The elements in the matrix are [15910111213_**13**_ 15] and the 8th smallest number is 13\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matrix = [[-5]] k = 1\n    **Output:** -5\n    \n\n\n\n**Constraints:**\n\n  * `n == matrix.length == matrix[i].length`\n  * `1 <= n <= 300`\n  * `-109 <= matrix[i][j] <= 109`\n  * All the rows and columns of `matrix` are **guaranteed** to be sorted in **non-decreasing order**.\n  * `1 <= k <= n2`\n\n\n\n**Follow up:**\n\n  * Could you solve the problem with a constant memory (i.e. `O(1)` memory complexity)?\n  * Could you solve the problem in `O(n)` time complexity? The solution may be too advanced for an interview but you may find reading [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) fun.\n\n,// Runtime: 281 ms (Top 5.06%) | Memory: 22.00 MB (Top 9.58%)\n\nclass Solution:\n    def kthSmallest(self matrix k):\n        n beg end = len(matrix) matrix[0][0] matrix[-1][-1]\n        \n        def check(m):\n            i j cnt = 0 n-1 0\n            for i in range(n):\n                while j >= 0 and matrix[i][j] > m: j -= 1\n                cnt += (j + 1)\n            return cnt\n         \n        while beg < end:\n            mid = (beg + end)//2\n            if check(mid) < k:\n                beg = mid + 1\n            else:\n                end = mid\n                \n        return beg\n
Kth Smallest Number in Multiplication Table,###  668\. Kth Smallest Number in Multiplication Table\n\nNearly everyone has used the [Multiplication\nTable](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication\ntable of size `m x n` is an integer matrix `mat` where `mat[i][j] == i * j`\n(**1-indexed**).\n\nGiven three integers `m` `n` and `k` return _the_`kth` _smallest element in\nthe_`m x n` _multiplication table_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg)\n\n    \n    \n    **Input:** m = 3 n = 3 k = 5\n    **Output:** 3\n    **Explanation:** The 5th smallest number is 3.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/05/02/multtable2-grid.jpg)\n\n    \n    \n    **Input:** m = 2 n = 3 k = 6\n    **Output:** 6\n    **Explanation:** The 6th smallest number is 6.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m n <= 3 * 104`\n  * `1 <= k <= m * n`\n\n,"// Runtime: 593 ms (Top 63.06%) | Memory: 17.30 MB (Top 29.73%)\n\nclass Solution:\n    def findKthNumber(self m n k):\n        def count(x):\n            return sum(min(x//i n) for i in range(1m+1))\n			\n        L R mid ans = 0 m*n 0 0\n        while L <= R:\n            mid = (L + R) >> 1\n            if count(mid) < k:\n                L = mid + 1\n            else:\n                R ans = mid - 1 mid\n        return ans\n"
Largest Combination With Bitwise AND Greater Than Zero,###  2275\. Largest Combination With Bitwise AND Greater Than Zero\n\nThe **bitwise AND** of an array `nums` is the bitwise AND of all integers in\n`nums`.\n\n  * For example for `nums = [1 5 3]` the bitwise AND is equal to `1 & 5 & 3 = 1`.\n  * Also for `nums = [7]` the bitwise AND is `7`.\n\nYou are given an array of positive integers `candidates`. Evaluate the\n**bitwise AND** of every **combination** of numbers of `candidates`. Each\nnumber in `candidates` may only be used **once** in each combination.\n\nReturn _the size of the**largest** combination of _`candidates` _with a\nbitwise AND**greater** than _`0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** candidates = [16177162122414]\n    **Output:** 4\n    **Explanation:** The combination [16176224] has a bitwise AND of 16 & 17 & 62 & 24 = 16 > 0.\n    The size of the combination is 4.\n    It can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.\n    Note that more than one combination may have the largest size.\n    For example the combination [62122414] has a bitwise AND of 62 & 12 & 24 & 14 = 8 > 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** candidates = [88]\n    **Output:** 2\n    **Explanation:** The largest combination [88] has a bitwise AND of 8 & 8 = 8 > 0.\n    The size of the combination is 2 so we return 2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= candidates.length <= 105`\n  * `1 <= candidates[i] <= 107`\n\n,# Runtime: 2282 ms (Top 70.42%) | Memory: 24.8 MB (Top 77.26%)\nclass Solution:\n    def largestCombination(self candidates: List[int]) -> int:\n        return max(sum(n & (1 << i) > 0 for n in candidates) for i in range(0 24))
Largest Component Size by Common Factor,###  952\. Largest Component Size by Common Factor\n\nYou are given an integer array of unique positive integers `nums`. Consider\nthe following graph:\n\n  * There are `nums.length` nodes labeled `nums[0]` to `nums[nums.length - 1]`\n  * There is an undirected edge between `nums[i]` and `nums[j]` if `nums[i]` and `nums[j]` share a common factor greater than `1`.\n\nReturn _the size of the largest connected component in the graph_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/01/ex1.png)\n\n    \n    \n    **Input:** nums = [461535]\n    **Output:** 4\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/01/ex2.png)\n\n    \n    \n    **Input:** nums = [2050963]\n    **Output:** 2\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2018/12/01/ex3.png)\n\n    \n    \n    **Input:** nums = [23674122139]\n    **Output:** 8\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 104`\n  * `1 <= nums[i] <= 105`\n  * All the values of `nums` are **unique**.\n\n,// Runtime: 818 ms (Top 91.97%) | Memory: 26.40 MB (Top 28.47%)\n\nclass UnionFind: \n    \n    def __init__(self n):\n        self.parent = list(range(n))\n        self.rank = [1]*n\n        \n    def find(self p): \n        if p != self.parent[p]: \n            self.parent[p] = self.find(self.parent[p])\n        return self.parent[p]\n    \n    def union(self p q): \n        prt qrt = self.find(p) self.find(q)\n        if prt == qrt: return False \n        if self.rank[prt] > self.rank[qrt]: prt qrt = qrt prt\n        self.parent[prt] = qrt\n        self.rank[qrt] += self.rank[prt]\n        return True \n\n\nclass Solution:\n    def largestComponentSize(self A: List[int]) -> int:\n        m = max(A)\n        uf = UnionFind(m+1)\n        seen = set(A)\n        \n        # modified sieve of eratosthenes \n        sieve = [1]*(m+1)\n        sieve[0] = sieve[1] = 0 \n        for k in range(m//2+1): \n            if sieve[k]: \n                prev = k if k in seen else 0\n                for x in range(2*k m+1 k): \n                    sieve[x] = 0\n                    if x in seen: \n                        if prev: uf.union(prev x)\n                        else: prev = x\n        return max(uf.rank)\n
Largest Divisible Subset,###  368\. Largest Divisible Subset\n\nGiven a set of **distinct** positive integers `nums` return the largest\nsubset `answer` such that every pair `(answer[i] answer[j])` of elements in\nthis subset satisfies:\n\n  * `answer[i] % answer[j] == 0` or\n  * `answer[j] % answer[i] == 0`\n\nIf there are multiple solutions return any of them.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** [12]\n    **Explanation:** [13] is also accepted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1248]\n    **Output:** [1248]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 2 * 109`\n  * All the integers in `nums` are **unique**.\n\n,class Solution:\n    def largestDivisibleSubset(self nums: List[int]) -> List[int]:\n        nums.sort()\n        n = len(nums)\n        dp = [1 for i in range(n)]\n        hashh = [i for i in range(n)]\n        ans_ind = 0\n        \n        for i in range(1 n):\n            for j in range(0i):\n                if nums[i]%nums[j] == 0 and dp[j]+1 > dp[i]:            \n                    dp[i] = dp[j]+1\n                    hashh[i] = j\n                    \n                    # print(dp)\n                    # print(hashh)\n        out = []\n        maxi = dp[0]\n        \n        for i in range(len(nums)):\n            if dp[i] > maxi:\n                ans_ind = i\n                maxi = dp[i]\n        \n        while(hashh[ans_ind]!=ans_ind):\n            out.append(nums[ans_ind])\n            ans_ind = hashh[ans_ind]\n        out.append(nums[ans_ind])\n        return(out)\n        \n        \n        \n
Largest Merge Of Two Strings,"###  1754\. Largest Merge Of Two Strings\n\nYou are given two strings `word1` and `word2`. You want to construct a string\n`merge` in the following way: while either `word1` or `word2` are non-empty\nchoose **one** of the following options:\n\n  * If `word1` is non-empty append the **first** character in `word1` to `merge` and delete it from `word1`. \n    * For example if `word1 = ""abc"" `and `merge = ""dv""` then after choosing this operation `word1 = ""bc""` and `merge = ""dva""`.\n  * If `word2` is non-empty append the **first** character in `word2` to `merge` and delete it from `word2`. \n    * For example if `word2 = ""abc"" `and `merge = """"` then after choosing this operation `word2 = ""bc""` and `merge = ""a""`.\n\nReturn _the lexicographically**largest** _`merge` _you can construct_.\n\nA string `a` is lexicographically larger than a string `b` (of the same\nlength) if in the first position where `a` and `b` differ `a` has a character\nstrictly larger than the corresponding character in `b`. For example `""abcd""`\nis lexicographically larger than `""abcc""` because the first position they\ndiffer is at the fourth character and `d` is greater than `c`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word1 = ""cabaa"" word2 = ""bcaaa""\n    **Output:** ""cbcabaaaaa""\n    **Explanation:** One way to get the lexicographically largest merge is:\n    - Take from word1: merge = ""c"" word1 = ""abaa"" word2 = ""bcaaa""\n    - Take from word2: merge = ""cb"" word1 = ""abaa"" word2 = ""caaa""\n    - Take from word2: merge = ""cbc"" word1 = ""abaa"" word2 = ""aaa""\n    - Take from word1: merge = ""cbca"" word1 = ""baa"" word2 = ""aaa""\n    - Take from word1: merge = ""cbcab"" word1 = ""aa"" word2 = ""aaa""\n    - Append the remaining 5 a's from word1 and word2 at the end of merge.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word1 = ""abcabc"" word2 = ""abdcaba""\n    **Output:** ""abdcabcabcaba""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word1.length word2.length <= 3000`\n  * `word1` and `word2` consist only of lowercase English letters.\n\n",class Solution:\n    def largestMerge(self word1: str word2: str) -> str:\n        res = ''\n        p1 = 0\n        p2 = 0\n        while p1 < len(word1) and p2 < len(word2):\n            if word1[p1:] > word2[p2:]:\n                res += word1[p1]\n                p1 += 1\n            else:\n                res += word2[p2]\n                p2 += 1\n        \n        res += word1[p1:] + word2[p2:]\n\n        \n        return res\n
Largest Multiple of Three,"###  1363\. Largest Multiple of Three\n\nGiven an array of digits `digits` return _the largest multiple of**three**\nthat can be formed by concatenating some of the given digits in **any\norder**_. If there is no answer return an empty string.\n\nSince the answer may not fit in an integer data type return the answer as a\nstring. Note that the returning answer must not contain unnecessary leading\nzeros.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** digits = [819]\n    **Output:** ""981""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** digits = [86710]\n    **Output:** ""8760""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** digits = [1]\n    **Output:** """"\n    \n\n\n\n**Constraints:**\n\n  * `1 <= digits.length <= 104`\n  * `0 <= digits[i] <= 9`\n\n","class Solution:\n	def largestMultipleOfThree(self digits: List[int]) -> str:\n		A = digits\n		A.sort()\n		A.reverse()\n\n		@cache\n		def DP(i r): # max number whose remainder is r using subarray [0:i] (inclusive) \n			if i == 0:\n				if A[0] % 3 == r:\n					return A[0]\n				else:\n					return 0\n\n			Ra = DP(i-1 r)\n			Rb = [ x for j in range(3) \\n				  for x in ( DP(i-1j) * 10 + A[i] )\n				  if x % 3 == r ]\n\n			return max([Ra *Rb])\n\n		ans = DP(len(A) - 1 0)\n\n		if ans == 0 and 0 not in A:\n			return """"\n		else:\n			return str(ans)\n"
Largest Number,"###  179\. Largest Number\n\nGiven a list of non-negative integers `nums` arrange them such that they form\nthe largest number and return it.\n\nSince the result may be very large so you need to return a string instead of\nan integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [102]\n    **Output:** ""210""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [3303459]\n    **Output:** ""9534330""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `0 <= nums[i] <= 109`\n\n","from functools import cmp_to_key\nclass Solution:\n    def largestNumber(self nums: List[int]) -> str:\n        nums = list(map(str nums))\n        nums = reversed(sorted(nums key = cmp_to_key(lambda x y: -1 if int(x+y) < int(y+x) else ( 1 if int(x+y) > int(y+x) else 0))))\n        res = """".join(nums)\n        return res if int(res) else ""0"""
Largest Number After Digit Swaps by Parity,###  2231\. Largest Number After Digit Swaps by Parity\n\nYou are given a positive integer `num`. You may swap any two digits of `num`\nthat have the same **parity** (i.e. both odd digits or both even digits).\n\nReturn _the**largest** possible value of _`num` _after**any** number of\nswaps._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 1234\n    **Output:** 3412\n    **Explanation:** Swap the digit 3 with the digit 1 this results in the number 3214.\n    Swap the digit 2 with the digit 4 this results in the number 3412.\n    Note that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\n    Also note that we may not swap the digit 4 with the digit 1 since they are of different parities.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 65875\n    **Output:** 87655\n    **Explanation:** Swap the digit 8 with the digit 6 this results in the number 85675.\n    Swap the first digit 5 with the digit 7 this results in the number 87655.\n    Note that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num <= 109`\n\n,class Solution:\n    def largestInteger(self num: int):\n        n = len(str(num))\n        arr = [int(i) for i in str(num)]\n        odd even = [] []\n        for i in arr:\n            if i % 2 == 0:\n                even.append(i)\n            else:\n                odd.append(i)\n        odd.sort()\n        even.sort()\n        res = 0\n        for i in range(n):\n            if arr[i] % 2 == 0:\n                res = res*10 + even.pop()\n            else:\n                res = res*10 + odd.pop()\n        return res\n
Largest Number After Mutating Substring,"###  1946\. Largest Number After Mutating Substring\n\nYou are given a string `num` which represents a large integer. You are also\ngiven a **0-indexed** integer array `change` of length `10` that maps each\ndigit `0-9` to another digit. More formally digit `d` maps to digit\n`change[d]`.\n\nYou may **choose** to **mutate a single substring** of `num`. To mutate a\nsubstring replace each digit `num[i]` with the digit it maps to in `change`\n(i.e. replace `num[i]` with `change[num[i]]`).\n\nReturn _a string representing the**largest** possible integer after\n**mutating** (or choosing not to) a **single substring** of _`num`.\n\nA **substring** is a contiguous sequence of characters within the string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = ""_1_ 32"" change = [9850364268]\n    **Output:** ""_8_ 32""\n    **Explanation:** Replace the substring ""1"":\n    - 1 maps to change[1] = 8.\n    Thus ""_1_ 32"" becomes ""_8_ 32"".\n    ""832"" is the largest number that can be created so return it.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = ""_021_ "" change = [9435721906]\n    **Output:** ""_934_ ""\n    **Explanation:** Replace the substring ""021"":\n    - 0 maps to change[0] = 9.\n    - 2 maps to change[2] = 3.\n    - 1 maps to change[1] = 4.\n    Thus ""_021_ "" becomes ""_934_ "".\n    ""934"" is the largest number that can be created so return it.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = ""5"" change = [1475325694]\n    **Output:** ""5""\n    **Explanation:** ""5"" is already the largest number that can be created so return it.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num.length <= 105`\n  * `num` consists of only digits `0-9`.\n  * `change.length == 10`\n  * `0 <= change[d] <= 9`\n\n","class Solution:\ndef maximumNumber(self num: str change: List[int]) -> str:\n    flag=0\n    ls=list(num)\n    for i in range(len(ls)):\n        k=int(ls[i])\n        if change[k]>k:\n            ls[i]=str(change[k])\n            flag=1\n        elif flag==1 and change[k]<k:\n            break\n    \n    return """".join(ls)\n"
Largest Number At Least Twice of Others,###  747\. Largest Number At Least Twice of Others\n\nYou are given an integer array `nums` where the largest integer is **unique**.\n\nDetermine whether the largest element in the array is **at least twice** as\nmuch as every other number in the array. If it is return _the**index** of the\nlargest element or return _`-1` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3610]\n    **Output:** 1\n    **Explanation:** 6 is the largest integer.\n    For every other number in the array x 6 is at least twice as big as x.\n    The index of value 6 is 1 so we return 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** -1\n    **Explanation:** 4 is less than twice the value of 3 so we return -1.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 50`\n  * `0 <= nums[i] <= 100`\n  * The largest element in `nums` is unique.\n\n,# Runtime: 40 ms (Top 86.73%) | Memory: 13.8 MB (Top 57.55%)\nclass Solution:\n    def dominantIndex(self nums: List[int]) -> int:\n        if len(nums) is 1:\n            return 0\n        dom = max(nums)\n        i = nums.index(dom)\n        nums.remove(dom)\n        if max(nums) * 2 <= dom:\n            return i\n        return -1
Largest Odd Number in String,"###  1903\. Largest Odd Number in String\n\nYou are given a string `num` representing a large integer. Return\n_the**largest-valued odd** integer (as a string) that is a **non-empty\nsubstring** of _`num` _ or an empty string_`""""`_if no odd integer exists_.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = ""52""\n    **Output:** ""5""\n    **Explanation:** The only non-empty substrings are ""5"" ""2"" and ""52"". ""5"" is the only odd number.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = ""4206""\n    **Output:** """"\n    **Explanation:** There are no odd numbers in ""4206"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = ""35427""\n    **Output:** ""35427""\n    **Explanation:** ""35427"" is already an odd number.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num.length <= 105`\n  * `num` only consists of digits and does not contain any leading zeros.\n\n","class Solution:\n    def largestOddNumber(self num: str) -> str:\n        indx = -1\n        n = len(num)\n        for i in range(n):\n            if int(num[i])%2 == 1:\n                indx = i\n        \n        if indx == -1:\n            return """"\n        return num[:indx+1]\n"
Largest Palindrome Product,###  479\. Largest Palindrome Product\n\nGiven an integer n return _the**largest palindromic integer** that can be\nrepresented as the product of two `n`-digits integers_. Since the answer can\nbe very large return it **modulo** `1337`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 987\n    Explanation: 99 x 91 = 9009 9009 % 1337 = 987\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 9\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 8`\n\n,class Solution:\n    def largestPalindrome(self n: int) -> int:\n        return [0 9 987 123 597 677 1218 877 475][n]\n\n        \n    def isPalindrome(x):\n        return str(x) == str(x)[::-1]\n\n    def solve(n):\n        best = 0\n        for i in range(10**n-1 0 -1):\n            for j in range(max(i (best-1)//i+1) 10**n):\n                if isPalindrome(i*j):\n                    #print(i j i*j)\n                    best = i*j\n        return best\n
Largest Perimeter Triangle,###  976\. Largest Perimeter Triangle\n\nGiven an integer array `nums` return _the largest perimeter of a triangle\nwith a non-zero area formed from three of these lengths_. If it is impossible\nto form any triangle of a non-zero area return `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [212]\n    **Output:** 5\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [121]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `3 <= nums.length <= 104`\n  * `1 <= nums[i] <= 106`\n\n,class Solution:\n    def largestPerimeter(self nums: List[int]) -> int:\n        nums=sorted(numsreverse=True)\n        l=len(nums)\n        for i in range(l-2):\n            if nums[i]<nums[i+1]+nums[i+2]: #condition if triangle can be formed\n                return  nums[i]+nums[i+1]+nums[i+2]\n        return 0\n
Largest Plus Sign,###  764\. Largest Plus Sign\n\nYou are given an integer `n`. You have an `n x n` binary grid `grid` with all\nvalues initially `1`'s except for some indices given in the array `mines`. The\n`ith` element of the array `mines` is defined as `mines[i] = [xi yi]` where\n`grid[xi][yi] == 0`.\n\nReturn _the order of the largest**axis-aligned** plus sign of _1 _'s contained\nin_`grid`. If there is none return `0`.\n\nAn **axis-aligned plus sign** of `1`'s of order `k` has some center\n`grid[r][c] == 1` along with four arms of length `k - 1` going up down left\nand right and made of `1`'s. Note that there could be `0`'s or `1`'s beyond\nthe arms of the plus sign only the relevant area of the plus sign is checked\nfor `1`'s.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg)\n\n    \n    \n    **Input:** n = 5 mines = [[42]]\n    **Output:** 2\n    **Explanation:** In the above grid the largest plus sign can only be of order 2. One of them is shown.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg)\n\n    \n    \n    **Input:** n = 1 mines = [[00]]\n    **Output:** 0\n    **Explanation:** There is no plus sign so return 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 500`\n  * `1 <= mines.length <= 5000`\n  * `0 <= xi yi < n`\n  * All the pairs `(xi yi)` are **unique**.\n\n,"class Solution:\n\n    def orderOfLargestPlusSign(self n: int mines: list[list[int]]) -> int:\n        matrix = [1] * n\n        aux = {}\n        hasOne = False\n        for i in range(0n):\n            matrix[i] = [1] * n\n        for mine in mines:\n            matrix[mine[0]][mine[1]] = 0\n        for i in range(0n):\n            for j in range(0n):\n                if(matrix[i][j] == 1):\n                    hasOne = True\n                if((ij) not in aux):\n                    aux[(ij)] = {""t"":0""l"":0""r"":0""b"":0}\n                if(j>0 and matrix[i][j] == 1 and matrix[i][j-1] == 1):\n                    aux[(ij)][""l""] = aux[(ij-1)][""l""] + 1  \n                if(i>0 and matrix[i][j] == 1 and matrix[i-1][j] == 1):\n                    aux[(ij)][""t""] = aux[(i-1j)][""t""] + 1\n        \n        maxOrder = 0 \n        for i in range(n-1-1-1):\n            if(i<maxOrder):\n                    break\n            for j in range(n-1-1-1):\n                if(j<maxOrder):\n                    break\n                if(j<n-1 and matrix[i][j] == 1 and matrix[i][j+1] == 1):\n                    aux[(ij)][""r""] = aux[(ij+1)][""r""] + 1  \n                if(i<n-1 and matrix[i][j] == 1 and matrix[i+1][j]):\n                    aux[(ij)][""b""] = aux[(i+1j)][""b""] + 1\n                maxOrder = max(min(aux[(ij)][""b""]aux[(ij)][""t""]aux[(ij)][""r""]aux[(ij)][""l""])maxOrder)\n \n        print(maxOrder+1)\n        return maxOrder + 1 \n"
Largest Submatrix With Rearrangements,###  1727\. Largest Submatrix With Rearrangements\n\nYou are given a binary matrix `matrix` of size `m x n` and you are allowed to\nrearrange the **columns** of the `matrix` in any order.\n\nReturn _the area of the largest submatrix within_`matrix` _where**every**\nelement of the submatrix is _`1` _after reordering the columns optimally._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40536-pm.png)\n\n    \n    \n    **Input:** matrix = [[001][111][101]]\n    **Output:** 4\n    **Explanation:** You can rearrange the columns as shown above.\n    The largest submatrix of 1s in bold has an area of 4.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40852-pm.png)\n\n    \n    \n    **Input:** matrix = [[10101]]\n    **Output:** 3\n    **Explanation:** You can rearrange the columns as shown above.\n    The largest submatrix of 1s in bold has an area of 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** matrix = [[110][101]]\n    **Output:** 2\n    **Explanation:** Notice that you must rearrange entire columns and there is no way to make a submatrix of 1s larger than an area of 2.\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m * n <= 105`\n  * `matrix[i][j]` is either `0` or `1`.\n\n,# Runtime: 3821 ms (Top 7.64%) | Memory: 37.3 MB (Top 95.14%)\nfrom collections import Counter\n\nclass Solution:\n    def largestSubmatrix(self matrix: List[List[int]]) -> int:\n        M = len(matrix)\n        N = len(matrix[0])\n\n        colcons = [] # preprocess columns\n        for c in range(N):\n            cons = []\n            s = 0\n            for r in range(M):\n                if not matrix[r][c]:\n                    s = 0\n                else:\n                    s += 1\n                cons.append(s)\n            colcons.append(cons)\n        # colcons[c][r] is how much 1's we'll get if we start from column c at row r and go up\n\n        best = 0\n        for r in range(M):\n            # try r as the lowest row\n            C = Counter(colcons[c][r] for c in range(N))\n            vs = sorted(C.keys() reverse=True)\n            cs = accumulate(C[v] for v in vs)\n            for vc in zip(vscs):\n                best = max(bestv*c)\n        return best
Largest Substring Between Two Equal Characters,"###  1624\. Largest Substring Between Two Equal Characters\n\nGiven a string `s` return _the length of the longest substring between two\nequal characters excluding the two characters._ If there is no such substring\nreturn `-1`.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aa""\n    **Output:** 0\n    **Explanation:** The optimal substring here is an empty substring between the two 'a's.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abca""\n    **Output:** 2\n    **Explanation:** The optimal substring here is ""bc"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""cbzxy""\n    **Output:** -1\n    **Explanation:** There are no characters that appear twice in s.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 300`\n  * `s` contains only lowercase English letters.\n\n",class Solution:\n    def maxLengthBetweenEqualCharacters(self s: str) -> int:\n        last ans = {} -1 \n        for i c in enumerate(s):\n            if c not in last:\n                last[c] = i\n            else:\n                ans = max(ans i - last[c] - 1)\n        return ans \n
Largest Sum of Averages,###  813\. Largest Sum of Averages\n\nYou are given an integer array `nums` and an integer `k`. You can partition\nthe array into **at most** `k` non-empty adjacent subarrays. The **score** of\na partition is the sum of the averages of each subarray.\n\nNote that the partition must use every integer in `nums` and that the score\nis not necessarily an integer.\n\nReturn _the maximum**score** you can achieve of all the possible partitions_.\nAnswers within `10-6` of the actual answer will be accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [91239] k = 3\n    **Output:** 20.00000\n    **Explanation:** \n    The best choice is to partition nums into [9] [1 2 3] [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\n    We could have also partitioned nums into [9 1] [2] [3 9] for example.\n    That partition would lead to a score of 5 + 2 + 6 = 13 which is worse.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234567] k = 4\n    **Output:** 20.50000\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `1 <= nums[i] <= 104`\n  * `1 <= k <= nums.length`\n\n,class Solution:\n    def largestSumOfAverages(self A k):\n        n = len(A)\n        dp = [0] * n\n        sum = 0\n        for i in range(n-1-1-1):\n            sum += A[i]\n            dp[i] = sum / (n-i)\n        for l in range(1k):\n            for i in range(n-l):\n                sum = 0\n                for j in range(in-l):\n                    sum += A[j]\n                    dp[i] = max(dp[i]dp[j+1] + sum / (j-i+1))\n        return dp[0]\n
Largest Time for Given Digits,"###  949\. Largest Time for Given Digits\n\nGiven an array `arr` of 4 digits find the latest 24-hour time that can be\nmade using each digit **exactly once**.\n\n24-hour times are formatted as `""HH:MM""` where `HH` is between `00` and `23`\nand `MM` is between `00` and `59`. The earliest 24-hour time is `00:00` and\nthe latest is `23:59`.\n\nReturn _the latest 24-hour time in`""HH:MM""` format_. If no valid time can be\nmade return an empty string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [1234]\n    **Output:** ""23:41""\n    **Explanation:** The valid 24-hour times are ""12:34"" ""12:43"" ""13:24"" ""13:42"" ""14:23"" ""14:32"" ""21:34"" ""21:43"" ""23:14"" and ""23:41"". Of these times ""23:41"" is the latest.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [5555]\n    **Output:** """"\n    **Explanation:** There are no valid 24-hour times as ""55:55"" is not valid.\n    \n\n\n\n**Constraints:**\n\n  * `arr.length == 4`\n  * `0 <= arr[i] <= 9`\n\n","class Solution:\n    def largestTimeFromDigits(self arr: List[int]) -> str:\n        res = """"\n        digit_freq = collections.Counter(arr)\n        # first digit\n        \n        \n        if 2 in arr and sum([digit_freq[d] for d in range(6)]) > 2:\n            res += ""2""\n            arr.remove(2)\n        else:\n            for digit in [10]:\n                if digit in arr:\n                    res += str(digit)\n                    arr.remove(digit)\n                    break\n        # can't make 24-hour time\n        if len(res) == 0:\n            return """"\n        \n        # second digit 0-3\n        if res == ""2"":\n            for digit in [3210]:\n                if digit in arr:\n                    res += str(digit)\n                    arr.remove(digit)\n                    break\n            # no 0-3 left in arr\n            if len(res) == 1:\n                return """"\n        # second digit 0-9\n        else:\n            for digit in range(9-1-1):\n                if digit in arr:\n                    res += str(digit)\n                    arr.remove(digit)\n                    break\n        \n        res += "":""\n        \n        for digit in range(5 -1 -1):\n            if digit in arr:\n                res += str(digit)\n                arr.remove(digit)\n                break\n            \n        if len(res) == 3:\n            return """"\n        \n        for digit in range(9-1-1):\n            if digit in arr:\n                res += str(digit)\n                return res\n                \n"
Largest Triangle Area,###  812\. Largest Triangle Area\n\nGiven an array of points on the **X-Y** plane `points` where `points[i] = [xi\nyi]` return _the area of the largest triangle that can be formed by any three\ndifferent points_. Answers within `10-5` of the actual answer will be\naccepted.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/04/1027.png)\n\n    \n    \n    **Input:** points = [[00][01][10][02][20]]\n    **Output:** 2.00000\n    **Explanation:** The five points are shown in the above figure. The red triangle is the largest.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** points = [[10][00][01]]\n    **Output:** 0.50000\n    \n\n\n\n**Constraints:**\n\n  * `3 <= points.length <= 50`\n  * `-50 <= xi yi <= 50`\n  * All the given points are **unique**.\n\n,from itertools import combinations\nclass Solution:\n    def largestTriangleArea(self points: List[List[int]]) -> float:\n        maxA = 0\n        for p1 p2 p3 in combinations(points 3):\n            x1 y1 = p1\n            x2 y2 = p2\n            x3 y3 = p3\n            A=(1/2) * abs(x1*(y2 - y3) + x2*(y3 - y1)+ x3*(y1 - y2))\n            if A > maxA: maxA = A\n        return maxA\n
Largest Values From Labels,###  1090\. Largest Values From Labels\n\nThere is a set of `n` items. You are given two integer arrays `values` and\n`labels` where the value and the label of the `ith` element are `values[i]`\nand `labels[i]` respectively. You are also given two integers `numWanted` and\n`useLimit`.\n\nChoose a subset `s` of the `n` elements such that:\n\n  * The size of the subset `s` is **less than or equal to** `numWanted`.\n  * There are **at most** `useLimit` items with the same label in `s`.\n\nThe **score** of a subset is the sum of the values in the subset.\n\nReturn _the maximum**score** of a subset _`s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** values = [54321] labels = [11223] numWanted = 3 useLimit = 1\n    **Output:** 9\n    **Explanation:** The subset chosen is the first third and fifth items.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** values = [54321] labels = [13332] numWanted = 3 useLimit = 2\n    **Output:** 12\n    **Explanation:** The subset chosen is the first second and third items.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** values = [98876] labels = [00011] numWanted = 3 useLimit = 1\n    **Output:** 16\n    **Explanation:** The subset chosen is the first and fourth items.\n    \n\n\n\n**Constraints:**\n\n  * `n == values.length == labels.length`\n  * `1 <= n <= 2 * 104`\n  * `0 <= values[i] labels[i] <= 2 * 104`\n  * `1 <= numWanted useLimit <= n`\n\n,from collections import defaultdict\nimport heapq\n\nclass Solution:\n    def largestValsFromLabels(\n        self values: list[int] labels: list[int] numWanted: int useLimit: int\n    ) -> int:\n\n        # Add labels and values into the heap\n        heap = [(-value label) for value label in zip(values labels)]\n        heapq.heapify(heap)\n\n        # Initialize the hashmap\n        used = defaultdict(int)\n\n        # Initialize the result\n        res = 0\n\n        # Iterate until we have used a certain number or the heap is empty\n        while numWanted > 0 and heap:\n\n            # Pop a label and its value from the heap\n            value label = heapq.heappop(heap)\n\n            # If we can use such label\n            if used[label] < useLimit:\n\n                # Add its value to the result\n                res += -value\n\n                # Increment its count in the hashmap\n                used[label] += 1\n\n                # Decrement the number of numbers we still want\n                numWanted -= 1\n\n        return res\n
Last Day Where You Can Still Cross,###  1970\. Last Day Where You Can Still Cross\n\nThere is a **1-based** binary matrix where `0` represents land and `1`\nrepresents water. You are given integers `row` and `col` representing the\nnumber of rows and columns in the matrix respectively.\n\nInitially on day `0` the **entire** matrix is **land**. However each day a\nnew cell becomes flooded with **water**. You are given a **1-based** 2D array\n`cells` where `cells[i] = [ri ci]` represents that on the `ith` day the\ncell on the `rith` row and `cith` column (**1-based** coordinates) will be\ncovered with **water** (i.e. changed to `1`).\n\nYou want to find the **last** day that it is possible to walk from the **top**\nto the **bottom** by only walking on land cells. You can start from **any**\ncell in the top row and end at **any** cell in the bottom row. You can only\ntravel in the**four** cardinal directions (left right up and down).\n\nReturn _the**last** day where it is possible to walk from the **top** to the\n**bottom** by only walking on land cells_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/27/1.png)\n\n    \n    \n    **Input:** row = 2 col = 2 cells = [[11][21][12][22]]\n    **Output:** 2\n    **Explanation:** The above image depicts how the matrix changes each day starting from day 0.\n    The last day where it is possible to cross from top to bottom is on day 2.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/07/27/2.png)\n\n    \n    \n    **Input:** row = 2 col = 2 cells = [[11][12][21][22]]\n    **Output:** 1\n    **Explanation:** The above image depicts how the matrix changes each day starting from day 0.\n    The last day where it is possible to cross from top to bottom is on day 1.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/07/27/3.png)\n\n    \n    \n    **Input:** row = 3 col = 3 cells = [[12][21][33][22][11][13][23][32][31]]\n    **Output:** 3\n    **Explanation:** The above image depicts how the matrix changes each day starting from day 0.\n    The last day where it is possible to cross from top to bottom is on day 3.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= row col <= 2 * 104`\n  * `4 <= row * col <= 2 * 104`\n  * `cells.length == row * col`\n  * `1 <= ri <= row`\n  * `1 <= ci <= col`\n  * All the values of `cells` are **unique**.\n\n,class UF:\n    def __init__(self m n):\n        self.n self.loc_id c_id = n dict() 0\n        self.col_set = [set() for _ in range(m*n)]\n        for i in range(m):                       # Assign id for each location (i j)\n            for j in range(n):\n                self.loc_id[(i j)] = c_id\n                self.col_set[c_id].add(j)\n                c_id += 1\n        self.p = [i for i in range(m*n)]         # Initialize parents array `p`\n        \n    def find(self i):\n        if self.p[i] != i:\n            self.p[i] = self.find(self.p[i])\n        return self.p[i]    \n    \n    def union(self i j):\n        pi pj = self.find(i) self.find(j)\n        if pi != pj:\n            self.p[pj] = pi                      # Update `pi`\n            self.col_set[pi] = self.col_set[pi] | self.col_set[pj]  # Take union of two sets (union all occupied columns)\n        return len(self.col_set[pi]) == self.n   # if length of col_set[pi] == self.n meaning this piece occupied all columns from 1 to `col` inclusive meaning we are blocked\n            \nclass Solution:\n    def latestDayToCross(self row: int col: int cells: List[List[int]]) -> int:\n        uf visited = UF(row col) set()\n        for i (x y) in enumerate(cells):\n            x y = x-1 y-1\n            visited.add((x y))\n            for dx dy in [(-1 -1) (-1 0) (-1 1) (1 -1) (1 0) (1 1) (0 1) (0 -1)]:\n                _x _y = x+dx y+dy              # Check if neighbor is flooded\n                if 0 <= _x < row and 0 <= _y < col and (_x _y) in visited:\n                    id1 id2 = uf.loc_id[(_x _y)] uf.loc_id[(x y)]\n                    if uf.union(id1 id2): return i # Union two flooded piece and return index if union return True\n        return -1\n
Last Moment Before All Ants Fall Out of a Plank,###  1503\. Last Moment Before All Ants Fall Out of a Plank\n\nWe have a wooden plank of the length `n` **units**. Some ants are walking on\nthe plank each ant moves with a speed of **1 unit per second**. Some of the\nants move to the **left**  the other move to the **right**.\n\nWhen two ants moving in two **different** directions meet at some point they\nchange their directions and continue moving again. Assume changing directions\ndoes not take any additional time.\n\nWhen an ant reaches **one end** of the plank at a time `t` it falls out of\nthe plank immediately.\n\nGiven an integer `n` and two integer arrays `left` and `right` the positions\nof the ants moving to the left and the right return _the moment when the last\nant(s) fall out of the plank_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/06/17/ants.jpg)\n\n    \n    \n    **Input:** n = 4 left = [43] right = [01]\n    **Output:** 4\n    **Explanation:** In the image above:\n    -The ant at index 0 is named A and going to the right.\n    -The ant at index 1 is named B and going to the right.\n    -The ant at index 3 is named C and going to the left.\n    -The ant at index 4 is named D and going to the left.\n    The last moment when an ant was on the plank is t = 4 seconds. After that it falls immediately out of the plank. (i.e. We can say that at t = 4.0000000001 there are no ants on the plank).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/06/17/ants2.jpg)\n\n    \n    \n    **Input:** n = 7 left = [] right = [01234567]\n    **Output:** 7\n    **Explanation:** All ants are going to the right the ant at index 0 needs 7 seconds to fall.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/06/17/ants3.jpg)\n\n    \n    \n    **Input:** n = 7 left = [01234567] right = []\n    **Output:** 7\n    **Explanation:** All ants are going to the left the ant at index 7 needs 7 seconds to fall.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n  * `0 <= left.length <= n + 1`\n  * `0 <= left[i] <= n`\n  * `0 <= right.length <= n + 1`\n  * `0 <= right[i] <= n`\n  * `1 <= left.length + right.length <= n + 1`\n  * All values of `left` and `right` are unique and each value can appear **only in one** of the two arrays.\n\n,# Runtime: 316 ms (Top 23.17%) | Memory: 15 MB (Top 18.90%)\nclass Solution:\n    def getLastMoment(self n: int left: List[int] right: List[int]) -> int:\n        # make sure left and right are not empty without changing the answer\n        left.append(0)\n        right.append(n)\n\n        return max(max(left) n - min(right))
Last Stone Weight,###  1046\. Last Stone Weight\n\nYou are given an array of integers `stones` where `stones[i]` is the weight of\nthe `ith` stone.\n\nWe are playing a game with the stones. On each turn we choose the **heaviest\ntwo stones** and smash them together. Suppose the heaviest two stones have\nweights `x` and `y` with `x <= y`. The result of this smash is:\n\n  * If `x == y` both stones are destroyed and\n  * If `x != y` the stone of weight `x` is destroyed and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game there is **at most one** stone left.\n\nReturn _the weight of the last remaining stone_. If there are no stones left\nreturn `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** stones = [274181]\n    **Output:** 1\n    **Explanation:** \n    We combine 7 and 8 to get 1 so the array converts to [24111] then\n    we combine 2 and 4 to get 2 so the array converts to [2111] then\n    we combine 2 and 1 to get 1 so the array converts to [111] then\n    we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** stones = [1]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= stones.length <= 30`\n  * `1 <= stones[i] <= 1000`\n\n,# Runtime: 59 ms (Top 27.86%) | Memory: 13.9 MB (Top 62.57%)\nclass Solution:\n    def lastStoneWeight(self stones: List[int]) -> int:\n        stones = [-x for x in stones]\n        heapq.heapify(stones)\n\n        while len(stones) > 1:\n            mx1 = -heapq.heappop(stones)\n            mx2 = -heapq.heappop(stones)\n            if mx1 - mx2:\n                heapq.heappush(stones -(mx1 - mx2))\n\n        if len(stones):\n            return -heapq.heappop(stones)\n        return 0\n
Last Stone Weight II,###  1049\. Last Stone Weight II\n\nYou are given an array of integers `stones` where `stones[i]` is the weight of\nthe `ith` stone.\n\nWe are playing a game with the stones. On each turn we choose any two stones\nand smash them together. Suppose the stones have weights `x` and `y` with `x\n<= y`. The result of this smash is:\n\n  * If `x == y` both stones are destroyed and\n  * If `x != y` the stone of weight `x` is destroyed and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game there is **at most one** stone left.\n\nReturn _the smallest possible weight of the left stone_. If there are no\nstones left return `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** stones = [274181]\n    **Output:** 1\n    **Explanation:**\n    We can combine 2 and 4 to get 2 so the array converts to [27181] then\n    we can combine 7 and 8 to get 1 so the array converts to [2111] then\n    we can combine 2 and 1 to get 1 so the array converts to [111] then\n    we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** stones = [3126332140]\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * `1 <= stones.length <= 30`\n  * `1 <= stones[i] <= 100`\n\n,class Solution:\n    def lastStoneWeightII(self stones: List[int]) -> int:\n        if len(stones) == 1: return stones[0]\n        total = sum(stones)\n        half leng =  total// 2 len(stones)\n        dp = [[0] *  (half + 1) for _ in  range(leng + 1)]\n        \n        for i in range(1 leng+1):\n            for j in range(1 half+1):\n                if j - stones[i-1] >= 0:\n                    dp[i][j] = max(dp[i-1][j] dp[i-1][j - stones[i-1]] + stones[i-1])\n                else:\n                    dp[i][j] = dp[i-1][j]\n        return total - 2 * dp[leng][half]\n
Last Substring in Lexicographical Order,"###  1163\. Last Substring in Lexicographical Order\n\nGiven a string `s` return _the last substring of_ `s` _in lexicographical\norder_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abab""\n    **Output:** ""bab""\n    **Explanation:** The substrings are [""a"" ""ab"" ""aba"" ""abab"" ""b"" ""ba"" ""bab""]. The lexicographically maximum substring is ""bab"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""leetcode""\n    **Output:** ""tcode""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 4 * 105`\n  * `s` contains only lowercase English letters.\n\n",# Runtime: 273 ms (Top 82.1%) | Memory: 20.15 MB (Top 100.0%)\n\nclass Solution:\n    def lastSubstring(self s: str) -> str:\n        i = 0\n        j = 1\n        k = 0\n        n = len(s)\n        while j + k < n:\n            if s[i + k] == s[j + k]:\n                k += 1\n            elif s[i + k] > s[j + k]:\n                j += k + 1\n                k = 0\n            elif s[i + k] < s[j + k]:\n                i = max(i + k + 1 j)\n                j = i + 1\n                k = 0\n        return s[i:]
Latest Time by Replacing Hidden Digits,"###  1736\. Latest Time by Replacing Hidden Digits\n\nYou are given a string `time` in the form of ` hh:mm` where some of the\ndigits in the string are hidden (represented by `?`).\n\nThe valid times are those inclusively between `00:00` and `23:59`.\n\nReturn _the latest valid time you can get from_ `time` _by replacing the\nhidden_ _digits_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** time = ""2?:?0""\n    **Output:** ""23:50""\n    **Explanation:** The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** time = ""0?:3?""\n    **Output:** ""09:39""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** time = ""1?:22""\n    **Output:** ""19:22""\n    \n\n\n\n**Constraints:**\n\n  * `time` is in the format `hh:mm`.\n  * It is guaranteed that you can produce a valid time from the given string.\n\n","class Solution:\ndef maximumTime(self time: str) -> str:\n    memo = {""0"":""9""\n            ""1"":""9""\n            ""?"":""3"" \n            ""2"":""3""}\n    \n    answer = """"\n    for idx val in enumerate(time):\n        if val == ""?"":\n            if idx == 0:\n                if time[idx+1] == ""?"":\n                    answer += ""2""\n                    \n                else:\n                    if int(time[idx+1]) >= 4:\n                        answer += ""1""\n                \n                    else: answer += ""2""\n                \n            if idx == 1:\n                answer += memo[time[idx-1]]\n            \n            if idx == 3:\n                answer += ""5""   \n                \n            if idx == 4:\n                answer += ""9""\n        \n        else:\n            answer += val\n    \n    return answer\n"
Leaf-Similar Trees,###  872\. Leaf-Similar Trees\n\nConsider all the leaves of a binary tree from left to right order the values\nof those leaves form a **leaf value sequence** _._\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png)\n\nFor example in the given tree above the leaf value sequence is `(6 7 4 9\n8)`.\n\nTwo binary trees are considered _leaf-similar_  if their leaf value sequence\nis the same.\n\nReturn `true` if and only if the two given trees with head nodes `root1` and\n`root2` are leaf-similar.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg)\n\n    \n    \n    **Input:** root1 = [3516298nullnull74] root2 = [3516742nullnullnullnullnullnull98]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg)\n\n    \n    \n    **Input:** root1 = [123] root2 = [132]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in each tree will be in the range `[1 200]`.\n  * Both of the given trees will have values in the range `[0 200]`.\n\n,# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def leafSimilar(self root1: Optional[TreeNode] root2: Optional[TreeNode]) -> bool:\n        tree=[]\n        def inorder(root):\n            nonlocal tree\n            if root is None:\n                return\n            if root.left is None and root.right is None:\n                tree.append(root.val)\n            \n            inorder(root.left)\n            inorder(root.right)\n        \n        inorder(root1)\n        inorder(root2)\n        tree1=tree[:len(tree)//2]\n        tree2=tree[len(tree)//2:]\n        if tree1==tree2:\n            return True\n        else:\n            return False
Least Operators to Express Number,"###  964\. Least Operators to Express Number\n\nGiven a single positive integer `x` we will write an expression of the form\n`x (op1) x (op2) x (op3) x ...` where each operator `op1` `op2` etc. is\neither addition subtraction multiplication or division (`+` `-` `*` or\n`/)`. For example with `x = 3` we might write `3 * 3 / 3 + 3 - 3` which is a\nvalue of 3.\n\nWhen writing such an expression we adhere to the following conventions:\n\n  * The division operator (`/`) returns rational numbers.\n  * There are no parentheses placed anywhere.\n  * We use the usual order of operations: multiplication and division happen before addition and subtraction.\n  * It is not allowed to use the unary negation operator (`-`). For example ""`x - x`"" is a valid expression as it only uses subtraction but ""`-x + x`"" is not because it uses negation.\n\nWe would like to write an expression with the least number of operators such\nthat the expression equals the given `target`. Return the least number of\noperators used.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** x = 3 target = 19\n    **Output:** 5\n    **Explanation:** 3 * 3 + 3 * 3 + 3 / 3.\n    The expression contains 5 operations.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** x = 5 target = 501\n    **Output:** 8\n    **Explanation:** 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.\n    The expression contains 8 operations.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** x = 100 target = 100000000\n    **Output:** 3\n    **Explanation:** 100 * 100 * 100 * 100.\n    The expression contains 3 operations.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= x <= 100`\n  * `1 <= target <= 2 * 108`\n\n",# Runtime: 3027 ms (Top 7.32%) | Memory: 13.9 MB (Top 97.56%)\nclass Solution(object):\n    def leastOpsExpressTarget(self x target):\n        return self.cost(x target)\n\n    def cost(self x val):\n        if val == x:\n            return 0\n        elif val < x:\n            # two possible states\n            # either val > x / 2: we substract 1s\n            state_1 = 2 * (x - val)\n            # or val < x / 2: we divide once to 1 and we add enough 1s\n            state_2 = 2*val - 1\n            return min(state_1 state_2)\n        else:\n            # there is a maximum power of x that we can add\n            p = int(log(val) // log(x))\n            # and either x^p or x^(p+1) is the closest\n            a = x**p\n            b = a*x\n            if b < 2*val:\n                # x**(p+1) - val < val - x**p\n                return min(p + self.cost(x val - a) p + 1 + self.cost(x b - val))\n            else:\n                return p + self.cost(x val - a)
Length of Last Word,"###  58\. Length of Last Word\n\nGiven a string `s` consisting of words and spaces return _the length of\nthe**last** word in the string._\n\nA **word** is a maximal substring consisting of non-space characters only.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""Hello World""\n    **Output:** 5\n    **Explanation:** The last word is ""World"" with length 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""   fly me   to   the moon  ""\n    **Output:** 4\n    **Explanation:** The last word is ""moon"" with length 4.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""luffy is still joyboy""\n    **Output:** 6\n    **Explanation:** The last word is ""joyboy"" with length 6.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `s` consists of only English letters and spaces `' '`.\n  * There will be at least one word in `s`.\n\n",class Solution:\n    def lengthOfLastWord(self s: str) -> int:\n        return len(s.strip().split()[-1])\n
Length of Longest Fibonacci Subsequence,###  873\. Length of Longest Fibonacci Subsequence\n\nA sequence `x1 x2 ... xn` is _Fibonacci-like_ if:\n\n  * `n >= 3`\n  * `xi + xi+1 == xi+2` for all `i + 2 <= n`\n\nGiven a **strictly increasing** array `arr` of positive integers forming a\nsequence return _the**length** of the longest Fibonacci-like subsequence of_\n`arr`. If one does not exist return `0`.\n\nA **subsequence** is derived from another sequence `arr` by deleting any\nnumber of elements (including none) from `arr` without changing the order of\nthe remaining elements. For example `[3 5 8]` is a subsequence of `[3 4\n5 6 7 8]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [12345678]\n    **Output:** 5\n    **Explanation:** The longest subsequence that is fibonacci-like: [12358].\n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [13711121418]\n    **Output:** 3\n    **Explanation** :**** The longest subsequence that is fibonacci-like: [11112] [31114] or [71118].\n\n\n\n**Constraints:**\n\n  * `3 <= arr.length <= 1000`\n  * `1 <= arr[i] < arr[i + 1] <= 109`\n\n,class Solution(object): #DP. Time Complexity: O(N^2) Space Complexity: O(NlogM) M = max(A)\n    def lenLongestFibSubseq(self A):\n        index = {Ai: i for i Ai in enumerate(A)}\n        dp = collections.defaultdict(lambda: 2)\n        ans = 0\n        for k Ak in enumerate(A): #Following IJK idiom here\n            for j in range(k-10-1):            \n                i = index.get(Ak - A[j] None)\n                if Ak - A[j] >= A[j]: break #Pruning for illegal Ai\n                if i is not None and i < j:\n                    cur_len = dp[j k] = dp[i j] + 1\n                    ans = max(ans cur_len)\n        \n        return ans # ans is either 0 or >=3 for SURE\n\n
Letter Combinations of a Phone Number,"###  17\. Letter Combinations of a Phone Number\n\nGiven a string containing digits from `2-9` inclusive return all possible\nletter combinations that the number could represent. Return the answer in\n**any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given\nbelow. Note that 1 does not map to any letters.\n\n![](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-\nkeypad2svg.png)\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** digits = ""23""\n    **Output:** [""ad""""ae""""af""""bd""""be""""bf""""cd""""ce""""cf""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** digits = """"\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** digits = ""2""\n    **Output:** [""a""""b""""c""]\n    \n\n\n\n**Constraints:**\n\n  * `0 <= digits.length <= 4`\n  * `digits[i]` is a digit in the range `['2' '9']`.\n\n","class Solution:\n    def letterCombinations(self digits: str) -> List[str]:\n        \n        mapping = {""2"": ""abc""\n                   ""3"": ""def""\n                   ""4"": ""ghi""\n                   ""5"": ""jkl""\n                   ""6"": ""mno""\n                   ""7"": ""pqrs""\n                   ""8"": ""tuv""\n                   ""9"": ""wxyz""}\n        \n        ans = []\n        first = True\n        for i in range(len(digits)):\n            \n            # mult: times we should print each digit\n            mult = 1 \n            for j in range(i+1 len(digits)):\n                mult *= len(mapping[digits[j]])\n            \n            # cycles: times we should run same filling cycle\n            if not first:\n                cycles = len(ans) // mult\n            else:\n                cycles = 1\n            if times > 1:\n                cycles //= len(mapping[digits[i]])\n            \n            # cyclically adding each digits to answer\n            answer_ind = 0 \n            for _ in range(cycles):\n                for char in mapping[digits[i]]:\n                    for __ in range(mult):\n                        if first:\n                            ans.append(char)\n                        else:\n                            ans[answer_ind] += char\n                        answer_ind += 1\n            if first:\n                first = False\n            \n        return ans\n"
Letter Tile Possibilities,"###  1079\. Letter Tile Possibilities\n\nYou have `n`  `tiles` where each tile has one letter `tiles[i]` printed on\nit.\n\nReturn _the number of possible non-empty sequences of letters_ you can make\nusing the letters printed on those `tiles`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** tiles = ""AAB""\n    **Output:** 8\n    **Explanation:** The possible sequences are ""A"" ""B"" ""AA"" ""AB"" ""BA"" ""AAB"" ""ABA"" ""BAA"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** tiles = ""AAABBC""\n    **Output:** 188\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** tiles = ""V""\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= tiles.length <= 7`\n  * `tiles` consists of uppercase English letters.\n\n",class Solution:\n    def numTilePossibilities(self tiles: str) -> int:\n        n= len(tiles)\n        tiles=list(tiles)\n        s1=set()\n        for i in range(1n+1):\n            s1.update(permutations(tilesi))\n        return len(s1)
Lexicographical Numbers,###  386\. Lexicographical Numbers\n\nGiven an integer `n` return all the numbers in the range `[1 n]` sorted in\nlexicographical order.\n\nYou must write an algorithm that runs in `O(n)` time and uses `O(1)` extra\nspace.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 13\n    **Output:** [11011121323456789]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** [12]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 5 * 104`\n\n,"class Solution:\n    def lexicalOrder(self n: int) -> List[int]:\n        result = []\n        orderDic = {}\n        for i in range(1 n + 1):\n            strI = str(i)\n            level = orderDic\n            for char in strI:\n                if char not in level:\n                    level[char] = {}\n                level = level[char]\n        self.traverse(orderDic """" result)\n        return result\n        \n    def traverse(self dic temp result):\n        for key in dic:\n            result.append(int(temp + key))\n            self.traverse(dic[key] temp + key result)\n"
LFU Cache,"###  460\. LFU Cache\n\nDesign and implement a data structure for a [Least Frequently Used\n(LFU)](https://en.wikipedia.org/wiki/Least_frequently_used) cache.\n\nImplement the `LFUCache` class:\n\n  * `LFUCache(int capacity)` Initializes the object with the `capacity` of the data structure.\n  * `int get(int key)` Gets the value of the `key` if the `key` exists in the cache. Otherwise returns `-1`.\n  * `void put(int key int value)` Update the value of the `key` if present or inserts the `key` if not already present. When the cache reaches its `capacity` it should invalidate and remove the **least frequently used** key before inserting a new item. For this problem when there is a **tie** (i.e. two or more keys with the same frequency) the **least recently used** `key` would be invalidated.\n\nTo determine the least frequently used key a **use counter** is maintained\nfor each key in the cache. The key with the smallest **use counter** is the\nleast frequently used key.\n\nWhen a key is first inserted into the cache its **use counter** is set to `1`\n(due to the `put` operation). The **use counter** for a key in the cache is\nincremented either a `get` or `put` operation is called on it.\n\nThe functions `get` and `put` must each run in `O(1)` average time complexity.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""LFUCache"" ""put"" ""put"" ""get"" ""put"" ""get"" ""get"" ""put"" ""get"" ""get"" ""get""]\n    [[2] [1 1] [2 2] [1] [3 3] [2] [3] [4 4] [1] [3] [4]]\n    **Output**\n    [null null null 1 null -1 3 null -1 3 4]\n    \n    **Explanation**\n    // cnt(x) = the use counter for key x\n    // cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\n    LFUCache lfu = new LFUCache(2);\n    lfu.put(1 1);   // cache=[1_] cnt(1)=1\n    lfu.put(2 2);   // cache=[21] cnt(2)=1 cnt(1)=1\n    lfu.get(1);      // return 1\n                     // cache=[12] cnt(2)=1 cnt(1)=2\n    lfu.put(3 3);   // 2 is the LFU key because cnt(2)=1 is the smallest invalidate 2.\n                     // cache=[31] cnt(3)=1 cnt(1)=2\n    lfu.get(2);      // return -1 (not found)\n    lfu.get(3);      // return 3\n                     // cache=[31] cnt(3)=2 cnt(1)=2\n    lfu.put(4 4);   // Both 1 and 3 have the same cnt but 1 is LRU invalidate 1.\n                     // cache=[43] cnt(4)=1 cnt(3)=2\n    lfu.get(1);      // return -1 (not found)\n    lfu.get(3);      // return 3\n                     // cache=[34] cnt(4)=1 cnt(3)=3\n    lfu.get(4);      // return 4\n                     // cache=[43] cnt(4)=2 cnt(3)=3\n    \n\n\n\n**Constraints:**\n\n  * `0 <= capacity <= 104`\n  * `0 <= key <= 105`\n  * `0 <= value <= 109`\n  * At most `2 * 105` calls will be made to `get` and `put`.\n\n\n\n\n\n",class Node:\n    \n    def __init__(self key val cnt=1 nxxt=None prev=None):\n        self.key = key\n        self.val = val\n        self.cnt = cnt\n        self.nxxt = nxxt\n        self.prev = prev\n        \n        \nclass NodeList(Node):\n    \n    def __init__(self):\n        self.head = Node(00)\n        self.tail = Node(00)\n        self.head.nxxt = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n        \n        \n    def addFront(self node):\n        temp = self.head.nxxt\n        self.head.nxxt = node\n        node.prev = self.head\n        node.nxxt = temp\n        temp.prev = node\n        \n        self.size += 1\n        \n        \n    def removeNode(self node):\n        delprev = node.prev\n        delnxxt = node.nxxt\n        delprev.nxxt = delnxxt\n        delnxxt.prev = delprev\n        \n        self.size -= 1\n        \n\nclass LFUCache(NodeList):\n\n    def __init__(self capacity: int):\n        self.keyNode = {}\n        self.freqNodeList = {}\n        self.maxSizeCache = capacity\n        self.currSize = 0\n        self.minFreq = 0\n        \n        \n    def updateFreqNodeList(self node):\n        del self.keyNode[node.key]\n        nodelist = self.freqNodeList[node.cnt]\n        nodelist.removeNode(node)\n        \n        if node.cnt == self.minFreq and self.freqNodeList[node.cnt].size == 0:\n            self.minFreq += 1\n            \n        if (node.cnt+1) in self.freqNodeList:\n            nextHigherFreqNodeList = self.freqNodeList[node.cnt+1]\n        else:\n            nextHigherFreqNodeList = NodeList()\n            \n        node.cnt += 1\n        nextHigherFreqNodeList.addFront(node)\n        \n        self.freqNodeList[node.cnt] = nextHigherFreqNodeList\n        self.keyNode[node.key] = node\n        \n\n    def get(self key: int) -> int:\n        if key in self.keyNode:\n            node = self.keyNode[key]\n            ans = node.val\n            self.updateFreqNodeList(node)\n            \n            return ans\n        \n        else:\n            return -1\n        \n\n    def put(self key: int value: int) -> None:\n        if self.maxSizeCache == 0:\n            return\n        \n        if key in self.keyNode:\n            node = self.keyNode[key]\n            node.val = value\n            self.updateFreqNodeList(node)\n            return\n        \n        else:\n            if self.currSize == self.maxSizeCache:\n                nodelist = self.freqNodeList[self.minFreq]\n                del self.keyNode[nodelist.tail.prev.key]\n                nodelist.removeNode(nodelist.tail.prev)\n                self.currSize -= 1\n                \n            self.currSize += 1\n            self.minFreq = 1\n            \n            if self.minFreq in self.freqNodeList:\n                nodelist = self.freqNodeList[self.minFreq]\n            else:\n                nodelist = NodeList()\n                \n            node = Node(key value)\n            nodelist.addFront(node)\n            \n            self.keyNode[key] = node\n            self.freqNodeList[self.minFreq] = nodelist\n        \n\n\n# Your LFUCache object will be instantiated and called as such:\n# obj = LFUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(keyvalue)\n
License Key Formatting,"###  482\. License Key Formatting\n\nYou are given a license key represented as a string `s` that consists of only\nalphanumeric characters and dashes. The string is separated into `n + 1`\ngroups by `n` dashes. You are also given an integer `k`.\n\nWe want to reformat the string `s` such that each group contains exactly `k`\ncharacters except for the first group which could be shorter than `k` but\nstill must contain at least one character. Furthermore there must be a dash\ninserted between two groups and you should convert all lowercase letters to\nuppercase.\n\nReturn _the reformatted license key_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""5F3Z-2e-9-w"" k = 4\n    **Output:** ""5F3Z-2E9W""\n    **Explanation:** The string s has been split into two parts each part has 4 characters.\n    Note that the two extra dashes are not needed and can be removed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""2-5g-3-J"" k = 2\n    **Output:** ""2-5G-3J""\n    **Explanation:** The string s has been split into three parts each part has 2 characters except the first part as it could be shorter as mentioned above.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of English letters digits and dashes `'-'`.\n  * `1 <= k <= 104`\n\n","# Runtime: 81 ms (Top 55.38%) | Memory: 14.3 MB (Top 86.51%)\nclass Solution:\n    def licenseKeyFormatting(self s: str k: int) -> str:\n        new_str = s.replace(""-"" """")\n        res = """"\n        j = len(new_str)-1\n        i = 0\n        while j >= 0:\n            res += new_str[j].upper()\n            i += 1\n            if i == k and j != 0:\n                res += ""-""\n                i = 0\n            j -= 1\n        return res[::-1]"
Linked List Components,###  817\. Linked List Components\n\nYou are given the `head` of a linked list containing unique integer values and\nan integer array `nums` that is a subset of the linked list values.\n\nReturn _the number of connected components in_`nums` _where two values are\nconnected if they appear**consecutively** in the linked list_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom1.jpg)\n\n    \n    \n    **Input:** head = [0123] nums = [013]\n    **Output:** 2\n    **Explanation:** 0 and 1 are connected so [0 1] and [3] are the two connected components.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/07/22/lc-linkedlistcom2.jpg)\n\n    \n    \n    **Input:** head = [01234] nums = [0314]\n    **Output:** 2\n    **Explanation:** 0 and 1 are connected 3 and 4 are connected so [0 1] and [3 4] are the two connected components.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the linked list is `n`.\n  * `1 <= n <= 104`\n  * `0 <= Node.val < n`\n  * All the values `Node.val` are **unique**.\n  * `1 <= nums.length <= n`\n  * `0 <= nums[i] < n`\n  * All the values of `nums` are **unique**.\n\n,# Runtime: 171 ms (Top 62.36%) | Memory: 19.1 MB (Top 64.07%)\nclass Solution:\n    def numComponents(self head: Optional[ListNode] nums: List[int]) -> int:\n        dcount={}0\n        for num in nums:\n            d[num] = 0\n\n        while head:\n            if head.val in d:\n                head = head.next\n                while head and head.val in d:\n                    head = head.next\n                count += 1\n            else:\n                head = head.next\n        return count
Linked List Cycle,###  141\. Linked List Cycle\n\nGiven `head` the head of a linked list determine if the linked list has a\ncycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can\nbe reached again by continuously following the `next` pointer. Internally\n`pos` is used to denote the index of the node that tail's `next` pointer is\nconnected to. **Note that  `pos` is not passed as a parameter**.\n\nReturn `true` _if there is a cycle in the linked list_. Otherwise return\n`false`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n\n    \n    \n    **Input:** head = [320-4] pos = 1\n    **Output:** true\n    **Explanation:** There is a cycle in the linked list where the tail connects to the 1st node (0-indexed).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)\n\n    \n    \n    **Input:** head = [12] pos = 0\n    **Output:** true\n    **Explanation:** There is a cycle in the linked list where the tail connects to the 0th node.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)\n\n    \n    \n    **Input:** head = [1] pos = -1\n    **Output:** false\n    **Explanation:** There is no cycle in the linked list.\n    \n\n\n\n**Constraints:**\n\n  * The number of the nodes in the list is in the range `[0 104]`.\n  * `-105 <= Node.val <= 105`\n  * `pos` is `-1` or a **valid index** in the linked-list.\n\n\n\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?\n\n,class Solution:\n    def hasCycle(self head: Optional[ListNode]) -> bool:\n        for i in range(0 10001):\n            if head == None: return False\n            head = head.next\n        \n        return True\n
Linked List Cycle II,###  142\. Linked List Cycle II\n\nGiven the `head` of a linked list return _the node where the cycle begins. If\nthere is no cycle return_`null`.\n\nThere is a cycle in a linked list if there is some node in the list that can\nbe reached again by continuously following the `next` pointer. Internally\n`pos` is used to denote the index of the node that tail's `next` pointer is\nconnected to (**0-indexed**). It is `-1` if there is no cycle. **Note that**\n`pos` **is not passed as a parameter**.\n\n**Do not modify** the linked list.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)\n\n    \n    \n    **Input:** head = [320-4] pos = 1\n    **Output:** tail connects to node index 1\n    **Explanation:** There is a cycle in the linked list where tail connects to the second node.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)\n\n    \n    \n    **Input:** head = [12] pos = 0\n    **Output:** tail connects to node index 0\n    **Explanation:** There is a cycle in the linked list where tail connects to the first node.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)\n\n    \n    \n    **Input:** head = [1] pos = -1\n    **Output:** no cycle\n    **Explanation:** There is no cycle in the linked list.\n    \n\n\n\n**Constraints:**\n\n  * The number of the nodes in the list is in the range `[0 104]`.\n  * `-105 <= Node.val <= 105`\n  * `pos` is `-1` or a **valid index** in the linked-list.\n\n\n\n**Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?\n\n,# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return None\n        slow = fast = entry = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n            if slow == fast:\n                while slow != entry:\n                    slow = slow.next\n                    entry = entry.next\n                return entry\n        return None\n
Linked List in Binary Tree,###  1367\. Linked List in Binary Tree\n\nGiven a binary tree `root` and a linked list with `head` as the first node.\n\nReturn True if all the elements in the linked list starting from the `head`\ncorrespond to some _downward path_ connected in the binary tree otherwise\nreturn False.\n\nIn this context downward path means a path that starts at some node and goes\ndownwards.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/02/12/sample_1_1720.png)**\n\n    \n    \n    **Input:** head = [428] root = [144null22null1null68nullnullnullnull13]\n    **Output:** true\n    **Explanation:** Nodes in blue form a subpath in the binary Tree.  \n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2020/02/12/sample_2_1720.png)**\n\n    \n    \n    **Input:** head = [1426] root = [144null22null1null68nullnullnullnull13]\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** head = [14268] root = [144null22null1null68nullnullnullnull13]\n    **Output:** false\n    **Explanation:** There is no path in the binary tree that contains all the elements of the linked list from head.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree will be in the range `[1 2500]`.\n  * The number of nodes in the list will be in the range `[1 100]`.\n  * `1 <= Node.val <= 100` for each node in the linked list and binary tree.\n\n,# Runtime: 139 ms (Top 73.10%) | Memory: 16.3 MB (Top 54.16%)\n\nclass Solution(object):\n    def isSubPath(self head root):\n        if not root:\n            return False\n        if self.issame(head root):\n            return True\n        return self.isSubPath(head root.left) or self.isSubPath(head root.right)\n    def issame(self head root):\n        if not head:\n            return True\n        if not root:\n            return False\n        if head.val != root.val:\n            return False\n        return self.issame(head.next root.left) or self.issame(head.next root.right)
Linked List Random Node,"###  382\. Linked List Random Node\n\nGiven a singly linked list return a random node's value from the linked list.\nEach node must have the **same probability** of being chosen.\n\nImplement the `Solution` class:\n\n  * `Solution(ListNode head)` Initializes the object with the head of the singly-linked list `head`.\n  * `int getRandom()` Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/16/getrand-linked-list.jpg)\n\n    \n    \n    **Input**\n    [""Solution"" ""getRandom"" ""getRandom"" ""getRandom"" ""getRandom"" ""getRandom""]\n    [[[1 2 3]] [] [] [] [] []]\n    **Output**\n    [null 1 3 2 2 3]\n    \n    **Explanation**\n    Solution solution = new Solution([1 2 3]);\n    solution.getRandom(); // return 1\n    solution.getRandom(); // return 3\n    solution.getRandom(); // return 2\n    solution.getRandom(); // return 2\n    solution.getRandom(); // return 3\n    // getRandom() should return either 1 2 or 3 randomly. Each element should have equal probability of returning.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the linked list will be in the range `[1 104]`.\n  * `-104 <= Node.val <= 104`\n  * At most `104` calls will be made to `getRandom`.\n\n\n\n**Follow up:**\n\n  * What if the linked list is extremely large and its length is unknown to you?\n  * Could you solve this efficiently without using extra space?\n\n",// Runtime: 53 ms (Top 95.6%) | Memory: 20.10 MB (Top 30.35%)\n\nclass Solution:\n    def __init__(self head: Optional[ListNode]):\n        self.ll=[]\n        while head:\n            self.ll.append(head.val)\n            head=head.next\n    def getRandom(self) -> int:\n        return self.ll[randint(0 len(self.ll)-1)]\n
Longer Contiguous Segments of Ones than Zeros,"###  1869\. Longer Contiguous Segments of Ones than Zeros\n\nGiven a binary string `s` return `true` _if the**longest** contiguous segment\nof _`1`'_s is**strictly longer** than the **longest** contiguous segment of\n_`0`'_s in_`s` or return `false` _otherwise_.\n\n  * For example in `s = ""_11_ 01 _000_ 10""` the longest continuous segment of `1`s has length `2` and the longest continuous segment of `0`s has length `3`.\n\nNote that if there are no `0`'s then the longest continuous segment of `0`'s\nis considered to have a length `0`. The same applies if there is no `1`'s.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""1101""\n    **Output:** true\n    **Explanation:**\n    The longest contiguous segment of 1s has length 2: ""_11_ 01""\n    The longest contiguous segment of 0s has length 1: ""11 _0_ 1""\n    The segment of 1s is longer so return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""111000""\n    **Output:** false\n    **Explanation:**\n    The longest contiguous segment of 1s has length 3: ""_111_ 000""\n    The longest contiguous segment of 0s has length 3: ""111 _000_ ""\n    The segment of 1s is not longer so return false.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""110100010""\n    **Output:** false\n    **Explanation:**\n    The longest contiguous segment of 1s has length 2: ""_11_ 0100010""\n    The longest contiguous segment of 0s has length 3: ""1101 _000_ 10""\n    The segment of 1s is not longer so return false.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s[i]` is either `'0'` or `'1'`.\n\n",# Runtime: 47 ms (Top 65.12%) | Memory: 13.9 MB (Top 66.60%)\nclass Solution:\n    def checkZeroOnes(self s: str) -> bool:\n        s1 = s.split('0')\n        s0 = s.split('1')\n        r1 = max([len(i) for i in s1])\n        r0 = max([len(i) for i in s0])\n        return r1>r0
Longest Absolute File Path,"###  388\. Longest Absolute File Path\n\nSuppose we have a file system that stores both files and directories. An\nexample of one system is represented in the following picture:\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mdir.jpg)\n\nHere we have `dir` as the only directory in the root. `dir` contains two\nsubdirectories `subdir1` and `subdir2`. `subdir1` contains a file `file1.ext`\nand subdirectory `subsubdir1`. `subdir2` contains a subdirectory `subsubdir2`\nwhich contains a file `file2.ext`.\n\nIn text form it looks like this (with ⟶ representing the tab character):\n\n    \n    \n    dir\n    ⟶ subdir1\n    ⟶ ⟶ file1.ext\n    ⟶ ⟶ subsubdir1\n    ⟶ subdir2\n    ⟶ ⟶ subsubdir2\n    ⟶ ⟶ ⟶ file2.ext\n    \n\nIf we were to write this representation in code it will look like this:\n`""dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext""`.\nNote that the `'\n'` and `'\t'` are the new-line and tab characters.\n\nEvery file and directory has a unique **absolute path** in the file system\nwhich is the order of directories that must be opened to reach the\nfile/directory itself all concatenated by `'/'s`. Using the above example\nthe **absolute path** to `file2.ext` is `""dir/subdir2/subsubdir2/file2.ext""`.\nEach directory name consists of letters digits and/or spaces. Each file name\nis of the form `name.extension` where `name` and `extension` consist of\nletters digits and/or spaces.\n\nGiven a string `input` representing the file system in the explained format\nreturn _the length of the**longest absolute path** to a **file** in the\nabstracted file system_. If there is no file in the system return `0`.\n\n**Note** that the testcases are generated such that the file system is valid\nand no file or directory name has length 0.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/dir1.jpg)\n\n    \n    \n    **Input:** input = ""dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext""\n    **Output:** 20\n    **Explanation:** We have only one file and the absolute path is ""dir/subdir2/file.ext"" of length 20.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/dir2.jpg)\n\n    \n    \n    **Input:** input = ""dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext""\n    **Output:** 32\n    **Explanation:** We have two files:\n    ""dir/subdir1/file1.ext"" of length 21\n    ""dir/subdir2/subsubdir2/file2.ext"" of length 32.\n    We return 32 since it is the longest absolute path to a file.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** input = ""a""\n    **Output:** 0\n    **Explanation:** We do not have any files just a single directory named ""a"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= input.length <= 104`\n  * `input` may contain lowercase or uppercase English letters a new line character `'\n'` a tab character `'\t'` a dot `'.'` a space `' '` and digits.\n  * All file and directory names have **positive** length.\n\n","class Solution:\n	def lengthLongestPath(self input: str) -> int:\n		if ""."" not in input:\n			return 0\n\n		a=input.split(""\n"")\n		files=[]\n		for i in a:\n			if ""."" in i:\n				files.append(i)\n\n		final=[]\n		for i in range(len(files)):\n			file=files[i]\n			lvl=file.count(""\t"")\n			idx=a.index(file)-1\n			save=[files[i].replace(""\t"""""")]\n			for j in range(lvl):\n				while a[idx].count(""\t"")!=lvl-1:\n					idx-=1\n				lvl=a[idx].count(""\t"")\n				save.append(a[idx].replace(""\t""""""))\n				idx-=1\n			final.append(save)\n\n		final=list(map(""/"".joinfinal))\n		return len(max(finalkey=len))"
Longest Arithmetic Subsequence of Given Difference,###  1218\. Longest Arithmetic Subsequence of Given Difference\n\nGiven an integer array `arr` and an integer `difference` return the length of\nthe longest subsequence in `arr` which is an arithmetic sequence such that the\ndifference between adjacent elements in the subsequence equals `difference`.\n\nA **subsequence** is a sequence that can be derived from `arr` by deleting\nsome or no elements without changing the order of the remaining elements.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [1234] difference = 1\n    **Output:** 4\n    **Explanation:** The longest arithmetic subsequence is [1234].\n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [1357] difference = 1\n    **Output:** 1\n    **Explanation:** The longest arithmetic subsequence is any single element.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [157853421] difference = -2\n    **Output:** 4\n    **Explanation:** The longest arithmetic subsequence is [7531].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 105`\n  * `-104 <= arr[i] difference <= 104`\n\n,# Runtime: 548 ms (Top 98.07%) | Memory: 27.7 MB (Top 73.31%)\nclass Solution:\n    def longestSubsequence(self arr: List[int] difference: int) -> int:\n        d = defaultdict(int)\n        for num in arr:\n            if num - difference in d:\n                d[num] = d[num - difference] + 1\n            else:\n                d[num] = 1\n        return max((d[x] for x in d))\n
Longest Binary Subsequence Less Than or Equal to K,"###  2311\. Longest Binary Subsequence Less Than or Equal to K\n\nYou are given a binary string `s` and a positive integer `k`.\n\nReturn _the length of the**longest** subsequence of _`s` _that makes up\na**binary** number less than or equal to_ `k`.\n\nNote:\n\n  * The subsequence can contain **leading zeroes**.\n  * The empty string is considered to be equal to `0`.\n  * A **subsequence** is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""1001010"" k = 5\n    **Output:** 5\n    **Explanation:** The longest subsequence of s that makes up a binary number less than or equal to 5 is ""00010"" as this number is equal to 2 in decimal.\n    Note that ""00100"" and ""00101"" are also possible which are equal to 4 and 5 in decimal respectively.\n    The length of this subsequence is 5 so 5 is returned.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""00101001"" k = 1\n    **Output:** 6\n    **Explanation:** ""000001"" is the longest subsequence of s that makes up a binary number less than or equal to 1 as this number is equal to 1 in decimal.\n    The length of this subsequence is 6 so 6 is returned.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s[i]` is either `'0'` or `'1'`.\n  * `1 <= k <= 109`\n\n","// Runtime: 46 ms (Top 62.5%) | Memory: 16.50 MB (Top 18.75%)\n\nclass Solution:\n    def longestSubsequence(self s: str k: int) -> int:\n    \n        end n  = len(s)-1 s.count(""0"")    \n        while end >=0 and  int(s[end:] 2)<= k:\n            end-=1\n        return n+ s[end+1:].count(""1"")\n        \n"
Longest Chunked Palindrome Decomposition,"###  1147\. Longest Chunked Palindrome Decomposition\n\nYou are given a string `text`. You should split it to k substrings `(subtext1\nsubtext2 ... subtextk)` such that:\n\n  * `subtexti` is a **non-empty** string.\n  * The concatenation of all the substrings is equal to `text` (i.e. `subtext1 + subtext2 + ... + subtextk == text`).\n  * `subtexti == subtextk - i + 1` for all valid values of `i` (i.e. `1 <= i <= k`).\n\nReturn the largest possible value of `k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text = ""ghiabcdefhelloadamhelloabcdefghi""\n    **Output:** 7\n    **Explanation:** We can split the string on ""(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text = ""merchant""\n    **Output:** 1\n    **Explanation:** We can split the string on ""(merchant)"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** text = ""antaprezatepzapreanta""\n    **Output:** 11\n    **Explanation:** We can split the string on ""(a)(nt)(a)(pre)(za)(tep)(za)(pre)(a)(nt)(a)"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length <= 1000`\n  * `text` consists only of lowercase English characters.\n\n",# Runtime: 82 ms (Top 23.89%) | Memory: 13.9 MB (Top 78.76%)\n\nclass Solution:\n    def longestDecomposition(self text: str) -> int:\n        left right = 0 len(text) - 1\n        sol last_left = 0 0\n        a b = deque() deque()\n        while right > left:\n            a.append(text[left])\n            b.appendleft(text[right])\n            if a == b:\n                sol += 2\n                last_left = left\n                a b = deque() deque()\n            right -= 1\n            left += 1\n        if left == right or left > last_left + 1:\n            sol += 1\n        return max(sol 1)\n
Longest Common Prefix,"###  14\. Longest Common Prefix\n\nWrite a function to find the longest common prefix string amongst an array of\nstrings.\n\nIf there is no common prefix return an empty string `""""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** strs = [""flower""""flow""""flight""]\n    **Output:** ""fl""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** strs = [""dog""""racecar""""car""]\n    **Output:** """"\n    **Explanation:** There is no common prefix among the input strings.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= strs.length <= 200`\n  * `0 <= strs[i].length <= 200`\n  * `strs[i]` consists of only lowercase English letters.\n\n","class Solution:\n    def longestCommonPrefix(self strs: List[str]) -> str:\n        cmp=strs[0]\n        for i in range(1len(strs)):\n            l=0\n            if (len(cmp)>len(strs[i])):\n                l+=len(strs[i])\n            else:\n                l+=len(cmp)\n            ans=""""\n            for j in range(l):\n                if (cmp[j]!=strs[i][j]):\n                    if (j==0):\n                        return """"\n                    else:\n                        break\n                else:\n                    ans+=strs[i][j]\n            cmp=ans\n        return cmp\n		\nUpvote If you Like!!!"
Longest Common Subpath,###  1923\. Longest Common Subpath\n\nThere is a country of `n` cities numbered from `0` to `n - 1`. In this\ncountry there is a road connecting **every pair** of cities.\n\nThere are `m` friends numbered from `0` to `m - 1` who are traveling through\nthe country. Each one of them will take a path consisting of some cities. Each\npath is represented by an integer array that contains the visited cities in\norder. The path may contain a city **more than once**  but the same city will\nnot be listed consecutively.\n\nGiven an integer `n` and a 2D integer array `paths` where `paths[i]` is an\ninteger array representing the path of the `ith` friend return _the length of\nthe**longest common subpath** that is shared by **every** friend's path or\n_`0` _if there is no common subpath at all_.\n\nA **subpath** of a path is a contiguous sequence of cities within that path.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5 paths = [[01_23_ 4]\n                           [_23_ 4]\n                           [401_23_]]\n    **Output:** 2\n    **Explanation:** The longest common subpath is [23].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3 paths = [[0][1][2]]\n    **Output:** 0\n    **Explanation:** There is no common subpath shared by the three paths.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 5 paths = [[_0_ 1234]\n                           [4321_0_]]\n    **Output:** 1\n    **Explanation:** The possible longest common subpaths are [0] [1] [2] [3] and [4]. All have a length of 1.\n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `m == paths.length`\n  * `2 <= m <= 105`\n  * `sum(paths[i].length) <= 105`\n  * `0 <= paths[i][j] < n`\n  * The same city is not listed multiple times consecutively in `paths[i]`.\n\n,"// Runtime: 4090 ms (Top 34.15%) | Memory: 51.70 MB (Top 78.05%)\n\nclass Solution:\n    def longestCommonSubpath(self n paths) -> int:\n        def get_common_subpath_hashes(k):\n            """"""Return hash values of common subpaths of length k or empty set if none exists""""""\n            def get_subpath_hashes(path):\n                hash coeff = 0 pow(n k-1 mod)\n                for i in range(len(path)+1):\n                    if i < k:\n                        hash = (hash*n + path[i]) % mod\n                    else:\n                        yield hash\n                        if i < len(path):\n                            hash = ((hash-coeff*path[i-k])*n + path[i]) % mod   \n            return reduce(set.intersection (set(get_subpath_hashes(p)) for p in paths))\n        \n	    # can be replaced with a pre-computed large prime\n        mod = self._generate_large_prime(int(1e18) int(9e18))\n        low high = 1 min(len(p) for p in paths)+1\n        while low < high:\n            mid = (low+high) // 2\n            if get_common_subpath_hashes(mid):\n                low = mid + 1\n            else:\n                high = mid\n        return high - 1\n    \n    def _generate_large_prime(self lower upper):\n        """"""Generate a prime between [lower upper)""""""\n        def is_prime(n trials=50):\n            def witness(a n):\n                x0 = pow(a u n)\n                for _ in range(t):\n                    x = x0**2 % n\n                    if x == 1 and x0 != 1 and x0 != n-1:\n                        return True\n                    x0 = x\n                return True if x0 != 1 else False\n\n            t u = 0 n-1\n            while u%2 == 0:\n                t u = t+1 u>>1\n            return not any(witness(randrange(1 n) n) for _ in range(trials))\n        return next(r for r in iter(lambda: randrange(lower upper) None) if is_prime(r))\n"
Longest Common Subsequence,"###  1143\. Longest Common Subsequence\n\nGiven two strings `text1` and `text2` return _the length of their\nlongest**common subsequence**. _If there is no **common subsequence**  return\n`0`.\n\nA **subsequence** of a string is a new string generated from the original\nstring with some characters (can be none) deleted without changing the\nrelative order of the remaining characters.\n\n  * For example `""ace""` is a subsequence of `""abcde""`.\n\nA **common subsequence** of two strings is a subsequence that is common to\nboth strings.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text1 = ""abcde"" text2 = ""ace"" \n    **Output:** 3  \n    **Explanation:** The longest common subsequence is ""ace"" and its length is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text1 = ""abc"" text2 = ""abc""\n    **Output:** 3\n    **Explanation:** The longest common subsequence is ""abc"" and its length is 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** text1 = ""abc"" text2 = ""def""\n    **Output:** 0\n    **Explanation:** There is no such common subsequence so the result is 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text1.length text2.length <= 1000`\n  * `text1` and `text2` consist of only lowercase English characters.\n\n",class Solution:\n    def longestCommonSubsequence(self text1: str text2: str) -> int:\n        def lcs(ind1ind2):\n            prev=[0 for i in range(ind2+1)]\n            curr=[0 for i in range(ind2+1)]\n            \n            for i in range(1ind1+1):\n                for j in range(1ind2+1):\n                    if text1[i-1]==text2[j-1]:\n                        curr[j]=1+prev[j-1]\n                         \n                    else:\n                        curr[j]=max(prev[j]curr[j-1])\n                prev=list(curr) # remember to use a new list for prev\n\n            return prev[-1]\n                    \n        \n        ans=lcs(len(text1)len(text2))\n        return ans\n
Longest Consecutive Sequence,###  128\. Longest Consecutive Sequence\n\nGiven an unsorted array of integers `nums` return _the length of the longest\nconsecutive elements sequence._\n\nYou must write an algorithm that runs in `O(n)` time.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1004200132]\n    **Output:** 4\n    **Explanation:** The longest consecutive elements sequence is [1 2 3 4]. Therefore its length is 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0372584601]\n    **Output:** 9\n    \n\n\n\n**Constraints:**\n\n  * `0 <= nums.length <= 105`\n  * `-109 <= nums[i] <= 109`\n\n,class Solution(object):\n    def longestConsecutive(self nums):\n        ans=0\n        nums=set(nums)\n        count=0\n        for i in nums:\n            if i-1 not in nums:\n                j=i\n                count=0\n                while j in nums:\n                    count+=1\n                    j+=1\n                ans=max(anscount)            \n        return ans\n
Longest Continuous Increasing Subsequence,###  674\. Longest Continuous Increasing Subsequence\n\nGiven an unsorted array of integers `nums` return _the length of the\nlongest**continuous increasing subsequence** (i.e. subarray)_. The subsequence\nmust be **strictly** increasing.\n\nA **continuous increasing subsequence** is defined by two indices `l` and `r`\n(`l < r`) such that it is `[nums[l] nums[l + 1] ... nums[r - 1] nums[r]]`\nand for each `l <= i < r` `nums[i] < nums[i + 1]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13547]\n    **Output:** 3\n    **Explanation:** The longest continuous increasing subsequence is [135] with length 3.\n    Even though [1357] is an increasing subsequence it is not continuous as elements 5 and 7 are separated by element\n    4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [22222]\n    **Output:** 1\n    **Explanation:** The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly\n    increasing.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-109 <= nums[i] <= 109`\n\n,# Runtime: 416 ms (Top 5.00%) | Memory: 15.4 MB (Top 49.36%)\n\nclass Solution:\n    def findLengthOfLCIS(self nums: List[int]) -> int:\n        count=0\n        for i in range(len(nums)):\n            a=nums[i]\n            c=1\n            for j in range(i+1 len(nums)):\n                if nums[j]>a:\n                    a=nums[j]\n                    c+=1\n                else:\n                    break\n            count=max(count c)\n        return count
Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit,###  1438\. Longest Continuous Subarray With Absolute Diff Less Than or Equal\nto Limit\n\nGiven an array of integers `nums` and an integer `limit` return the size of\nthe longest **non-empty** subarray such that the absolute difference between\nany two elements of this subarray is less than or equal to `limit` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [8247] limit = 4\n    **Output:** 2 \n    **Explanation:** All subarrays are: \n    [8] with maximum absolute diff |8-8| = 0 <= 4.\n    [82] with maximum absolute diff |8-2| = 6 > 4. \n    [824] with maximum absolute diff |8-2| = 6 > 4.\n    [8247] with maximum absolute diff |8-2| = 6 > 4.\n    [2] with maximum absolute diff |2-2| = 0 <= 4.\n    [24] with maximum absolute diff |2-4| = 2 <= 4.\n    [247] with maximum absolute diff |2-7| = 5 > 4.\n    [4] with maximum absolute diff |4-4| = 0 <= 4.\n    [47] with maximum absolute diff |4-7| = 3 <= 4.\n    [7] with maximum absolute diff |7-7| = 0 <= 4. \n    Therefore the size of the longest subarray is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1012472] limit = 5\n    **Output:** 4 \n    **Explanation:** The subarray [2472] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [42224422] limit = 0\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 109`\n  * `0 <= limit <= 109`\n\n,# max absolte diff within a subarray is subarray max substracted by subarray min\nclass Solution:\n    def longestSubarray(self nums: List[int] limit: int) -> int:\n        q = collections.deque() # monotonic decreasing deque to compute subarray max index of\n        q2 = collections.deque() # monotonic increasing deque to compute subarray min index of\n        \n        # sliding window\n        res = left = 0\n        for right in range(len(nums)):\n            # pop monotocity-violating numbers from right end\n            while q and nums[q[-1]] <= nums[right]:\n                q.pop()\n            q.append(right)\n            \n            # pop monotocity-violating numbers from right end\n            while q2 and nums[q2[-1]] >= nums[right]:\n                q2.pop()\n            q2.append(right)\n            \n            # sliding window\n            while left < right and q and q2 and nums[q[0]] - nums[q2[0]] > limit:\n                # compress window from left pointer\n                if q and q[0] == left:\n                    q.popleft()\n                \n                # compress left pointer\n                if q2 and q2[0] == left:\n                    q2.popleft()\n                    \n                left += 1\n            \n            if nums[q[0]] - nums[q2[0]] <= limit:\n                res = max(res right - left + 1)\n        \n        return res\n
Longest Cycle in a Graph,###  2360\. Longest Cycle in a Graph\n\nYou are given a **directed** graph of `n` nodes numbered from `0` to `n - 1`\nwhere each node has **at most one** outgoing edge.\n\nThe graph is represented with a given **0-indexed** array `edges` of size `n`\nindicating that there is a directed edge from node `i` to node `edges[i]`. If\nthere is no outgoing edge from node `i` then `edges[i] == -1`.\n\nReturn _the length of the**longest** cycle in the graph_. If no cycle exists\nreturn `-1`.\n\nA cycle is a path that starts and ends at the **same** node.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/06/08/graph4drawio-5.png)\n\n    \n    \n    **Input:** edges = [33423]\n    **Output:** 3\n    **Explanation:** The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\n    The length of this cycle is 3 so 3 is returned.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-1.png)\n\n    \n    \n    **Input:** edges = [2-131]\n    **Output:** -1\n    **Explanation:** There are no cycles in this graph.\n    \n\n\n\n**Constraints:**\n\n  * `n == edges.length`\n  * `2 <= n <= 105`\n  * `-1 <= edges[i] < n`\n  * `edges[i] != i`\n\n,class Solution:\n    def longestCycle(self edges: List[int]) -> int:\n        preorder = [-1 for _ in range(len(edges))]\n        self.ans = -1\n        self.pre = 0\n        \n        def dfs(self i: int st: int) -> None:\n            preorder[i] = self.pre\n            self.pre += 1\n            \n            if edges[i] == -1:\n                return\n            elif preorder[edges[i]] == -1:\n                dfs(self edges[i] st)\n                return\n            elif preorder[edges[i]] >= st:\n                self.ans = max(self.ans preorder[i] - preorder[edges[i]] + 1)\n                return\n        \n        for i in range(len(edges)):\n            if preorder[i] == -1 and edges[i] != -1:\n                dfs(self i self.pre)\n        \n        return self.ans\n
Longest Duplicate Substring,"###  1044\. Longest Duplicate Substring\n\nGiven a string `s` consider all _duplicated substrings_ : (contiguous)\nsubstrings of s that occur 2 or more times. The occurrences may overlap.\n\nReturn **any** duplicated substring that has the longest possible length. If\n`s` does not have a duplicated substring the answer is `""""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""banana""\n    **Output:** ""ana""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcd""\n    **Output:** """"\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 3 * 104`\n  * `s` consists of lowercase English letters.\n\n","# Runtime: 2799 ms (Top 43.0%) | Memory: 16.80 MB (Top 93.0%)\n\nclass Solution:\n    def longestDupSubstring(self s: str) -> str:\n        left = 0\n        right = 1\n        res = """"\n        n = len(s)\n        while right<n:\n            if s[left:right] in s[left+1:]:\n                if right - left > len(res):\n                    res = s[left:right]\n                right+=1\n                continue\n            left+=1\n            if left == right:\n                right+=1\n        return res"
Longest Happy String,"###  1405\. Longest Happy String\n\nA string `s` is called **happy** if it satisfies the following conditions:\n\n  * `s` only contains the letters `'a'` `'b'` and `'c'`.\n  * `s` does not contain any of `""aaa""` `""bbb""` or `""ccc""` as a substring.\n  * `s` contains **at most** `a` occurrences of the letter `'a'`.\n  * `s` contains **at most** `b` occurrences of the letter `'b'`.\n  * `s` contains **at most** `c` occurrences of the letter `'c'`.\n\nGiven three integers `a` `b` and `c` return _the**longest possible happy**\nstring_. If there are multiple longest happy strings return _any of them_. If\nthere is no such string return _the empty string_`""""`.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** a = 1 b = 1 c = 7\n    **Output:** ""ccaccbcc""\n    **Explanation:** ""ccbccacc"" would also be a correct answer.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** a = 7 b = 1 c = 0\n    **Output:** ""aabaa""\n    **Explanation:** It is the only correct answer in this case.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= a b c <= 100`\n  * `a + b + c > 0`\n\n","class Solution:\n	def longestDiverseString(self a: int b: int c: int) -> str:\n		pq = []\n		if a > 0: heapq.heappush(pq(-a'a'))        \n		if b > 0: heapq.heappush(pq(-b'b'))        \n		if c > 0: heapq.heappush(pq(-c'c'))\n\n		ans = ''\n		while pq:\n			c ch = heapq.heappop(pq)\n			if len(ans)>1 and ans[-1] == ans[-2] == ch:\n				if not pq: break\n				c2 ch2 = heapq.heappop(pq)\n				ans += ch2\n				c2 += 1\n				if c2: heapq.heappush(pq(c2ch2))\n			else:\n				ans += ch\n				c += 1\n			if c: heapq.heappush(pq(cch))\n\n		return ans\n"
Longest Harmonious Subsequence,###  594\. Longest Harmonious Subsequence\n\nWe define a harmonious array as an array where the difference between its\nmaximum value and its minimum value is **exactly** `1`.\n\nGiven an integer array `nums` return _the length of its longest harmonious\nsubsequence among all its possible subsequences_.\n\nA **subsequence** of array is a sequence that can be derived from the array by\ndeleting some or no elements without changing the order of the remaining\nelements.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13225237]\n    **Output:** 5\n    **Explanation:** The longest harmonious subsequence is [32223].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1111]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 104`\n  * `-109 <= nums[i] <= 109`\n\n,"\nfrom collections import Counter\nclass Solution:\n	def findLHS(self nums: List[int]) -> int:\n		counter=Counter(nums)\n		# values=set(nums)\n		res=0\n		# if len(values)==1:return 0\n		for num in nums:\n			if num+1 in counter or num-1 in counter:\n				res=max(rescounter[num]+counter.get(num+10))\n				res=max(rescounter[num]+counter.get(num-10))\n\n		return res\n"""""
Longest Ideal Subsequence,"###  2370\. Longest Ideal Subsequence\n\nYou are given a string `s` consisting of lowercase letters and an integer `k`.\nWe call a string `t` **ideal** if the following conditions are satisfied:\n\n  * `t` is a **subsequence** of the string `s`.\n  * The absolute difference in the alphabet order of every two **adjacent** letters in `t` is less than or equal to `k`.\n\nReturn _the length of the**longest** ideal string_.\n\nA **subsequence** is a string that can be derived from another string by\ndeleting some or no characters without changing the order of the remaining\ncharacters.\n\n**Note** that the alphabet order is not cyclic. For example the absolute\ndifference in the alphabet order of `'a'` and `'z'` is `25` not `1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""acfgbd"" k = 2\n    **Output:** 4\n    **Explanation:** The longest ideal string is ""acbd"". The length of this string is 4 so 4 is returned.\n    Note that ""acfgbd"" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcd"" k = 3\n    **Output:** 4\n    **Explanation:** The longest ideal string is ""abcd"". The length of this string is 4 so 4 is returned.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `0 <= k <= 25`\n  * `s` consists of lowercase English letters.\n\n","// Runtime: 381 ms (Top 86.75%) | Memory: 17.40 MB (Top 70.48%)\n\nclass Solution:\n    def longestIdealString(self s: str k: int) -> int:\n        dp = [0] * 26\n        for ch in s:\n            i = ord(ch) - ord(""a"")\n            dp[i] = 1 + max(dp[max(0 i - k) : min(26 i + k + 1)])\n        return max(dp)\n"
Longest Increasing Path in a Matrix,###  329\. Longest Increasing Path in a Matrix\n\nGiven an `m x n` integers `matrix` return _the length of the longest\nincreasing path in_`matrix`.\n\nFrom each cell you can either move in four directions: left right up or\ndown. You **may not** move **diagonally** or move **outside the boundary**\n(i.e. wrap-around is not allowed).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)\n\n    \n    \n    **Input:** matrix = [[994][668][211]]\n    **Output:** 4\n    **Explanation:** The longest increasing path is [1 2 6 9].\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg)\n\n    \n    \n    **Input:** matrix = [[345][326][221]]\n    **Output:** 4\n    **Explanation:** The longest increasing path is [3 4 5 6]. Moving diagonally is not allowed.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** matrix = [[1]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m n <= 200`\n  * `0 <= matrix[i][j] <= 231 - 1`\n\n,class Solution:\n    def longestIncreasingPath(self matrix: List[List[int]]) -> int:\n        ROWS COLS = len(matrix) len(matrix[0])\n        dp = {}\n        \n        def dfs(r c prevVal):\n            if (r < 0 or r == ROWS or\n                c < 0 or c == COLS or\n                matrix[r][c] <= prevVal):\n                return 0\n            if (r c) in dp:\n                return dp[(r c)]\n            res = 1\n            res = max(res 1 + dfs(r + 1 c matrix[r][c]))\n            res = max(res 1 + dfs(r - 1 c matrix[r][c]))\n            res = max(res 1 + dfs(r c + 1 matrix[r][c]))\n            res = max(res 1 + dfs(r c - 1 matrix[r][c]))\n            dp[(r c)] = res\n            return res\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r c -1)\n        return max(dp.values())\n
Longest Increasing Subsequence,###  300\. Longest Increasing Subsequence\n\nGiven an integer array `nums` return the length of the longest strictly\nincreasing subsequence.\n\nA **subsequence** is a sequence that can be derived from an array by deleting\nsome or no elements without changing the order of the remaining elements. For\nexample `[3627]` is a subsequence of the array `[0316227]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [109253710118]\n    **Output:** 4\n    **Explanation:** The longest increasing subsequence is [237101] therefore the length is 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [010323]\n    **Output:** 4\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [7777777]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2500`\n  * `-104 <= nums[i] <= 104`\n\n\n\n**Follow up:**  Can you come up with an algorithm that runs in `O(n log(n))`\ntime complexity?\n\n,class Solution:\n    def lengthOfLIS(self nums: list[int]) -> int:\n\n        # Initialize the result\n        res = []\n\n        # Binary search to find the index of the smallest number in result that is greater than or equal to the target\n        def binarySearch(l r target):\n\n            nonlocal res\n\n            # If the left and right pointers meet we have found the smallest number that is greater than the target\n            if l == r:\n                return l\n\n            # Find the mid pointer\n            m = (r - l) // 2 + l\n\n            # If the number at the mid pointer is equal to the target we have found a number that is equal to the target\n            if res[m] == target:\n                return m\n\n            # Else if the number at the mid poitner is less than the target we search the right side\n            elif res[m] < target:\n                return binarySearch(m + 1 r target)\n\n            # Else we search the left side including the number at mid pointer because it is one of the possible solution since it is greater than the target\n            else:\n                return binarySearch(l m target)\n\n        # Iterate through all numbers\n        for n in nums:\n\n            # If the last number in the result is less than the current number\n            if not res or res[-1] < n:\n\n                # Append the current number to the result\n                res.append(n)\n\n                continue\n\n            # Else find the index of the smallest number in the result that is greater than or equal to the current number\n            i = binarySearch(0 len(res) - 1 n)\n\n            # Replace the current number at such index\n            res[i] = n\n\n        return len(res)\n
Longest Palindrome by Concatenating Two Letter Words,"###  2131\. Longest Palindrome by Concatenating Two Letter Words\n\nYou are given an array of strings `words`. Each element of `words` consists of\n**two** lowercase English letters.\n\nCreate the **longest possible palindrome** by selecting some elements from\n`words` and concatenating them in **any order**. Each element can be selected\n**at most once**.\n\nReturn _the**length** of the longest palindrome that you can create_. If it is\nimpossible to create any palindrome return `0`.\n\nA **palindrome** is a string that reads the same forward and backward.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""lc""""cl""""gg""]\n    **Output:** 6\n    **Explanation:** One longest palindrome is ""lc"" + ""gg"" + ""cl"" = ""lcggcl"" of length 6.\n    Note that ""clgglc"" is another longest palindrome that can be created.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""ab""""ty""""yt""""lc""""cl""""ab""]\n    **Output:** 8\n    **Explanation:** One longest palindrome is ""ty"" + ""lc"" + ""cl"" + ""yt"" = ""tylcclyt"" of length 8.\n    Note that ""lcyttycl"" is another longest palindrome that can be created.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""cc""""ll""""xx""]\n    **Output:** 2\n    **Explanation:** One longest palindrome is ""cc"" of length 2.\n    Note that ""ll"" is another longest palindrome that can be created and so is ""xx"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 105`\n  * `words[i].length == 2`\n  * `words[i]` consists of lowercase English letters.\n\n",class Solution(object):\n    def longestPalindrome(self words):\n        wc = collections.Counter(words)\n        aa = 0  # count how many words contain only two identical letters like 'aa'\n        center = 0  # if one count of 'aa' is odd that means it can be the center of the palindrome answer can plus 2\n        abba = 0 # count how many word pairs like ('ab' 'ba') and they can put on both sides respectively\n\n        for w c in wc.items():\n            if w[0] == w[1]: # like 'aa' 'bb' ...\n                aa += c // 2 * 2 # if there are 3 'aa' we can only use 2 'aa' put on both sides respectively\n                # if one count of 'aa' is odd that means it can be the center of the palindrome answer can plus 2\n                if c % 2 == 1: center = 2\n            else:\n                abba += min(wc[w] wc[w[::-1]]) * 0.5  # will definitely double counting\n        return aa * 2 + int(abba) * 4 + center\n
Longest Palindromic Subsequence,"###  516\. Longest Palindromic Subsequence\n\nGiven a string `s` find _the longest palindromic**subsequence** 's length in_\n`s`.\n\nA **subsequence** is a sequence that can be derived from another sequence by\ndeleting some or no elements without changing the order of the remaining\nelements.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""bbbab""\n    **Output:** 4\n    **Explanation:** One possible longest palindromic subsequence is ""bbbb"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""cbbd""\n    **Output:** 2\n    **Explanation:** One possible longest palindromic subsequence is ""bb"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s` consists only of lowercase English letters.\n\n",// Runtime: 1248 ms (Top 52.16%) | Memory: 34.60 MB (Top 50.8%)\n\nclass Solution:\n    def longestPalindromeSubseq(self s: str) -> int:\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\n        for k in range(1 len(s) + 1):\n            for i in range(len(s) - k + 1):\n                j = k + i - 1\n                if i == j:\n                    dp[i][j] = 1\n                elif i + 1 == j and s[i] == s[j]:\n                    dp[i][j] = 2\n                elif s[i] == s[j]:\n                    dp[i][j] = dp[i+1][j-1] + 2\n                else:\n                    dp[i][j] = max(dp[i+1][j] dp[i][j-1])\n        return dp[0][-1]\n
Longest Palindromic Substring,"###  5\. Longest Palindromic Substring\n\nGiven a string `s` return _the longest palindromic substring_ in `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""babad""\n    **Output:** ""bab""\n    **Explanation:** ""aba"" is also a valid answer.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""cbbd""\n    **Output:** ""bb""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s` consist of only digits and English letters.\n\n","# Runtime: 643 ms (Top 86.54%) | Memory: 14 MB (Top 58.84%)\nclass Solution:\n    def longestPalindrome(self s: str) -> str:\n        res = """"\n        for i in range(len(s)):\n            left right = i - 1 i + 1\n\n            while (right < len(s) and s[right] == s[i]):\n                right += 1\n\n            while (0 <= left < right < len(s) and s[left] == s[right]):\n                left right = left - 1 right + 1\n\n            res = s[left+1:right] if right - left-1 > len(res) else res\n        return res"
Longest Path With Different Adjacent Characters,"###  2246\. Longest Path With Different Adjacent Characters\n\nYou are given a **tree** (i.e. a connected undirected graph that has no\ncycles) **rooted** at node `0` consisting of `n` nodes numbered from `0` to `n\n- 1`. The tree is represented by a **0-indexed** array `parent` of size `n`\nwhere `parent[i]` is the parent of node `i`. Since node `0` is the root\n`parent[0] == -1`.\n\nYou are also given a string `s` of length `n` where `s[i]` is the character\nassigned to node `i`.\n\nReturn _the length of the**longest path** in the tree such that no pair of\n**adjacent** nodes on the path have the same character assigned to them._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png)\n\n    \n    \n    **Input:** parent = [-100112] s = ""abacbe""\n    **Output:** 3\n    **Explanation:** The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3 so 3 is returned.\n    It can be proven that there is no longer path that satisfies the conditions. \n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png)\n\n    \n    \n    **Input:** parent = [-1000] s = ""aabc""\n    **Output:** 3\n    **Explanation:** The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3 so 3 is returned.\n    \n\n\n\n**Constraints:**\n\n  * `n == parent.length == s.length`\n  * `1 <= n <= 105`\n  * `0 <= parent[i] <= n - 1` for all `i >= 1`\n  * `parent[0] == -1`\n  * `parent` represents a valid tree.\n  * `s` consists of only lowercase English letters.\n\n",class Solution:\n    def longestPath(self parent: list[int] s: str) -> int:\n        def l_path_and_chain(tree: dict[int list[int]] s: str root: int) -> tuple[int int]:\n            lp = lc1 = lc2 = 0\n            for child path chain in ((c *l_path_and_chain(tree s c)) for c in tree[root]):\n                lp = max(lp path)\n                if s[child] != s[root]: *_ lc2 lc1 = sorted((chain lc2 lc1))\n\n            return max(lp lc1 + lc2 + 1) lc1 + 1\n\n        t = defaultdict(list)\n        for c p in enumerate(parent): t[p].append(c)\n        return l_path_and_chain(t s 0)[0]\n
Longest Repeating Character Replacement,"###  424\. Longest Repeating Character Replacement\n\nYou are given a string `s` and an integer `k`. You can choose any character of\nthe string and change it to any other uppercase English character. You can\nperform this operation at most `k` times.\n\nReturn _the length of the longest substring containing the same letter you can\nget after performing the above operations_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ABAB"" k = 2\n    **Output:** 4\n    **Explanation:** Replace the two 'A's with two 'B's or vice versa.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""AABABBA"" k = 1\n    **Output:** 4\n    **Explanation:** Replace the one 'A' in the middle with 'B' and form ""AABBBBA"".\n    The substring ""BBBB"" has the longest repeating letters which is 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of only uppercase English letters.\n  * `0 <= k <= s.length`\n\n",class Solution:\n    def characterReplacement(self s: str k: int) -> int:\n        # Initialize variables\n        window_start = 0\n        max_length = 0\n        max_count = 0\n        char_count = {}\n\n        # Traverse the string s\n        for window_end in range(len(s)):\n            # Increment the count of the current character\n            char_count[s[window_end]] = char_count.get(s[window_end] 0) + 1\n            # Update the maximum count seen so far\n            max_count = max(max_count char_count[s[window_end]])\n            \n            # Shrink the window if required\n            if window_end - window_start + 1 > max_count + k:\n                char_count[s[window_start]] -= 1\n                window_start += 1\n            \n            # Update the maximum length of the substring with repeating characters seen so far\n            max_length = max(max_length window_end - window_start + 1)\n        \n        return max_length\n
Longest Subarray of 1's After Deleting One Element,###  1493\. Longest Subarray of 1's After Deleting One Element\n\nGiven a binary array `nums` you should delete one element from it.\n\nReturn _the size of the longest non-empty subarray containing only_`1` _'s in\nthe resulting array_. Return `0` if there is no such subarray.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1101]\n    **Output:** 3\n    **Explanation:** After deleting the number in position 2 [111] contains 3 numbers with value of 1's.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [011101101]\n    **Output:** 5\n    **Explanation:** After deleting the number in position 4 [01111101] longest subarray with value of 1's is [11111].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [111]\n    **Output:** 2\n    **Explanation:** You must delete one element.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `nums[i]` is either `0` or `1`.\n\n,class Solution:\n    def longestSubarray(self nums: List[int]) -> int:\n        n = len(nums)\n        pre suf = [1]*n [1]*n\n        if nums[0] == 0:pre[0] = 0\n        if nums[-1] == 0:suf[-1] = 0\n        \n        for i in range(1 n):\n            if nums[i] == 1 and nums[i-1] == 1:\n                pre[i] = pre[i-1] + 1\n            elif nums[i] == 0:\n                pre[i] = 0\n        \n        for i in range(n-2 -1 -1):\n            if nums[i] == 1 and nums[i+1] == 1:\n                suf[i] = suf[i+1] + 1\n            elif nums[i] == 0:\n                suf[i] = 0\n        \n        ans = 0\n        for i in range(n):\n            if i == 0:\n                ans = max(ans suf[i+1])\n            elif i == n-1:\n                ans = max(ans pre[i-1])\n            else:\n                ans = max(ans pre[i-1] + suf[i+1])\n        \n        return ans
Longest Substring of One Repeating Character,"###  2213\. Longest Substring of One Repeating Character\n\nYou are given a **0-indexed** string `s`. You are also given a **0-indexed**\nstring `queryCharacters` of length `k` and a **0-indexed** array of integer\n**indices** `queryIndices` of length `k` both of which are used to describe\n`k` queries.\n\nThe `ith` query updates the character in `s` at index `queryIndices[i]` to the\ncharacter `queryCharacters[i]`.\n\nReturn _an array_ `lengths` _of length_`k` _where_ `lengths[i]` _is\nthe**length** of the **longest substring** of _`s` _consisting of**only one\nrepeating** character **after** the_ `ith` _query_ _is performed._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""babacc"" queryCharacters = ""bcb"" queryIndices = [133]\n    **Output:** [334]\n    **Explanation:** \n    - 1st query updates s = ""_b**b** b_acc"". The longest substring consisting of one repeating character is ""bbb"" with length 3.\n    - 2nd query updates s = ""bbb _**c** cc_"". \n      The longest substring consisting of one repeating character can be ""bbb"" or ""ccc"" with length 3.\n    - 3rd query updates s = ""_bbb**b**_ cc"". The longest substring consisting of one repeating character is ""bbbb"" with length 4.\n    Thus we return [334].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abyzz"" queryCharacters = ""aa"" queryIndices = [21]\n    **Output:** [23]\n    **Explanation:**\n    - 1st query updates s = ""ab**a** _zz_ "". The longest substring consisting of one repeating character is ""zz"" with length 2.\n    - 2nd query updates s = ""_a**a** a_zz"". The longest substring consisting of one repeating character is ""aaa"" with length 3.\n    Thus we return [23].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of lowercase English letters.\n  * `k == queryCharacters.length == queryIndices.length`\n  * `1 <= k <= 105`\n  * `queryCharacters` consists of lowercase English letters.\n  * `0 <= queryIndices[i] < s.length`\n\n",// Runtime: 3460 ms (Top 87.5%) | Memory: 38.10 MB (Top 67.5%)\n\nfrom sortedcontainers import SortedList\n\nclass Solution:\n    def longestRepeating(self s: str queryCharacters: str queryIndices: List[int]) -> List[int]:\n        sl = SortedList()\n        length = SortedList()\n        curr = 0\n        for char it in itertools.groupby(s):\n            c = sum(1 for _ in it)\n            length.add(c)\n            sl.add((curr curr + c char))\n            curr += c\n        ans = []\n        for char i in zip(queryCharacters queryIndices):\n            t = (i math.inf 'a')\n            index = sl.bisect_right(t) - 1\n            to_remove = [sl[index]]\n            to_add = []\n            left right original_char = to_remove[0]\n            if original_char != char:\n                length.remove(right - left)\n                if right - left > 1:\n                    if i == left:\n                        left += 1\n                        to_add.append((left right original_char))\n                        length.add(right - left)\n                    elif i == right - 1:\n                        right -= 1\n                        to_add.append((left right original_char))\n                        length.add(right - left)\n                    else:\n                        to_add.append((left i original_char))\n                        length.add(i - left)\n                        to_add.append((i + 1 right original_char))\n                        length.add(right - (i + 1))\n                \n                l r = i i + 1\n                if index - 1 >= 0 and sl[index - 1][1:3] == (i char):\n                    l old_r _ = sl[index - 1]\n                    to_remove.append(sl[index - 1])\n                    length.remove(old_r - l)\n                if index + 1 < len(sl) and sl[index + 1][0] == i + 1 and sl[index + 1][2] == char:\n                    old_l r old_length = sl[index + 1]\n                    to_remove.append(sl[index + 1])\n                    length.remove(r - old_l)\n                length.add(r - l)\n                sl.add((l r char))\n                for t in to_remove:\n                    sl.remove(t)\n                sl.update(to_add)\n            # print(sl)\n            # print(length)\n            ans.append(length[-1])\n\n        return ans\n
Longest Substring with At Least K Repeating Characters,"###  395\. Longest Substring with At Least K Repeating Characters\n\nGiven a string `s` and an integer `k` return _the length of the longest\nsubstring of_ `s` _such that the frequency of each character in this substring\nis greater than or equal to_ `k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aaabb"" k = 3\n    **Output:** 3\n    **Explanation:** The longest substring is ""aaa"" as 'a' is repeated 3 times.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""ababbc"" k = 2\n    **Output:** 5\n    **Explanation:** The longest substring is ""ababb"" as 'a' is repeated 2 times and 'b' is repeated 3 times.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `s` consists of only lowercase English letters.\n  * `1 <= k <= 105`\n\n",# Runtime: 57 ms (Top 73.85%) | Memory: 14.4 MB (Top 21.39%)\nfrom collections import Counter\n\nclass Solution:\n    def longestSubstring(self s: str k: int) -> int:\n        return get_longest_substring(s k)\n\ndef get_longest_substring(s k):\n    if len(s) == 0: return 0\n    c = Counter(s)\n    low_freq_char = set([char for char freq in c.items() if freq < k])\n    # base case\n    if len(low_freq_char) == 0:\n        return len(s)\n    # recursively split str into substr\n    division_points = [i for i in range(len(s)) if s[i] in low_freq_char]\n    substr_lst = []\n    # start\n    substr_lst.append(s[:division_points[0]])\n    # middle\n    for i in range(len(division_points) - 1):\n        substr_lst.append(s[division_points[i] + 1: division_points[i + 1]])\n    # end\n    substr_lst.append(s[division_points[-1] + 1:])\n    return max([get_longest_substring(substr k) for substr in substr_lst])
Longest Substring Without Repeating Characters,"###  3\. Longest Substring Without Repeating Characters\n\nGiven a string `s` find the length of the **longest substring** without\nrepeating characters.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcabcbb""\n    **Output:** 3\n    **Explanation:** The answer is ""abc"" with the length of 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""bbbbb""\n    **Output:** 1\n    **Explanation:** The answer is ""b"" with the length of 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""pwwkew""\n    **Output:** 3\n    **Explanation:** The answer is ""wke"" with the length of 3.\n    Notice that the answer must be a substring ""pwke"" is a subsequence and not a substring.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= s.length <= 5 * 104`\n  * `s` consists of English letters digits symbols and spaces.\n\n",class Solution:\n    def lengthOfLongestSubstring(self s: str) -> int:\n        \n        longest_s = ''\n        curr_s = ''\n        for i in s:\n            if i not in curr_s:\n                curr_s += i\n                if len(curr_s) >= len(longest_s):\n                    longest_s = curr_s\n            else:\n                curr_s = curr_s[curr_s.index(i)+1:]+i\n        \n        return len(longest_s)\n
Longest Turbulent Subarray,###  978\. Longest Turbulent Subarray\n\nGiven an integer array `arr` return _the length of a maximum size turbulent\nsubarray of_ `arr`.\n\nA subarray is **turbulent** if the comparison sign flips between each adjacent\npair of elements in the subarray.\n\nMore formally a subarray `[arr[i] arr[i + 1] ... arr[j]]` of `arr` is said\nto be turbulent if and only if:\n\n  * For `i <= k < j`: \n    * `arr[k] > arr[k + 1]` when `k` is odd and\n    * `arr[k] < arr[k + 1]` when `k` is even.\n  * Or for `i <= k < j`: \n    * `arr[k] > arr[k + 1]` when `k` is even and\n    * `arr[k] < arr[k + 1]` when `k` is odd.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [9421078819]\n    **Output:** 5\n    **Explanation:** arr[1] > arr[2] < arr[3] > arr[4] < arr[5]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [481216]\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [100]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 4 * 104`\n  * `0 <= arr[i] <= 109`\n\n,# Runtime: 1152 ms (Top 13.10%) | Memory: 18.7 MB (Top 31.75%)\nclass Solution:\n    def maxTurbulenceSize(self arr: List[int]) -> int:\n        def cmp(ab):\n            if a == b: return 0\n            if a > b : return 1\n            return -1\n\n        n = len(arr)\n        ans = 1\n        prev = 0\n        for i in range(1n):\n            c = cmp(arr[i-1]arr[i])\n            if c == 0:\n                # we shift prev to i\n                prev = i\n            elif i == n-1 or c * cmp(arr[i]arr[i+1]) != -1:\n                ans = ans if ans > i - prev + 1 else i - prev + 1\n                prev = i\n        return ans
Longest Uncommon Subsequence I,"###  521\. Longest Uncommon Subsequence I\n\nGiven two strings `a` and `b` return _the length of the**longest uncommon\nsubsequence** between _`a` _and_ `b`. If the longest uncommon subsequence does\nnot exist return `-1`.\n\nAn **uncommon subsequence** between two strings is a string that is a\n**subsequence of one but not the other**.\n\nA **subsequence** of a string `s` is a string that can be obtained after\ndeleting any number of characters from `s`.\n\n  * For example `""abc""` is a subsequence of `""aebdc""` because you can delete the underlined characters in `""a _e_ b _d_ c""` to get `""abc""`. Other subsequences of `""aebdc""` include `""aebdc""` `""aeb""` and `""""` (empty string).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** a = ""aba"" b = ""cdc""\n    **Output:** 3\n    **Explanation:** One longest uncommon subsequence is ""aba"" because ""aba"" is a subsequence of ""aba"" but not ""cdc"".\n    Note that ""cdc"" is also a longest uncommon subsequence.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** a = ""aaa"" b = ""bbb""\n    **Output:** 3\n    **Explanation:**  The longest uncommon subsequences are ""aaa"" and ""bbb"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** a = ""aaa"" b = ""aaa""\n    **Output:** -1\n    **Explanation:**  Every subsequence of string a is also a subsequence of string b. Similarly every subsequence of string b is also a subsequence of string a.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= a.length b.length <= 100`\n  * `a` and `b` consist of lower-case English letters.\n\n",# Runtime: 47 ms (Top 54.94%) | Memory: 13.9 MB (Top 58.35%)\nclass Solution:\n    def findLUSlength(self a: str b: str) -> int:\n        if a == b:\n            return -1\n\n        else:\n            return max(len(a) len(b))
Longest Uncommon Subsequence II,"###  522\. Longest Uncommon Subsequence II\n\nGiven an array of strings `strs` return _the length of the**longest uncommon\nsubsequence** between them_. If the longest uncommon subsequence does not\nexist return `-1`.\n\nAn **uncommon subsequence** between an array of strings is a string that is a\n**subsequence of one string but not the others**.\n\nA **subsequence** of a string `s` is a string that can be obtained after\ndeleting any number of characters from `s`.\n\n  * For example `""abc""` is a subsequence of `""aebdc""` because you can delete the underlined characters in `""a _e_ b _d_ c""` to get `""abc""`. Other subsequences of `""aebdc""` include `""aebdc""` `""aeb""` and `""""` (empty string).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** strs = [""aba""""cdc""""eae""]\n    **Output:** 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** strs = [""aaa""""aaa""""aa""]\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `2 <= strs.length <= 50`\n  * `1 <= strs[i].length <= 10`\n  * `strs[i]` consists of lowercase English letters.\n\n",// Runtime: 40 ms (Top 71.65%) | Memory: 17.30 MB (Top 26.77%)\n\nclass Solution:\n    def findLUSlength(self strs: List[str]) -> int:\n        def isSubseq(a b):\n            j = 0\n            for i in range(len(b)):\n                if a[j] == b[i]:\n                    j += 1\n                    if j == len(a):\n                        return True\n            return False\n        c = Counter(strs)\n        s = sorted(c.keys() key=len reverse=True)\n        for i in range(len(s)):\n            if c[s[i]] > 1:\n                continue\n            if i == 0 or not any(isSubseq(s[i] s[j]) for j in range(i)):    \n                return len(s[i])\n        return -1 \n
Longest Univalue Path,###  687\. Longest Univalue Path\n\nGiven the `root` of a binary tree return _the length of the longest path\nwhere each node in the path has the same value_. This path may or may not pass\nthrough the root.\n\n**The length of the path** between two nodes is represented by the number of\nedges between them.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/13/ex1.jpg)\n\n    \n    \n    **Input:** root = [54511null5]\n    **Output:** 2\n    **Explanation:** The shown image shows that the longest path of the same value (i.e. 5).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/13/ex2.jpg)\n\n    \n    \n    **Input:** root = [14544null5]\n    **Output:** 2\n    **Explanation:** The shown image shows that the longest path of the same value (i.e. 4).\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 104]`.\n  * `-1000 <= Node.val <= 1000`\n  * The depth of the tree will not exceed `1000`.\n\n,"class Solution:\n	max_path=0\n	def longestUnivaluePath(self root: Optional[TreeNode]) -> int:\n		self.dfs(root);\n		return self.max_path\n\n	def dfs(selfroot):\n		if root is None:return 0\n		left=self.dfs(root.left)\n		right=self.dfs(root.right)\n\n		if root.left  and  root.left.val == root.val:\n			leftPath=left+1\n		else:\n			leftPath=0\n\n		if root.right and  root.right.val == root.val:\n			rightPath=right+1\n		else:\n			rightPath=0\n\n		self.max_path = max(self.max_path leftPath + rightPath)\n		return max(leftPath rightPath)\n"
Longest Well-Performing Interval,###  1124\. Longest Well-Performing Interval\n\nWe are given `hours` a list of the number of hours worked per day for a given\nemployee.\n\nA day is considered to be a _tiring day_ if and only if the number of hours\nworked is (strictly) greater than `8`.\n\nA _well-performing interval_ is an interval of days for which the number of\ntiring days is strictly larger than the number of non-tiring days.\n\nReturn the length of the longest well-performing interval.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** hours = [9960669]\n    **Output:** 3\n    **Explanation:** The longest well-performing interval is [996].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** hours = [666]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= hours.length <= 104`\n  * `0 <= hours[i] <= 16`\n\n,"class Solution:\n    def longestWPI(self hours: List[int]) -> int:\n        #accumulative count\n        #+1 when > 8 -1 when less than 8. \n        #find strictly increasing length.\n        \n        p = [] #number of tiring days vs not\n        c = 0\n        for e in hours:\n            if e > 8:\n                c +=1\n            else:\n                c-=1\n            \n            p.append(c)\n            \n            \n        \n        #for every moment: we want earliest moment which could be positive overall tiring days.\n        a = []\n        #a is sorted by tiringnes. At day 8 have -2 want earliest point that could get us to at least 1.\n        #so up until that point we have -3 -4 etc and we want earliest out of it to get longest well performing interval. Which is when prefix comes in.\n        \n        a1 =[]\n        for i in range(len(p)):\n            a.append([p[i] i])\n            a1.append(p[i])\n        \n        a1.sort() #bisectable list\n        a.sort()\n        \n        prefix = []\n        currearly = float('inf')\n        for t day in a:\n            currearly = min(currearly day)\n            prefix.append(currearly)\n        \n        \n        res = 0\n        \n        # print(p)\n        \n        for i in range(len(hours)):\n            if p[i] > 0:\n                res = max(res i + 1) \n            \n            else:\n                #find earliest \n                #value must be less than -1-p[i] \n                loc = bisect_right(a1 -1+p[i]) #bisect right means anything before this is less than or equals to\n                \n                \n                \n                if loc == 0: #the rightmost place to put it is at the beginning...\n                    \n                    continue\n                \n                \n                else:\n                    earliest = prefix[loc - 1]\n                    \n                    if earliest >= i: continue\n                    \n                    interval = i - earliest #notice: we're not including the starting index since its also technically being removed!\n\n                    # print(""From day"" earliest ""to"" i)\n                    \n                    res = max(res interval)\n        \n        \n        \n        return res\n        \n        \n        \n        \n"
Longest Word in Dictionary,"###  720\. Longest Word in Dictionary\n\nGiven an array of strings `words` representing an English Dictionary return\n_the longest word in_ `words` _that can be built one character at a time by\nother words in_ `words`.\n\nIf there is more than one possible answer return the longest word with the\nsmallest lexicographical order. If there is no answer return the empty\nstring.\n\nNote that the word should be built from left to right with each additional\ncharacter being added to the end of a previous word.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""w""""wo""""wor""""worl""""world""]\n    **Output:** ""world""\n    **Explanation:** The word ""world"" can be built one character at a time by ""w"" ""wo"" ""wor"" and ""worl"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""a""""banana""""app""""appl""""ap""""apply""""apple""]\n    **Output:** ""apple""\n    **Explanation:** Both ""apply"" and ""apple"" can be built from other words in the dictionary. However ""apple"" is lexicographically smaller than ""apply"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 1000`\n  * `1 <= words[i].length <= 30`\n  * `words[i]` consists of lowercase English letters.\n\n",# Runtime: 240 ms (Top 36.59%) | Memory: 15.2 MB (Top 46.59%)\nclass Solution:\n    def longestWord(self words: List[str]) -> str:\n        TrieNode = lambda: defaultdict(TrieNode)\n        root = TrieNode()\n        for is in enumerate(words):\n            cur = root\n            for c in s: cur=cur[c]\n            cur['$']=i\n\n        ans = ''\n        st = list(root.values())\n        while st:\n            cur = st.pop()\n            if '$' in cur:\n                w = words[cur['$']]\n                if len(ans)<len(w) or len(ans)==len(w) and w<ans:ans=w\n                st.extend([cur[i] for i in cur if i!='$'])\n        return ans
Longest Word in Dictionary through Deleting,"###  524\. Longest Word in Dictionary through Deleting\n\nGiven a string `s` and a string array `dictionary` return _the longest string\nin the dictionary that can be formed by deleting some of the given string\ncharacters_. If there is more than one possible result return the longest\nword with the smallest lexicographical order. If there is no possible result\nreturn the empty string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abpcplea"" dictionary = [""ale""""apple""""monkey""""plea""]\n    **Output:** ""apple""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abpcplea"" dictionary = [""a""""b""""c""]\n    **Output:** ""a""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `1 <= dictionary.length <= 1000`\n  * `1 <= dictionary[i].length <= 1000`\n  * `s` and `dictionary[i]` consist of lowercase English letters.\n\n","class Solution:\n    def findLongestWord(self s: str dictionary: list[str]) -> str:\n        solution = """"\n        for word in dictionary:\n            j = 0\n            for i in range(len(s)):\n                if s[i] == word[j]:\n                    j+=1\n                if j == len(word):\n                    solution = word if len(word) > len(solution) or len(word) == len(solution) and word < solution  else solution\n                    break\n        return solution"
Longest ZigZag Path in a Binary Tree,###  1372\. Longest ZigZag Path in a Binary Tree\n\nYou are given the `root` of a binary tree.\n\nA ZigZag path for a binary tree is defined as follow:\n\n  * Choose **any** node in the binary tree and a direction (right or left).\n  * If the current direction is right move to the right child of the current node; otherwise move to the left child.\n  * Change the direction from right to left or from left to right.\n  * Repeat the second and third steps until you can't move in the tree.\n\nZigzag length is defined as the number of nodes visited - 1. (A single node\nhas a length of 0).\n\nReturn _the longest**ZigZag** path contained in that tree_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/01/22/sample_1_1702.png)\n\n    \n    \n    **Input:** root = [1null111nullnull11null1nullnullnull1null1]\n    **Output:** 3\n    **Explanation:** Longest ZigZag path in blue nodes (right -> left -> right).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/01/22/sample_2_1702.png)\n\n    \n    \n    **Input:** root = [111null1nullnull11null1]\n    **Output:** 4\n    **Explanation:** Longest ZigZag path in blue nodes (left -> right -> left -> right).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 5 * 104]`.\n  * `1 <= Node.val <= 100`\n\n,# Runtime: 437 ms (Top 91.25%) | Memory: 59.8 MB (Top 86.06%)\n\nclass Solution:\n    def longestZigZag(self root: Optional[TreeNode]) -> int:\n        self.res = 0\n\n        def helper(root):\n            if root is None:\n                return -1 -1\n\n            leftRight = helper(root.left)[1] + 1\n            rightLeft = helper(root.right)[0] + 1\n            self.res = max(self.res leftRight rightLeft)\n            return leftRight rightLeft\n\n        helper(root)\n        return self.res
Loud and Rich,###  851\. Loud and Rich\n\nThere is a group of `n` people labeled from `0` to `n - 1` where each person\nhas a different amount of money and a different level of quietness.\n\nYou are given an array `richer` where `richer[i] = [ai bi]` indicates that\n`ai` has more money than `bi` and an integer array `quiet` where `quiet[i]` is\nthe quietness of the `ith` person. All the given data in richer are\n**logically correct** (i.e. the data will not lead you to a situation where\n`x` is richer than `y` and `y` is richer than `x` at the same time).\n\nReturn _an integer array_`answer` _where_`answer[x] = y` _if_`y` _is the least\nquiet person (that is the person_`y` _with the smallest value of_`quiet[y]`_)\namong all people who definitely have equal to or more money than the\nperson_`x`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** richer = [[10][21][31][37][43][53][63]] quiet = [32546170]\n    **Output:** [55254567]\n    **Explanation:** \n    answer[0] = 5.\n    Person 5 has more money than 3 which has more money than 1 which has more money than 0.\n    The only person who is quieter (has lower quiet[x]) is person 7 but it is not clear if they have more money than person 0.\n    answer[7] = 7.\n    Among all people that definitely have equal to or more money than person 7 (which could be persons 3 4 5 6 or 7) the person who is the quietest (has lower quiet[x]) is person 7.\n    The other answers can be filled out with similar reasoning.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** richer = [] quiet = [0]\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * `n == quiet.length`\n  * `1 <= n <= 500`\n  * `0 <= quiet[i] < n`\n  * All the values of `quiet` are **unique**.\n  * `0 <= richer.length <= n * (n - 1) / 2`\n  * `0 <= ai bi < n`\n  * `ai != bi`\n  * All the pairs of `richer` are **unique**.\n  * The observations in `richer` are all logically consistent.\n\n,class Solution:\n    def loudAndRich(self richer: List[List[int]] quiet: List[int]) -> List[int]:\n        length = len(quiet)\n        arr = [i for i in range(length)]\n        indegree = [0 for _ in range(length)]\n        graph = collections.defaultdict(list)\n        dq = collections.deque([])\n        \n        for a b in richer:\n            # Note that the graph is uni-directional\n            graph[a].append(b)\n            indegree[b] += 1\n\n        for i in range(length):\n            if not indegree[i]: \n                dq.append(i)\n    \n        while dq:\n            node = dq.popleft()\n            \n            for vertex in graph[node]:\n                indegree[vertex] -= 1\n                if quiet[arr[node]] < quiet[arr[vertex]]:\n                    arr[vertex] = arr[node]\n                if not indegree[vertex]:\n                    dq.append(vertex)\n        return arr\n
LRU Cache,"###  146\. LRU Cache\n\nDesign a data structure that follows the constraints of a **[Least Recently\nUsed (LRU)\ncache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU)**.\n\nImplement the `LRUCache` class:\n\n  * `LRUCache(int capacity)` Initialize the LRU cache with **positive** size `capacity`.\n  * `int get(int key)` Return the value of the `key` if the key exists otherwise return `-1`.\n  * `void put(int key int value)` Update the value of the `key` if the `key` exists. Otherwise add the `key-value` pair to the cache. If the number of keys exceeds the `capacity` from this operation **evict** the least recently used key.\n\nThe functions `get` and `put` must each run in `O(1)` average time complexity.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""LRUCache"" ""put"" ""put"" ""get"" ""put"" ""get"" ""put"" ""get"" ""get"" ""get""]\n    [[2] [1 1] [2 2] [1] [3 3] [2] [4 4] [1] [3] [4]]\n    **Output**\n    [null null null 1 null -1 null -1 3 4]\n    \n    **Explanation**\n    LRUCache lRUCache = new LRUCache(2);\n    lRUCache.put(1 1); // cache is {1=1}\n    lRUCache.put(2 2); // cache is {1=1 2=2}\n    lRUCache.get(1);    // return 1\n    lRUCache.put(3 3); // LRU key was 2 evicts key 2 cache is {1=1 3=3}\n    lRUCache.get(2);    // returns -1 (not found)\n    lRUCache.put(4 4); // LRU key was 1 evicts key 1 cache is {4=4 3=3}\n    lRUCache.get(1);    // return -1 (not found)\n    lRUCache.get(3);    // return 3\n    lRUCache.get(4);    // return 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= capacity <= 3000`\n  * `0 <= key <= 104`\n  * `0 <= value <= 105`\n  * At most `2 * 105` calls will be made to `get` and `put`.\n\n",class LRUCache {\n    int N;\n    list<int> pages;\n    unordered_map<int pair<int list<int>::iterator>> cache;\npublic:\n    LRUCache(int capacity) : N(capacity) {\n        \n    }\n    \n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            pages.erase(cache[key].second);\n            pages.push_front(key);\n            cache[key].second = pages.begin();\n            return cache[key].first;\n        }\n        \n        return -1;\n    }\n    \n    void put(int key int value) {\n        if (cache.find(key) != cache.end()) {\n            pages.erase(cache[key].second);\n        } else {\n            if (pages.size() == N) {\n                int lru = pages.back();\n                cache.erase(lru);\n                pages.pop_back();\n            }\n        }\n        \n        pages.push_front(key);\n        cache[key] = {value pages.begin()};\n    }\n};\n
Lucky Numbers in a Matrix,###  1380\. Lucky Numbers in a Matrix\n\nGiven an `m x n` matrix of **distinct** numbers return _all**lucky numbers**\nin the matrix in **any** order_.\n\nA **lucky number** is an element of the matrix such that it is the minimum\nelement in its row and maximum in its column.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** matrix = [[378][91113][151617]]\n    **Output:** [15]\n    **Explanation:** 15 is the only lucky number since it is the minimum in its row and the maximum in its column.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matrix = [[11042][9387][15161712]]\n    **Output:** [12]\n    **Explanation:** 12 is the only lucky number since it is the minimum in its row and the maximum in its column.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** matrix = [[78][12]]\n    **Output:** [7]\n    **Explanation:** 7 is the only lucky number since it is the minimum in its row and the maximum in its column.\n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat[i].length`\n  * `1 <= n m <= 50`\n  * `1 <= matrix[i][j] <= 105`.\n  * All elements in the matrix are distinct.\n\n,class Solution:\n    def luckyNumbers (self matrix: List[List[int]]) -> List[int]:\n        min_ max_ = 0 0\n        min_temp = []\n        max_temp = []\n        m = len(matrix)\n        n = len(matrix[0])\n        for i in matrix:\n            min_temp.append(min(i))\n        print(min_temp)\n        if n >= m:\n            for i in range(n):\n                max_check = []\n                for j in range(m):\n                    max_check.append(matrix[j][i])\n                max_temp.append(max(max_check))\n            return set(min_temp).intersection(set(max_temp))\n        elif n == 1:\n            for i in range(m):\n                max_check = []\n                for j in range(n):\n                    max_check.append(matrix[i][j])\n                max_temp.append(max(max_check))\n            return [max(max_temp)]\n        else:\n            for i in range(n):\n                max_check = []\n                for j in range(m):\n                    max_check.append(matrix[j][i])\n                max_temp.append(max(max_check))\n            return set(min_temp).intersection(set(max_temp))\n
Magic Squares In Grid,"###  840\. Magic Squares In Grid\n\nA `3 x 3` magic square is a `3 x 3` grid filled with distinct numbers\n**from**`1`**to**`9` such that each row column and both diagonals all have\nthe same sum.\n\nGiven a `row x col` `grid` of integers how many `3 x 3` ""magic square""\nsubgrids are there?  (Each subgrid is contiguous).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/11/magic_main.jpg)\n\n    \n    \n    **Input:** grid = [[4384][9519][2762]]\n    **Output:** 1\n    **Explanation:**\n    The following subgrid is a 3 x 3 magic square:\n    ![](https://assets.leetcode.com/uploads/2020/09/11/magic_valid.jpg)\n    while this one is not:\n    ![](https://assets.leetcode.com/uploads/2020/09/11/magic_invalid.jpg)\n    In total there is only one magic square inside the given grid.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[8]]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `row == grid.length`\n  * `col == grid[i].length`\n  * `1 <= row col <= 10`\n  * `0 <= grid[i][j] <= 15`\n\n",class Solution:\n\n    digits = {1 2 3 4 5 6 7 8 9}\n\n    @classmethod\n    def magic_3_3(cls square: List[List[int]]) -> bool:\n        if set(sum(square [])) != Solution.digits:\n            return False\n        sum_row0 = sum(square[0])\n        for r in range(1 3):\n            if sum(square[r]) != sum_row0:\n                return False\n        if any(sum(col) != sum_row0 for col in zip(*square)):\n            return False\n        sum_main_diagonal = sum_second_diagonal = 0\n        for i in range(3):\n            sum_main_diagonal += square[i][i]\n            sum_second_diagonal += square[i][2 - i]\n        return sum_main_diagonal == sum_second_diagonal == sum_row0\n\n    def numMagicSquaresInside(self grid: List[List[int]]) -> int:\n        count = 0\n        rows cols = len(grid) len(grid[0])\n        for r in range(rows - 2):\n            for c in range(cols - 2):\n                if Solution.magic_3_3([grid[row_idx][c: c + 3]\n                                       for row_idx in range(r r + 3)]):\n                    count += 1\n        return count\n
Magical String,"###  481\. Magical String\n\nA magical string `s` consists of only `'1'` and `'2'` and obeys the following\nrules:\n\n  * The string s is magical because concatenating the number of contiguous occurrences of characters `'1'` and `'2'` generates the string `s` itself.\n\nThe first few elements of `s` is `s = ""1221121221221121122……""`. If we\ngroup the consecutive `1`'s and `2`'s in `s` it will be `""1 22 11 2 1 22 1 22\n11 2 11 22 ......""` and the occurrences of `1`'s or `2`'s in each group are\n`""1 2 2 1 1 2 1 2 2 1 2 2 ......""`. You can see that the occurrence sequence\nis `s` itself.\n\nGiven an integer `n` return the number of `1`'s in the first `n` number in\nthe magical string `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 6\n    **Output:** 3\n    **Explanation:** The first 6 elements of magical string s is ""122112"" and it contains three 1's so return 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n\n",# Runtime: 489 ms (Top 6.14%) | Memory: 14.1 MB (Top 72.07%)\nclass Solution:\n    def magicalString(self n: int) -> int:\n        queue ans i = deque([2]) 1 1\n\n        while i <= n - 2:\n            m = queue.popleft()\n            ans += (m == 1)\n            queue.extend([1 + (i % 2 == 0)] * m)\n            i += 1\n\n        return ans
Magnetic Force Between Two Balls,###  1552\. Magnetic Force Between Two Balls\n\nIn the universe Earth C-137 Rick discovered a special form of magnetic force\nbetween two balls if they are put in his new invented basket. Rick has `n`\nempty baskets the `ith` basket is at `position[i]` Morty has `m` balls and\nneeds to distribute the balls into the baskets such that the **minimum\nmagnetic force** between any two balls is **maximum**.\n\nRick stated that magnetic force between two different balls at positions `x`\nand `y` is `|x - y|`.\n\nGiven the integer array `position` and the integer `m`. Return _the required\nforce_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/11/q3v1.jpg)\n\n    \n    \n    **Input:** position = [12347] m = 3\n    **Output:** 3\n    **Explanation:** Distributing the 3 balls into baskets 1 4 and 7 will make the magnetic force between ball pairs [3 3 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** position = [543211000000000] m = 2\n    **Output:** 999999999\n    **Explanation:** We can use baskets 1 and 1000000000.\n    \n\n\n\n**Constraints:**\n\n  * `n == position.length`\n  * `2 <= n <= 105`\n  * `1 <= position[i] <= 109`\n  * All integers in `position` are **distinct**.\n  * `2 <= m <= position.length`\n\n,class Solution:\n  def possible (selfdistancepositionsM):\n    ball = 1 \n    lastPos = positions[0]  \n    for pos in positions:\n      if pos-lastPos >= distance:\n        ball+=1 \n        if ball == M: return True \n        lastPos=pos \n     \n    return False \n        \n      \n    \n  def maxDistance(self positionsM):\n    positions.sort()\n    low = 0 \n    high = positions [-1] \n    ans = 0\n    while low<=high:\n      distance = low+(high-low)//2 \n      \n      if self.possible(distancepositionsM):\n        ans = distance\n        low=distance+1 \n      else:\n        high=distance-1 \n    return ans \n
Majority Element,###  169\. Majority Element\n\nGiven an array `nums` of size `n` return _the majority element_.\n\nThe majority element is the element that appears more than `⌊n / 2⌋`\ntimes. You may assume that the majority element always exists in the array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [323]\n    **Output:** 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2211122]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 5 * 104`\n  * `-109 <= nums[i] <= 109`\n\n\n\n**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?\n\n,class Solution(object):\n    def majorityElement(self nums):\n        sol = None\n        cnt = 0\n        for i in nums:\n            if cnt == 0:\n                sol = i\n            cnt += (1 if i == sol else -1)\n        return sol\n
Majority Element II,###  229\. Majority Element II\n\nGiven an integer array of size `n` find all elements that appear more than\n`⌊ n/3 ⌋` times.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [323]\n    **Output:** [3]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1]\n    **Output:** [1]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [12]\n    **Output:** [12]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5 * 104`\n  * `-109 <= nums[i] <= 109`\n\n\n\n**Follow up:** Could you solve the problem in linear time and in `O(1)` space?\n\n,class Solution:\n    def majorityElement(self nums: List[int]) -> List[int]:\n        \n        #Boyer Moore Voting Algo (As used in ME1 ques) \n        #now we can observe that there cannot be more than two elements occuring more than n//3 times in an array\n        #so find two majority elements(me=majority element)\n        \n\n        n=len(nums)\n        req=n//3  #for an element to be ME required number of times present \n\n        c1=0 #count 1\n        c2=0 #count 2\n        me1=None #majority element 1\n        me2=None #majority element 2\n\n        for i in nums:\n            if i == me1:\n                c1+=1\n\n            elif i == me2:\n                c2+=1\n\n            elif c1 == 0:\n                me1=i\n                c1=1\n\n            elif c2 == 0:\n                me2=i\n                c2=1\n\n            else:\n                c1-=1\n                c2-=1\n        #here we have found our majority elements now check if the found majority element is ME\n        # print(me1me2)\n\n        #check if the found majority element is ME\n        c1=0\n        c2=0\n        for i in nums:\n            if i==me1:\n                c1+=1\n            if i==me2:\n                c2+=1\n        # print(c1c2)\n\n        if c1 > req  and c2 > req:\n\n            return [me1me2]\n\n        elif c1> req :\n            return [me1]\n\n        elif c2> req :\n            return [me2]\n\n
Make Array Strictly Increasing,###  1187\. Make Array Strictly Increasing\n\nGiven two integer arrays `arr1` and `arr2` return the minimum number of\noperations (possibly zero) needed to make `arr1` strictly increasing.\n\nIn one operation you can choose two indices `0 <= i < arr1.length` and `0 <=\nj < arr2.length` and do the assignment `arr1[i] = arr2[j]`.\n\nIf there is no way to make `arr1` strictly increasing return `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr1 = [15367] arr2 = [1324]\n    **Output:** 1\n    **Explanation:** Replace 5 with 2 then arr1 = [1 2 3 6 7].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr1 = [15367] arr2 = [431]\n    **Output:** 2\n    **Explanation:** Replace 5 with 3 and then replace 3 with 4. arr1 = [1 3 4 6 7].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr1 = [15367] arr2 = [1633]\n    **Output:** -1\n    **Explanation:** You can't make arr1 strictly increasing.\n\n\n\n**Constraints:**\n\n  * `1 <= arr1.length arr2.length <= 2000`\n  * `0 <= arr1[i] arr2[i] <= 10^9`\n\n\n\n,class Solution:\n    def makeArrayIncreasing(self arr1: List[int] arr2: List[int]) -> int:\n        n1  n2 dp = len(arr1)  len(arr2)  {}\n        arr2.sort()\n        \n        def solve(i  j  prev):\n            \n            if i == n1:return 0\n            \n            if (ijprev) in dp: return dp[(ijprev)]\n            \n            k = bisect.bisect_right(arr2[j:]prev) + j\n        \n            ans = float('inf') if k == n2 else solve(i+1k+1arr2[k]) + 1\n            \n            if arr1[i] > prev:ans = min(anssolve(i+1  j arr1[i]))\n            \n            dp[(ijprev)] = ans\n            \n            return ans\n        \n        \n        ans = solve(00-float('inf'))\n        \n        return ans if ans != float('inf') else -1
Make Array Zero by Subtracting Equal Amounts,###  2357\. Make Array Zero by Subtracting Equal Amounts\n\nYou are given a non-negative integer array `nums`. In one operation you must:\n\n  * Choose a positive integer `x` such that `x` is less than or equal to the **smallest non-zero** element in `nums`.\n  * Subtract `x` from every **positive** element in `nums`.\n\nReturn _the**minimum** number of operations to make every element in _`nums`\n_equal to_`0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [15035]\n    **Output:** 3\n    **Explanation:**\n    In the first operation choose x = 1. Now nums = [04024].\n    In the second operation choose x = 2. Now nums = [02002].\n    In the third operation choose x = 2. Now nums = [00000].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0]\n    **Output:** 0\n    **Explanation:** Each element in nums is already 0 so no operations are needed.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `0 <= nums[i] <= 100`\n\n,class Solution:\n    def minimumOperations(self nums: List[int]) -> int:\n        return len(set(nums) - {0})\n
Make The String Great,"###  1544\. Make The String Great\n\nGiven a string `s` of lower and upper case English letters.\n\nA good string is a string which doesn't have **two adjacent characters**\n`s[i]` and `s[i + 1]` where:\n\n  * `0 <= i <= s.length - 2`\n  * `s[i]` is a lower-case letter and `s[i + 1]` is the same letter but in upper-case or **vice-versa**.\n\nTo make the string good you can choose **two adjacent** characters that make\nthe string bad and remove them. You can keep doing this until the string\nbecomes good.\n\nReturn _the string_ after making it good. The answer is guaranteed to be\nunique under the given constraints.\n\n**Notice** that an empty string is also good.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""leEeetcode""\n    **Output:** ""leetcode""\n    **Explanation:** In the first step either you choose i = 1 or i = 2 both will result ""leEeetcode"" to be reduced to ""leetcode"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abBAcC""\n    **Output:** """"\n    **Explanation:** We have many possible scenarios and all lead to the same answer. For example:\n    ""abBAcC"" --> ""aAcC"" --> ""cC"" --> """"\n    ""abBAcC"" --> ""abBA"" --> ""aA"" --> """"\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""s""\n    **Output:** ""s""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s` contains only lower and upper case English letters.\n\n",# Runtime: 76 ms (Top 13.82%) | Memory: 13.8 MB (Top 62.06%)\nclass Solution:\n    def makeGood(self s: str) -> str:\n        while True:\n            for i in range(len(s)-1):\n                if s[i].lower() == s[i+1].lower() and (s[i].islower() and s[i+1].isupper() or s[i].isupper() and s[i+1].islower()):\n                    s = s[:i]+s[i+2:]\n                    break\n            else:\n                break\n        return s
Making File Names Unique,"###  1487\. Making File Names Unique\n\nGiven an array of strings `names` of size `n`. You will create `n` folders in\nyour file system **such that**  at the `ith` minute you will create a folder\nwith the name `names[i]`.\n\nSince two files **cannot** have the same name if you enter a folder name that\nwas previously used the system will have a suffix addition to its name in the\nform of `(k)` where `k` is the **smallest positive integer** such that the\nobtained name remains unique.\n\nReturn _an array of strings of length_`n` where `ans[i]` is the actual name\nthe system will assign to the `ith` folder when you create it.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** names = [""pes""""fifa""""gta""""pes(2019)""]\n    **Output:** [""pes""""fifa""""gta""""pes(2019)""]\n    **Explanation:** Let's see how the file system creates folder names:\n    ""pes"" --> not assigned before remains ""pes""\n    ""fifa"" --> not assigned before remains ""fifa""\n    ""gta"" --> not assigned before remains ""gta""\n    ""pes(2019)"" --> not assigned before remains ""pes(2019)""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** names = [""gta""""gta(1)""""gta""""avalon""]\n    **Output:** [""gta""""gta(1)""""gta(2)""""avalon""]\n    **Explanation:** Let's see how the file system creates folder names:\n    ""gta"" --> not assigned before remains ""gta""\n    ""gta(1)"" --> not assigned before remains ""gta(1)""\n    ""gta"" --> the name is reserved system adds (k) since ""gta(1)"" is also reserved systems put k = 2. it becomes ""gta(2)""\n    ""avalon"" --> not assigned before remains ""avalon""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** names = [""onepiece""""onepiece(1)""""onepiece(2)""""onepiece(3)""""onepiece""]\n    **Output:** [""onepiece""""onepiece(1)""""onepiece(2)""""onepiece(3)""""onepiece(4)""]\n    **Explanation:** When the last folder is created the smallest positive valid k is 4 and it becomes ""onepiece(4)"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= names.length <= 5 * 104`\n  * `1 <= names[i].length <= 20`\n  * `names[i]` consists of lowercase English letters digits and/or round brackets.\n\n",# Runtime: 1004 ms (Top 5.08%) | Memory: 28.1 MB (Top 35.29%)\nclass Solution:\n    def getFolderNames(self names: List[str]) -> List[str]:\n        # Hashmap will store the name as key and the number of times that name has duplicated so fas as value.\n        hashmap = {}\n\n        for name in names:\n            modified = name\n            # Check whether the name has already been used\n            if name in hashmap:\n                # Get the number of times the {name} has been used\n                k = hashmap[name]\n                # Calculate the next available suffix.\n                while modified in hashmap:\n                    k += 1\n                    modified = f'{name}({k})'\n                # Update the number of times the original {name} is used. This will help to efficiently check for next available suffix if the {name} again comes in future.\n                hashmap[name] = k\n            # Store the modified {name} with 0 as it is not duplicated yet.\n            hashmap[modified] = 0\n\n        # Return the keys of hashmap as that would be the unique file names.\n        return hashmap.keys()
Map of Highest Peak,###  1765\. Map of Highest Peak\n\nYou are given an integer matrix `isWater` of size `m x n` that represents a\nmap of **land** and **water** cells.\n\n  * If `isWater[i][j] == 0` cell `(i j)` is a **land** cell.\n  * If `isWater[i][j] == 1` cell `(i j)` is a **water** cell.\n\nYou must assign each cell a height in a way that follows these rules:\n\n  * The height of each cell must be non-negative.\n  * If the cell is a **water** cell its height must be `0`.\n  * Any two adjacent cells must have an absolute height difference of **at most** `1`. A cell is adjacent to another cell if the former is directly north east south or west of the latter (i.e. their sides are touching).\n\nFind an assignment of heights such that the maximum height in the matrix is\n**maximized**.\n\nReturn _an integer matrix_`height` _of size_`m x n` _where_`height[i][j]`_is\ncell_`(i j)`_'s height. If there are multiple solutions return**any** of\nthem_.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png)**\n\n    \n    \n    **Input:** isWater = [[01][00]]\n    **Output:** [[10][21]]\n    **Explanation:** The image shows the assigned heights of each cell.\n    The blue cell is the water cell and the green cells are the land cells.\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82050-am.png)**\n\n    \n    \n    **Input:** isWater = [[001][100][000]]\n    **Output:** [[110][011][122]]\n    **Explanation:** A height of 2 is the maximum possible height of any assignment.\n    Any height assignment that has a maximum height of 2 while still meeting the rules will also be accepted.\n    \n\n\n\n**Constraints:**\n\n  * `m == isWater.length`\n  * `n == isWater[i].length`\n  * `1 <= m n <= 1000`\n  * `isWater[i][j]` is `0` or `1`.\n  * There is at least **one** water cell.\n\n,class Solution:\n    def highestPeak(self isWater: List[List[int]]) -> List[List[int]]:\n        arr = collections.deque()\n        m n = len(isWater) len(isWater[0])\n        for i in range(m):\n            for j in range(n):\n                if isWater[i][j] == 1:\n                    arr.append((0 i j))\n                    \n        ans = [[-1] * n for _ in range(m)]\n        while arr:\n            val x y = arr.popleft() \n            if ans[x][y] != -1: continue\n            ans[x][y] = val\n            for dx dy in [(-1 0) (1 0) (0 -1) (0 1)]:\n                xx yy = x+dx y+dy\n                if 0 <= xx < m and 0 <= yy < n and ans[xx][yy] == -1:\n                    arr.append((val+1 xx yy))\n        return ans\n
Map Sum Pairs,"###  677\. Map Sum Pairs\n\nDesign a map that allows you to do the following:\n\n  * Maps a string key to a given value.\n  * Returns the sum of the values that have a key with a prefix equal to a given string.\n\nImplement the `MapSum` class:\n\n  * `MapSum()` Initializes the `MapSum` object.\n  * `void insert(String key int val)` Inserts the `key-val` pair into the map. If the `key` already existed the original `key-value` pair will be overridden to the new one.\n  * `int sum(string prefix)` Returns the sum of all the pairs' value whose `key` starts with the `prefix`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MapSum"" ""insert"" ""sum"" ""insert"" ""sum""]\n    [[] [""apple"" 3] [""ap""] [""app"" 2] [""ap""]]\n    **Output**\n    [null null 3 null 5]\n    \n    **Explanation**\n    MapSum mapSum = new MapSum();\n    mapSum.insert(""apple"" 3);  \n    mapSum.sum(""ap"");           // return 3 (_ap_ ple = 3)\n    mapSum.insert(""app"" 2);    \n    mapSum.sum(""ap"");           // return 5 (_ap_ ple + _ap_ p = 3 + 2 = 5)\n    \n\n\n\n**Constraints:**\n\n  * `1 <= key.length prefix.length <= 50`\n  * `key` and `prefix` consist of only lowercase English letters.\n  * `1 <= val <= 1000`\n  * At most `50` calls will be made to `insert` and `sum`.\n\n",// Runtime: 29 ms (Top 97.14%) | Memory: 17.50 MB (Top 9.54%)\n\nclass MapSum:\n\n    def __init__(self):\n        self.trie = {}\n\n    def insert(self key: str val: int) -> None:\n        node = self.trie\n        for ch in key:\n            node = node.setdefault(ch {})\n        node['val'] = val\n        return\n\n    def sum(self prefix: str) -> int:\n        def traverse(node):\n            nonlocal res\n            if not node:\n                return\n            if 'val' in node:\n                res += node['val']\n            for child in node:\n                if child == 'val': continue\n                traverse(node[child])\n            return\n            \n        node = self.trie\n        for ch in prefix:\n            node = node.get(ch {})\n            if not node:\n                return 0\n        res = 0\n        traverse(node)\n        return res\n
Masking Personal Information,"###  831\. Masking Personal Information\n\nYou are given a personal information string `s` representing either an\n**email address** or a **phone number**. Return _the**masked** personal\ninformation using the below rules_.\n\n_**Email address:**_\n\nAn email address is:\n\n  * A **name** consisting of uppercase and lowercase English letters followed by\n  * The `'@'` symbol followed by\n  * The **domain** consisting of uppercase and lowercase English letters with a dot `'.'` somewhere in the middle (not the first or last character).\n\nTo mask an email:\n\n  * The uppercase letters in the **name** and **domain** must be converted to lowercase letters.\n  * The middle letters of the **name** (i.e. all but the first and last letters) must be replaced by 5 asterisks `""*****""`.\n\n_**Phone number:**_\n\nA phone number is formatted as follows:\n\n  * The phone number contains 10-13 digits.\n  * The last 10 digits make up the **local number**.\n  * The remaining 0-3 digits in the beginning make up the **country code**.\n  * **Separation characters** from the set `{'+' '-' '(' ')' ' '}` separate the above digits in some way.\n\nTo mask a phone number:\n\n  * Remove all **separation characters**.\n  * The masked phone number should have the form: \n    * `""***-***-XXXX""` if the country code has 0 digits.\n    * `""+*-***-***-XXXX""` if the country code has 1 digit.\n    * `""+**-***-***-XXXX""` if the country code has 2 digits.\n    * `""+***-***-***-XXXX""` if the country code has 3 digits.\n  * `""XXXX""` is the last 4 digits of the **local number**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""LeetCode@LeetCode.com""\n    **Output:** ""l*****e@leetcode.com""\n    **Explanation:** s is an email address.\n    The name and domain are converted to lowercase and the middle of the name is replaced by 5 asterisks.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""AB@qq.com""\n    **Output:** ""a*****b@qq.com""\n    **Explanation:** s is an email address.\n    The name and domain are converted to lowercase and the middle of the name is replaced by 5 asterisks.\n    Note that even though ""ab"" is 2 characters it still must have 5 asterisks in the middle.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""1(234)567-890""\n    **Output:** ""***-***-7890""\n    **Explanation:** s is a phone number.\n    There are 10 digits so the local number is 10 digits and the country code is 0 digits.\n    Thus the resulting masked number is ""***-***-7890"".\n    \n\n\n\n**Constraints:**\n\n  * `s` is either a **valid** email or a phone number.\n  * If `s` is an email: \n    * `8 <= s.length <= 40`\n    * `s` consists of uppercase and lowercase English letters and exactly one `'@'` symbol and `'.'` symbol.\n  * If `s` is a phone number: \n    * `10 <= s.length <= 20`\n    * `s` consists of digits spaces and the symbols `'('` `')'` `'-'` and `'+'`.\n\n","class Solution:\n    def maskPII(self s: str) -> str:\n        res=''\n        if '@' in s:\n            \n            l=s.split('@')\n            \n            a=l[0]\n            b=l[1]\n            \n            c=b.split('.')\n            \n            \n            res=a[0].lower()+'*'*5+a[-1].lower()+'@'+c[0].lower()+'.'+c[1].lower()\n            return res\n        else:\n            l=0\n            res=''\n            flag=False\n            f=False\n            c=0\n            for i in range(len(s)-1-1-1):\n                if s[i]==""("" or s[i]==')' or s[i]=='-' or s[i]=='+' or s[i]==' ':\n                    continue\n                  \n                if f==True:\n                    c+=1\n                    continue\n                \n                if flag==False:\n                    res=s[i]+res\n                else:\n                    res='*'+res\n                    \n                \n                \n                if l==3 or l==6:\n                    if l==3:\n                        flag=True\n                    res='-'+res\n                l+=1\n                \n                if len(res)==12:\n                    f=True\n            if c==1:\n                res='+*-'+res\n            elif c==2:\n                res=""+**-""+res\n            elif c==3:\n                res=""+***-""+res\n                    \n           \n            return res\n            \n                    \n                    \n                    \n                    \n        \n"
Match Substring After Replacement,"###  2301\. Match Substring After Replacement\n\nYou are given two strings `s` and `sub`. You are also given a 2D character\narray `mappings` where `mappings[i] = [oldi newi]` indicates that you may\nperform the following operation **any** number of times:\n\n  * **Replace** a character `oldi` of `sub` with `newi`.\n\nEach character in `sub` **cannot** be replaced more than once.\n\nReturn `true` _if it is possible to make_`sub` _a substring of_`s` _by\nreplacing zero or more characters according to_`mappings`. Otherwise return\n`false`.\n\nA **substring** is a contiguous non-empty sequence of characters within a\nstring.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""fool3e7bar"" sub = ""leet"" mappings = [[""e""""3""][""t""""7""][""t""""8""]]\n    **Output:** true\n    **Explanation:** Replace the first 'e' in sub with '3' and 't' in sub with '7'.\n    Now sub = ""l3e7"" is a substring of s so we return true.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""fooleetbar"" sub = ""f00l"" mappings = [[""o""""0""]]\n    **Output:** false\n    **Explanation:** The string ""f00l"" is not a substring of s and no replacements can be made.\n    Note that we cannot replace '0' with 'o'.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""Fool33tbaR"" sub = ""leetd"" mappings = [[""e""""3""][""t""""7""][""t""""8""][""d""""b""][""p""""b""]]\n    **Output:** true\n    **Explanation:** Replace the first and second 'e' in sub with '3' and 'd' in sub with 'b'.\n    Now sub = ""l33tb"" is a substring of s so we return true.\n    \n    \n\n\n\n**Constraints:**\n\n  * `1 <= sub.length <= s.length <= 5000`\n  * `0 <= mappings.length <= 1000`\n  * `mappings[i].length == 2`\n  * `oldi != newi`\n  * `s` and `sub` consist of uppercase and lowercase English letters and digits.\n  * `oldi` and `newi` are either uppercase or lowercase English letters or digits.\n\n","from collections import defaultdict\nimport re\n\nclass Solution:\n    def matchReplacement(self s: str sub: str mappings: List[List[str]]) -> bool:\n        reachable = defaultdict(set)\n        for a b in mappings:\n            reachable[a].add(b)\n        for c in sub:\n            reachable[c].add(c)\n        regex = """"\n        for c in sub:\n            if len(reachable[c]) > 1:\n                regex += ""(""\n                regex += ""|"".join(reachable[c])\n                regex += "")""\n            else:\n                regex += c\n        return re.compile(regex).search(s)\n"
Matchsticks to Square,###  473\. Matchsticks to Square\n\nYou are given an integer array `matchsticks` where `matchsticks[i]` is the\nlength of the `ith` matchstick. You want to use **all the matchsticks** to\nmake one square. You **should not break** any stick but you can link them up\nand each matchstick must be used **exactly one time**.\n\nReturn `true` if you can make this square and `false` otherwise.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/09/matchsticks1-grid.jpg)\n\n    \n    \n    **Input:** matchsticks = [11222]\n    **Output:** true\n    **Explanation:** You can form a square with length 2 one side of the square came two sticks with length 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matchsticks = [33334]\n    **Output:** false\n    **Explanation:** You cannot find a way to form a square with all the matchsticks.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= matchsticks.length <= 15`\n  * `1 <= matchsticks[i] <= 108`\n\n,class Solution:\n    def makesquare(self matchsticks: List[int]) -> bool:\n        targetm=divmod(sum(matchsticks)4)\n        if m:return False\n        targetLst=[0]*4\n        length=len(matchsticks)\n        matchsticks.sort(reverse=True)\n        def bt(i):\n            if i==length:\n                return len(set(targetLst))==1\n            for j in range(4):\n                if matchsticks[i]+targetLst[j]>target:\n                    continue\n                targetLst[j]+=matchsticks[i]\n                if bt(i+1):\n                    return True\n                targetLst[j]-=matchsticks[i]\n                if not targetLst[j]:break\n            return False\n        return matchsticks[0]<=target and bt(0)\n
Matrix Block Sum,###  1314\. Matrix Block Sum\n\nGiven a `m x n` matrix `mat` and an integer `k` return _a matrix_ `answer`\n_where each_ `answer[i][j]` _is the sum of all elements_ `mat[r][c]` _for_ :\n\n  * `i - k <= r <= i + k`\n  * `j - k <= c <= j + k` and\n  * `(r c)` is a valid position in the matrix.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** mat = [[123][456][789]] k = 1\n    **Output:** [[122116][274533][243928]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mat = [[123][456][789]] k = 2\n    **Output:** [[454545][454545][454545]]\n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat[i].length`\n  * `1 <= m n k <= 100`\n  * `1 <= mat[i][j] <= 100`\n\n,# Runtime: 308 ms (Top 20.31%) | Memory: 15.2 MB (Top 51.05%)\nclass Solution:\n    def matrixBlockSum(self matrix: List[List[int]] k: int) -> List[List[int]]:\n        ROWS COLS = len(matrix) len(matrix[0])\n\n        prefix_sums = [[0] * (COLS + 1) for _ in range(ROWS + 1)]\n\n        for r in range(1 ROWS + 1):\n            for c in range(1 COLS + 1):\n                prefix_sums[r][c] = prefix_sums[r - 1][c] + prefix_sums[r][c - 1] + \\n                    matrix[r - 1][c - 1] - prefix_sums[r - 1][c - 1]\n\n        res = [[0] * COLS for _ in range(ROWS)]\n        for r in range(ROWS):\n            for c in range(COLS):\n                res[r][c] = prefix_sums[min(r + k + 1 ROWS)][min(c + k + 1 COLS)] - \\n                    prefix_sums[max(r - k 0)][min(c + k + 1 COLS)] - \\n                    prefix_sums[min(r + k + 1 ROWS)][max(c - k 0)] + \\n                    prefix_sums[max(r - k 0)][max(c - k 0)]\n\n        return res
Matrix Cells in Distance Order,###  1030\. Matrix Cells in Distance Order\n\nYou are given four integers `row` `cols` `rCenter` and `cCenter`. There is\na `rows x cols` matrix and you are on the cell with the coordinates `(rCenter\ncCenter)`.\n\nReturn _the coordinates of all cells in the matrix sorted by\ntheir**distance** from _`(rCenter cCenter)`_from the smallest distance to the\nlargest distance_. You may return the answer in **any order** that satisfies\nthis condition.\n\nThe **distance** between two cells `(r1 c1)` and `(r2 c2)` is `|r1 - r2| +\n|c1 - c2|`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rows = 1 cols = 2 rCenter = 0 cCenter = 0\n    **Output:** [[00][01]]\n    **Explanation:** The distances from (0 0) to other cells are: [01]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rows = 2 cols = 2 rCenter = 0 cCenter = 1\n    **Output:** [[01][00][11][10]]\n    **Explanation:** The distances from (0 1) to other cells are: [0112]\n    The answer [[01][11][00][10]] would also be accepted as correct.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** rows = 2 cols = 3 rCenter = 1 cCenter = 2\n    **Output:** [[12][02][11][01][10][00]]\n    **Explanation:** The distances from (1 2) to other cells are: [011223]\n    There are other answers that would also be accepted as correct such as [[12][11][02][10][01][00]].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rows cols <= 100`\n  * `0 <= rCenter < rows`\n  * `0 <= cCenter < cols`\n\n,class Solution:\n    def allCellsDistOrder(self rows: int cols: int rCenter: int cCenter: int) -> List[List[int]]:\n        # create a r c matrix given the rows & cols\n        # each element represents a list [r c] where r is the row & c the col\n        # find find the distances of all cells from the center (append to res)\n        # sort the result by distance function\n        # Time O(M + N) Space O(M + N)\n        \n        \n        def distance(p1 p2):\n            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n        \n        matrix = [[i j] for i in range(rows) for j in range(cols)]\n        center = [rCenter cCenter]\n        matrix.sort(key=lambda c: distance(c center))\n        \n        return matrix\n
Matrix Diagonal Sum,###  1572\. Matrix Diagonal Sum\n\nGiven a square matrix `mat` return the sum of the matrix diagonals.\n\nOnly include the sum of all the elements on the primary diagonal and all the\nelements on the secondary diagonal that are not part of the primary diagonal.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png)\n\n    \n    \n    **Input:** mat = [[**1** 2**3**]\n                  [4**5** 6]\n                  [**7** 8**9**]]\n    **Output:** 25\n    **Explanation:** Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25\n    Notice that element mat[1][1] = 5 is counted only once.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mat = [[**1** 11**1**]\n                  [1**1** **1** 1]\n                  [1**1** **1** 1]\n                  [**1** 11**1**]]\n    **Output:** 8\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** mat = [[**5**]]\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * `n == mat.length == mat[i].length`\n  * `1 <= n <= 100`\n  * `1 <= mat[i][j] <= 100`\n\n,// Runtime: 98 ms (Top 89.16%) | Memory: 17.60 MB (Top 5.05%)\n\nclass Solution:\n    def diagonalSum(self mat: List[List[int]]) -> int:\n        \n        n = len(mat)\n        \n        mid = n // 2\n        \n        summation = 0\n        \n        for i in range(n):\n            \n            # primary diagonal\n            summation += mat[i][i]\n            \n            # secondary diagonal\n            summation += mat[n-1-i][i]\n            \n            \n        if n % 2 == 1:\n            # remove center element (repeated) on odd side-length case\n            summation -= mat[mid][mid]\n            \n            \n        return summation\n
Max Area of Island,###  695\. Max Area of Island\n\nYou are given an `m x n` binary matrix `grid`. An island is a group of `1`'s\n(representing land) connected **4-directionally** (horizontal or vertical.)\nYou may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is the number of cells with a value `1` in the\nisland.\n\nReturn _the maximum**area** of an island in _`grid`. If there is no island\nreturn `0`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)\n\n    \n    \n    **Input:** grid = [[0010000100000][0000000111000][0110100000000][0100110010100][0100110011100][0000000000100][0000000111000][0000000110000]]\n    **Output:** 6\n    **Explanation:** The answer is not 11 because the island must be connected 4-directionally.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[00000000]]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 50`\n  * `grid[i][j]` is either `0` or `1`.\n\n,"// Runtime: 101 ms (Top 94.71%) | Memory: 17.70 MB (Top 80.2%)\n\nclass Solution:\n    def maxAreaOfIsland(self grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        maxArea = 0\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1: # run dfs only when we find a land\n                    maxArea = max(maxArea self.dfs(grid i j))\n                    \n        return maxArea\n    \n                    \n    def dfs(self grid i j):\n		# conditions for out of bound and when we encounter water\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:\n            return 0\n        \n        maxArea = 1\n        grid[i][j] = '#'  # this will act as visited set\n        maxArea += self.dfs(grid i+1 j)\n        maxArea += self.dfs(grid i-1 j)\n        maxArea += self.dfs(grid i j+1)\n        maxArea += self.dfs(grid i j-1)\n        \n        return maxArea\n"
Max Chunks To Make Sorted,###  769\. Max Chunks To Make Sorted\n\nYou are given an integer array `arr` of length `n` that represents a\npermutation of the integers in the range `[0 n - 1]`.\n\nWe split `arr` into some number of **chunks** (i.e. partitions) and\nindividually sort each chunk. After concatenating them the result should\nequal the sorted array.\n\nReturn _the largest number of chunks we can make to sort the array_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [43210]\n    **Output:** 1\n    **Explanation:**\n    Splitting into two or more chunks will not return the required result.\n    For example splitting into [4 3] [2 1 0] will result in [3 4 0 1 2] which isn't sorted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [10234]\n    **Output:** 4\n    **Explanation:**\n    We can split into two chunks such as [1 0] [2 3 4].\n    However splitting into [1 0] [2] [3] [4] is the highest number of chunks possible.\n    \n\n\n\n**Constraints:**\n\n  * `n == arr.length`\n  * `1 <= n <= 10`\n  * `0 <= arr[i] < n`\n  * All the elements of `arr` are **unique**.\n\n,class Solution(object):\n    def maxChunksToSorted(self arr):\n        n= len(arr)\n\n        count=0\n        currentmax= -2**63\n        for i in range(0n):\n            currentmax=max(currentmax arr[i])\n            if (currentmax==i):\n                count+=1\n        return count\n        \n        \n    \n
Max Chunks To Make Sorted II,###  768\. Max Chunks To Make Sorted II\n\nYou are given an integer array `arr`.\n\nWe split `arr` into some number of **chunks** (i.e. partitions) and\nindividually sort each chunk. After concatenating them the result should\nequal the sorted array.\n\nReturn _the largest number of chunks we can make to sort the array_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [54321]\n    **Output:** 1\n    **Explanation:**\n    Splitting into two or more chunks will not return the required result.\n    For example splitting into [5 4] [3 2 1] will result in [4 5 1 2 3] which isn't sorted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [21344]\n    **Output:** 4\n    **Explanation:**\n    We can split into two chunks such as [2 1] [3 4 4].\n    However splitting into [2 1] [3] [4] [4] is the highest number of chunks possible.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 2000`\n  * `0 <= arr[i] <= 108`\n\n,# Runtime: 187 ms (Top 16.67%) | Memory: 14.5 MB (Top 12.03%)\nclass Solution:\n    def maxChunksToSorted(self arr: List[int]) -> int:\n        sortedArr = sorted(arr)\n\n        posMap = defaultdict(list)\n        for i in range(len(sortedArr)):\n            posMap[sortedArr[i]].append(i) # keep track the right sortedArr[i] position\n\n        idx = len(arr) - 1\n        cnt = 0\n        for i in range(len(arr) - 1 -1 -1):\n            idx = min(idx posMap[arr[i]][-1]) # the smallest position need to move arr[i] to correct position\n            posMap[arr[i]].pop()\n            if i == idx:\n                cnt += 1\n                idx -= 1\n        return cnt
Max Consecutive Ones,###  485\. Max Consecutive Ones\n\nGiven a binary array `nums` return _the maximum number of consecutive_`1` _'s\nin the array_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [110111]\n    **Output:** 3\n    **Explanation:** The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [101101]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `nums[i]` is either `0` or `1`.\n\n,// Runtime: 297 ms (Top 70.36%) | Memory: 16.60 MB (Top 19.05%)\n\nclass Solution:\n    def findMaxConsecutiveOnes(self nums: List[int]) -> int:\n        \n        count = maxCount = 0\n        \n        for i in range(len(nums)):\n            if nums[i] == 1:\n                count += 1\n            else:\n                maxCount = max(count maxCount)\n                count = 0\n                \n        return max(count maxCount)\n
Max Consecutive Ones III,###  1004\. Max Consecutive Ones III\n\nGiven a binary array `nums` and an integer `k` return _the maximum number of\nconsecutive_`1` _'s in the array if you can flip at most_ `k` `0`'s.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [11100011110] k = 2\n    **Output:** 6\n    **Explanation:** [11100_**1** 1111**1**_]\n    Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0011001110110001111] k = 3\n    **Output:** 10\n    **Explanation:** [00_11**1** **1** 111**1** 11_0001111]\n    Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `nums[i]` is either `0` or `1`.\n  * `0 <= k <= nums.length`\n\n,// Runtime: 398 ms (Top 99.0%) | Memory: 17.90 MB (Top 17.54%)\n\nclass Solution:\n    def longestOnes(self nums: List[int] k: int) -> int:\n        l=r=0    \n        for r in range(len(nums)):\n            if nums[r] == 0:\n                k-=1\n            if k<0:\n                if nums[l] == 0:\n                    k+=1\n                l+=1\n        return r-l+1\n
Max Difference You Can Get From Changing an Integer,###  1432\. Max Difference You Can Get From Changing an Integer\n\nYou are given an integer `num`. You will apply the following steps exactly\n**two** times:\n\n  * Pick a digit `x (0 <= x <= 9)`.\n  * Pick another digit `y (0 <= y <= 9)`. The digit `y` can be equal to `x`.\n  * Replace all the occurrences of `x` in the decimal representation of `num` by `y`.\n  * The new integer **cannot** have any leading zeros also the new integer **cannot** be 0.\n\nLet `a` and `b` be the results of applying the operations to `num` the first\nand second times respectively.\n\nReturn _the max difference_ between `a` and `b`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 555\n    **Output:** 888\n    **Explanation:** The first time pick x = 5 and y = 9 and store the new integer in a.\n    The second time pick x = 5 and y = 1 and store the new integer in b.\n    We have now a = 999 and b = 111 and max difference = 888\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 9\n    **Output:** 8\n    **Explanation:** The first time pick x = 9 and y = 9 and store the new integer in a.\n    The second time pick x = 9 and y = 1 and store the new integer in b.\n    We have now a = 9 and b = 1 and max difference = 8\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num <= 10`8\n\n,"// Runtime: 34 ms (Top 82.14%) | Memory: 16.40 MB (Top 63.78%)\n\nclass Solution:\n    def maxDiff(self num: int) -> int:\n        num = str(num)\n        \n        i = next((i for i in range(len(num)) if num[i] != ""9"") -1) #first non-9 digit\n        hi = int(num.replace(num[i] ""9""))\n        \n        if num[0] != ""1"": lo = int(num.replace(num[0] ""1""))\n        else: \n            i = next((i for i in range(len(num)) if num[i] not in ""01"") -1)\n            lo = int(num.replace(num[i] ""0"") if i > 0 else num)\n            \n        return hi - lo\n"
Max Dot Product of Two Subsequences,###  1458\. Max Dot Product of Two Subsequences\n\nGiven two arrays `nums1` and `nums2`.\n\nReturn the maximum dot product between **non-empty** subsequences of nums1 and\nnums2 with the same length.\n\nA subsequence of a array is a new array which is formed from the original\narray by deleting some (can be none) of the characters without disturbing the\nrelative positions of the remaining characters. (ie `[235]` is a\nsubsequence of `[12345]` while `[153]` is not).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [21-25] nums2 = [30-6]\n    **Output:** 18\n    **Explanation:** Take subsequence [2-2] from nums1 and subsequence [3-6] from nums2.\n    Their dot product is (2*3 + (-2)*(-6)) = 18.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [3-2] nums2 = [2-67]\n    **Output:** 21\n    **Explanation:** Take subsequence [3] from nums1 and subsequence [7] from nums2.\n    Their dot product is (3*7) = 21.\n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [-1-1] nums2 = [11]\n    **Output:** -1\n    **Explanation:** Take subsequence [-1] from nums1 and subsequence [1] from nums2.\n    Their dot product is -1.\n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 500`\n  * `-1000 <= nums1[i] nums2[i] <= 1000`\n\n,# Runtime: 435 ms (Top 93.00%) | Memory: 13.8 MB (Top 100.00%)\nclass Solution:\n    def maxDotProduct(self A B):\n        dp = [float('-inf')] * (len(B)+1)\n        for i in range(len(A)):\n            prev = float('-inf')\n            for j in range(len(B)):\n                product = A[i] * B[j]\n                prev dp[j+1] = dp[j+1] max(dp[j+1] dp[j] product prev + product)\n        return dp[-1]
Max Increase to Keep City Skyline,###  807\. Max Increase to Keep City Skyline\n\nThere is a city composed of `n x n` blocks where each block contains a single\nbuilding shaped like a vertical square prism. You are given a **0-indexed** `n\nx n` integer matrix `grid` where `grid[r][c]` represents the **height** of the\nbuilding located in the block at row `r` and column `c`.\n\nA city's **skyline** is the the outer contour formed by all the building when\nviewing the side of the city from a distance. The **skyline** from each\ncardinal direction north east south and west may be different.\n\nWe are allowed to increase the height of **any number of buildings by any\namount** (the amount can be different per building). The height of a\n`0`-height building can also be increased. However increasing the height of a\nbuilding should **not** affect the city's **skyline** from any cardinal\ndirection.\n\nReturn _the**maximum total sum** that the height of the buildings can be\nincreased by **without** changing the city's **skyline** from any cardinal\ndirection_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png)\n\n    \n    \n    **Input:** grid = [[3084][2457][9263][0310]]\n    **Output:** 35\n    **Explanation:** The building heights are shown in the center of the above image.\n    The skylines when viewed from each cardinal direction are drawn in red.\n    The grid after increasing the height of buildings without affecting skylines is:\n    gridNew = [ [8 4 8 7]\n                [7 4 7 7]\n                [9 4 8 7]\n                [3 3 3 3] ]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[000][000][000]]\n    **Output:** 0\n    **Explanation:** Increasing the height of any building will result in the skyline changing.\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length`\n  * `n == grid[r].length`\n  * `2 <= n <= 50`\n  * `0 <= grid[r][c] <= 100`\n\n,"class Solution:\n	def maxIncreaseKeepingSkyline(self grid: List[List[int]]) -> int:\n		mxr = [max(i) for i in grid]\n		mxc = [0 for _ in range(len(grid[0]))]\n		for i in range(len(grid)):\n			for j in range(len(grid[0])):\n				mxc[j] = max(grid[i][j]mxc[j])\n		ans =0 \n		for i in range(len(grid)):\n			for j in range(len(grid)):\n				ans+=(min(mxr[i]mxc[j]) - grid[i][j]) \n		return ans"
Max Number of K-Sum Pairs,###  1679\. Max Number of K-Sum Pairs\n\nYou are given an integer array `nums` and an integer `k`.\n\nIn one operation you can pick two numbers from the array whose sum equals `k`\nand remove them from the array.\n\nReturn _the maximum number of operations you can perform on the array_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234] k = 5\n    **Output:** 2\n    **Explanation:** Starting with nums = [1234]:\n    - Remove numbers 1 and 4 then nums = [23]\n    - Remove numbers 2 and 3 then nums = []\n    There are no more pairs that sum up to 5 hence a total of 2 operations.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [31343] k = 6\n    **Output:** 1\n    **Explanation:** Starting with nums = [31343]:\n    - Remove the first two 3's then nums = [143]\n    There are no more pairs that sum up to 6 hence a total of 1 operation.\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 109`\n  * `1 <= k <= 109`\n\n,class Solution:\n    def maxOperations(self nums: List[int] k: int) -> int:\n        nums.sort()\n        left = 0\n        right = len(nums) - 1\n        ans = 0\n        while left < right:\n            cur = nums[left] + nums[right]\n            if cur == k:\n                ans += 1\n                left += 1\n                right -= 1\n            elif cur < k:\n                left += 1\n            else:\n                right -= 1\n        \n        return ans\n
Max Sum of a Pair With Equal Sum of Digits,###  2342\. Max Sum of a Pair With Equal Sum of Digits\n\nYou are given a **0-indexed** array `nums` consisting of **positive**\nintegers. You can choose two indices `i` and `j` such that `i != j` and the\nsum of digits of the number `nums[i]` is equal to that of `nums[j]`.\n\nReturn _the**maximum** value of _`nums[i] + nums[j]`_that you can obtain over\nall possible indices_`i` _and_`j` _that satisfy the conditions._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [184336137]\n    **Output:** 54\n    **Explanation:** The pairs (i j) that satisfy the conditions are:\n    - (0 2) both numbers have a sum of digits equal to 9 and their sum is 18 + 36 = 54.\n    - (1 4) both numbers have a sum of digits equal to 7 and their sum is 43 + 7 = 50.\n    So the maximum sum that we can obtain is 54.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [10121914]\n    **Output:** -1\n    **Explanation:** There are no two numbers that satisfy the conditions so we return -1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 109`\n\n,"class Solution:     # The plan here is to:\n                    # \n                    #   • sort the elements of nums into a dict of maxheaps\n                    #     according to sum-of-digits.\n                    #\n                    #   • For each key determine whether there are at least two \n                    #     elements in that key's values and if so compute the\n                    #     product of the greatest two elements.\n                    #\n                    #   • return the the greatest such product as the answer.\n\n                    # For example:\n					\n                    #     nums = [61513122421] –> {3:[1221] 4:[13] 6:[61524]}\n					\n                    #     Only two keys qualify 3 and 6 for which the greatest two elements\n                    #     are 1221 and 1524 respectively. 12+21 = 33 and 15+24 = 39\n                    #     so the answer is 39.\n\n    def maximumSum(self nums: List[int]) -> int:\n        d mx = defaultdict(list) -1\n        digits = lambda x: sum(map(int list(str(x))))      # <-- sum-of-digits function\n       \n        for n in nums:                                      # <-- construct max-heaps\n            heappush(d[digits(n)]-n)                       #     (note ""-n"") \n\n        for i in d:                                         # <-- pop the two greatest values off\n            if len(d[i]) > 1:                               #     each maxheap (when possible) and\n                mx= max(mx -heappop(d[i])-heappop(d[i]))   #     compare with current max value.\n                                                           \n        return mx"
Max Sum of Rectangle No Larger Than K,###  363\. Max Sum of Rectangle No Larger Than K\n\nGiven an `m x n` matrix `matrix` and an integer `k` return _the max sum of a\nrectangle in the matrix such that its sum is no larger than_ `k`.\n\nIt is **guaranteed** that there will be a rectangle with a sum no larger than\n`k`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg)\n\n    \n    \n    **Input:** matrix = [[101][0-23]] k = 2\n    **Output:** 2\n    **Explanation:** Because the sum of the blue rectangle [[0 1] [-2 3]] is 2 and 2 is the max number no larger than k (k = 2).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matrix = [[22-1]] k = 3\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m n <= 100`\n  * `-100 <= matrix[i][j] <= 100`\n  * `-105 <= k <= 105`\n\n\n\n**Follow up:** What if the number of rows is much larger than the number of\ncolumns?\n\n,"class Solution:\n    def maxSumSubmatrix(self matrix: List[List[int]] k: int) -> int:\n        import numpy as np\n        \n        matrix = np.array(matrix dtype=np.int32)\n        \n        MN = matrix.shape\n        \n        ret = float(""-inf"")\n        \n        CUM = np.zeros((MN) dtype=np.int32)\n        for shift_r in range(M):\n            CUM[:M-shift_r] += matrix[shift_r:]\n            \n            _CUM = np.zeros((M-shift_rN) dtype=np.int32)\n            for shift_c in range(N):\n                _CUM[: :N-shift_c] += CUM[:M-shift_rshift_c:]\n                tmp = _CUM[(_CUM<=k) & (_CUM>ret)]\n                if tmp.size:\n                    ret = tmp.max()\n            if ret == k:\n                return ret\n        \n        return ret\n\n'''\n"
Max Value of Equation,###  1499\. Max Value of Equation\n\nYou are given an array `points` containing the coordinates of points on a 2D\nplane sorted by the x-values where `points[i] = [xi yi]` such that `xi <\nxj` for all `1 <= i < j <= points.length`. You are also given an integer `k`.\n\nReturn _the maximum value of the equation_`yi + yj + |xi - xj|` where `|xi -\nxj| <= k` and `1 <= i < j <= points.length`.\n\nIt is guaranteed that there exists at least one pair of points that satisfy\nthe constraint `|xi - xj| <= k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** points = [[13][20][510][6-10]] k = 1\n    **Output:** 4\n    **Explanation:** The first two points satisfy the condition |xi - xj| <= 1 and if we calculate the equation we get 3 + 0 + |1 - 2| = 4. Third and fourth points also satisfy the condition and give a value of 10 + -10 + |5 - 6| = 1.\n    No other pairs satisfy the condition so we return the max of 4 and 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** points = [[00][30][92]] k = 3\n    **Output:** 3\n    **Explanation:** Only the first two points have an absolute difference of 3 or less in the x-values and give the value of 0 + 0 + |0 - 3| = 3.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= points.length <= 105`\n  * `points[i].length == 2`\n  * `-108 <= xi yi <= 108`\n  * `0 <= k <= 2 * 108`\n  * `xi < xj` for all `1 <= i < j <= points.length`\n  * `xi` form a strictly increasing sequence.\n\n,"class Solution:\n    def findMaxValueOfEquation(self points: List[List[int]] k: int) -> int:\n        """"""\n            Eqn is: yi + yj + |xi - xj|\n            Since points is sorted by x values \n                therefore xj will always be greater than xi\n                therefore xi - xj will always be negative\n            So the above eqn can be rewritten as\n                (yj+xj) + (yi-xi)\n            Now the problem boils down to finding maximum in sliding window of k size.\n            (https://leetcode.com/problems/sliding-window-maximum/discuss/1911533/Python-or-Dequeue-or-Sliding-Window-or-Simple-Solution)\n        """"""\n        queue = deque()\n        maxVal = -sys.maxsize\n        for xy in points:\n            while queue and abs(queue[0][0] - x) > k:\n                queue.popleft()\n            \n            if queue:\n                maxVal = max(maxVal y+x+queue[0][1])\n            \n            while queue and queue[-1][1] <= y-x:\n                queue.pop()\n            \n            queue.append((x y-x))\n            \n        return maxVal\n"
Maximal Network Rank,###  1615\. Maximal Network Rank\n\nThere is an infrastructure of `n` cities with some number of `roads`\nconnecting these cities. Each `roads[i] = [ai bi]` indicates that there is a\nbidirectional road between cities `ai` and `bi`.\n\nThe **network rank** __ of **two different cities** is defined as the total\nnumber of **directly** connected roads to **either** city. If a road is\ndirectly connected to both cities it is only counted **once**.\n\nThe **maximal network rank** of the infrastructure is the **maximum network\nrank** of all pairs of different cities.\n\nGiven the integer `n` and the array `roads` return _the**maximal network\nrank** of the entire infrastructure_.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/09/21/ex1.png)**\n\n    \n    \n    **Input:** n = 4 roads = [[01][03][12][13]]\n    **Output:** 4\n    **Explanation:** The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2020/09/21/ex2.png)**\n\n    \n    \n    **Input:** n = 5 roads = [[01][03][12][13][23][24]]\n    **Output:** 5\n    **Explanation:** There are 5 roads that are connected to cities 1 or 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 8 roads = [[01][12][23][24][56][57]]\n    **Output:** 5\n    **Explanation:** The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 100`\n  * `0 <= roads.length <= n * (n - 1) / 2`\n  * `roads[i].length == 2`\n  * `0 <= ai bi <= n-1`\n  * `ai != bi`\n  * Each pair of cities has **at most one** road connecting them.\n\n,class Solution:\n    def maximalNetworkRank(self n: int roads) -> int:\n        max_rank = 0\n        connections = {i: set() for i in range(n)}\n        for i j in roads:\n            connections[i].add(j)\n            connections[j].add(i)\n        for i in range(n - 1):\n            for j in range(i + 1 n):\n                max_rank = max(max_rank len(connections[i]) +\n                               len(connections[j]) - (j in connections[i]))\n        return max_rank\n
Maximal Rectangle,"###  85\. Maximal Rectangle\n\nGiven a `rows x cols` binary `matrix` filled with `0`'s and `1`'s find the\nlargest rectangle containing only `1`'s and return _its area_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)\n\n    \n    \n    **Input:** matrix = [[""1""""0""""1""""0""""0""][""1""""0""""1""""1""""1""][""1""""1""""1""""1""""1""][""1""""0""""0""""1""""0""]]\n    **Output:** 6\n    **Explanation:** The maximal rectangle is shown in the above picture.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matrix = [[""0""]]\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** matrix = [[""1""]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `rows == matrix.length`\n  * `cols == matrix[i].length`\n  * `1 <= row cols <= 200`\n  * `matrix[i][j]` is `'0'` or `'1'`.\n\n","# Runtime: 1058 ms (Top 6.78%) | Memory: 15.2 MB (Top 89.63%)\nclass Solution:\n    def maxArea(selfarr: List[List[int]]) -> int:\n        maxA = 0 #local max variable to return max area of a 1D array\n        stack = [-1] #initializing with minimum value so we can avoid using loop for remaining element in the stack after whole traversing\n        arr.append(-1) # value for stack index -1 and one extra iteration to empty the stack\n        for i in range(len(arr)): # traversing for stack from left to right\n            arr[i] = int(arr[i]) # we are getting str value from matrix\n            while stack and arr[stack[-1]] >= int(arr[i]): #stack is non empty and stack top is greater or equal to current element\n                index = stack.pop() #pop greater element from stack and finds its area\n                width = i - stack[-1] - 1 if stack else i # for empty stack width is len of 1D arr and after poping if we have element in stack then it becomes left boundary and current index as right boundary\n                maxA = max(maxA width * arr[index]) # geting max area (L * B)\n            stack.append(int(i)) # inserting each element in stack\n        return maxA # return the max area\n    """"""Below is the code for adding each row one by one and passing it to above function to get the max area for each row""""""\n    # r1 - 1 0 1 0 0\n    # r2 - 1 0 1 1 1\n    # r = 2 0 2 1 1 This is for else condition\n\n    # r1 - 1 1 1 0 1\n    # r2 - 1 0 1 1 0\n    # r = 2 0 2 1 0 This is for if condition\n\n    def maximalRectangle(self matrix: List[List[str]]) -> int:\n        result = [0] * len(matrix[0])\n        maxReact = 0\n        maxReact = self.maxArea(result)\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                matrix[i][j] = int(matrix[i][j])\n                if matrix[i][j] == 0:\n                    result[j] = 0\n                else:\n                    result[j] = result[j] + matrix[i][j]\n            maxReact = max(maxReactself.maxArea(result)) #after getting max area for 1D arr we are getting max value from those 1D arr for the 2D arr\n        return maxReact\n"
Maximize Distance to Closest Person,###  849\. Maximize Distance to Closest Person\n\nYou are given an array representing a row of `seats` where `seats[i] = 1`\nrepresents a person sitting in the `ith` seat and `seats[i] = 0` represents\nthat the `ith` seat is empty **(0-indexed)**.\n\nThere is at least one empty seat and at least one person sitting.\n\nAlex wants to sit in the seat such that the distance between him and the\nclosest person to him is maximized.\n\nReturn _that maximum distance to the closest person_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/10/distance.jpg)\n\n    \n    \n    **Input:** seats = [1000101]\n    **Output:** 2\n    **Explanation:**\n    If Alex sits in the second open seat (i.e. seats[2]) then the closest person has distance 2.\n    If Alex sits in any other open seat the closest person has distance 1.\n    Thus the maximum distance to the closest person is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** seats = [1000]\n    **Output:** 3\n    **Explanation:**\n    If Alex sits in the last seat (i.e. seats[3]) the closest person is 3 seats away.\n    This is the maximum distance possible so the answer is 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** seats = [01]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `2 <= seats.length <= 2 * 104`\n  * `seats[i]` is `0` or `1`.\n  * At least one seat is **empty**.\n  * At least one seat is **occupied**.\n\n,class Solution:\n    def maxDistToClosest(self seats: List[int]) -> int:\n        # strategy is greedy solution:\n        # calculate local maximum for each interval: (b-a)//2\n        # then take max of local maximums\n        # the solution is O(n)\n        # I find this solution clear but uses 5 passes\n        \n        # get all the occupied seat nums\n        seat_nums = [ix for ix val in enumerate(seats) if val == 1]\n        \n        # check the ends\n        left_max right_max = min(seat_nums) len(seats)-max(seat_nums)-1\n        \n        # calculate max distance for each gap\n        dists = [(y-x)//2 for x y in zip(seat_nums seat_nums[1:])]\n        \n        # take max of sitting on either end + each gap\n        return max([left_max right_max *dists])\n
Maximize Number of Nice Divisors,###  1808\. Maximize Number of Nice Divisors\n\nYou are given a positive integer `primeFactors`. You are asked to construct a\npositive integer `n` that satisfies the following conditions:\n\n  * The number of prime factors of `n` (not necessarily distinct) is **at most** `primeFactors`.\n  * The number of nice divisors of `n` is maximized. Note that a divisor of `n` is **nice** if it is divisible by every prime factor of `n`. For example if `n = 12` then its prime factors are `[223]` then `6` and `12` are nice divisors while `3` and `4` are not.\n\nReturn _the number of nice divisors of_ `n`. Since that number can be too\nlarge return it **modulo** `109 + 7`.\n\nNote that a prime number is a natural number greater than `1` that is not a\nproduct of two smaller natural numbers. The prime factors of a number `n` is a\nlist of prime numbers such that their product equals `n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** primeFactors = 5\n    **Output:** 6\n    **Explanation:** 200 is a valid value of n.\n    It has 5 prime factors: [22255] and it has 6 nice divisors: [10204050100200].\n    There is not other value of n that has at most 5 prime factors and more nice divisors.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** primeFactors = 8\n    **Output:** 18\n    \n\n\n\n**Constraints:**\n\n  * `1 <= primeFactors <= 109`\n\n,MOD = 10**9 + 7\nclass Solution:\n    def maxNiceDivisors(self n: int) -> int:\n        if n <= 2: return n\n        i c = divmod(n 3)\n        if not c: return pow(3 i MOD)\n        return (self.maxNiceDivisors(n-2)*2) % MOD\n
Maximize Number of Subsequences in a String,"###  2207\. Maximize Number of Subsequences in a String\n\nYou are given a **0-indexed** string `text` and another **0-indexed** string\n`pattern` of length `2` both of which consist of only lowercase English\nletters.\n\nYou can add **either** `pattern[0]` **or** `pattern[1]` anywhere in `text`\n**exactly once**. Note that the character can be added even at the beginning\nor at the end of `text`.\n\nReturn _the**maximum** number of times_ `pattern` _can occur as\na**subsequence** of the modified _`text`.\n\nA **subsequence** is a string that can be derived from another string by\ndeleting some or no characters without changing the order of the remaining\ncharacters.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text = ""abdcdbc"" pattern = ""ac""\n    **Output:** 4\n    **Explanation:**\n    If we add pattern[0] = 'a' in between text[1] and text[2] we get ""ab _**a**_ dcdbc"". Now the number of times ""ac"" occurs as a subsequence is 4.\n    Some other strings which have 4 subsequences ""ac"" after adding a character to text are ""_**a**_ abdcdbc"" and ""abd _**a**_ cdbc"".\n    However strings such as ""abdc _**a**_ dbc"" ""abd _**c**_ cdbc"" and ""abdcdbc _**c**_ "" although obtainable have only 3 subsequences ""ac"" and are thus suboptimal.\n    It can be shown that it is not possible to get more than 4 subsequences ""ac"" by adding only one character.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text = ""aabb"" pattern = ""ab""\n    **Output:** 6\n    **Explanation:**\n    Some of the strings which can be obtained from text and have 6 subsequences ""ab"" are ""_**a**_ aabb"" ""aa _**a**_ bb"" and ""aab _**b**_ b"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length <= 105`\n  * `pattern.length == 2`\n  * `text` and `pattern` consist only of lowercase English letters.\n\n",class Solution:\n    def maximumSubsequenceCount(self text: str pattern: str) -> int:\n        total = count_a = count_b = 0\n        for c in text:\n            if c == pattern[1]:\n                total += count_a\n                count_b += 1\n            if c == pattern[0]:\n                count_a += 1\n        \n        return total + max(count_a count_b)\n
Maximize Palindrome Length From Subsequences,"###  1771\. Maximize Palindrome Length From Subsequences\n\nYou are given two strings `word1` and `word2`. You want to construct a string\nin the following manner:\n\n  * Choose some **non-empty** subsequence `subsequence1` from `word1`.\n  * Choose some **non-empty** subsequence `subsequence2` from `word2`.\n  * Concatenate the subsequences: `subsequence1 + subsequence2` to make the string.\n\nReturn _the**length** of the longest **palindrome** that can be constructed in\nthe described manner. _If no palindromes can be constructed return `0`.\n\nA **subsequence** of a string `s` is a string that can be made by deleting\nsome (possibly none) characters from `s` without changing the order of the\nremaining characters.\n\nA **palindrome** is a string that reads the same forward as well as backward.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word1 = ""cacb"" word2 = ""cbba""\n    **Output:** 5\n    **Explanation:** Choose ""ab"" from word1 and ""cba"" from word2 to make ""abcba"" which is a palindrome.\n\n**Example 2:**\n\n    \n    \n    **Input:** word1 = ""ab"" word2 = ""ab""\n    **Output:** 3\n    **Explanation:** Choose ""ab"" from word1 and ""a"" from word2 to make ""aba"" which is a palindrome.\n\n**Example 3:**\n\n    \n    \n    **Input:** word1 = ""aa"" word2 = ""bb""\n    **Output:** 0\n    **Explanation:** You cannot construct a palindrome from the described method so return 0.\n\n\n\n**Constraints:**\n\n  * `1 <= word1.length word2.length <= 1000`\n  * `word1` and `word2` consist of lowercase English letters.\n\n","// Runtime: 932 ms (Top 96.15%) | Memory: 70.20 MB (Top 90.38%)\n\nclass Solution:\n	def longestPalindrome(self word1: str word2: str) -> int:\n		res=0\n		new_word=word1+word2\n		nmid=len(word1)+len(word2)len(word1)\n		dp=[[0]*n for _ in range(n)]\n		for i in range(n):\n			dp[i][i]=1\n		for l in range(n-2-1-1):\n			for r in range(l+1n1):\n				if new_word[l]==new_word[r]:\n					dp[l][r]=(dp[l+1][r-1] if r-1>=l+1 else 0)+2\n					if l<mid and r>=mid:\n						res=max(resdp[l][r])\n				else:\n					dp[l][r]=max(dp[l+1][r]dp[l][r-1])\n		return res"
Maximize Score After N Operations,###  1799\. Maximize Score After N Operations\n\nYou are given `nums` an array of positive integers of size `2 * n`. You must\nperform `n` operations on this array.\n\nIn the `ith` operation **(1-indexed)**  you will:\n\n  * Choose two elements `x` and `y`.\n  * Receive a score of `i * gcd(x y)`.\n  * Remove `x` and `y` from `nums`.\n\nReturn _the maximum score you can receive after performing_`n` _operations._\n\nThe function `gcd(x y)` is the greatest common divisor of `x` and `y`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12]\n    **Output:** 1\n    **Explanation:**  The optimal choice of operations is:\n    (1 * gcd(1 2)) = 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [3468]\n    **Output:** 11\n    **Explanation:**  The optimal choice of operations is:\n    (1 * gcd(3 6)) + (2 * gcd(4 8)) = 3 + 8 = 11\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [123456]\n    **Output:** 14\n    **Explanation:**  The optimal choice of operations is:\n    (1 * gcd(1 5)) + (2 * gcd(2 4)) + (3 * gcd(3 6)) = 1 + 4 + 9 = 14\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 7`\n  * `nums.length == 2 * n`\n  * `1 <= nums[i] <= 106`\n\n,# Runtime: 6454 ms (Top 9.35%) | Memory: 24.7 MB (Top 37.40%)\nfrom functools import lru_cache\n\nclass Solution:\n    def maxScore(self nums: List[int]) -> int:\n        def gcd(a b):\n            while a:\n                a b = b%a a\n            return b\n        halfplus = len(nums)//2 + 1\n        @lru_cache(None)\n        def dfs(mask k):\n            if k == halfplus:\n                return 0\n            res = 0\n            for i in range(len(nums)):\n                for j in range(i+1 len(nums)):\n                    if not(mask & (1<<i)) and not(mask &(1<<j)):\n                        res = max(res k*gcd(nums[i] nums[j])+dfs(mask|(1<<i)|(1<<j) k+1))\n            return res\n        return dfs(0 1)
Maximize Sum Of Array After K Negations,###  1005\. Maximize Sum Of Array After K Negations\n\nGiven an integer array `nums` and an integer `k` modify the array in the\nfollowing way:\n\n  * choose an index `i` and replace `nums[i]` with `-nums[i]`.\n\nYou should apply this process exactly `k` times. You may choose the same index\n`i` multiple times.\n\nReturn _the largest possible sum of the array after modifying it in this way_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [423] k = 1\n    **Output:** 5\n    **Explanation:** Choose index 1 and nums becomes [4-23].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [3-102] k = 3\n    **Output:** 6\n    **Explanation:** Choose indices (1 2 2) and nums becomes [3102].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [2-3-15-4] k = 2\n    **Output:** 13\n    **Explanation:** Choose indices (1 4) and nums becomes [23-154].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-100 <= nums[i] <= 100`\n  * `1 <= k <= 104`\n\n,from heapq import heapify heapreplace\n\nclass Solution:\n    def largestSumAfterKNegations(self nums: List[int] k: int) -> int:\n        heapify(nums)\n        while k and nums[0] < 0:\n            heapreplace(nums -nums[0])\n            k -= 1\n        if k % 2:\n            heapreplace(nums -nums[0])\n        return sum(nums)
Maximize the Confusion of an Exam,"###  2024\. Maximize the Confusion of an Exam\n\nA teacher is writing a test with `n` true/false questions with `'T'` denoting\ntrue and `'F'` denoting false. He wants to confuse the students by\n**maximizing** the number of **consecutive** questions with the **same**\nanswer (multiple trues or multiple falses in a row).\n\nYou are given a string `answerKey` where `answerKey[i]` is the original\nanswer to the `ith` question. In addition you are given an integer `k` the\nmaximum number of times you may perform the following operation:\n\n  * Change the answer key for any question to `'T'` or `'F'` (i.e. set `answerKey[i]` to `'T'` or `'F'`).\n\nReturn _the**maximum** number of consecutive_ `'T'`s or `'F'`s _in the answer\nkey after performing the operation at most_ `k` _times_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** answerKey = ""TTFF"" k = 2\n    **Output:** 4\n    **Explanation:** We can replace both the 'F's with 'T's to make answerKey = ""_TTTT_ "".\n    There are four consecutive 'T's.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** answerKey = ""TFFT"" k = 1\n    **Output:** 3\n    **Explanation:** We can replace the first 'T' with an 'F' to make answerKey = ""_FFF_ T"".\n    Alternatively we can replace the second 'T' with an 'F' to make answerKey = ""T _FFF_ "".\n    In both cases there are three consecutive 'F's.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** answerKey = ""TTFTTFTT"" k = 1\n    **Output:** 5\n    **Explanation:** We can replace the first 'F' to make answerKey = ""_TTTTT_ FTT""\n    Alternatively we can replace the second 'F' to make answerKey = ""TTF _TTTTT_ "". \n    In both cases there are five consecutive 'T's.\n    \n\n\n\n**Constraints:**\n\n  * `n == answerKey.length`\n  * `1 <= n <= 5 * 104`\n  * `answerKey[i]` is either `'T'` or `'F'`\n  * `1 <= k <= n`\n\n","# Runtime: 482 ms (Top 77.29%) | Memory: 14.4 MB (Top 36.09%)\nclass Solution:\n    def maxConsecutiveAnswers(self string: str k: int) -> int:\n        result = 0\n        j = 0\n        count1 = k\n        for i in range(len(string)):\n            if count1 == 0 and string[i] == ""F"":\n                while string[j] != ""F"":\n                    j+=1\n                count1+=1\n                j+=1\n\n            if string[i] == ""F"":\n                if count1 > 0:\n                    count1-=1\n\n            if i - j + 1 > result:\n                result = i - j + 1\n\n        j = 0\n        count2 = k\n        for i in range(len(string)):\n            if count2 == 0 and string[i] == ""T"":\n                while string[j] != ""T"":\n                    j+=1\n                count2+=1\n                j+=1\n\n            if string[i] == ""T"":\n                if count2 > 0:\n                    count2-=1\n\n            if i - j + 1 > result:\n                result = i - j + 1\n\n        return result"
Maximum Absolute Sum of Any Subarray,###  1749\. Maximum Absolute Sum of Any Subarray\n\nYou are given an integer array `nums`. The **absolute sum** of a subarray\n`[numsl numsl+1 ... numsr-1 numsr]` is `abs(numsl + numsl+1 + ... +\nnumsr-1 + numsr)`.\n\nReturn _the**maximum** absolute sum of any **(possibly empty)** subarray of\n_`nums`.\n\nNote that `abs(x)` is defined as follows:\n\n  * If `x` is a negative integer then `abs(x) = -x`.\n  * If `x` is a non-negative integer then `abs(x) = x`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1-323-4]\n    **Output:** 5\n    **Explanation:** The subarray [23] has absolute sum = abs(2+3) = abs(5) = 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2-51-43-2]\n    **Output:** 8\n    **Explanation:** The subarray [-51-4] has absolute sum = abs(-5+1-4) = abs(-8) = 8.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-104 <= nums[i] <= 104`\n\n,"class Solution:\n	def maxAbsoluteSum(self A):\n\n		mamires = 000\n		for a in A:\n			ma = max(0ma+a)\n			mi = min(0mi+a)\n			res = max(resma-mi)\n		return res\n"
Maximum Alternating Subsequence Sum,###  1911\. Maximum Alternating Subsequence Sum\n\nThe **alternating sum** of a **0-indexed** array is defined as the **sum** of\nthe elements at **even** indices **minus** the **sum** of the elements at\n**odd** indices.\n\n  * For example the alternating sum of `[4253]` is `(4 + 5) - (2 + 3) = 4`.\n\nGiven an array `nums` return _the**maximum alternating sum** of any\nsubsequence of _`nums` _(after**reindexing** the elements of the\nsubsequence)_.\n\nA **subsequence** of an array is a new array generated from the original array\nby deleting some elements (possibly none) without changing the remaining\nelements' relative order. For example `[274]` is a subsequence of `[4_2_\n3_7_ 21_4_]` (the underlined elements) while `[242]` is not.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [_4_ _2_ _5_ 3]\n    **Output:** 7\n    **Explanation:** It is optimal to choose the subsequence [425] with alternating sum (4 + 5) - 2 = 7.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [567_8_]\n    **Output:** 8\n    **Explanation:** It is optimal to choose the subsequence [8] with alternating sum 8.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [_6_ 2_1_ 24_5_]\n    **Output:** 10\n    **Explanation:** It is optimal to choose the subsequence [615] with alternating sum (6 + 5) - 1 = 10.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 105`\n\n,# Runtime: 2571 ms (Top 53.06%) | Memory: 28.4 MB (Top 82.81%)\nclass Solution:\n    def maxAlternatingSum(self nums: List[int]) -> int:\n        ans = 0\n        direction = 'down'\n        n = len(nums)\n        for i in range(n-1):\n            if direction == 'down' and nums[i] >= nums[i+1]:\n                ans += nums[i]\n                direction = 'up'\n            elif direction == 'up' and nums[i] <= nums[i+1]:\n                ans -= nums[i]\n                direction = 'down'\n        if direction == 'up':\n            return ans\n        return ans + nums[-1]
Maximum AND Sum of Array,###  2172\. Maximum AND Sum of Array\n\nYou are given an integer array `nums` of length `n` and an integer `numSlots`\nsuch that `2 * numSlots >= n`. There are `numSlots` slots numbered from `1` to\n`numSlots`.\n\nYou have to place all `n` integers into the slots such that each slot contains\nat **most** two numbers. The **AND sum** of a given placement is the sum of\nthe **bitwise** `AND` of every number with its respective slot number.\n\n  * For example the **AND sum** of placing the numbers `[1 3]` into slot _`1`_ and `[4 6]` into slot _`2`_ is equal to `(1 AND _1_) + (3 AND _1_) + (4 AND _2_) + (6 AND _2_) = 1 + 1 + 0 + 2 = 4`.\n\nReturn _the maximum possible**AND sum** of _`nums` _given_`numSlots` _slots._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123456] numSlots = 3\n    **Output:** 9\n    **Explanation:** One possible placement is [1 4] into slot _1_  [2 6] into slot _2_  and [3 5] into slot _3_. \n    This gives the maximum AND sum of (1 AND _1_) + (4 AND _1_) + (2 AND _2_) + (6 AND _2_) + (3 AND _3_) + (5 AND _3_) = 1 + 0 + 2 + 2 + 3 + 1 = 9.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1310471] numSlots = 9\n    **Output:** 24\n    **Explanation:** One possible placement is [1 1] into slot _1_  [3] into slot _3_  [4] into slot _4_  [7] into slot _7_  and [10] into slot _9_.\n    This gives the maximum AND sum of (1 AND _1_) + (1 AND _1_) + (3 AND _3_) + (4 AND _4_) + (7 AND _7_) + (10 AND _9_) = 1 + 1 + 3 + 4 + 7 + 8 = 24.\n    Note that slots 2 5 6 and 8 are empty which is permitted.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= numSlots <= 9`\n  * `1 <= n <= 2 * numSlots`\n  * `1 <= nums[i] <= 15`\n\n,# Runtime: 1881 ms (Top 9.44%) | Memory: 23.9 MB (Top 80.86%)\nfrom functools import lru_cache cache\n\nclass Solution:\n    def maximumANDSum(self nums: List[int] numSlots: int) -> int:\n        @cache\n        def dp(i=0 m1=0 m2=0): # mask1 mask2\n            if i == len(nums):\n                return 0\n            ans = 0\n            for s in range(numSlots):\n                if m2 & (1 << s) == 0: # i.e. 0b0? implying the slot is not full\n                    if m1 & (1 << s) == 0: # 0b00 + 1 => 0b01\n                        nm1 = m1 | (1 << s); nm2 = m2\n                    else: # 0b01 + 1 => 0b10\n                        nm1 = m1 & ~(1 << s); nm2 = m2 | (1 << s)\n                    ans = max(ans dp(i + 1 nm1 nm2) + ((s + 1) & nums[i])) # s + 1 is the actual slot no.\n            return ans\n        return dp()
Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts,###  1465\. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts\n\nYou are given a rectangular cake of size `h x w` and two arrays of integers\n`horizontalCuts` and `verticalCuts` where:\n\n  * `horizontalCuts[i]` is the distance from the top of the rectangular cake to the `ith` horizontal cut and similarly and\n  * `verticalCuts[j]` is the distance from the left of the rectangular cake to the `jth` vertical cut.\n\nReturn _the maximum area of a piece of cake after you cut at each horizontal\nand vertical position provided in the arrays_ `horizontalCuts` _and_\n`verticalCuts`. Since the answer can be a large number return this **modulo**\n`109 + 7`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/05/14/leetcode_max_area_2.png)\n\n    \n    \n    **Input:** h = 5 w = 4 horizontalCuts = [124] verticalCuts = [13]\n    **Output:** 4 \n    **Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake the green piece of cake has the maximum area.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/05/14/leetcode_max_area_3.png)\n\n    \n    \n    **Input:** h = 5 w = 4 horizontalCuts = [31] verticalCuts = [1]\n    **Output:** 6\n    **Explanation:** The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake the green and yellow pieces of cake have the maximum area.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** h = 5 w = 4 horizontalCuts = [3] verticalCuts = [3]\n    **Output:** 9\n    \n\n\n\n**Constraints:**\n\n  * `2 <= h w <= 109`\n  * `1 <= horizontalCuts.length <= min(h - 1 105)`\n  * `1 <= verticalCuts.length <= min(w - 1 105)`\n  * `1 <= horizontalCuts[i] < h`\n  * `1 <= verticalCuts[i] < w`\n  * All the elements in `horizontalCuts` are distinct.\n  * All the elements in `verticalCuts` are distinct.\n\n,class Solution:\n    def maxArea(self h: int w: int horizontalCuts: List[int] verticalCuts: List[int]) -> int:\n        horizontalCuts.sort()\n        verticalCuts.sort()\n        \n        mxHr = 0\n        prev = 0\n        for i in horizontalCuts:\n            mxHr = max(mxHr i-prev)\n            prev = i\n        mxHr = max(mxHr h-horizontalCuts[-1])\n        \n        mxVr = 0\n        prev = 0\n        for i in verticalCuts:\n            mxVr = max(mxVr i-prev)\n            prev = i\n        mxVr = max(mxVr w-verticalCuts[-1])\n        \n        return (mxHr * mxVr) % ((10 ** 9) + 7)\n
Maximum Ascending Subarray Sum,###  1800\. Maximum Ascending Subarray Sum\n\nGiven an array of positive integers `nums` return the _maximum possible sum\nof an**ascending** subarray in _`nums`.\n\nA subarray is defined as a contiguous sequence of numbers in an array.\n\nA subarray `[numsl numsl+1 ... numsr-1 numsr]` is **ascending** if for all\n`i` where `l <= i < r` `numsi  < numsi+1`. Note that a subarray of size `1`\nis **ascending**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [10203051050]\n    **Output:** 65\n    **Explanation:**[51050] is the ascending subarray with the maximum sum of 65.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1020304050]\n    **Output:** 150\n    **Explanation:**[1020304050] is the ascending subarray with the maximum sum of 150.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [12171513101112]\n    **Output:** 33\n    **Explanation:**[101112] is the ascending subarray with the maximum sum of 33.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `1 <= nums[i] <= 100`\n\n,class Solution:\n    def maxAscendingSum(self nums: List[int]) -> int:\n        count=nums[0]\n        final=nums[0]\n        for i in range(1len(nums)):\n            if nums[i]>nums[i-1]:\n                count+=nums[i]\n            else:\n                count=nums[i]\n            final=max(finalcount)\n        return final\n
Maximum Average Pass Ratio,###  1792\. Maximum Average Pass Ratio\n\nThere is a school that has classes of students and each class will be having a\nfinal exam. You are given a 2D integer array `classes` where `classes[i] =\n[passi totali]`. You know beforehand that in the `ith` class there are\n`totali` total students but only `passi` number of students will pass the\nexam.\n\nYou are also given an integer `extraStudents`. There are another\n`extraStudents` brilliant students that are **guaranteed** to pass the exam of\nany class they are assigned to. You want to assign each of the `extraStudents`\nstudents to a class in a way that **maximizes** the **average** pass ratio\nacross **all** the classes.\n\nThe **pass ratio** of a class is equal to the number of students of the class\nthat will pass the exam divided by the total number of students of the class.\nThe **average pass ratio** is the sum of pass ratios of all the classes\ndivided by the number of the classes.\n\nReturn _the**maximum** possible average pass ratio after assigning the\n_`extraStudents` _students._ Answers within `10-5` of the actual answer will\nbe accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** classes = [[12][35][22]] extraStudents = 2\n    **Output:** 0.78333\n    **Explanation:** You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** classes = [[24][39][45][210]] extraStudents = 4\n    **Output:** 0.53485\n    \n\n\n\n**Constraints:**\n\n  * `1 <= classes.length <= 105`\n  * `classes[i].length == 2`\n  * `1 <= passi <= totali <= 105`\n  * `1 <= extraStudents <= 105`\n\n,"class Solution:\n	def maxAverageRatio(self classes: List[List[int]] extraStudents: int) -> float:\n		\n		n = len(classes)\n		\n		impacts = [0]*n\n		minRatioIndex = 0\n		\n		# calculate and store impacts for each class in form of tuples -> (-impactValue passCount totalCount)\n		for i in range(n):\n			passCount = classes[i][0]\n			totalCount = classes[i][1]\n			\n			# calculate the impact  for class i\n			currentRatio = passCount/totalCount\n			expectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\n			impact = expectedRatioAfterUpdate - currentRatio\n			\n			impacts[i] = (-impact passCount totalCount)  # note the - sign for impact\n			\n		heapq.heapify(impacts)\n		\n		while(extraStudents > 0):\n			# pick the next class with greatest impact \n			_ passCount totalCount = heapq.heappop(impacts)\n			\n			# assign a student to the class\n			passCount+=1\n			totalCount+=1\n			\n			# calculate the updated impact  for current class\n			currentRatio = passCount/totalCount\n			expectedRatioAfterUpdate = (passCount+1)/(totalCount+1)\n			impact = expectedRatioAfterUpdate - currentRatio\n			\n			# insert updated impact back into the heap\n			heapq.heappush(impacts (-impact passCount totalCount))\n			extraStudents -= 1\n		\n		result = 0\n			\n		# for all the updated classes calculate the total passRatio \n		for _ passCount totalCount in impacts:\n			result += passCount/totalCount\n			\n		# return the average pass ratio\n		return result/n\n"
Maximum Average Subarray I,###  643\. Maximum Average Subarray I\n\nYou are given an integer array `nums` consisting of `n` elements and an\ninteger `k`.\n\nFind a contiguous subarray whose **length is equal to** `k` that has the\nmaximum average value and return _this value_. Any answer with a calculation\nerror less than `10-5` will be accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [112-5-6503] k = 4\n    **Output:** 12.75000\n    **Explanation:** Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [5] k = 1\n    **Output:** 5.00000\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= k <= n <= 105`\n  * `-104 <= nums[i] <= 104`\n\n,//O(N) Time and O(1) Space - SLIDING WINDOW\n\nclass Solution {\npublic:\n    double findMaxAverage(vector<int>& nums int k) {\n        \n        double ans = INT_MIN;\n        \n        int i = 0;\n        int j = 0;\n        int sum = 0;\n        \n        while(j<nums.size()){\n            \n            //calcs\n            sum = sum+nums[j];\n            \n            if(j-i+1 < k){\n                j++;\n            }\n            else if(j-i+1 == k){\n                \n                //ans\n                double nos =  k*1.0;\n                ans = max(ans sum/nos);\n                \n\n                int v = nums[i];\n                sum = sum - v;\n                \n                //SLIDE\n                i++;\n                j++;\n            }\n        }\n        \n        return ans;\n        \n        \n    }\n};\n
Maximum Bags With Full Capacity of Rocks,###  2279\. Maximum Bags With Full Capacity of Rocks\n\nYou have `n` bags numbered from `0` to `n - 1`. You are given two\n**0-indexed** integer arrays `capacity` and `rocks`. The `ith` bag can hold a\nmaximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You\nare also given an integer `additionalRocks` the number of additional rocks\nyou can place in **any** of the bags.\n\nReturn _the**maximum** number of bags that could have full capacity after\nplacing the additional rocks in some bags._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** capacity = [2345] rocks = [1244] additionalRocks = 2\n    **Output:** 3\n    **Explanation:**\n    Place 1 rock in bag 0 and 1 rock in bag 1.\n    The number of rocks in each bag are now [2344].\n    Bags 0 1 and 2 have full capacity.\n    There are 3 bags at full capacity so we return 3.\n    It can be shown that it is not possible to have more than 3 bags at full capacity.\n    Note that there may be other ways of placing the rocks that result in an answer of 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** capacity = [1022] rocks = [220] additionalRocks = 100\n    **Output:** 3\n    **Explanation:**\n    Place 8 rocks in bag 0 and 2 rocks in bag 2.\n    The number of rocks in each bag are now [1022].\n    Bags 0 1 and 2 have full capacity.\n    There are 3 bags at full capacity so we return 3.\n    It can be shown that it is not possible to have more than 3 bags at full capacity.\n    Note that we did not use all of the additional rocks.\n    \n\n\n\n**Constraints:**\n\n  * `n == capacity.length == rocks.length`\n  * `1 <= n <= 5 * 104`\n  * `1 <= capacity[i] <= 109`\n  * `0 <= rocks[i] <= capacity[i]`\n  * `1 <= additionalRocks <= 109`\n\n,class Solution:\n    def maximumBags(self capacity: List[int] rocks: List[int] additionalRocks: int) -> int:\n       v c l = [] 0 len(rocks)\n        for i in range(l):\n            p = capacity[i]-rocks[i]\n            if(p>0):\n                v.append(p)\n            else: c += 1\n        v.sort()\n        k=0\n        while(additionalRocks>0 and k<len(v)):\n            if(v[k]<=additionalRocks):\n                c += 1\n                additionalRocks -= v[k]\n            k += 1\n        return c\n
Maximum Binary String After Change,"###  1702\. Maximum Binary String After Change\n\nYou are given a binary string `binary` consisting of only `0`'s or `1`'s. You\ncan apply each of the following operations any number of times:\n\n  * Operation 1: If the number contains the substring `""00""` you can replace it with `""10""`. \n    * For example `""_00_ 010"" -> ""_10_ 010`""\n  * Operation 2: If the number contains the substring `""10""` you can replace it with `""01""`. \n    * For example `""000 _10_ "" -> ""000 _01_ ""`\n\n_Return the**maximum binary string** you can obtain after any number of\noperations. Binary string `x` is greater than binary string `y` if `x`'s\ndecimal representation is greater than `y`'s decimal representation._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** binary = ""000110""\n    **Output:** ""111011""\n    **Explanation:** A valid transformation sequence can be:\n    ""0001 _10_ "" -> ""0001 _01_ "" \n    ""_00_ 0101"" -> ""_10_ 0101"" \n    ""1 _00_ 101"" -> ""1 _10_ 101"" \n    ""110 _10_ 1"" -> ""110 _01_ 1"" \n    ""11 _00_ 11"" -> ""11 _10_ 11""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** binary = ""01""\n    **Output:** ""01""\n    **Explanation:**  ""01"" cannot be transformed any further.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= binary.length <= 105`\n  * `binary` consist of `'0'` and `'1'`.\n\n","# Runtime: 128 ms (Top 57.69%) | Memory: 15.4 MB (Top 69.23%)\nclass Solution:\n    def maximumBinaryString(self binary: str) -> str:\n        zero = binary.count('0') # count number of '0'\n        zero_idx = binary.index('0') if zero > 0 else 0 # find the index of fist '0' if exists\n        one = len(binary) - zero_idx - zero # count number of '1' (not including leading '1's)\n        return f""{binary[:zero_idx]}{'1'*(zero-1)}{'0'*min(zero 1)}{'1'*one}"""
Maximum Binary Tree,###  654\. Maximum Binary Tree\n\nYou are given an integer array `nums` with no duplicates. A **maximum binary\ntree** can be built recursively from `nums` using the following algorithm:\n\n  1. Create a root node whose value is the maximum value in `nums`.\n  2. Recursively build the left subtree on the **subarray prefix** to the **left** of the maximum value.\n  3. Recursively build the right subtree on the **subarray suffix** to the **right** of the maximum value.\n\nReturn _the**maximum binary tree** built from _`nums`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)\n\n    \n    \n    **Input:** nums = [321605]\n    **Output:** [635null20nullnull1]\n    **Explanation:** The recursive calls are as follow:\n    - The largest value in [321605] is 6. Left prefix is [321] and right suffix is [05].\n        - The largest value in [321] is 3. Left prefix is [] and right suffix is [21].\n            - Empty array so no child.\n            - The largest value in [21] is 2. Left prefix is [] and right suffix is [1].\n                - Empty array so no child.\n                - Only one element so child is a node with value 1.\n        - The largest value in [05] is 5. Left prefix is [0] and right suffix is [].\n            - Only one element so child is a node with value 0.\n            - Empty array so no child.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)\n\n    \n    \n    **Input:** nums = [321]\n    **Output:** [3null2null1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `0 <= nums[i] <= 1000`\n  * All integers in `nums` are **unique**.\n\n,"class Solution:\n	def constructMaximumBinaryTree(self nums: List[int]) -> Optional[TreeNode]:\n		if not nums:\n			return None\n		m = max(nums)\n		idx  = nums.index(m)\n		root = TreeNode(m)\n		root.left = self.constructMaximumBinaryTree(nums[:idx])\n		root.right = self.constructMaximumBinaryTree(nums[idx+1:])\n		return root"
Maximum Binary Tree II,###  998\. Maximum Binary Tree II\n\nA **maximum tree** is a tree where every node has a value greater than any\nother value in its subtree.\n\nYou are given the `root` of a maximum binary tree and an integer `val`.\n\nJust as in the [previous problem](https://leetcode.com/problems/maximum-\nbinary-tree/) the given tree was constructed from a list `a` (`root =\nConstruct(a)`) recursively with the following `Construct(a)` routine:\n\n  * If `a` is empty return `null`.\n  * Otherwise let `a[i]` be the largest element of `a`. Create a `root` node with the value `a[i]`.\n  * The left child of `root` will be `Construct([a[0] a[1] ... a[i - 1]])`.\n  * The right child of `root` will be `Construct([a[i + 1] a[i + 2] ... a[a.length - 1]])`.\n  * Return `root`.\n\nNote that we were not given `a` directly only a root node `root =\nConstruct(a)`.\n\nSuppose `b` is a copy of `a` with the value `val` appended to it. It is\nguaranteed that `b` has unique values.\n\nReturn `Construct(b)`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/08/09/maxtree1.JPG)\n\n    \n    \n    **Input:** root = [413nullnull2] val = 5\n    **Output:** [54null13nullnull2]\n    **Explanation:** a = [1423] b = [14235]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/08/09/maxtree21.JPG)\n\n    \n    \n    **Input:** root = [524null1] val = 3\n    **Output:** [524null1null3]\n    **Explanation:** a = [2154] b = [21543]\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/08/09/maxtree3.JPG)\n\n    \n    \n    **Input:** root = [523null1] val = 4\n    **Output:** [524null13]\n    **Explanation:** a = [2153] b = [21534]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 100]`.\n  * `1 <= Node.val <= 100`\n  * All the values of the tree are **unique**.\n  * `1 <= val <= 100`\n\n,"class Solution:\n    """"""\n    approach:\n    given a we can get the inorder traversal of it then append val to it and\n    then construct the tree back\n    """"""\n    def insertIntoMaxTree(self root: Optional[TreeNode] val: int) -> Optional[TreeNode]:\n        inorder_list = []\n        def inorder(root):\n            if not root:\n                return\n            inorder(root.left)\n            inorder_list.append(root.val)\n            inorder(root.right)\n            \n        inorder(root)\n        inorder_list.append(val)\n        \n        def get_maximum(val_list):\n            max_index = -1\n            max_val = -1\n            for i val in enumerate(val_list):\n                if val > max_val:\n                    max_val = val\n                    max_index = i\n            return max_index max_val\n                \n        def create_tree(val_list):\n            if not len(val_list):\n                return None\n            index val = get_maximum(val_list)\n            node = TreeNode(val)\n            node.left = create_tree(val_list[:index])\n            node.right = create_tree(val_list[index+1:])\n            return node\n        \n        b = create_tree(inorder_list)\n        return b\n"
Maximum Building Height,###  1840\. Maximum Building Height\n\nYou want to build `n` new buildings in a city. The new buildings will be built\nin a line and are labeled from `1` to `n`.\n\nHowever there are city restrictions on the heights of the new buildings:\n\n  * The height of each building must be a non-negative integer.\n  * The height of the first building **must** be `0`.\n  * The height difference between any two adjacent buildings **cannot exceed** `1`.\n\nAdditionally there are city restrictions on the maximum height of specific\nbuildings. These restrictions are given as a 2D integer array `restrictions`\nwhere `restrictions[i] = [idi maxHeighti]` indicates that building `idi` must\nhave a height **less than or equal to** `maxHeighti`.\n\nIt is guaranteed that each building will appear **at most once** in\n`restrictions` and building `1` will **not** be in `restrictions`.\n\nReturn _the**maximum possible height** of the **tallest** building_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/08/ic236-q4-ex1-1.png)\n\n    \n    \n    **Input:** n = 5 restrictions = [[21][41]]\n    **Output:** 2\n    **Explanation:** The green area in the image indicates the maximum allowed height for each building.\n    We can build the buildings with heights [01212] and the tallest building has a height of 2.\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/08/ic236-q4-ex2.png)\n\n    \n    \n    **Input:** n = 6 restrictions = []\n    **Output:** 5\n    **Explanation:** The green area in the image indicates the maximum allowed height for each building.\n    We can build the buildings with heights [012345] and the tallest building has a height of 5.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/04/08/ic236-q4-ex3.png)\n\n    \n    \n    **Input:** n = 10 restrictions = [[53][25][74][103]]\n    **Output:** 5\n    **Explanation:** The green area in the image indicates the maximum allowed height for each building.\n    We can build the buildings with heights [0123344543] and the tallest building has a height of 5.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 109`\n  * `0 <= restrictions.length <= min(n - 1 105)`\n  * `2 <= idi <= n`\n  * `idi` is **unique**.\n  * `0 <= maxHeighti <= 109`\n\n,// Runtime: 1203 ms (Top 88.37%) | Memory: 55.60 MB (Top 9.3%)\n\n#Readability version\nclass Solution:\n    def maxBuilding(self n: int restrictions: List[List[int]]) -> int:\n        # Set the initial height for the 1st building\n        restrictions.append([1 0])\n        restrictions.sort()\n\n        # Process restrictions to find the valid ones for reaching previous restrictions\n        valid_restrictions_forward = []\n        temp_diff = 0\n        for id ht in restrictions:\n            current_diff = id - ht\n            if current_diff >= temp_diff:\n                temp_diff = current_diff\n                valid_restrictions_forward.append([id ht])\n\n        # Process valid restrictions backward to find the ones for reaching next restrictions\n        valid_restrictions_backward = []\n        temp_sum = n + n - 1\n        for id ht in valid_restrictions_forward[::-1]:\n            current_sum = id + ht\n            if current_sum <= temp_sum:\n                temp_sum = current_sum\n                valid_restrictions_backward.append([id ht])\n\n        # Reverse the backward valid restrictions to get the correct order\n        valid_restrictions_backward.reverse()\n\n        # Add maximum height for the last building due to the last restriction\n        if valid_restrictions_backward[-1][0] != n:\n            valid_restrictions_backward.append([n valid_restrictions_backward[-1][1] + n - valid_restrictions_backward[-1][0]])\n\n        # Calculate the maximum height\n        max_height = 0\n        for i in range(len(valid_restrictions_backward) - 1):\n            x1 y1 = valid_restrictions_backward[i]\n            x2 y2 = valid_restrictions_backward[i + 1]\n            available_height = (-x1 + y1 + x2 + y2) // 2\n            if available_height > max_height:\n                max_height = available_height\n\n        return max_height\n\n
Maximum Candies Allocated to K Children,###  2226\. Maximum Candies Allocated to K Children\n\nYou are given a **0-indexed** integer array `candies`. Each element in the\narray denotes a pile of candies of size `candies[i]`. You can divide each pile\ninto any number of **sub piles**  but you **cannot** merge two piles\ntogether.\n\nYou are also given an integer `k`. You should allocate piles of candies to `k`\nchildren such that each child gets the **same** number of candies. Each child\ncan take **at most one** pile of candies and some piles of candies may go\nunused.\n\nReturn _the**maximum number of candies** each child can get._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** candies = [586] k = 3\n    **Output:** 5\n    **Explanation:** We can divide candies[1] into 2 piles of size 5 and 3 and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5 5 3 5 and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** candies = [25] k = 11\n    **Output:** 0\n    **Explanation:** There are 11 children but only 7 candies in total so it is impossible to ensure each child receives at least one candy. Thus each child gets no candy and the answer is 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= candies.length <= 105`\n  * `1 <= candies[i] <= 107`\n  * `1 <= k <= 1012`\n\n,# Runtime: 3294 ms (Top 14.29%) | Memory: 27.4 MB (Top 62.05%)\ndef canSplit(candies mid k):\n    split = 0\n    for i in candies:\n        split += i//mid\n    if split >= k:\n        return True\n    else:\n        return False\n\nclass Solution:\n    def maximumCandies(self candies: List[int] k: int) -> int:\n        end = sum(candies)//k\n        start = 1\n        ans = 0\n        while start <= end:\n            mid = (start + end)//2\n            if canSplit(candies mid k):\n                start = mid + 1\n                ans = mid\n            else:\n                end = mid - 1\n        return ans\n
Maximum Candies You Can Get from Boxes,###  1298\. Maximum Candies You Can Get from Boxes\n\nYou have `n` boxes labeled from `0` to `n - 1`. You are given four arrays:\n`status` `candies` `keys` and `containedBoxes` where:\n\n  * `status[i]` is `1` if the `ith` box is open and `0` if the `ith` box is closed\n  * `candies[i]` is the number of candies in the `ith` box\n  * `keys[i]` is a list of the labels of the boxes you can open after opening the `ith` box.\n  * `containedBoxes[i]` is a list of the boxes you found inside the `ith` box.\n\nYou are given an integer array `initialBoxes` that contains the labels of the\nboxes you initially have. You can take all the candies in **any open box** and\nyou can use the keys in it to open new boxes and you also can use the boxes\nyou find in it.\n\nReturn _the maximum number of candies you can get following the rules above_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** status = [1010] candies = [754100] keys = [[][][1][]] containedBoxes = [[12][3][][]] initialBoxes = [0]\n    **Output:** 16\n    **Explanation:** You will be initially given box 0. You will find 7 candies in it and boxes 1 and 2.\n    Box 1 is closed and you do not have a key for it so you will open box 2. You will find 4 candies and a key to box 1 in box 2.\n    In box 1 you will find 5 candies and box 3 but you will not find a key to box 3 so box 3 will remain closed.\n    Total number of candies collected = 7 + 4 + 5 = 16 candy.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** status = [100000] candies = [111111] keys = [[12345][][][][][]] containedBoxes = [[12345][][][][][]] initialBoxes = [0]\n    **Output:** 6\n    **Explanation:** You have initially box 0. Opening it you can find boxes 1234 and 5 and their keys.\n    The total number of candies will be 6.\n    \n\n\n\n**Constraints:**\n\n  * `n == status.length == candies.length == keys.length == containedBoxes.length`\n  * `1 <= n <= 1000`\n  * `status[i]` is either `0` or `1`.\n  * `1 <= candies[i] <= 1000`\n  * `0 <= keys[i].length <= n`\n  * `0 <= keys[i][j] < n`\n  * All values of `keys[i]` are **unique**.\n  * `0 <= containedBoxes[i].length <= n`\n  * `0 <= containedBoxes[i][j] < n`\n  * All values of `containedBoxes[i]` are unique.\n  * Each box is contained in one box at most.\n  * `0 <= initialBoxes.length <= n`\n  * `0 <= initialBoxes[i] < n`\n\n,"class Solution:\n    count = 0  # Found candy. Class variable to keep found candy\n    def maxCandies(self status: List[int] candies: List[int] keys: List[List[int]] containedBoxes: List[List[int]] initialBoxes: List[int]) -> int:\n        boxes = []  # Newly found boxes\n        progress = False\n        for box in initialBoxes:\n            if status[box]:  # The box is open\n                progress = True\n                boxes.extend(containedBoxes[box])  # Add newly found boxes\n                self.count += candies[box]  # Count found candy\n                for key in keys[box]:\n                    status[key] = 1  # Use found keys to open boxes even if we don't have them.\n            else:\n                boxes.append(box)  # The box is closed. Keep it for the next iteration.\n        if not progress:  # Nothing happened. return.\n            return self.count\n		# Run another iteration with the new 'boxes'\n        return self.maxCandies(status candies keys containedBoxes boxes)\n"
Maximum Compatibility Score Sum,###  1947\. Maximum Compatibility Score Sum\n\nThere is a survey that consists of `n` questions where each question's answer\nis either `0` (no) or `1` (yes).\n\nThe survey was given to `m` students numbered from `0` to `m - 1` and `m`\nmentors numbered from `0` to `m - 1`. The answers of the students are\nrepresented by a 2D integer array `students` where `students[i]` is an integer\narray that contains the answers of the `ith` student (**0-indexed**). The\nanswers of the mentors are represented by a 2D integer array `mentors` where\n`mentors[j]` is an integer array that contains the answers of the `jth` mentor\n(**0-indexed**).\n\nEach student will be assigned to **one** mentor and each mentor will have\n**one** student assigned to them. The **compatibility score** of a student-\nmentor pair is the number of answers that are the same for both the student\nand the mentor.\n\n  * For example if the student's answers were `[1 _0_  _1_]` and the mentor's answers were `[0 _0_  _1_]` then their compatibility score is 2 because only the second and the third answers are the same.\n\nYou are tasked with finding the optimal student-mentor pairings to\n**maximize** the**sum of the compatibility scores**.\n\nGiven `students` and `mentors` return _the**maximum compatibility score sum**\nthat can be achieved._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** students = [[110][101][001]] mentors = [[100][001][110]]\n    **Output:** 8\n    **Explanation:**  We assign students to mentors in the following way:\n    - student 0 to mentor 2 with a compatibility score of 3.\n    - student 1 to mentor 0 with a compatibility score of 2.\n    - student 2 to mentor 1 with a compatibility score of 3.\n    The compatibility score sum is 3 + 2 + 3 = 8.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** students = [[00][00][00]] mentors = [[11][11][11]]\n    **Output:** 0\n    **Explanation:** The compatibility score of any student-mentor pair is 0.\n    \n\n\n\n**Constraints:**\n\n  * `m == students.length == mentors.length`\n  * `n == students[i].length == mentors[j].length`\n  * `1 <= m n <= 8`\n  * `students[i][k]` is either `0` or `1`.\n  * `mentors[j][k]` is either `0` or `1`.\n\n,# Runtime: 104 ms (Top 82.18%) | Memory: 13.9 MB (Top 66.34%)\nimport heapq\nfrom collections import defaultdict\n\nclass Solution:\n    def maxCompatibilitySum(self students: List[List[int]] mentors: List[List[int]]) -> int:\n        m n = len(students) len(students[0])\n        def hamming(student mentor):\n            return sum([int(student[i] != mentor[i]) for i in range(n)])\n\n        pq = [(0 0 '0'*m)] # state: (n-comp_score aka Hamming distance number of assigned students mentor status)\n        optimal = defaultdict(lambda:float('inf'))\n\n        while pq: # O(V)\n            cost i mentor_status = heapq.heappop(pq) # O(logV)\n\n            # early stopping with termination condition\n            if i == m:\n                return m * n - cost\n\n            # generate successors. The next student to be assigned is at index i\n            for j mentor in enumerate(mentors): # O(m)\n                if mentor_status[j] != '1':\n                    new_cost = cost + hamming(students[i] mentor)\n                    new_mentor_status = mentor_status[:j] + '1' + mentor_status[j+1:]\n\n                    # update optimal cost if a new successor appears with lower cost to the same node\n                    if new_cost < optimal[(i+1 new_mentor_status)]:\n                        optimal[(i+1 new_mentor_status)] = new_cost\n                        heapq.heappush(pq (new_cost i+1 new_mentor_status)) # O(logV)\n\n        return 0
Maximum Consecutive Floors Without Special Floors,###  2274\. Maximum Consecutive Floors Without Special Floors\n\nAlice manages a company and has rented some floors of a building as office\nspace. Alice has decided some of these floors should be **special floors** \nused for relaxation only.\n\nYou are given two integers `bottom` and `top` which denote that Alice has\nrented all the floors from `bottom` to `top` (**inclusive**). You are also\ngiven the integer array `special` where `special[i]` denotes a special floor\nthat Alice has designated for relaxation.\n\nReturn _the**maximum** number of consecutive floors without a special floor_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** bottom = 2 top = 9 special = [46]\n    **Output:** 3\n    **Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor:\n    - (2 3) with a total amount of 2 floors.\n    - (5 5) with a total amount of 1 floor.\n    - (7 9) with a total amount of 3 floors.\n    Therefore we return the maximum number which is 3 floors.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** bottom = 6 top = 8 special = [768]\n    **Output:** 0\n    **Explanation:** Every floor rented is a special floor so we return 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= special.length <= 105`\n  * `1 <= bottom <= special[i] <= top <= 109`\n  * All the values of `special` are **unique**.\n\n,class Solution:\n    def maxConsecutive(self bottom: int top: int special: List[int]) -> int:\n        special.sort()\n        special.insert(0 bottom - 1)\n        special.append(top + 1)\n        \n        ans = 0\n        for i in range(len(special)-1):\n            ans = max(ans special[i+1] - special[i] - 1)\n        return ans\n
Maximum Depth of N-ary Tree,###  559\. Maximum Depth of N-ary Tree\n\nGiven a n-ary tree find its maximum depth.\n\nThe maximum depth is the number of nodes along the longest path from the root\nnode down to the farthest leaf node.\n\n_Nary-Tree input serialization is represented in their level order traversal\neach group of children is separated by the null value (See examples)._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n\n    \n    \n    **Input:** root = [1null324null56]\n    **Output:** 3\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n\n    \n    \n    **Input:** root = [1null2345nullnull67null8null910nullnull11null12null13nullnull14]\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * The total number of nodes is in the range `[0 104]`.\n  * The depth of the n-ary tree is less than or equal to `1000`.\n\n,"""\n# Definition for a Node.\nclass Node:\n    def __init__(self val=None children=None):\n        self.val = val\n        self.children = children\n""\n\n#DFS\nclass Solution:\n    def maxDepth(self root: 'Node') -> int:\n        if root is None:\n            return 0\n        def dfs(r):\n            \n            if not r.children:\n                return 1\n            depth = 0\n            for child in r.children:\n                depth = max(depth dfs(child) + 1)\n            \n            return depth\n\n        return dfs(root)\n		\n		\n#BFS \nclass Solution:\n    def maxDepth(self root: 'Node') -> int:\n        if root is None:\n            return 0\n        def bfs(r):\n            \n            q = []\n            q.append(root)\n            level = 0\n            while q != []:\n                    num_nodes = len(q)\n                    level += 1\n                    for _ in  range(num_nodes):\n                        node = q.pop(0)\n\n                        for child in node.children:\n                            q.append(child)\n            return level\n\n        return bfs(root)\n\n"
Maximum Difference Between Increasing Elements,###  2016\. Maximum Difference Between Increasing Elements\n\nGiven a **0-indexed** integer array `nums` of size `n` find the **maximum\ndifference** between `nums[i]` and `nums[j]` (i.e. `nums[j] - nums[i]`) such\nthat `0 <= i < j < n` and `nums[i] < nums[j]`.\n\nReturn _the**maximum difference**. _If no such `i` and `j` exists return\n`-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [7**_1_** **_5_** 4]\n    **Output:** 4\n    **Explanation:**\n    The maximum difference occurs with i = 1 and j = 2 nums[j] - nums[i] = 5 - 1 = 4.\n    Note that with i = 1 and j = 0 the difference nums[j] - nums[i] = 7 - 1 = 6 but i > j so it is not valid.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [9432]\n    **Output:** -1\n    **Explanation:**\n    There is no i and j such that i < j and nums[i] < nums[j].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [**_1_** 52**_10_**]\n    **Output:** 9\n    **Explanation:**\n    The maximum difference occurs with i = 0 and j = 3 nums[j] - nums[i] = 10 - 1 = 9.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `2 <= n <= 1000`\n  * `1 <= nums[i] <= 109`\n\n,class Solution:\n    def maximumDifference(self nums: List[int]) -> int:\n        curmin = nums[0]\n        diff = 0\n        for num in nums:\n            diff = max(diff num - curmin)\n            curmin = min(curmin num)\n        return diff or -1\n
Maximum Difference Between Node and Ancestor,###  1026\. Maximum Difference Between Node and Ancestor\n\nGiven the `root` of a binary tree find the maximum value `v` for which there\nexist **different** nodes `a` and `b` where `v = |a.val - b.val|` and `a` is\nan ancestor of `b`.\n\nA node `a` is an ancestor of `b` if either: any child of `a` is equal to `b`\nor any child of `a` is an ancestor of `b`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg)\n\n    \n    \n    **Input:** root = [831016null14nullnull4713]\n    **Output:** 7\n    **Explanation:** We have various ancestor-node differences some of which are given below :\n    |8 - 3| = 5\n    |3 - 7| = 4\n    |8 - 1| = 7\n    |10 - 13| = 3\n    Among all possible differences the maximum value of 7 is obtained by |8 - 1| = 7.\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/09/tmp-tree-1.jpg)\n\n    \n    \n    **Input:** root = [1null2null03]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[2 5000]`.\n  * `0 <= Node.val <= 105`\n\n,class Solution:\n    def maxAncestorDiff(self root: Optional[TreeNode]) -> int:\n        self.max_diff = float('-inf')\n        \n        def dfs(nodeprev_minprev_max):\n            if not node:\n                return\n            dfs(node.leftmin(prev_minnode.val)max(prev_maxnode.val))\n            dfs(node.rightmin(prev_minnode.val)max(prev_maxnode.val))\n            self.max_diff = max(abs(node.val-prev_min)abs(node.val-prev_max)self.max_diff)\n        dfs(rootroot.valroot.val)\n        return self.max_diff\n
Maximum Earnings From Taxi,###  2008\. Maximum Earnings From Taxi\n\nThere are `n` points on a road you are driving your taxi on. The `n` points on\nthe road are labeled from `1` to `n` in the direction you are going and you\nwant to drive from point `1` to point `n` to make money by picking up\npassengers. You cannot change the direction of the taxi.\n\nThe passengers are represented by a **0-indexed** 2D integer array `rides`\nwhere `rides[i] = [starti endi tipi]` denotes the `ith` passenger requesting\na ride from point `starti` to point `endi` who is willing to give a `tipi`\ndollar tip.\n\nFor**each** passenger `i` you pick up you **earn** `endi - starti + tipi`\ndollars. You may only drive **at most one** passenger at a time.\n\nGiven `n` and `rides` return _the**maximum** number of dollars you can earn\nby picking up the passengers optimally._\n\n**Note:** You may drop off a passenger and pick up a different passenger at\nthe same point.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5 rides = [_[254]_ [151]]\n    **Output:** 7\n    **Explanation:** We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 20 rides = [[161]_[3102]_ _[10123]_ [11122][12152]_[13181]_]\n    **Output:** 20\n    **Explanation:** We will pick up the following passengers:\n    - Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.\n    - Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.\n    - Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.\n    We earn 9 + 5 + 6 = 20 dollars in total.\n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `1 <= rides.length <= 3 * 104`\n  * `rides[i].length == 3`\n  * `1 <= starti < endi <= n`\n  * `1 <= tipi <= 105`\n\n,class Solution:\n    def maxTaxiEarnings(self n: int rides: List[List[int]]) -> int:        \n        rides.sort()\n        for job in rides:\n            job[2]+=job[1]-job[0]\n        \n        heap=[]\n        cur=ans=0\n        for startep in rides:\n            \n            while heap and heap[0][0]<=start: \n                _val=heappop(heap)\n                cur=max(curval)\n            heappush(heap(ecur+p))\n           \n            ans=max(anscur+p)\n            \n        return ans\n
Maximum Employees to Be Invited to a Meeting,###  2127\. Maximum Employees to Be Invited to a Meeting\n\nA company is organizing a meeting and has a list of `n` employees waiting to\nbe invited. They have arranged for a large **circular** table capable of\nseating **any number** of employees.\n\nThe employees are numbered from `0` to `n - 1`. Each employee has a\n**favorite** person and they will attend the meeting **only if** they can sit\nnext to their favorite person at the table. The favorite person of an employee\nis **not** themself.\n\nGiven a **0-indexed** integer array `favorite` where `favorite[i]` denotes\nthe favorite person of the `ith` employee return _the**maximum number of\nemployees** that can be invited to the meeting_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/14/ex1.png)\n\n    \n    \n    **Input:** favorite = [2212]\n    **Output:** 3\n    **Explanation:**\n    The above figure shows how the company can invite employees 0 1 and 2 and seat them at the round table.\n    All employees cannot be invited because employee 2 cannot sit beside employees 0 1 and 3 simultaneously.\n    Note that the company can also invite employees 1 2 and 3 and give them their desired seats.\n    The maximum number of employees that can be invited to the meeting is 3. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** favorite = [120]\n    **Output:** 3\n    **Explanation:** \n    Each employee is the favorite person of at least one other employee and the only way the company can invite them is if they invite every employee.\n    The seating arrangement will be the same as that in the figure given in example 1:\n    - Employee 0 will sit between employees 2 and 1.\n    - Employee 1 will sit between employees 0 and 2.\n    - Employee 2 will sit between employees 1 and 0.\n    The maximum number of employees that can be invited to the meeting is 3.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/12/14/ex2.png)\n\n    \n    \n    **Input:** favorite = [30141]\n    **Output:** 4\n    **Explanation:**\n    The above figure shows how the company will invite employees 0 1 3 and 4 and seat them at the round table.\n    Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.\n    So the company leaves them out of the meeting.\n    The maximum number of employees that can be invited to the meeting is 4.\n    \n\n\n\n**Constraints:**\n\n  * `n == favorite.length`\n  * `2 <= n <= 105`\n  * `0 <= favorite[i] <= n - 1`\n  * `favorite[i] != i`\n\n,class Solution:\n    def maximumInvitations(self favorite: List[int]) -> int:\n        n = len(favorite)\n        visited_time = [0] * n\n        inpath = [False] * n\n        cur_time = 1\n        def get_max_len_cycle(cur) :\n            nonlocal cur_time\n            inpath[cur] visited_time[cur] nxt = True cur_time favorite[cur]\n            cur_time += 1\n            ret = 0 if not inpath[nxt] else visited_time[cur] - visited_time[nxt] + 1\n            if visited_time[nxt] == 0 : ret = max(ret get_max_len_cycle(nxt))\n            inpath[cur] = False\n            return ret\n        \n        ret_cycle = 0\n        for i in range(n) :\n            if visited_time[i] == 0 :\n                ret_cycle = max(ret_cycle get_max_len_cycle(i))\n        \n        ret_not_cycle = 0\n        back_edge_graph = [[] for _ in range(n)]\n        for i in range(n) : back_edge_graph[favorite[i]].append(i)\n        def get_max_depth(cur) :\n            ret = 0\n            for nxt in back_edge_graph[cur] :\n                if favorite[cur] != nxt :\n                    ret = max(ret get_max_depth(nxt) + 1)\n            return ret\n        \n        for i in range(n) :\n            if favorite[favorite[i]] == i : ret_not_cycle += get_max_depth(i) + 1\n        \n        ret = max(ret_cycle ret_not_cycle)\n        return ret\n
Maximum Erasure Value,###  1695\. Maximum Erasure Value\n\nYou are given an array of positive integers `nums` and want to erase a\nsubarray containing **unique elements**. The **score** you get by erasing the\nsubarray is equal to the **sum** of its elements.\n\nReturn _the**maximum score** you can get by erasing **exactly one** subarray._\n\nAn array `b` is called to be a subarray of `a` if it forms a contiguous\nsubsequence of `a` that is if it is equal to `a[l]a[l+1]...a[r]` for some\n`(lr)`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [42456]\n    **Output:** 17\n    **Explanation:** The optimal subarray here is [2456].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [521252125]\n    **Output:** 8\n    **Explanation:** The optimal subarray here is [521] or [125].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 104`\n\n,"// Runtime: 796 ms (Top 99.64%) | Memory: 29.60 MB (Top 94.86%)\n\nclass Solution:\n	def maximumUniqueSubarray(self nums: List[int]) -> int:\n		low = 0\n		visited = set()\n		result = 0\n		curSum = 0\n		for high in range(len(nums)):\n			while nums[high] in visited:\n				visited.remove(nums[low])\n				curSum -= nums[low]\n				low+=1\n\n			visited.add(nums[high])\n			curSum += nums[high]\n\n			if curSum > result:\n				result = curSum\n\n		return result\n"
Maximum Frequency Stack,"###  895\. Maximum Frequency Stack\n\nDesign a stack-like data structure to push elements to the stack and pop the\nmost frequent element from the stack.\n\nImplement the `FreqStack` class:\n\n  * `FreqStack()` constructs an empty frequency stack.\n  * `void push(int val)` pushes an integer `val` onto the top of the stack.\n  * `int pop()` removes and returns the most frequent element in the stack. \n    * If there is a tie for the most frequent element the element closest to the stack's top is removed and returned.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""FreqStack"" ""push"" ""push"" ""push"" ""push"" ""push"" ""push"" ""pop"" ""pop"" ""pop"" ""pop""]\n    [[] [5] [7] [5] [7] [4] [5] [] [] [] []]\n    **Output**\n    [null null null null null null null 5 7 5 4]\n    \n    **Explanation**\n    FreqStack freqStack = new FreqStack();\n    freqStack.push(5); // The stack is [5]\n    freqStack.push(7); // The stack is [57]\n    freqStack.push(5); // The stack is [575]\n    freqStack.push(7); // The stack is [5757]\n    freqStack.push(4); // The stack is [57574]\n    freqStack.push(5); // The stack is [575745]\n    freqStack.pop();   // return 5 as 5 is the most frequent. The stack becomes [57574].\n    freqStack.pop();   // return 7 as 5 and 7 is the most frequent but 7 is closest to the top. The stack becomes [5754].\n    freqStack.pop();   // return 5 as 5 is the most frequent. The stack becomes [574].\n    freqStack.pop();   // return 4 as 4 5 and 7 is the most frequent but 4 is closest to the top. The stack becomes [57].\n    \n\n\n\n**Constraints:**\n\n  * `0 <= val <= 109`\n  * At most `2 * 104` calls will be made to `push` and `pop`.\n  * It is guaranteed that there will be at least one element in the stack before calling `pop`.\n\n",# Runtime: 347 ms (Top 94.76%) | Memory: 22.7 MB (Top 60.86%)\nclass FreqStack:\n\n    def __init__(self):\n        self.cnt = {}\n        self.maxcount = 0\n        self.stack = {}\n\n    def push(self val: int) -> None:\n        count = self.cnt.get(val0)+1\n        self.cnt[val] = count\n        if count>self.maxcount:\n            self.maxcount = count\n            self.stack[count] = []\n        self.stack[count].append(val)\n\n    def pop(self) -> int:\n        res = self.stack[self.maxcount].pop()\n        self.cnt[res]-=1\n        if not self.stack[self.maxcount]:\n            self.maxcount-=1\n        return res\n\n# Your FreqStack object will be instantiated and called as such:\n# obj = FreqStack()\n# obj.push(val)\n# param_2 = obj.pop()
Maximum Fruits Harvested After at Most K Steps,###  2106\. Maximum Fruits Harvested After at Most K Steps\n\nFruits are available at some positions on an infinite x-axis. You are given a\n2D integer array `fruits` where `fruits[i] = [positioni amounti]` depicts\n`amounti` fruits at the position `positioni`. `fruits` is already **sorted**\nby `positioni` in **ascending order**  and each `positioni` is **unique**.\n\nYou are also given an integer `startPos` and an integer `k`. Initially you\nare at the position `startPos`. From any position you can either walk to the\n**left or right**. It takes **one step** to move **one unit** on the x-axis\nand you can walk **at most** `k` steps in total. For every position you reach\nyou harvest all the fruits at that position and the fruits will disappear\nfrom that position.\n\nReturn _the**maximum total number** of fruits you can harvest_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/11/21/1.png)\n\n    \n    \n    **Input:** fruits = [[28][63][86]] startPos = 5 k = 4\n    **Output:** 9\n    **Explanation:** \n    The optimal way is to:\n    - Move right to position 6 and harvest 3 fruits\n    - Move right to position 8 and harvest 6 fruits\n    You moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/11/21/2.png)\n\n    \n    \n    **Input:** fruits = [[09][41][57][62][74][109]] startPos = 5 k = 4\n    **Output:** 14\n    **Explanation:** \n    You can move at most k = 4 steps so you cannot reach position 0 nor 10.\n    The optimal way is to:\n    - Harvest the 7 fruits at the starting position 5\n    - Move left to position 4 and harvest 1 fruit\n    - Move right to position 6 and harvest 2 fruits\n    - Move right to position 7 and harvest 4 fruits\n    You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/11/21/3.png)\n\n    \n    \n    **Input:** fruits = [[03][64][85]] startPos = 3 k = 2\n    **Output:** 0\n    **Explanation:**\n    You can move at most k = 2 steps and cannot reach any position with fruits.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= fruits.length <= 105`\n  * `fruits[i].length == 2`\n  * `0 <= startPos positioni <= 2 * 105`\n  * `positioni-1 < positioni` for any `i > 0` (**0-indexed**)\n  * `1 <= amounti <= 104`\n  * `0 <= k <= 2 * 105`\n\n,# Runtime: 5941 ms (Top 24.26%) | Memory: 59.9 MB (Top 86.39%)\nclass Solution:\n    def maxTotalFruits(self fruits: List[List[int]] startPos: int k: int) -> int:\n        arr = [0 for _ in range(2*k+1)]\n        for pos numOfFruit in fruits:\n            if pos < startPos-k or pos > startPos+k:\n                continue\n            arr[pos-(startPos-k)] += numOfFruit\n\n        left right = sum(arr[:k+1]) sum(arr[k:])\n        maxSeen = max(left right)\n\n        turn = 1 # turning point\n        for i in range(2 k+1 2):\n            left = left-arr[i-2]-arr[i-1]+arr[k+turn]\n            right = right-arr[~(i-2)]-arr[~(i-1)]+arr[k-turn]\n            maxSeen = max(maxSeen left right)\n            turn += 1\n\n        return maxSeen
Maximum Gap,###  164\. Maximum Gap\n\nGiven an integer array `nums` return _the maximum difference between two\nsuccessive elements in its sorted form_. If the array contains less than two\nelements return `0`.\n\nYou must write an algorithm that runs in linear time and uses linear extra\nspace.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3691]\n    **Output:** 3\n    **Explanation:** The sorted form of the array is [1369] either (36) or (69) has the maximum difference 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [10]\n    **Output:** 0\n    **Explanation:** The array contains less than 2 elements therefore return 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 109`\n\n,"class Solution:\n    def maximumGap(self nums: List[int]) -> int:\n        if len(nums)<2: return 0\n        \n        #radix sort\n        #N = length of nums\n        #find number of digits in largest number - O(K) where K = length of largest number\n        longest = 0\n        for i in nums:\n            longest = max(longestlen(str(i)))\n            \n        #normalize so that all numbers have same number of digits by adding 0s at the start of shorter numbers - O(N*K)\n        for i in range(len(nums)):\n            if len(str(nums[i]))!=longest:\n                nums[i] = '0'*(longest-len(str(nums[i]))) + str(nums[i])\n            else:\n                nums[i] = str(nums[i])\n        \n        #apply counting sort starting with each digit from the end of the last digits - O(K*N)\n        for digit in range(longest-1-1-1):\n            vals = [[] for k in range(10)]\n            for num in nums:\n                vals[int(num[digit])] += [num]\n			#join list sorted by that digit position together:\n            new = []\n            for i in vals:\n                new += i\n            nums = new.copy()\n        \n        #find the largest difference in the now sorted nums - O(N)\n        best_diff = 0\n        for i in range(1len(nums)):\n            best_diff = max(best_diffint(nums[i])-int(nums[i-1]))\n        return best_diff\n    \n#Overall complexity is O(N*K) but K is at most 10 so O(10*N) = O(N) so linear\n#Please correct me if I am wrong!\n"
Maximum Genetic Difference Query,###  1938\. Maximum Genetic Difference Query\n\nThere is a rooted tree consisting of `n` nodes numbered `0` to `n - 1`. Each\nnode's number denotes its **unique genetic value** (i.e. the genetic value of\nnode `x` is `x`). The **genetic difference** between two genetic values is\ndefined as the **bitwise-****XOR** of their values. You are given the integer\narray `parents` where `parents[i]` is the parent for node `i`. If node `x` is\nthe **root** of the tree then `parents[x] == -1`.\n\nYou are also given the array `queries` where `queries[i] = [nodei vali]`. For\neach query `i` find the **maximum genetic difference** between `vali` and\n`pi` where `pi` is the genetic value of any node that is on the path between\n`nodei` and the root (including `nodei` and the root). More formally you want\nto maximize `vali XOR pi`.\n\nReturn _an array_`ans` _where_`ans[i]`_is the answer to the_`ith` _query_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/29/c1.png)\n\n    \n    \n    **Input:** parents = [-1011] queries = [[02][32][25]]\n    **Output:** [237]\n    **Explanation:** The queries are processed as follows:\n    - [02]: The node with the maximum genetic difference is 0 with a difference of 2 XOR 0 = 2.\n    - [32]: The node with the maximum genetic difference is 1 with a difference of 2 XOR 1 = 3.\n    - [25]: The node with the maximum genetic difference is 2 with a difference of 5 XOR 2 = 7.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/29/c2.png)\n\n    \n    \n    **Input:** parents = [37-120702] queries = [[46][115][05]]\n    **Output:** [6147]\n    **Explanation:** The queries are processed as follows:\n    - [46]: The node with the maximum genetic difference is 0 with a difference of 6 XOR 0 = 6.\n    - [115]: The node with the maximum genetic difference is 1 with a difference of 15 XOR 1 = 14.\n    - [05]: The node with the maximum genetic difference is 2 with a difference of 5 XOR 2 = 7.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= parents.length <= 105`\n  * `0 <= parents[i] <= parents.length - 1` for every node `i` that is **not** the root.\n  * `parents[root] == -1`\n  * `1 <= queries.length <= 3 * 104`\n  * `0 <= nodei <= parents.length - 1`\n  * `0 <= vali <= 2 * 105`\n\n,"# Runtime: 6663 ms (Top 46.4%) | Memory: 339.09 MB (Top 7.1%)\n\nclass Solution:\n    def maxGeneticDifference(self parents: List[int] queries: List[List[int]]) -> List[int]:\n        adj_map = collections.defaultdict(set)\n        root = None\n        for i node in enumerate(parents):\n            if node == -1:\n                root = i\n            else:\n                adj_map[node].add(i)\n        queries_map = collections.defaultdict(set)\n\n        for q in queries:\n            queries_map[q[0]].add(q[1])\n        self.res_map = {}\n        def helperDFS(curr_rootprefix_map):\n\n            if curr_root in queries_map:\n                for val in queries_map[curr_root]:\n                    bin_rep = format(val '020b')\n                    best_bin = """"\n                    print(bin_rep)\n                    for i in range(20):\n                        if prefix_map[best_bin+str(1-int(bin_rep[i]))]:\n                            best_bin += str(1-int(bin_rep[i]))\n                        else:\n                            best_bin += bin_rep[i]\n                    self.res_map[(curr_rootval)] = int(best_bin2) ^ val \n            for child in adj_map[curr_root]:\n                bin_rep = format(child '020b')\n                for i in range(1 len(bin_rep)+1):\n                    prefix_map[bin_rep[0:i]].add(child)\n                helperDFS(child prefix_map)\n                for i in range(1 len(bin_rep)+1):\n                    prefix_map[bin_rep[0:i]].remove(child)\n\n        initial_prefixmap = collections.defaultdict(set)\n        root_rep = format(root '020b')\n        for i in range(121):\n            initial_prefixmap[root_rep[0:i]].add(root)\n        helperDFS(root initial_prefixmap)\n        res = []\n        for q in queries:\n            res.append(self.res_map[(q[0]q[1])])\n        return res\n            \n"
Maximum Good People Based on Statements,###  2151\. Maximum Good People Based on Statements\n\nThere are two types of persons:\n\n  * The **good person** : The person who always tells the truth.\n  * The **bad person** : The person who might tell the truth and might lie.\n\nYou are given a **0-indexed** 2D integer array `statements` of size `n x n`\nthat represents the statements made by `n` people about each other. More\nspecifically `statements[i][j]` could be one of the following:\n\n  * `0` which represents a statement made by person `i` that person `j` is a **bad** person.\n  * `1` which represents a statement made by person `i` that person `j` is a **good** person.\n  * `2` represents that **no statement** is made by person `i` about person `j`.\n\nAdditionally no person ever makes a statement about themselves. Formally we\nhave that `statements[i][i] = 2` for all `0 <= i < n`.\n\nReturn _the**maximum** number of people who can be **good** based on the\nstatements made by the _`n` _people_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/01/15/logic1.jpg)\n\n    \n    \n    **Input:** statements = [[212][122][202]]\n    **Output:** 2\n    **Explanation:** Each person makes a single statement.\n    - Person 0 states that person 1 is good.\n    - Person 1 states that person 0 is good.\n    - Person 2 states that person 1 is bad.\n    Let's take person 2 as the key.\n    - Assuming that person 2 is a good person:\n        - Based on the statement made by person 2 person 1 is a bad person.\n        - Now we know for sure that person 1 is bad and person 2 is good.\n        - Based on the statement made by person 1 and since person 1 is bad they could be:\n            - telling the truth. There will be a contradiction in this case and this assumption is invalid.\n            - lying. In this case person 0 is also a bad person and lied in their statement.\n        - **Following that person 2 is a good person there will be only one good person in the group**.\n    - Assuming that person 2 is a bad person:\n        - Based on the statement made by person 2 and since person 2 is bad they could be:\n            - telling the truth. Following this scenario person 0 and 1 are both bad as explained before.\n                - **Following that person 2 is bad but told the truth there will be no good persons in the group**.\n            - lying. In this case person 1 is a good person.\n                - Since person 1 is a good person person 0 is also a good person.\n                - **Following that person 2 is bad and lied there will be two good persons in the group**.\n    We can see that at most 2 persons are good in the best case so we return 2.\n    Note that there is more than one way to arrive at this conclusion.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/01/15/logic2.jpg)\n\n    \n    \n    **Input:** statements = [[20][02]]\n    **Output:** 1\n    **Explanation:** Each person makes a single statement.\n    - Person 0 states that person 1 is bad.\n    - Person 1 states that person 0 is bad.\n    Let's take person 0 as the key.\n    - Assuming that person 0 is a good person:\n        - Based on the statement made by person 0 person 1 is a bad person and was lying.\n        - **Following that person 0 is a good person there will be only one good person in the group**.\n    - Assuming that person 0 is a bad person:\n        - Based on the statement made by person 0 and since person 0 is bad they could be:\n            - telling the truth. Following this scenario person 0 and 1 are both bad.\n                - **Following that person 0 is bad but told the truth there will be no good persons in the group**.\n            - lying. In this case person 1 is a good person.\n                - **Following that person 0 is bad and lied there will be only one good person in the group**.\n    We can see that at most one person is good in the best case so we return 1.\n    Note that there is more than one way to arrive at this conclusion.\n    \n\n\n\n**Constraints:**\n\n  * `n == statements.length == statements[i].length`\n  * `2 <= n <= 15`\n  * `statements[i][j]` is either `0` `1` or `2`.\n  * `statements[i][i] == 2`\n\n,class Solution:\n    def maximumGood(self S):\n        n ans = len(S) 0\n        def valid(cur):\n            for i in range(n):\n                if cur[i]:\n                    for j in range(n):\n                        if S[i][j] != 2 and S[i][j] != cur[j]: return False\n            return True;\n        def dfs(cur i cnt):\n            nonlocal ans\n            if i == n:\n                if valid(cur): ans = max(ans cnt)\n                return\n            cur.append(0)\n            dfs(cur i+1 cnt)\n            cur[-1] = 1\n            dfs(cur i+1 cnt+1)\n            cur.pop()\n        \n        dfs([] 0 0)\n        return ans\n        \n
Maximum Height by Stacking Cuboids,###  1691\. Maximum Height by Stacking Cuboids\n\nGiven `n` `cuboids` where the dimensions of the `ith` cuboid is `cuboids[i] =\n[widthi lengthi heighti]` (**0-indexed**). Choose a **subset** of `cuboids`\nand place them on each other.\n\nYou can place cuboid `i` on cuboid `j` if `widthi <= widthj` and `lengthi <=\nlengthj` and `heighti <= heightj`. You can rearrange any cuboid's dimensions\nby rotating it to put it on another cuboid.\n\nReturn _the**maximum height** of the stacked_ `cuboids`.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2019/10/21/image.jpg)**\n\n    \n    \n    **Input:** cuboids = [[504520][953753][452312]]\n    **Output:** 190\n    **Explanation:**\n    Cuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.\n    Cuboid 0 is placed next with the 45x20 side facing down with height 50.\n    Cuboid 2 is placed next with the 23x12 side facing down with height 45.\n    The total height is 95 + 50 + 45 = 190.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cuboids = [[382545][76353]]\n    **Output:** 76\n    **Explanation:**\n    You can't place any of the cuboids on the other.\n    We choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** cuboids = [[71117][71711][11717][11177][17711][17117]]\n    **Output:** 102\n    **Explanation:**\n    After rearranging the cuboids you can see that all cuboids have the same dimension.\n    You can place the 11x7 side down on all cuboids so their heights are 17.\n    The maximum height of stacked cuboids is 6 * 17 = 102.\n    \n\n\n\n**Constraints:**\n\n  * `n == cuboids.length`\n  * `1 <= n <= 100`\n  * `1 <= widthi lengthi heighti <= 100`\n\n,# Runtime: 199 ms (Top 36.11%) | Memory: 13.8 MB (Top 87.22%)\n\nclass Solution:\n    def maxHeight(self cuboids: List[List[int]]) -> int:\n        dp=[0]*len(cuboids)\n        max_value=0\n        for i in range(len(cuboids)):\n            cuboids[i].sort()\n        cuboids.sort()\n        for i in range(len(cuboids)):\n            dp[i]=cuboids[i][2]\n            for j in range(i):\n                if cuboids[i][0]>=cuboids[j][0] and cuboids[i][1]>=cuboids[j][1] and cuboids[i][2]>=cuboids[j][2]:\n                    dp[i]=max(dp[i]dp[j]+cuboids[i][2])\n            if dp[i]>max_value:\n                max_value=dp[i]\n        return max_value
Maximum Ice Cream Bars,###  1833\. Maximum Ice Cream Bars\n\nIt is a sweltering summer day and a boy wants to buy some ice cream bars.\n\nAt the store there are `n` ice cream bars. You are given an array `costs` of\nlength `n` where `costs[i]` is the price of the `ith` ice cream bar in coins.\nThe boy initially has `coins` coins to spend and he wants to buy as many ice\ncream bars as possible.\n\nReturn _the**maximum** number of ice cream bars the boy can buy with _`coins`\n_coins._\n\n**Note:** The boy can buy the ice cream bars in any order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** costs = [13241] coins = 7\n    **Output:** 4\n    **Explanation:** The boy can buy ice cream bars at indices 0124 for a total price of 1 + 3 + 2 + 1 = 7.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** costs = [1068778] coins = 5\n    **Output:** 0\n    **Explanation:** The boy cannot afford any of the ice cream bars.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** costs = [163125] coins = 20\n    **Output:** 6\n    **Explanation:** The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.\n    \n\n\n\n**Constraints:**\n\n  * `costs.length == n`\n  * `1 <= n <= 105`\n  * `1 <= costs[i] <= 105`\n  * `1 <= coins <= 108`\n\n,class Solution:\n    def maxIceCream(self costs: List[int] coins: int) -> int:\n        costs.sort()\n        i= 0\n        for price in costs:\n            if price<= coins:\n                i+= 1\n                coins-= price\n            else:\n                break\n        return i
Maximum Length of a Concatenated String with Unique Characters,"###  1239\. Maximum Length of a Concatenated String with Unique Characters\n\nYou are given an array of strings `arr`. A string `s` is formed by the\n**concatenation** of a **subsequence** of `arr` that has **unique\ncharacters**.\n\nReturn _the**maximum** possible length_ of `s`.\n\nA **subsequence** is an array that can be derived from another array by\ndeleting some or no elements without changing the order of the remaining\nelements.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [""un""""iq""""ue""]\n    **Output:** 4\n    **Explanation:** All the valid concatenations are:\n    - """"\n    - ""un""\n    - ""iq""\n    - ""ue""\n    - ""uniq"" (""un"" + ""iq"")\n    - ""ique"" (""iq"" + ""ue"")\n    Maximum length is 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [""cha""""r""""act""""ers""]\n    **Output:** 6\n    **Explanation:** Possible longest valid concatenations are ""chaers"" (""cha"" + ""ers"") and ""acters"" (""act"" + ""ers"").\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [""abcdefghijklmnopqrstuvwxyz""]\n    **Output:** 26\n    **Explanation:** The only string in arr has all 26 characters.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 16`\n  * `1 <= arr[i].length <= 26`\n  * `arr[i]` contains only lowercase English letters.\n\n",# Runtime: 266 ms (Top 32.10%) | Memory: 14.1 MB (Top 35.69%)\nclass Solution:\n    def maxLength(self arr: List[str]) -> int:\n        ans = 0\n        count = [0]*26\n        counts = []\n        new_arr = []\n\n        for string in arr:\n            flag = True\n            tmp = [0]*26\n            for ch in string:\n                if tmp[ord(ch) - 97] == True:\n                    flag = False\n                    break\n                else:\n                    tmp[ord(ch) - 97] = True\n\n            if flag == False:continue\n            counts.append(tmp)\n            new_arr.append(string)\n\n        n = len(new_arr)\n\n        def compatible(ab):\n            for i in range(26):\n                if a[i] == True and b[i] == True: return False\n            return True\n\n        def addUp(ab):\n            for i in range(26):\n                if b[i] == True: a[i] = True\n\n        def solve(indexcount):\n            if index == n:return 0\n            cpy = count.copy()\n            ch1 = -inf\n            if compatible(countcounts[index]):\n                addUp(countcounts[index])\n                ch1 = solve(index+1count) + len(new_arr[index])\n            ch2 = solve(index+1  cpy)\n            ans = max(ch1ch2)\n            return ans\n\n        return solve(0count)
Maximum Length of Pair Chain,###  646\. Maximum Length of Pair Chain\n\nYou are given an array of `n` pairs `pairs` where `pairs[i] = [lefti righti]`\nand `lefti < righti`.\n\nA pair `p2 = [c d]` **follows** a pair `p1 = [a b]` if `b < c`. A **chain**\nof pairs can be formed in this fashion.\n\nReturn _the length longest chain which can be formed_.\n\nYou do not need to use up all the given intervals. You can select pairs in any\norder.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** pairs = [[12][23][34]]\n    **Output:** 2\n    **Explanation:** The longest chain is [12] -> [34].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** pairs = [[12][78][45]]\n    **Output:** 3\n    **Explanation:** The longest chain is [12] -> [45] -> [78].\n    \n\n\n\n**Constraints:**\n\n  * `n == pairs.length`\n  * `1 <= n <= 1000`\n  * `-1000 <= lefti < righti <= 1000`\n\n,class Solution {\npublic:\n    int findLongestChain(vector<vector<int>>& arr) {\n      \n       if(arr.size()==1)\n       {\n           return 1;\n       }\n       vector<pair<intint>>v;\n       for(int i=0;i<arr.size();i++)\n       {\n           v.push_back({arr[i][0]arr[i][1]});\n       }\n       sort(v.begin()v.end());\n       \n       vector<int>dp(v.size()0);\n       int ans=INT_MIN; \n       dp[0]=1;\n       for(int i=1;i<v.size();i++)\n       {\n           int temp=0;\n           for(int j=i-1;j>=0;j--)\n           {\n               if(v[j].second<v[i].first)\n               {\n                   temp=max(tempdp[j]);\n               }\n           }\n           dp[i]=1+temp;\n           ans=max(ansdp[i]);\n       }\n       return ans;\n    }\n};\n
Maximum Length of Repeated Subarray,###  718\. Maximum Length of Repeated Subarray\n\nGiven two integer arrays `nums1` and `nums2` return _the maximum length of a\nsubarray that appears in**both** arrays_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [12321] nums2 = [32147]\n    **Output:** 3\n    **Explanation:** The repeated subarray with maximum length is [321].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [00000] nums2 = [00000]\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 1000`\n  * `0 <= nums1[i] nums2[i] <= 100`\n\n,class Solution:\n    def findLength(self nums1: List[int] nums2: List[int]) -> int:\n        dp = [[0]*(len(nums1)+ 1) for _ in range(len(nums2) + 1)]\n        max_len = 0\n        for row in range(len(nums2)):\n            for col in range(len(nums1)):\n                if nums2[row] == nums1[col]:\n                    dp[row][col] = 1 + dp[row - 1][col - 1]\n                    max_len = max(max_lendp[row][col])\n                else:\n                    dp[row][col] = 0\n        return max_len\n    \n
Maximum Length of Subarray With Positive Product,###  1567\. Maximum Length of Subarray With Positive Product\n\nGiven an array of integers `nums` find the maximum length of a subarray where\nthe product of all its elements is positive.\n\nA subarray of an array is a consecutive sequence of zero or more values taken\nout of that array.\n\nReturn _the maximum length of a subarray with positive product_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1-2-34]\n    **Output:** 4\n    **Explanation:** The array nums already has a positive product of 24.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [01-2-3-4]\n    **Output:** 3\n    **Explanation:** The longest subarray with positive product is [1-2-3] which has a product of 6.\n    Notice that we cannot include 0 in the subarray since that'll make the product 0 which is not positive.\n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [-1-2-301]\n    **Output:** 2\n    **Explanation:** The longest subarray with positive product is [-1-2] or [-2-3].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-109 <= nums[i] <= 109`\n\n,class Solution:\n    def getMaxLen(self arr: List[int]) -> int:\n        n=len(arr)\n        def solve(nums):\n            ijlast_negnegans=00None00\n            while j<n:\n                while j<n and nums[j]!=0:\n                    if nums[j]<0: \n                        neg+=1\n                        last_neg=j\n                    j+=1\n                if neg%2==0:\n                    ans=max(ansj-i)\n                elif last_neg!=None:\n                    ans=max(anslast_neg-ij-last_neg-1)\n                ijneglast_neg=j+1j+10None\n            return ans\n        return max(solve(arr)solve(arr[::-1]))\n\n        \n            \n            \n
Maximum Level Sum of a Binary Tree,###  1161\. Maximum Level Sum of a Binary Tree\n\nGiven the `root` of a binary tree the level of its root is `1` the level of\nits children is `2` and so on.\n\nReturn the **smallest** level `x` such that the sum of all the values of nodes\nat level `x` is **maximal**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/05/03/capture.JPG)\n\n    \n    \n    **Input:** root = [1707-8nullnull]\n    **Output:** 2\n    **Explanation:**\n    Level 1 sum = 1.\n    Level 2 sum = 7 + 0 = 7.\n    Level 3 sum = 7 + -8 = -1.\n    So we return the level with the maximum sum which is level 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [989null1025098693-89388nullnullnull-32127]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `-105 <= Node.val <= 105`\n\n, class Solution:\n    def maxLevelSum(self root: Optional[TreeNode]) -> int:\n        global_max = float('-inf')\n        res = -1\n        q = deque([root])\n        lvl = 1\n        while q:\n            total = 0\n            for _ in range(len(q)):\n                node = q.popleft()\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n                total+=node.val\n            if total>global_max:\n                res = lvl\n                global_max = total\n            lvl+=1\n        return res\n
Maximum Nesting Depth of the Parentheses,"###  1614\. Maximum Nesting Depth of the Parentheses\n\nA string is a **valid parentheses string** (denoted **VPS**) if it meets one\nof the following:\n\n  * It is an empty string `""""` or a single character not equal to `""(""` or `"")""`\n  * It can be written as `AB` (`A` concatenated with `B`) where `A` and `B` are **VPS** 's or\n  * It can be written as `(A)` where `A` is a **VPS**.\n\nWe can similarly define the **nesting depth** `depth(S)` of any VPS `S` as\nfollows:\n\n  * `depth("""") = 0`\n  * `depth(C) = 0` where `C` is a string with a single character not equal to `""(""` or `"")""`.\n  * `depth(A + B) = max(depth(A) depth(B))` where `A` and `B` are **VPS** 's.\n  * `depth(""("" + A + "")"") = 1 + depth(A)` where `A` is a **VPS**.\n\nFor example `""""` `""()()""` and `""()(()())""` are **VPS** 's (with nesting\ndepths 0 1 and 2) and `"")(""` and `""(()""` are not **VPS** 's.\n\nGiven a **VPS** represented as string `s` return _the**nesting depth** of\n_`s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""(1+(2*3)+((_8_)/4))+1""\n    **Output:** 3\n    **Explanation:** Digit 8 is inside of 3 nested parentheses in the string.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""(1)+((2))+(((_3_)))""\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s` consists of digits `0-9` and characters `'+'` `'-'` `'*'` `'/'` `'('` and `')'`.\n  * It is guaranteed that parentheses expression `s` is a **VPS**.\n\n",class Solution:\n    def maxDepth(self s: str) -> int:\n        ans = cur = 0\n        for c in s:\n            if c == '(':\n                cur += 1\n                ans = max(ans cur)\n            elif c == ')':\n                cur -= 1\n        return ans \n
Maximum Nesting Depth of Two Valid Parentheses Strings,"###  1111\. Maximum Nesting Depth of Two Valid Parentheses Strings\n\nA string is a _valid parentheses string_  (denoted VPS) if and only if it\nconsists of `""(""` and `"")""` characters only and:\n\n  * It is the empty string or\n  * It can be written as `AB` (`A` concatenated with `B`) where `A` and `B` are VPS's or\n  * It can be written as `(A)` where `A` is a VPS.\n\nWe can similarly define the _nesting depth_ `depth(S)` of any VPS `S` as\nfollows:\n\n  * `depth("""") = 0`\n  * `depth(A + B) = max(depth(A) depth(B))` where `A` and `B` are VPS's\n  * `depth(""("" + A + "")"") = 1 + depth(A)` where `A` is a VPS.\n\nFor example  `""""` `""()()""` and `""()(()())""` are VPS's (with nesting depths\n0 1 and 2) and `"")(""` and `""(()""` are not VPS's.\n\n\n\nGiven a VPS seq split it into two disjoint subsequences `A` and `B` such\nthat `A` and `B` are VPS's (and `A.length + B.length = seq.length`).\n\nNow choose **any** such `A` and `B` such that `max(depth(A) depth(B))` is the\nminimum possible value.\n\nReturn an `answer` array (of length `seq.length`) that encodes such a choice\nof `A` and `B`:  `answer[i] = 0` if `seq[i]` is part of `A` else `answer[i] =\n1`.  Note that even though multiple answers may exist you may return any of\nthem.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** seq = ""(()())""\n    **Output:** [011110]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** seq = ""()(())()""\n    **Output:** [00011011]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= seq.size <= 10000`\n\n",class Solution:\n    def maxDepthAfterSplit(self seq: str) -> List[int]:\n        ans = []\n        last = 1\n        for i in seq:\n            if i == '(':\n                if last == 0: ans.append(1)\n                else:ans.append(0)\n            else:\n                ans.append(last)\n            last = (last + 1) % 2\n        return ans\n
Maximum Non Negative Product in a Matrix,###  1594\. Maximum Non Negative Product in a Matrix\n\nYou are given a `m x n` matrix `grid`. Initially you are located at the top-\nleft corner `(0 0)` and in each step you can only **move right or down** in\nthe matrix.\n\nAmong all possible paths starting from the top-left corner `(0 0)` and ending\nin the bottom-right corner `(m - 1 n - 1)` find the path with the **maximum\nnon-negative product**. The product of a path is the product of all integers\nin the grid cells visited along the path.\n\nReturn the _maximum non-negative product**modulo** _`109 + 7`. _If the maximum\nproduct is**negative**  return _`-1`.\n\nNotice that the modulo is performed after getting the maximum product.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/23/product1.jpg)\n\n    \n    \n    **Input:** grid = [[-1-2-3][-2-3-3][-3-3-2]]\n    **Output:** -1\n    **Explanation:** It is not possible to get non-negative product in the path from (0 0) to (2 2) so return -1.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/23/product2.jpg)\n\n    \n    \n    **Input:** grid = [[1-21][1-21][3-41]]\n    **Output:** 8\n    **Explanation:** Maximum non-negative product is shown (1 * 1 * -2 * -4 * 1 = 8).\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/12/23/product3.jpg)\n\n    \n    \n    **Input:** grid = [[13][0-4]]\n    **Output:** 0\n    **Explanation:** Maximum non-negative product is shown (1 * 0 * -4 = 0).\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 15`\n  * `-4 <= grid[i][j] <= 4`\n\n,"# Runtime: 63 ms (Top 56.0%) | Memory: 16.84 MB (Top 17.4%)\n\nclass Solution:\n    def maxProductPath(self grid: List[List[int]]) -> int:\n        m n = len(grid) len(grid[0])\n        \n        @lru_cache(None)\n        def fn(i j): \n            """"""Return maximum & minimum products ending at (i j).""""""\n            if i == 0 and j == 0: return grid[0][0] grid[0][0]\n            if i < 0 or j < 0: return -inf inf\n            if grid[i][j] == 0: return 0 0\n            mx1 mn1 = fn(i-1 j) # from top\n            mx2 mn2 = fn(i j-1) # from left \n            mx mn = max(mx1 mx2)*grid[i][j] min(mn1 mn2)*grid[i][j]\n            return (mx mn) if grid[i][j] > 0 else (mn mx)\n        \n        mx _ = fn(m-1 n-1)\n        return -1 if mx < 0 else mx % 1_000_000_007"
Maximum Number of Achievable Transfer Requests,###  1601\. Maximum Number of Achievable Transfer Requests\n\nWe have `n` buildings numbered from `0` to `n - 1`. Each building has a number\nof employees. It's transfer season and some employees want to change the\nbuilding they reside in.\n\nYou are given an array `requests` where `requests[i] = [fromi toi]`\nrepresents an employee's request to transfer from building `fromi` to building\n`toi`.\n\n**All buildings are full**  so a list of requests is achievable only if for\neach building the **net change in employee transfers is zero**. This means\nthe number of employees **leaving** is **equal** to the number of employees\n**moving in**. For example if `n = 3` and two employees are leaving building\n`0` one is leaving building `1` and one is leaving building `2` there\nshould be two employees moving to building `0` one employee moving to\nbuilding `1` and one employee moving to building `2`.\n\nReturn _the maximum number of achievable requests_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/10/move1.jpg)\n\n    \n    \n    **Input:** n = 5 requests = [[01][10][01][12][20][34]]\n    **Output:** 5\n    **Explantion:** Let's see the requests:\n    From building 0 we have employees x and y and both want to move to building 1.\n    From building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\n    From building 2 we have employee z and they want to move to building 0.\n    From building 3 we have employee c and they want to move to building 4.\n    From building 4 we don't have any requests.\n    We can achieve the requests of users x and b by swapping their places.\n    We can achieve the requests of users y a and z by swapping the places in the 3 buildings.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/10/move2.jpg)\n\n    \n    \n    **Input:** n = 3 requests = [[00][12][21]]\n    **Output:** 3\n    **Explantion:** Let's see the requests:\n    From building 0 we have employee x and they want to stay in the same building 0.\n    From building 1 we have employee y and they want to move to building 2.\n    From building 2 we have employee z and they want to move to building 1.\n    We can achieve all the requests. \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 4 requests = [[03][31][12][20]]\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 20`\n  * `1 <= requests.length <= 16`\n  * `requests[i].length == 2`\n  * `0 <= fromi toi < n`\n\n,# Runtime: 4533 ms (Top 17.14%) | Memory: 13.9 MB (Top 48.57%)\nclass Solution:\n    def maximumRequests(self n: int r: List[List[int]]) -> int:\n        k=len(r)\n        deg=[0 for i in range(n)]\n\n        def check(iress):\n            if i==k:\n                #print(degs)\n                if max(deg)==min(deg)==0:\n                    res[0]=max(res[0]s)\n                return\n\n            uv=r[i]\n            deg[u]-=1\n            deg[v]+=1\n            check(i+1ress+1)\n            deg[u]+=1\n            deg[v]-=1\n            check(i+1ress)\n        res=[0]\n        check(0res0)\n        return res[0]\n
Maximum Number of Balloons,"###  1189\. Maximum Number of Balloons\n\nGiven a string `text` you want to use the characters of `text` to form as\nmany instances of the word **""balloon""** as possible.\n\nYou can use each character in `text` **at most once**. Return the maximum\nnumber of instances that can be formed.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2019/09/05/1536_ex1_upd.JPG)**\n\n    \n    \n    **Input:** text = ""nlaebolko""\n    **Output:** 1\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2019/09/05/1536_ex2_upd.JPG)**\n\n    \n    \n    **Input:** text = ""loonbalxballpoon""\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** text = ""leetcode""\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length <= 104`\n  * `text` consists of lower case English letters only.\n\n",class Solution:\n    def maxNumberOfBalloons(self text: str) -> int:\n        freq = {'b': 0 'a': 0 'l': 0 'o': 0 'n': 0}\n        \n        for char in text:\n            if not char in freq:\n                continue\n                \n            step = 0.5 if char == 'l' or char == 'o' else 1\n            \n            freq[char] += step\n        \n        result = min(freq.values())\n        \n        return floor(result)
Maximum Number of Balls in a Box,###  1742\. Maximum Number of Balls in a Box\n\nYou are working in a ball factory where you have `n` balls numbered from\n`lowLimit` up to `highLimit` **inclusive** (i.e. `n == highLimit - lowLimit +\n1`) and an infinite number of boxes numbered from `1` to `infinity`.\n\nYour job at this factory is to put each ball in the box with a number equal to\nthe sum of digits of the ball's number. For example the ball number `321`\nwill be put in the box number `3 + 2 + 1 = 6` and the ball number `10` will be\nput in the box number `1 + 0 = 1`.\n\nGiven two integers `lowLimit` and `highLimit` return _the number of balls in\nthe box with the most balls._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** lowLimit = 1 highLimit = 10\n    **Output:** 2\n    **Explanation:**\n    Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...\n    Ball Count:  2 1 1 1 1 1 1 1 1 0  0  ...\n    Box 1 has the most number of balls with 2 balls.\n\n**Example 2:**\n\n    \n    \n    **Input:** lowLimit = 5 highLimit = 15\n    **Output:** 2\n    **Explanation:**\n    Box Number:  1 2 3 4 5 6 7 8 9 10 11 ...\n    Ball Count:  1 1 1 1 2 2 1 1 1 0  0  ...\n    Boxes 5 and 6 have the most number of balls with 2 balls in each.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** lowLimit = 19 highLimit = 28\n    **Output:** 2\n    **Explanation:**\n    Box Number:  1 2 3 4 5 6 7 8 9 10 11 12 ...\n    Ball Count:  0 1 1 1 1 1 1 1 1 2  0  0  ...\n    Box 10 has the most number of balls with 2 balls.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= lowLimit <= highLimit <= 105`\n\n,"class Solution:\n    def countBalls(self lowLimit: int highLimit: int) -> int:\n        boxes = [0] * 100\n        \n        for i in range(lowLimit highLimit + 1):\n			\n			# For the current number ""i"" convert it into a list of its digits.\n			# Compute its sum and increment the count in the frequency table.\n			\n            boxes[sum([int(j) for j in str(i)])] += 1\n        \n        return max(boxes)"
Maximum Number of Coins You Can Get,###  1561\. Maximum Number of Coins You Can Get\n\nThere are `3n` piles of coins of varying size you and your friends will take\npiles of coins as follows:\n\n  * In each step you will choose **any**`3` piles of coins (not necessarily consecutive).\n  * Of your choice Alice will pick the pile with the maximum number of coins.\n  * You will pick the next pile with the maximum number of coins.\n  * Your friend Bob will pick the last pile.\n  * Repeat until there are no more piles of coins.\n\nGiven an array of integers `piles` where `piles[i]` is the number of coins in\nthe `ith` pile.\n\nReturn the maximum number of coins that you can have.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** piles = [241278]\n    **Output:** 9\n    **Explanation:** Choose the triplet (2 7 8) Alice Pick the pile with 8 coins you the pile with **7** coins and Bob the last one.\n    Choose the triplet (1 2 4) Alice Pick the pile with 4 coins you the pile with **2** coins and Bob the last one.\n    The maximum number of coins which you can have are: 7 + 2 = 9.\n    On the other hand if we choose this arrangement (1 **2**  8) (2 **4**  7) you only get 2 + 4 = 6 coins which is not optimal.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** piles = [245]\n    **Output:** 4\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** piles = [987651234]\n    **Output:** 18\n    \n\n\n\n**Constraints:**\n\n  * `3 <= piles.length <= 105`\n  * `piles.length % 3 == 0`\n  * `1 <= piles[i] <= 104`\n\n,class Solution:\n    def maxCoins(self piles: List[int]) -> int:\n        piles.sort()\n        n = len(piles)\n        k = n // 3\n        i j = 0 2\n        ans = 0\n        while i < k:\n            ans += piles[n-j]\n            j += 2\n            i +=1\n        return ans
Maximum Number of Consecutive Values You Can Make,###  1798\. Maximum Number of Consecutive Values You Can Make\n\nYou are given an integer array `coins` of length `n` which represents the `n`\ncoins that you own. The value of the `ith` coin is `coins[i]`. You can\n**make** some value `x` if you can choose some of your `n` coins such that\ntheir values sum up to `x`.\n\nReturn the _maximum number of consecutive integer values that you**can**\n**make** with your coins **starting** from and **including** _`0`.\n\nNote that you may have multiple coins of the same value.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** coins = [13]\n    **Output:** 2\n    **Explanation:** You can make the following values:\n    - 0: take []\n    - 1: take [1]\n    You can make 2 consecutive integer values starting from 0.\n\n**Example 2:**\n\n    \n    \n    **Input:** coins = [1114]\n    **Output:** 8\n    **Explanation:** You can make the following values:\n    - 0: take []\n    - 1: take [1]\n    - 2: take [11]\n    - 3: take [111]\n    - 4: take [4]\n    - 5: take [41]\n    - 6: take [411]\n    - 7: take [4111]\n    You can make 8 consecutive integer values starting from 0.\n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [141031]\n    **Output:** 20\n\n\n\n**Constraints:**\n\n  * `coins.length == n`\n  * `1 <= n <= 4 * 104`\n  * `1 <= coins[i] <= 4 * 104`\n\n,// Runtime: 576 ms (Top 97.83%) | Memory: 23.00 MB (Top 5.22%)\n\nclass Solution:\n    def getMaximumConsecutive(self coins: List[int]) -> int:\n        cur_max = 0\n        coins.sort()\n      \n        for coin in coins:\n            if coin == 1:\n                cur_max += 1\n            elif coin <= cur_max+1:\n                cur_max += coin\n            else: #coin > cur_max + 1\n                break\n        \n        return cur_max+1\n
Maximum Number of Darts Inside of a Circular Dartboard,###  1453\. Maximum Number of Darts Inside of a Circular Dartboard\n\nAlice is throwing `n` darts on a very large wall. You are given an array\n`darts` where `darts[i] = [xi yi]` is the position of the `ith` dart that\nAlice threw on the wall.\n\nBob knows the positions of the `n` darts on the wall. He wants to place a\ndartboard of radius `r` on the wall so that the maximum number of darts that\nAlice throws lies on the dartboard.\n\nGiven the integer `r` return _the maximum number of darts that can lie on the\ndartboard_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/04/29/sample_1_1806.png)\n\n    \n    \n    **Input:** darts = [[-20][20][02][0-2]] r = 2\n    **Output:** 4\n    **Explanation:** Circle dartboard with center in (00) and radius = 2 contain all points.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/04/29/sample_2_1806.png)\n\n    \n    \n    **Input:** darts = [[-30][30][26][54][09][78]] r = 5\n    **Output:** 5\n    **Explanation:** Circle dartboard with center in (04) and radius = 5 contain all points except the point (78).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= darts.length <= 100`\n  * `darts[i].length == 2`\n  * `-104 <= xi yi <= 104`\n  * `1 <= r <= 5000`\n\n,# Runtime: 275 ms (Top 78.13%) | Memory: 14.5 MB (Top 9.38%)\nclass Solution:\n    def numPoints(self points: List[List[int]] r: int) -> int:\n\n        def getPointsInside(i r n):\n            # This vector stores alpha and beta and flag\n            # is marked true for alpha and false for beta\n            angles = []\n\n            for j in range(n):\n\n                if i != j and distance[i][j] <= 2 * r:\n                    # acos returns the arc cosine of the complex\n                    # used for cosine inverse\n                    B = math.acos(distance[i][j] / (2 * r))\n\n                    # arg returns the phase angle of the complex\n                    x1 y1 = points[i]\n                    x2 y2 = points[j]\n\n                    A = math.atan2(y1 - y2 x1 - x2)\n\n                    alpha = A - B\n\n                    beta = A + B\n\n                    angles.append((alpha False))\n\n                    angles.append((beta True))\n\n            # angles vector is sorted and traversed\n            angles.sort()\n            # count maintains the number of points inside\n            # the circle at certain value of theta\n            # res maintains the maximum of all count\n            cnt res = 1 1\n            for angle in angles:\n                # entry angle\n                if angle[1] == False:\n                    cnt += 1\n                # exit angle\n                else:\n                    cnt -= 1\n\n                res = max(cnt res)\n\n            return res\n\n        # Returns count of maximum points that can lie\n        # in a circle of radius r.\n        #a dis array stores the distance between every\n        # pair of points\n        n = len(points)\n        max_pts = n\n        distance = [[0 for _ in range(max_pts)] for _ in range(max_pts)]\n        for i in range(n - 1):\n            for j in range(i + 1 n):\n                # abs gives the magnitude of the complex\n                # number and hence the distance between\n                # i and j\n                x1 y1 = points[i]\n                x2 y2 = points[j]\n                distance[i][j] = distance[j][i] = sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\n        # This loop picks a point p\n        ans = 0\n        # maximum number of points for point arr[i]\n        for i in range(n):\n            ans = max(ans getPointsInside(i r n))\n\n        return ans
Maximum Number of Eaten Apples,###  1705\. Maximum Number of Eaten Apples\n\nThere is a special kind of apple tree that grows apples every day for `n`\ndays. On the `ith` day the tree grows `apples[i]` apples that will rot after\n`days[i]` days that is on day `i + days[i]` the apples will be rotten and\ncannot be eaten. On some days the apple tree does not grow any apples which\nare denoted by `apples[i] == 0` and `days[i] == 0`.\n\nYou decided to eat **at most** one apple a day (to keep the doctors away).\nNote that you can keep eating after the first `n` days.\n\nGiven two integer arrays `days` and `apples` of length `n` return _the\nmaximum number of apples you can eat._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** apples = [12352] days = [32142]\n    **Output:** 7\n    **Explanation:** You can eat 7 apples:\n    - On the first day you eat an apple that grew on the first day.\n    - On the second day you eat an apple that grew on the second day.\n    - On the third day you eat an apple that grew on the second day. After this day the apples that grew on the third day rot.\n    - On the fourth to the seventh days you eat apples that grew on the fourth day.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** apples = [300002] days = [300002]\n    **Output:** 5\n    **Explanation:** You can eat 5 apples:\n    - On the first to the third day you eat apples that grew on the first day.\n    - Do nothing on the fouth and fifth days.\n    - On the sixth and seventh days you eat apples that grew on the sixth day.\n    \n\n\n\n**Constraints:**\n\n  * `n == apples.length == days.length`\n  * `1 <= n <= 2 * 104`\n  * `0 <= apples[i] days[i] <= 2 * 104`\n  * `days[i] = 0` if and only if `apples[i] = 0`.\n\n,"import heapq\nclass Solution(object):\n    def eatenApples(self apples days):\n        """"""\n        :type apples: List[int]\n        :type days: List[int]\n        :rtype: int\n        """"""\n        heap = [(days[0] apples[0])]\n        heapq.heapify(heap)\n        day = 0\n        rtn = 0\n        while heap or day < len(days):\n            # print(heap day)\n            apple = 0\n            if heap :\n                cnt apple = heapq.heappop(heap)\n                while heap and cnt <= day and apple > 0:\n                    cnt apple = heapq.heappop(heap)\n            if apple > 0 and cnt > day  :\n                rtn +=1\n            day +=1\n            if apple >  1 and cnt > day:\n                heapq.heappush(heap (cnt apple-1))\n            if day < len(days) and apples[day] > 0 :\n                heapq.heappush(heap (day +days[day] apples[day]))\n        return rtn "
Maximum Number of Events That Can Be Attended,###  1353\. Maximum Number of Events That Can Be Attended\n\nYou are given an array of `events` where `events[i] = [startDayi endDayi]`.\nEvery event `i` starts at `startDayi` and ends at `endDayi`.\n\nYou can attend an event `i` at any day `d` where `startTimei <= d <=\nendTimei`. You can only attend one event at any time `d`.\n\nReturn _the maximum number of events you can attend_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/02/05/e1.png)\n\n    \n    \n    **Input:** events = [[12][23][34]]\n    **Output:** 3\n    **Explanation:** You can attend all the three events.\n    One way to attend them all is as shown.\n    Attend the first event on day 1.\n    Attend the second event on day 2.\n    Attend the third event on day 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** events= [[12][23][34][12]]\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= events.length <= 105`\n  * `events[i].length == 2`\n  * `1 <= startDayi <= endDayi <= 105`\n\n,"# Runtime: 1160 ms (Top 93.22%) | Memory: 61.6 MB (Top 51.45%)\nclass Solution(object):\n    def maxEvents(self events):\n        """"""\n        :type events: List[List[int]]\n        :rtype: int\n        """"""\n        events = sorted(events key=lambda x: x[0])\n        current_day = 0\n        min_heap = []\n        event_id = 0\n        total_number_of_days = max(end for start end in events)\n        total_events_attended = 0\n        #total_number_of_days+1 because I want to include the last day\n        for day in range(1 total_number_of_days+1):\n\n            #Add all the events that can be started on that day\n            while event_id < len(events) and events[event_id][0] == day:\n                heapq.heappush(min_heap events[event_id][1])\n                event_id+=1\n\n            #while there is something in heap and the event should have been completed before the current day\n            #remove those evenets and consider them not attended\n            while min_heap and min_heap[0] < day :\n                heapq.heappop(min_heap)\n\n            #if theere is an event present in heap\n            #lets mark 1 of those events as complted today and add it to\n            #total_events_attended\n\n            if min_heap:\n                heapq.heappop(min_heap)\n                total_events_attended+=1\n        return total_events_attended\n"
Maximum Number of Events That Can Be Attended II,###  1751\. Maximum Number of Events That Can Be Attended II\n\nYou are given an array of `events` where `events[i] = [startDayi endDayi\nvaluei]`. The `ith` event starts at `startDayi` and ends at `endDayi` and if\nyou attend this event you will receive a value of `valuei`. You are also\ngiven an integer `k` which represents the maximum number of events you can\nattend.\n\nYou can only attend one event at a time. If you choose to attend an event you\nmust attend the **entire** event. Note that the end day is **inclusive** :\nthat is you cannot attend two events where one of them starts and the other\nends on the same day.\n\nReturn _the**maximum sum** of values that you can receive by attending\nevents._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60048-pm.png)\n\n    \n    \n    **Input:** events = [[124][343][231]] k = 2\n    **Output:** 7\n    **Explanation:** Choose the green events 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60150-pm.png)\n\n    \n    \n    **Input:** events = [[124][343][2310]] k = 2\n    **Output:** 10\n    **Explanation:** Choose event 2 for a total value of 10.\n    Notice that you cannot attend any other event as they overlap and that you do **not** have to attend k events.\n\n**Example 3:**\n\n**![](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60703-pm.png)**\n\n    \n    \n    **Input:** events = [[111][222][333][444]] k = 3\n    **Output:** 9\n    **Explanation:** Although the events do not overlap you can only attend 3 events. Pick the highest valued three.\n\n\n\n**Constraints:**\n\n  * `1 <= k <= events.length`\n  * `1 <= k * events.length <= 106`\n  * `1 <= startDayi <= endDayi <= 109`\n  * `1 <= valuei <= 106`\n\n,import bisect\nfrom functools import lru_cache\n\nclass Solution:\n    def maxValue(self events: List[List[int]] k: int) -> int:\n        if k == 1: # optimization for TLE test case 57/67\n            return max([event[2] for event in events])\n        \n        events.sort()\n        event_starts = [event[0] for event in events] # enables binary search\n        \n        @lru_cache(None)\n        def dp(i j):\n            if j == 0: # out of turns\n                return 0\n            if i >= len(events): # end of events array\n                return 0\n            max_score = events[i][2]\n            \n            # get minimum index where start day is greater than current end day\n            next_index_minimum = bisect.bisect_left(event_starts events[i][1] + 1)\n            \n            # check each possibility from the minimum next index until end of the array\n            for k in range(next_index_minimum len(events)):\n                max_score = max(max_score events[i][2] + dp(k j - 1))\n            \n            # check if we can get a better score if we skip this index altogether\n            max_score = max(max_score dp(i + 1 j))\n            return max_score\n        return dp(0 k)\n
Maximum Number of Non-Overlapping Substrings,"###  1520\. Maximum Number of Non-Overlapping Substrings\n\nGiven a string `s` of lowercase letters you need to find the maximum number\nof **non-empty** substrings of `s` that meet the following conditions:\n\n  1. The substrings do not overlap that is for any two substrings `s[i..j]` and `s[x..y]` either `j < x` or `i > y` is true.\n  2. A substring that contains a certain character `c` must also contain all occurrences of `c`.\n\nFind _the maximum number of substrings that meet the above conditions_. If\nthere are multiple solutions with the same number of substrings _return the\none with minimum total length._ It can be shown that there exists a unique\nsolution of minimum total length.\n\nNotice that you can return the substrings in **any** order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""adefaddaccc""\n    **Output:** [""e""""f""""ccc""]\n    **Explanation:**  The following are all the possible substrings that meet the conditions:\n    [\n      ""adefaddaccc""\n      ""adefadda""\n      ""ef""\n      ""e""\n      ""f""\n      ""ccc""\n    ]\n    If we choose the first string we cannot choose anything else and we'd get only 1. If we choose ""adefadda"" we are left with ""ccc"" which is the only one that doesn't overlap thus obtaining 2 substrings. Notice also that it's not optimal to choose ""ef"" since it can be split into two. Therefore the optimal way is to choose [""e""""f""""ccc""] which gives us 3 substrings. No other solution of the same number of substrings exist.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abbaccd""\n    **Output:** [""d""""bb""""cc""]\n    **Explanation:** Notice that while the set of substrings [""d""""abba""""cc""] also has length 3 it's considered incorrect since it has larger total length.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` contains only lowercase English letters.\n\n",from collections import defaultdict\nclass Solution:\n    def maxNumOfSubstrings(self s: str) -> List[str]:\n        st = defaultdict(lambda : -1)\n        ed = defaultdict(int)\n        for i c in enumerate(s):\n            if st[c]==-1:\n                st[c] = i\n                ed[c] = i\n            else:\n                ed[c] = i\n        ints = []\n        for c in set(s):\n            b e = st[c] ed[c]\n            i = b\n            while i <= e and b == st[c]:\n                b = min(b st[s[i]])\n                e = max(e ed[s[i]])\n                i += 1\n            if b == st[c]:\n                ints.append((be))\n        ints.sort(key = lambda e: e[1])\n        res = []\n        prev = -1\n        for i in range(len(ints)):\n            jk = ints[i]\n            if j > prev:\n                res.append(s[j:k+1])\n                prev = k\n        return res
Maximum Number of Pairs in Array,###  2341\. Maximum Number of Pairs in Array\n\nYou are given a **0-indexed** integer array `nums`. In one operation you may\ndo the following:\n\n  * Choose **two** integers in `nums` that are **equal**.\n  * Remove both integers from `nums` forming a **pair**.\n\nThe operation is done on `nums` as many times as possible.\n\nReturn _a**0-indexed** integer array _`answer` _of size_`2`\n_where_`answer[0]`_is the number of pairs that are formed and_`answer[1]`_is\nthe number of leftover integers in_`nums` _after doing the operation as many\ntimes as possible_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1321322]\n    **Output:** [31]\n    **Explanation:**\n    Form a pair with nums[0] and nums[3] and remove them from nums. Now nums = [32322].\n    Form a pair with nums[0] and nums[2] and remove them from nums. Now nums = [222].\n    Form a pair with nums[0] and nums[1] and remove them from nums. Now nums = [2].\n    No more pairs can be formed. A total of 3 pairs have been formed and there is 1 number leftover in nums.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [11]\n    **Output:** [10]\n    **Explanation:** Form a pair with nums[0] and nums[1] and remove them from nums. Now nums = [].\n    No more pairs can be formed. A total of 1 pair has been formed and there are 0 numbers leftover in nums.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [0]\n    **Output:** [01]\n    **Explanation:** No pairs can be formed and there is 1 number leftover in nums.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `0 <= nums[i] <= 100`\n\n,class Solution:\n    def numberOfPairs(self nums: List[int]) -> List[int]:\n        ans = [0] * 2\n        c = Counter(nums)\n        \n        for v in c.values():\n            ans[0] += (v // 2)\n            ans[1] += (v % 2)\n        \n        return ans\n
Maximum Number of Points with Cost,###  1937\. Maximum Number of Points with Cost\n\nYou are given an `m x n` integer matrix `points` (**0-indexed**). Starting\nwith `0` points you want to **maximize** the number of points you can get\nfrom the matrix.\n\nTo gain points you must pick one cell in **each row**. Picking the cell at\ncoordinates `(r c)` will **add** `points[r][c]` to your score.\n\nHowever you will lose points if you pick a cell too far from the cell that\nyou picked in the previous row. For every two adjacent rows `r` and `r + 1`\n(where `0 <= r < m - 1`) picking cells at coordinates `(r c1)` and `(r + 1\nc2)` will **subtract** `abs(c1 - c2)` from your score.\n\nReturn _the**maximum** number of points you can achieve_.\n\n`abs(x)` is defined as:\n\n  * `x` for `x >= 0`.\n  * `-x` for `x < 0`.\n\n\n\n**Example 1:******\n\n![](https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-\ndrawio-diagrams-net.png)\n\n    \n    \n    **Input:** points = [[123][151][311]]\n    **Output:** 9\n    **Explanation:**\n    The blue cells denote the optimal cells to pick which have coordinates (0 2) (1 1) and (2 0).\n    You add 3 + 5 + 3 = 11 to your score.\n    However you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\n    Your final score is 11 - 2 = 9.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-\ndrawio-diagrams-net.png)\n\n    \n    \n    **Input:** points = [[15][23][42]]\n    **Output:** 11\n    **Explanation:**\n    The blue cells denote the optimal cells to pick which have coordinates (0 1) (1 1) and (2 0).\n    You add 5 + 3 + 4 = 12 to your score.\n    However you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\n    Your final score is 12 - 1 = 11.\n    \n\n\n\n**Constraints:**\n\n  * `m == points.length`\n  * `n == points[r].length`\n  * `1 <= m n <= 105`\n  * `1 <= m * n <= 105`\n  * `0 <= points[r][c] <= 105`\n\n,class Solution:\n    def maxPoints(self points: List[List[int]]) -> int:\n        m n = len(points) len(points[0])\n        \n        for i in range(m - 1):\n            for j in range(1 n):\n                points[i][j] = max(points[i][j] points[i][j - 1] - 1)\n            \n            for j in range(n - 2 -1 -1):\n                points[i][j] = max(points[i][j] points[i][j + 1] - 1)\n            \n            for j in range(n):\n                points[i + 1][j] += points[i][j]\n        \n        return max(points[m - 1])
Maximum Number of Removable Characters,"###  1898\. Maximum Number of Removable Characters\n\nYou are given two strings `s` and `p` where `p` is a **subsequence** of `s`.\nYou are also given a **distinct 0-indexed** integer array `removable`\ncontaining a subset of indices of `s` (`s` is also **0-indexed**).\n\nYou want to choose an integer `k` (`0 <= k <= removable.length`) such that\nafter removing `k` characters from `s` using the **first** `k` indices in\n`removable` `p` is still a **subsequence** of `s`. More formally you will\nmark the character at `s[removable[i]]` for each `0 <= i < k` then remove all\nmarked characters and check if `p` is still a subsequence.\n\nReturn _the**maximum** _`k` _you can choose such that_`p` _is still\na**subsequence** of _`s` _after the removals_.\n\nA **subsequence** of a string is a new string generated from the original\nstring with some characters (can be none) deleted without changing the\nrelative order of the remaining characters.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcacb"" p = ""ab"" removable = [310]\n    **Output:** 2\n    **Explanation** : After removing the characters at indices 3 and 1 ""a~~**b**~~ c~~**a**~~ cb"" becomes ""accb"".\n    ""ab"" is a subsequence of ""**_a_** cc** _b_** "".\n    If we remove the characters at indices 3 1 and 0 ""~~**ab**~~ c~~**a**~~ cb"" becomes ""ccb"" and ""ab"" is no longer a subsequence.\n    Hence the maximum k is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcbddddd"" p = ""abcd"" removable = [321456]\n    **Output:** 1\n    **Explanation** : After removing the character at index 3 ""abc~~**b**~~ ddddd"" becomes ""abcddddd"".\n    ""abcd"" is a subsequence of ""_**abcd**_ dddd"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""abcab"" p = ""abc"" removable = [01234]\n    **Output:** 0\n    **Explanation** : If you remove the first index in the array removable ""abc"" is no longer a subsequence.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= p.length <= s.length <= 105`\n  * `0 <= removable.length < s.length`\n  * `0 <= removable[i] < s.length`\n  * `p` is a **subsequence** of `s`.\n  * `s` and `p` both consist of lowercase English letters.\n  * The elements in `removable` are **distinct**.\n\n",// Runtime: 957 ms (Top 98.8%) | Memory: 28.80 MB (Top 96.39%)\n\nclass Solution:\n    def maximumRemovals(self s: str p: str removable: List[int]) -> int:\n        l r = 0 len(removable)\n\n        def isEnough(k):\n            s_arr = list(s)\n            for i in removable[:k]:\n                s_arr[i] = ''\n            return isSubsequence(p s_arr)\n            \n        def isSubsequence(s t):\n            t = iter(t)\n            return all(c in t for c in s)\n\n        while l < r:\n            m = (l+r+1)//2\n            if isEnough(m):\n                l = m\n            else:\n                r = m - 1\n        \n        return l\n
Maximum Number of Visible Points,###  1610\. Maximum Number of Visible Points\n\nYou are given an array `points` an integer `angle` and your `location`\nwhere `location = [posx posy]` and `points[i] = [xi yi]` both denote\n**integral coordinates** on the X-Y plane.\n\nInitially you are facing directly east from your position. You **cannot\nmove** from your position but you can **rotate**. In other words `posx` and\n`posy` cannot be changed. Your field of view in **degrees** is represented by\n`angle` determining how wide you can see from any given view direction. Let\n`d` be the amount in degrees that you rotate counterclockwise. Then your\nfield of view is the **inclusive** range of angles `[d - angle/2 d +\nangle/2]`.\n\nYour browser does not support the video tag or this video format.\n\nYou can **see** some set of points if for each point the **angle** formed by\nthe point your position and the immediate east direction from your position\nis **in your field of view**.\n\nThere can be multiple points at one coordinate. There may be points at your\nlocation and you can always see these points regardless of your rotation.\nPoints do not obstruct your vision to other points.\n\nReturn _the maximum number of points you can see_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/30/89a07e9b-00ab-4967-976a-c723b2aa8656.png)\n\n    \n    \n    **Input:** points = [[21][22][33]] angle = 90 location = [11]\n    **Output:** 3\n    **Explanation:** The shaded region represents your field of view. All points can be made visible in your field of view including [33] even though [22] is in front and in the same line of sight.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** points = [[21][22][34][11]] angle = 90 location = [11]\n    **Output:** 4\n    **Explanation:** All points can be made visible in your field of view including the one at your location.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/09/30/5010bfd3-86e6-465f-ac64-e9df941d2e49.png)\n\n    \n    \n    **Input:** points = [[10][21]] angle = 13 location = [11]\n    **Output:** 1\n    **Explanation:** You can only see one of the two points as shown above.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= points.length <= 105`\n  * `points[i].length == 2`\n  * `location.length == 2`\n  * `0 <= angle < 360`\n  * `0 <= posx posy xi yi <= 100`\n\n,# Runtime: 5206 ms (Top 8.11%) | Memory: 46.3 MB (Top 98.26%)\nclass Solution:\n    def visiblePoints(self points: List[List[int]] angle: int location: List[int]) -> int:\n\n        arr extra = [] 0\n        xx yy = location\n\n        for x y in points:\n            if x == xx and y == yy:\n                extra += 1\n                continue\n            arr.append(math.atan2(y - yy x - xx))\n\n        arr.sort()\n        arr = arr + [x + 2.0 * math.pi for x in arr]\n        angle = math.pi * angle / 180\n\n        l = ans = 0\n        for r in range(len(arr)):\n            while arr[r] - arr[l] > angle:\n                l += 1\n            ans = max(ans r - l + 1)\n\n        return ans + extra
Maximum Number of Vowels in a Substring of Given Length,"###  1456\. Maximum Number of Vowels in a Substring of Given Length\n\nGiven a string `s` and an integer `k` return _the maximum number of vowel\nletters in any substring of_`s` _with length_`k`.\n\n**Vowel letters** in English are `'a'` `'e'` `'i'` `'o'` and `'u'`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abciiidef"" k = 3\n    **Output:** 3\n    **Explanation:** The substring ""iii"" contains 3 vowel letters.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aeiou"" k = 2\n    **Output:** 2\n    **Explanation:** Any substring of length 2 contains 2 vowels.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""leetcode"" k = 3\n    **Output:** 2\n    **Explanation:** ""lee"" ""eet"" and ""ode"" contain 2 vowels.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of lowercase English letters.\n  * `1 <= k <= s.length`\n\n",class Solution:\n    def maxVowels(self s: str k: int) -> int:\n        \n        def find_count_vowels(string):\n            lst_vowels= ['a' 'e' 'i' 'o' 'u']\n            c=0\n            for i in string:\n                if i in lst_vowels:\n                    c+=1\n            return c\n            \n        \n        lst_vowels= ['a' 'e' 'i' 'o' 'u']\n        if k>len(s):\n            return find_count_vowels(s)\n        dp = [0]*(len(s)-k+1)\n        dp[0] = find_count_vowels(s[:k])\n        for i in range(1len(s)-k+1):\n            \n           \n            if s[i-1] in lst_vowels and s[i+k-1] in lst_vowels:\n                dp[i] = dp[i-1]\n            elif s[i-1] in lst_vowels and s[i+k-1] not in lst_vowels:\n                dp[i] = dp[i-1] - 1\n\n            elif s[i-1] not in lst_vowels and s[i+k-1] in lst_vowels:\n                dp[i] = dp[i-1] + 1\n            else:\n                dp[i] = dp[i-1]\n        return max(dp)\n                \n
Maximum Number of Ways to Partition an Array,###  2025\. Maximum Number of Ways to Partition an Array\n\nYou are given a **0-indexed** integer array `nums` of length `n`. The number\nof ways to **partition** `nums` is the number of `pivot` indices that satisfy\nboth conditions:\n\n  * `1 <= pivot < n`\n  * `nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]`\n\nYou are also given an integer `k`. You can choose to change the value of\n**one** element of `nums` to `k` or to leave the array **unchanged**.\n\nReturn _the**maximum** possible number of ways to **partition** _`nums` _to\nsatisfy both conditions after changing**at most** one element_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [2-12] k = 3\n    **Output:** 1\n    **Explanation:** One optimal approach is to change nums[0] to k. The array becomes [**_3_** -12].\n    There is one way to partition the array:\n    - For pivot = 2 we have the partition [3-1 | 2]: 3 + -1 == 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [000] k = 1\n    **Output:** 2\n    **Explanation:** The optimal approach is to leave the array unchanged.\n    There are two ways to partition the array:\n    - For pivot = 1 we have the partition [0 | 00]: 0 == 0 + 0.\n    - For pivot = 2 we have the partition [00 | 0]: 0 + 0 == 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [224-25-20-1515-16719-100-13-14] k = -33\n    **Output:** 4\n    **Explanation:** One optimal approach is to change nums[2] to k. The array becomes [224_**-33**_ -20-1515-16719-100-13-14].\n    There are four ways to partition the array.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `2 <= n <= 105`\n  * `-105 <= k nums[i] <= 105`\n\n,# Runtime: 3346 ms (Top 89.52%) | Memory: 46.9 MB (Top 30.64%)\nclass Solution:\n    def waysToPartition(self nums: List[int] k: int) -> int:\n        prefix_sums = list(accumulate(nums))\n        total_sum = prefix_sums[-1]\n        best = 0\n        if total_sum % 2 == 0:\n            best = prefix_sums[:-1].count(total_sum // 2) # If no change\n\n        after_counts = Counter(total_sum - 2 * prefix_sum\n                               for prefix_sum in prefix_sums[:-1])\n        before_counts = Counter()\n\n        best = max(best after_counts[k - nums[0]]) # If we change first num\n\n        for prefix x in zip(prefix_sums nums[1:]):\n            gap = total_sum - 2 * prefix\n            after_counts[gap] -= 1\n            before_counts[gap] += 1\n\n            best = max(best after_counts[k - x] + before_counts[x - k])\n\n        return best
Maximum Number of Weeks for Which You Can Work,###  1953\. Maximum Number of Weeks for Which You Can Work\n\nThere are `n` projects numbered from `0` to `n - 1`. You are given an integer\narray `milestones` where each `milestones[i]` denotes the number of milestones\nthe `ith` project has.\n\nYou can work on the projects following these two rules:\n\n  * Every week you will finish **exactly one** milestone of **one** project. You **must**  work every week.\n  * You **cannot** work on two milestones from the same project for two **consecutive** weeks.\n\nOnce all the milestones of all the projects are finished or if the only\nmilestones that you can work on will cause you to violate the above rules you\nwill **stop working**. Note that you may not be able to finish every project's\nmilestones due to these constraints.\n\nReturn _the**maximum** number of weeks you would be able to work on the\nprojects without violating the rules mentioned above_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** milestones = [123]\n    **Output:** 6\n    **Explanation:** One possible scenario is:\n    ​​​​- During the 1st week you will work on a milestone of project 0.\n    - During the 2nd week you will work on a milestone of project 2.\n    - During the 3rd week you will work on a milestone of project 1.\n    - During the 4th week you will work on a milestone of project 2.\n    - During the 5th week you will work on a milestone of project 1.\n    - During the 6th week you will work on a milestone of project 2.\n    The total number of weeks is 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** milestones = [521]\n    **Output:** 7\n    **Explanation:** One possible scenario is:\n    - During the 1st week you will work on a milestone of project 0.\n    - During the 2nd week you will work on a milestone of project 1.\n    - During the 3rd week you will work on a milestone of project 0.\n    - During the 4th week you will work on a milestone of project 1.\n    - During the 5th week you will work on a milestone of project 0.\n    - During the 6th week you will work on a milestone of project 2.\n    - During the 7th week you will work on a milestone of project 0.\n    The total number of weeks is 7.\n    Note that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules.\n    Thus one milestone in project 0 will remain unfinished.\n    \n\n\n\n**Constraints:**\n\n  * `n == milestones.length`\n  * `1 <= n <= 105`\n  * `1 <= milestones[i] <= 109`\n\n,# Runtime: 1032 ms (Top 59.60%) | Memory: 25.7 MB (Top 80.23%)\nclass Solution:\n    def numberOfWeeks(self m: List[int]) -> int:\n        return min(sum(m) 2 * (sum(m) - max(m)) + 1)
Maximum Number of Words Found in Sentences,"###  2114\. Maximum Number of Words Found in Sentences\n\nA **sentence** is a list of **words** that are separated by a single space\nwith no leading or trailing spaces.\n\nYou are given an array of strings `sentences` where each `sentences[i]`\nrepresents a single **sentence**.\n\nReturn _the**maximum number of words** that appear in a single sentence_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** sentences = [""alice and bob love leetcode"" ""i think so too"" _""this is great thanks very much""_]\n    **Output:** 6\n    **Explanation:** \n    - The first sentence ""alice and bob love leetcode"" has 5 words in total.\n    - The second sentence ""i think so too"" has 4 words in total.\n    - The third sentence ""this is great thanks very much"" has 6 words in total.\n    Thus the maximum number of words in a single sentence comes from the third sentence which has 6 words.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** sentences = [""please wait"" _""continue to fight""_  _""continue to win""_]\n    **Output:** 3\n    **Explanation:** It is possible that multiple sentences contain the same number of words. \n    In this example the second and third sentences (underlined) have the same number of words.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= sentences.length <= 100`\n  * `1 <= sentences[i].length <= 100`\n  * `sentences[i]` consists only of lowercase English letters and `' '` only.\n  * `sentences[i]` does not have leading or trailing spaces.\n  * All the words in `sentences[i]` are separated by a single space.\n\n","// Runtime: 43 ms (Top 84.42%) | Memory: 16.70 MB (Top 56.32%)\n\nclass Solution:\n    def mostWordsFound(self sentences: List[str]) -> int:\n        mx=0\n        for i in sentences:\n            c=i.split()\n            if len(c)>mx:\n                mx=len(c)\n        return mx\n		\n"
Maximum Number of Words You Can Type,"###  1935\. Maximum Number of Words You Can Type\n\nThere is a malfunctioning keyboard where some letter keys do not work. All\nother keys on the keyboard work properly.\n\nGiven a string `text` of words separated by a single space (no leading or\ntrailing spaces) and a string `brokenLetters` of all **distinct** letter keys\nthat are broken return _the**number of words** in_ `text` _you can fully type\nusing this keyboard_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text = ""hello world"" brokenLetters = ""ad""\n    **Output:** 1\n    **Explanation:** We cannot type ""world"" because the 'd' key is broken.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text = ""leet code"" brokenLetters = ""lt""\n    **Output:** 1\n    **Explanation:** We cannot type ""leet"" because the 'l' and 't' keys are broken.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** text = ""leet code"" brokenLetters = ""e""\n    **Output:** 0\n    **Explanation:** We cannot type either word because the 'e' key is broken.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length <= 104`\n  * `0 <= brokenLetters.length <= 26`\n  * `text` consists of words separated by a single space without any leading or trailing spaces.\n  * Each word only consists of lowercase English letters.\n  * `brokenLetters` consists of **distinct** lowercase English letters.\n\n","class Solution:\n    def canBeTypedWords(self text: str brokenLetters: str) -> int:\n        text = text.split()\n        length = len(text)\n        brokenLetters = set(brokenLetters)\n\n        for word in text:\n            for char in word:\n                if char in brokenLetters:\n                    length -= 1\n                    break\n					\n        return length\n"
Maximum of Absolute Value Expression,###  1131\. Maximum of Absolute Value Expression\n\nGiven two arrays of integers with equal lengths return the maximum value of:\n\n`|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|`\n\nwhere the maximum is taken over all `0 <= i j < arr1.length`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr1 = [1234] arr2 = [-1456]\n    **Output:** 13\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr1 = [1-2-5010] arr2 = [0-2-1-7-4]\n    **Output:** 20\n    \n\n\n\n**Constraints:**\n\n  * `2 <= arr1.length == arr2.length <= 40000`\n  * `-10^6 <= arr1[i] arr2[i] <= 10^6`\n\n,"class Solution(object):\n    def maxAbsValExpr(self arr1 arr2):\n        """"""\n        :type arr1: List[int]\n        :type arr2: List[int]\n        :rtype: int\n        """"""\n        max_pppmax_ppmmax_pmpmax_pmm=float('-inf')float('-inf')float('-inf')float('-inf')\n        min_pppmin_ppmmin_pmpmin_pmm=float('inf')float('inf')float('inf')float('inf')\n        for i(ab) in enumerate(zip(arr1arr2)):\n            ppp=a+b+i\n            if ppp>max_ppp:max_ppp=ppp\n            if ppp<min_ppp:min_ppp=ppp\n            ppm=a+b-i\n            if ppm>max_ppm:max_ppm=ppm\n            if ppm<min_ppm:min_ppm=ppm\n            pmp=a-b+i\n            if pmp>max_pmp:max_pmp=pmp\n            if pmp<min_pmp:min_pmp=pmp\n            pmm=a-b-i\n            if pmm>max_pmm:max_pmm=pmm\n            if pmm<min_pmm:min_pmm=pmm\n        return max(max_ppp-min_pppmax_ppm-min_ppmmax_pmp-min_pmpmax_pmm-min_pmm)   \n"
Maximum Path Quality of a Graph,###  2065\. Maximum Path Quality of a Graph\n\nThere is an **undirected** graph with `n` nodes numbered from `0` to `n - 1`\n(**inclusive**). You are given a **0-indexed** integer array `values` where\n`values[i]` is the **value** of the `ith` node. You are also given a\n**0-indexed** 2D integer array `edges` where each `edges[j] = [uj vj\ntimej]` indicates that there is an undirected edge between the nodes `uj` and\n`vj` and it takes `timej` seconds to travel between the two nodes. Finally\nyou are given an integer `maxTime`.\n\nA **valid** **path** in the graph is any path that starts at node `0` ends at\nnode `0` and takes **at most** `maxTime` seconds to complete. You may visit\nthe same node multiple times. The **quality** of a valid path is the **sum**\nof the values of the **unique nodes** visited in the path (each node's value\nis added **at most once** to the sum).\n\nReturn _the**maximum** quality of a valid path_.\n\n**Note:** There are **at most four** edges connected to each node.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/10/19/ex1drawio.png)\n\n    \n    \n    **Input:** values = [0321043] edges = [[0110][1215][0310]] maxTime = 49\n    **Output:** 75\n    **Explanation:**\n    One possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49.\n    The nodes visited are 0 1 and 3 giving a maximal path quality of 0 + 32 + 43 = 75.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/10/19/ex2drawio.png)\n\n    \n    \n    **Input:** values = [5101520] edges = [[0110][1210][0310]] maxTime = 30\n    **Output:** 25\n    **Explanation:**\n    One possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30.\n    The nodes visited are 0 and 3 giving a maximal path quality of 5 + 20 = 25.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/10/19/ex31drawio.png)\n\n    \n    \n    **Input:** values = [1234] edges = [[0110][1211][2312][1313]] maxTime = 50\n    **Output:** 7\n    **Explanation:**\n    One possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50.\n    The nodes visited are 0 1 and 3 giving a maximal path quality of 1 + 2 + 4 = 7.\n    \n\n\n\n**Constraints:**\n\n  * `n == values.length`\n  * `1 <= n <= 1000`\n  * `0 <= values[i] <= 108`\n  * `0 <= edges.length <= 2000`\n  * `edges[j].length == 3 `\n  * `0 <= uj < vj <= n - 1`\n  * `10 <= timej maxTime <= 100`\n  * All the pairs `[uj vj]` are **unique**.\n  * There are **at most four** edges connected to each node.\n  * The graph may not be connected.\n\n,"class Solution:\n    def maximalPathQuality(self values: List[int] edges: List[List[int]] maxTime: int) -> int:\n        graph = defaultdict(list)\n		# build graph\n        for edge in edges:\n            graph[edge[0]].append((edge[1] edge[2]))\n            graph[edge[1]].append((edge[0] edge[2]))\n        \n        q = deque()\n        q.append((0 0 values[0] set([0])))\n        cache = {}\n        maxPoint = 0\n		\n        while q:\n            currV currTime currPoints currSet = q.popleft()\n            if currV in cache:\n				# if vertex has been visited and if the previousTime is \n				# less or equal to current time but current points is lower?\n				# then this path can't give us better quality so stop proceeding.\n                prevTime prevPoints = cache[currV]\n                if prevTime <= currTime and prevPoints > currPoints:\n                    continue\n            cache[currV] = (currTime currPoints)\n			# can't go over the maxTime limit\n            if currTime > maxTime:\n                continue\n			# collect maxPoint only if current vertex is 0\n            if currV == 0:\n                maxPoint = max(maxPoint currPoints)\n            for neigh neighTime in graph[currV]:\n                newSet = currSet.copy()\n				# collects quality only if not collected before\n                if neigh not in currSet:\n                    newSet.add(neigh)\n                    newPoint = currPoints + values[neigh]\n                else:\n                    newPoint = currPoints\n                q.append((neigh currTime + neighTime newPoint newSet))\n        return maxPoint\n"
Maximum Performance of a Team,###  1383\. Maximum Performance of a Team\n\nYou are given two integers `n` and `k` and two integer arrays `speed` and\n`efficiency` both of length `n`. There are `n` engineers numbered from `1` to\n`n`. `speed[i]` and `efficiency[i]` represent the speed and efficiency of the\n`ith` engineer respectively.\n\nChoose **at most** `k` different engineers out of the `n` engineers to form a\nteam with the maximum **performance**.\n\nThe performance of a team is the sum of their engineers' speeds multiplied by\nthe minimum efficiency among their engineers.\n\nReturn _the maximum performance of this team_. Since the answer can be a huge\nnumber return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 6 speed = [2103158] efficiency = [543972] k = 2\n    **Output:** 60\n    **Explanation:** \n    We have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is performance = (10 + 5) * min(4 7) = 60.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 6 speed = [2103158] efficiency = [543972] k = 3\n    **Output:** 68\n    **Explanation:** This is the same example as the first but k = 3. We can select engineer 1 engineer 2 and engineer 5 to get the maximum performance of the team. That is performance = (2 + 10 + 5) * min(5 4 7) = 68.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 6 speed = [2103158] efficiency = [543972] k = 4\n    **Output:** 72\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= n <= 105`\n  * `speed.length == n`\n  * `efficiency.length == n`\n  * `1 <= speed[i] <= 105`\n  * `1 <= efficiency[i] <= 108`\n\n,class Solution:\n    def maxPerformance(self n: int speed: List[int] efficiency: List[int] k: int) -> int:\n        l = list(zip(efficiencyspeed))\n        l.sort(reverse=True)\n        h = []\n        res = 0\n        mod = 1000000007\n        mx_sum = 0\n        print(l)\n        for i in range(n):\n            res = max(res  (mx_sum+l[i][1])*l[i][0])\n            if len(h)<k-1:\n                heappush(hl[i][1])\n                mx_sum+=l[i][1]\n            elif k!=1:\n                x=0\n                if h:\n                    x = heappop(h)\n                heappush(hmax(xl[i][1]))\n                mx_sum = mx_sum - x + max(xl[i][1])\n        return res%mod\n            \n
Maximum Points in an Archery Competition,###  2212\. Maximum Points in an Archery Competition\n\nAlice and Bob are opponents in an archery competition. The competition has set\nthe following rules:\n\n  1. Alice first shoots `numArrows` arrows and then Bob shoots `numArrows` arrows.\n  2. The points are then calculated as follows: \n    1. The target has integer scoring sections ranging from `0` to `11` **inclusive**.\n    2. For **each** section of the target with score `k` (in between `0` to `11`) say Alice and Bob have shot `ak` and `bk` arrows on that section respectively. If `ak >= bk` then Alice takes `k` points. If `ak < bk` then Bob takes `k` points.\n    3. However if `ak == bk == 0` then **nobody** takes `k` points.\n\n  * For example if Alice and Bob both shot `2` arrows on the section with score `11` then Alice takes `11` points. On the other hand if Alice shot `0` arrows on the section with score `11` and Bob shot `2` arrows on that same section then Bob takes `11` points.\n\nYou are given the integer `numArrows` and an integer array `aliceArrows` of\nsize `12` which represents the number of arrows Alice shot on each scoring\nsection from `0` to `11`. Now Bob wants to **maximize** the total number of\npoints he can obtain.\n\nReturn _the array_`bobArrows` _which represents the number of arrows Bob shot\non**each** scoring section from _`0` _to_`11`. The sum of the values in\n`bobArrows` should equal `numArrows`.\n\nIf there are multiple ways for Bob to earn the maximum total points return\n**any** one of them.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/02/24/ex1.jpg)\n\n    \n    \n    **Input:** numArrows = 9 aliceArrows = [110100210120]\n    **Output:** [000011001231]\n    **Explanation:** The table above shows how the competition is scored. \n    Bob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\n    It can be shown that Bob cannot obtain a score higher than 47 points.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/02/24/ex2new.jpg)\n\n    \n    \n    **Input:** numArrows = 3 aliceArrows = [001000000002]\n    **Output:** [000000001110]\n    **Explanation:** The table above shows how the competition is scored.\n    Bob earns a total point of 8 + 9 + 10 = 27.\n    It can be shown that Bob cannot obtain a score higher than 27 points.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= numArrows <= 105`\n  * `aliceArrows.length == bobArrows.length == 12`\n  * `0 <= aliceArrows[i] bobArrows[i] <= numArrows`\n  * `sum(aliceArrows[i]) == numArrows`\n\n,"// Runtime: 114 ms (Top 97.78%) | Memory: 16.60 MB (Top 73.33%)\n\nclass Solution:\n    def maximumBobPoints(self numArrows: int aliceArrows: List[int]) -> List[int]:\n        max_score = [0 None]\n        def calc(i remaining score arrows):\n		    # Base case. Update max score.\n            if remaining == 0 or i == -1:\n                if score > max_score[0]:\n                    max_score[0] = score\n                    max_score[1] = arrows[:]\n                return\n\n			# Special handling for the last section. Use up all the arrows.\n            if i == 0:\n                arrows[i] = remaining\n                calc(i - 1 0 score + i arrows)\n                arrows[i] = 0\n                return\n\n		    # Try to compete with Alice if there are enough arrows.\n            arrowsNeeded = aliceArrows[i] + 1\n            if remaining >= arrowsNeeded:\n                arrows[i] = arrowsNeeded\n                calc(i - 1 remaining - arrowsNeeded score + i arrows)\n                arrows[i] = 0\n\n            # Skip this section and go to the next section.\n            calc(i - 1 remaining score arrows)\n        \n		# Kick off the recursion\n        calc(len(aliceArrows) - 1 numArrows 0 [0 for _ in aliceArrows])\n        return max_score[1]\n"
Maximum Points You Can Obtain from Cards,###  1423\. Maximum Points You Can Obtain from Cards\n\nThere are several cards **arranged in a row**  and each card has an\nassociated number of points. The points are given in the integer array\n`cardPoints`.\n\nIn one step you can take one card from the beginning or from the end of the\nrow. You have to take exactly `k` cards.\n\nYour score is the sum of the points of the cards you have taken.\n\nGiven the integer array `cardPoints` and the integer `k` return the _maximum\nscore_ you can obtain.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** cardPoints = [1234561] k = 3\n    **Output:** 12\n    **Explanation:** After the first step your score will always be 1. However choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right giving a final score of 1 + 6 + 5 = 12.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cardPoints = [222] k = 2\n    **Output:** 4\n    **Explanation:** Regardless of which two cards you take your score will always be 4.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** cardPoints = [9779779] k = 7\n    **Output:** 55\n    **Explanation:** You have to take all the cards. Your score is the sum of points of all cards.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= cardPoints.length <= 105`\n  * `1 <= cardPoints[i] <= 104`\n  * `1 <= k <= cardPoints.length`\n\n,// Runtime: 314 ms (Top 86.56%) | Memory: 29.90 MB (Top 66.7%)\n\nclass Solution:\n    def maxScore(self cardPoints: List[int] k: int) -> int:\n        n = len(cardPoints)\n        total = sum(cardPoints)\n        \n        remaining_length = n - k\n        subarray_sum = sum(cardPoints[:remaining_length])\n        \n        min_sum = subarray_sum\n        for i in range(remaining_length n):\n            # Update the sliding window sum to the subarray ending at index i\n            subarray_sum += cardPoints[i]\n            subarray_sum -= cardPoints[i - remaining_length]\n            # Update min_sum to track the overall minimum sum so far\n            min_sum = min(min_sum subarray_sum)\n        return total - min_sum\n
Maximum Population Year,###  1854\. Maximum Population Year\n\nYou are given a 2D integer array `logs` where each `logs[i] = [birthi\ndeathi]` indicates the birth and death years of the `ith` person.\n\nThe **population** of some year `x` is the number of people alive during that\nyear. The `ith` person is counted in year `x`'s population if `x` is in the\n**inclusive** range `[birthi deathi - 1]`. Note that the person is **not**\ncounted in the year that they die.\n\nReturn _the**earliest** year with the **maximum population**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** logs = [[19931999][20002010]]\n    **Output:** 1993\n    **Explanation:** The maximum population is 1 and 1993 is the earliest year with this population.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** logs = [[19501961][19601971][19701981]]\n    **Output:** 1960\n    **Explanation:** \n    The maximum population is 2 and it had happened in years 1960 and 1970.\n    The earlier year between them is 1960.\n\n\n\n**Constraints:**\n\n  * `1 <= logs.length <= 100`\n  * `1950 <= birthi < deathi <= 2050`\n\n,class Solution:\n    def maximumPopulation(self logs: List[List[int]]) -> int:\n        logs.sort(key=lambda x: x[0])\n        print(logs)\n        living = 0\n        max_living = 0\n        year = 0\n\n        for ind (start stop) in enumerate(logs):\n            born = ind+1\n            dead = 0\n            for i in range(ind):\n                if logs[i][1] <= start:\n                    dead += 1\n            \n            living = born - dead\n            # print(born dead living max_living)\n            if living > max_living:\n                max_living = living\n                year = start\n\n        \n        \n        return year
Maximum Product After K Increments,###  2233\. Maximum Product After K Increments\n\nYou are given an array of non-negative integers `nums` and an integer `k`. In\none operation you may choose **any** element from `nums` and **increment** it\nby `1`.\n\nReturn _the**maximum** **product** of _`nums` _after**at most** _`k`\n_operations._ Since the answer may be very large return it **modulo** `109 +\n7`. Note that you should maximize the product before taking the modulo.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [04] k = 5\n    **Output:** 20\n    **Explanation:** Increment the first number 5 times.\n    Now nums = [5 4] with a product of 5 * 4 = 20.\n    It can be shown that 20 is maximum product possible so we return 20.\n    Note that there may be other ways to increment nums to have the maximum product.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [6332] k = 2\n    **Output:** 216\n    **Explanation:** Increment the second number 1 time and increment the fourth number 1 time.\n    Now nums = [6 4 3 3] with a product of 6 * 4 * 3 * 3 = 216.\n    It can be shown that 216 is maximum product possible so we return 216.\n    Note that there may be other ways to increment nums to have the maximum product.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length k <= 105`\n  * `0 <= nums[i] <= 106`\n\n,// Runtime: 985 ms (Top 85.38%) | Memory: 27.10 MB (Top 71.7%)\n\nclass Solution:\n    def maximumProduct(self nums: List[int] k: int) -> int:\n        heap = nums.copy()\n        heapify(heap)\n        for i in range(k):\n            t = heappop(heap)\n            heappush(heap t + 1)\n        ans = 1\n        mod = 1000000007\n        for i in heap:\n            ans = (ans*i) % mod\n        return ans\n
Maximum Product Difference Between Two Pairs,###  1913\. Maximum Product Difference Between Two Pairs\n\nThe **product difference** between two pairs `(a b)` and `(c d)` is defined\nas `(a * b) - (c * d)`.\n\n  * For example the product difference between `(5 6)` and `(2 7)` is `(5 * 6) - (2 * 7) = 16`.\n\nGiven an integer array `nums` choose four **distinct** indices `w` `x` `y`\nand `z` such that the **product difference** between pairs `(nums[w]\nnums[x])` and `(nums[y] nums[z])` is **maximized**.\n\nReturn _the**maximum** such product difference_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [56274]\n    **Output:** 34\n    **Explanation:** We can choose indices 1 and 3 for the first pair (6 7) and indices 2 and 4 for the second pair (2 4).\n    The product difference is (6 * 7) - (2 * 4) = 34.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [4259748]\n    **Output:** 64\n    **Explanation:** We can choose indices 3 and 6 for the first pair (9 8) and indices 1 and 5 for the second pair (2 4).\n    The product difference is (9 * 8) - (2 * 4) = 64.\n    \n\n\n\n**Constraints:**\n\n  * `4 <= nums.length <= 104`\n  * `1 <= nums[i] <= 104`\n\n,class Solution:\n    def maxProductDifference(self nums: List[int]) -> int:\n        max_1 = 0\n        max_2 = 0\n        min_1 = 10001\n        min_2 = 10001\n        for i in nums:\n            if i >= max_1:\n                max_2max_1 = max_1i\n            elif i > max_2:\n                max_2 = i\n            if i <= min_1:\n                min_2min_1 = min_1i\n            elif i < min_2:\n                min_2 = i\n            \n        return max_1*max_2 - min_1*min_2\n
Maximum Product of Splitted Binary Tree,###  1339\. Maximum Product of Splitted Binary Tree\n\nGiven the `root` of a binary tree split the binary tree into two subtrees by\nremoving one edge such that the product of the sums of the subtrees is\nmaximized.\n\nReturn _the maximum product of the sums of the two subtrees_. Since the answer\nmay be too large return it **modulo** `109 + 7`.\n\n**Note** that you need to maximize the answer before taking the mod and not\nafter taking it.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/01/21/sample_1_1699.png)\n\n    \n    \n    **Input:** root = [123456]\n    **Output:** 110\n    **Explanation:** Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/01/21/sample_2_1699.png)\n\n    \n    \n    **Input:** root = [1null234nullnull56]\n    **Output:** 90\n    **Explanation:** Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[2 5 * 104]`.\n  * `1 <= Node.val <= 104`\n\n,class Solution:\n    def maxProduct(self root: Optional[TreeNode]) -> int:\n        def findTotalSum(node totalSum):\n            if node is None:\n                return totalSum\n            totalSum = findTotalSum(node.lefttotalSum)\n            totalSum += node.val\n            totalSum = findTotalSum(node.righttotalSum)\n            return totalSum\n        \n        def dfs(nodemaxProdtotalSum):\n            if node is None:\n                return maxProd0\n            if not node.left and not node.right:\n                return maxProdnode.val\n            maxProd lSum = dfs(node.leftmaxProdtotalSum)\n            maxProd rSum = dfs(node.rightmaxProdtotalSum)\n            subTreeSum = lSum+rSum+node.val\n            maxProd = max(maxProd(totalSum-lSum)*lSum(totalSum-rSum)*rSum(totalSum-subTreeSum)*subTreeSum)\n            return maxProd subTreeSum\n        \n        totalSum = findTotalSum(root 0)\n        product_ = dfs(root1totalSum)\n        return product % (pow(109)+7)\n
Maximum Product of the Length of Two Palindromic Subsequences,"###  2002\. Maximum Product of the Length of Two Palindromic Subsequences\n\nGiven a string `s` find two **disjoint palindromic subsequences** of `s` such\nthat the **product** of their lengths is **maximized**. The two subsequences\nare **disjoint** if they do not both pick a character at the same index.\n\nReturn _the**maximum** possible **product** of the lengths of the two\npalindromic subsequences_.\n\nA **subsequence** is a string that can be derived from another string by\ndeleting some or no characters without changing the order of the remaining\ncharacters. A string is **palindromic** if it reads the same forward and\nbackward.\n\n\n\n**Example 1:**\n\n![example-1](https://assets.leetcode.com/uploads/2021/08/24/two-palindromic-\nsubsequences.png)\n\n    \n    \n    **Input:** s = ""leetcodecom""\n    **Output:** 9\n    **Explanation** : An optimal solution is to choose ""ete"" for the 1st subsequence and ""cdc"" for the 2nd subsequence.\n    The product of their lengths is: 3 * 3 = 9.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""bb""\n    **Output:** 1\n    **Explanation** : An optimal solution is to choose ""b"" (the first character) for the 1st subsequence and ""b"" (the second character) for the 2nd subsequence.\n    The product of their lengths is: 1 * 1 = 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""accbcaxxcxx""\n    **Output:** 25\n    **Explanation** : An optimal solution is to choose ""accca"" for the 1st subsequence and ""xxcxx"" for the 2nd subsequence.\n    The product of their lengths is: 5 * 5 = 25.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 12`\n  * `s` consists of lowercase English letters only.\n\n",class Solution:\n    def maxProduct(self s: str) -> int:\n        # n <= 12 which means the search space is small\n        n = len(s)\n        arr = []\n        \n        for mask in range(1 1<<n):\n            subseq = ''\n            for i in range(n):\n                # convert the bitmask to the actual subsequence\n                if mask & (1 << i) > 0:\n                    subseq += s[i]\n            if subseq == subseq[::-1]:\n                arr.append((mask len(subseq)))\n        \n        result = 1\n        for (mask1 len1) (mask2 len2) in product(arr arr):\n            # disjoint\n            if mask1 & mask2 == 0:\n                result = max(result len1 * len2)\n        return result\n
Maximum Product of the Length of Two Palindromic Substrings,"###  1960\. Maximum Product of the Length of Two Palindromic Substrings\n\nYou are given a **0-indexed** string `s` and are tasked with finding two\n**non-intersecting palindromic** substrings of **odd** length such that the\nproduct of their lengths is maximized.\n\nMore formally you want to choose four integers `i` `j` `k` `l` such that\n`0 <= i <= j < k <= l < s.length` and both the substrings `s[i...j]` and\n`s[k...l]` are palindromes and have odd lengths. `s[i...j]` denotes a\nsubstring from index `i` to index `j` **inclusive**.\n\nReturn _the**maximum** possible product of the lengths of the two non-\nintersecting palindromic substrings._\n\nA **palindrome** is a string that is the same forward and backward. A\n**substring** is a contiguous sequence of characters in a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ababbb""\n    **Output:** 9\n    **Explanation:** Substrings ""aba"" and ""bbb"" are palindromes with odd length. product = 3 * 3 = 9.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""zaaaxbbby""\n    **Output:** 9\n    **Explanation:** Substrings ""aaa"" and ""bbb"" are palindromes with odd length. product = 3 * 3 = 9.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 105`\n  * `s` consists of lowercase English letters.\n\n",class Solution:\n    def maxProduct(self s: str) -> int:\n        n = len(s)\n        \n        # Manacher's algo\n        hlen = [0]*n # half-length\n        center = right = 0 \n        for i in range(n): \n            if i < right: hlen[i] = min(right - i hlen[2*center - i])\n            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: \n                hlen[i] += 1\n            if right < i+hlen[i]: center right = i i+hlen[i]\n        \n        prefix = [0]*n\n        suffix = [0]*n\n        for i in range(n): \n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]] 2*hlen[i]+1)\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]] 2*hlen[i]+1)\n        \n        for i in range(1 n): \n            prefix[~i] = max(prefix[~i] prefix[~i+1]-2)\n            suffix[i] = max(suffix[i] suffix[i-1]-2)\n        \n        for i in range(1 n): \n            prefix[i] = max(prefix[i-1] prefix[i])\n            suffix[~i] = max(suffix[~i] suffix[~i+1])\n        \n        return max(prefix[i-1]*suffix[i] for i in range(1 n))
Maximum Product of Three Numbers,###  628\. Maximum Product of Three Numbers\n\nGiven an integer array `nums` _find three numbers whose product is maximum\nand return the maximum product_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** 6\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** 24\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [-1-2-3]\n    **Output:** -6\n    \n\n\n\n**Constraints:**\n\n  * `3 <= nums.length <= 104`\n  * `-1000 <= nums[i] <= 1000`\n\n,class Solution:\n    def maximumProduct(self nums: List[int]) -> int:\n        # TC = O(NlogN) because sorting the array \n        # SC = O(1); no extra space needed; sorting was done in place.\n        \n        # sorting the array in descending order\n        nums.sort(reverse = True)\n        \n        # maximum product can only occur for:\n        # 1. positive no * positive no * positive no\n        # 2. negative no * negative no * positive no\n        \n        # one negative and two positives and all negatives wont give max product\n        # case where all numbers in the array are negative \n        # eg : [-4-3-2-1] is covered in all positives \n        \n        return max(nums[0]*nums[1]*nums[2]nums[-1]*nums[-2]*nums[0])\n
Maximum Product of Two Elements in an Array,###  1464\. Maximum Product of Two Elements in an Array\n\nGiven the array of integers `nums` you will choose two different indices `i`\nand `j` of that array. _Return the maximum value of_\n`(nums[i]-1)*(nums[j]-1)`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3452]\n    **Output:** 12 \n    **Explanation:** If you choose the indices i=1 and j=2 (indexed from 0) you will get the maximum value that is (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1545]\n    **Output:** 16\n    **Explanation:** Choosing the indices i=1 and j=3 (indexed from 0) you will get the maximum value of (5-1)*(5-1) = 16.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [37]\n    **Output:** 12\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 500`\n  * `1 <= nums[i] <= 10^3`\n\n,class Solution:\n    def maxProduct(self nums: List[int]) -> int:\n        # mx1 - max element mx2 - second max element\n        mx1 = nums[0] if nums[0] > nums[1] else nums[1]\n        mx2 = nums[1] if nums[0] > nums[1] else nums[0]\n        for num in nums[2:]:\n            if num > mx1:\n                mx1 mx2 = num mx1\n            elif num > mx2:\n                mx2 = num\n\n        return (mx1 - 1) * (mx2 - 1)\n\n
Maximum Product of Word Lengths,"###  318\. Maximum Product of Word Lengths\n\nGiven a string array `words` return _the maximum value of_ `length(word[i]) *\nlength(word[j])` _where the two words do not share common letters_. If no such\ntwo words exist return `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""abcw""""baz""""foo""""bar""""xtfn""""abcdef""]\n    **Output:** 16\n    **Explanation:** The two words can be ""abcw"" ""xtfn"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""a""""ab""""abc""""d""""cd""""bcd""""abcd""]\n    **Output:** 4\n    **Explanation:** The two words can be ""ab"" ""cd"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""a""""aa""""aaa""""aaaa""]\n    **Output:** 0\n    **Explanation:** No such pair of words.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= words.length <= 1000`\n  * `1 <= words[i].length <= 1000`\n  * `words[i]` consists only of lowercase English letters.\n\n",// Runtime: 332 ms (Top 87.93%) | Memory: 19.80 MB (Top 74.15%)\n\nclass Solution:\n    def maxProduct(self words: List[str]) -> int:\n        n=len(words)\n        \n        bit_masks = [0] * n\n        lengths = [0] * n\n        \n        for i in range(n):             \n            for c in words[i]:\n                bit_masks[i]|=1<<(ord(c) - ord('a')) # set the character bit            \n            lengths[i]=len(words[i])\n                        \n        max_val = 0\n        for i in range(n):\n            for j in range(i+1 n):\n                if not (bit_masks[i] & bit_masks[j]):\n                    max_val=max(max_val lengths[i] * lengths[j])\n        \n        return max_val  \n
Maximum Product Subarray,###  152\. Maximum Product Subarray\n\nGiven an integer array `nums` find a contiguous non-empty subarray within the\narray that has the largest product and return _the product_.\n\nThe test cases are generated so that the answer will fit in a **32-bit**\ninteger.\n\nA **subarray** is a contiguous subsequence of the array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [23-24]\n    **Output:** 6\n    **Explanation:** [23] has the largest product 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-20-1]\n    **Output:** 0\n    **Explanation:** The result cannot be 2 because [-2-1] is not a subarray.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 104`\n  * `-10 <= nums[i] <= 10`\n  * The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\n,class Solution:\n    def maxProduct(self nums: List[int]) -> int:\n        prod=1\n        maxprod=-100000000\n        for i in range(len(nums)): # traverse from L-R so that we get max \n            prod*=nums[i]\n            maxprod=max(maxprodprod)\n            if prod==0:\n                prod=1\n\n        prod=1\n        for i in range(len(nums)-1-1-1): #if 0 or -ve present at starting then find from back\n            prod*=nums[i]\n            maxprod=max(maxprodprod)\n            if prod==0:\n                prod=1\n\n        return maxprod\n
Maximum Profit in Job Scheduling,###  1235\. Maximum Profit in Job Scheduling\n\nWe have `n` jobs where every job is scheduled to be done from `startTime[i]`\nto `endTime[i]` obtaining a profit of `profit[i]`.\n\nYou're given the `startTime` `endTime` and `profit` arrays return the\nmaximum profit you can take such that there are no two jobs in the subset with\noverlapping time range.\n\nIf you choose a job that ends at time `X` you will be able to start another\njob that starts at time `X`.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2019/10/10/sample1_1584.png)**\n\n    \n    \n    **Input:** startTime = [1233] endTime = [3456] profit = [50104070]\n    **Output:** 120\n    **Explanation:** The subset chosen is the first and fourth job. \n    Time range [1-3]+[3-6]  we get profit of 120 = 50 + 70.\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2019/10/10/sample22_1584.png)**\n\n    \n    \n    **Input:** startTime = [12346] endTime = [351069] profit = [20201007060]\n    **Output:** 150\n    **Explanation:** The subset chosen is the first fourth and fifth job. \n    Profit obtained 150 = 20 + 70 + 60.\n    \n\n**Example 3:**\n\n**![](https://assets.leetcode.com/uploads/2019/10/10/sample3_1584.png)**\n\n    \n    \n    **Input:** startTime = [111] endTime = [234] profit = [564]\n    **Output:** 6\n    \n\n\n\n**Constraints:**\n\n  * `1 <= startTime.length == endTime.length == profit.length <= 5 * 104`\n  * `1 <= startTime[i] < endTime[i] <= 109`\n  * `1 <= profit[i] <= 104`\n\n,# Runtime: 990 ms (Top 41.71%) | Memory: 47.5 MB (Top 21.04%)\nclass Solution:\n    def jobScheduling(self startTime: List[int] endTime: List[int] profit: List[int]) -> int:\n        n = len(startTime)\n        jobs = list(zip(startTime endTime profit))\n        jobs.sort()\n        startTime.sort()\n        @lru_cache(None)\n        def recur(i):\n            if i == n:\n                return 0\n            j = bisect_left(startTime jobs[i][1])\n            one = jobs[i][2] + recur(j)\n            two = recur(i+1)\n            return max(one two)\n        return recur(0)
Maximum Profit of Operating a Centennial Wheel,###  1599\. Maximum Profit of Operating a Centennial Wheel\n\nYou are the operator of a Centennial Wheel that has **four gondolas**  and\neach gondola has room for **up** **to** **four people**. You have the ability\nto rotate the gondolas **counterclockwise**  which costs you `runningCost`\ndollars.\n\nYou are given an array `customers` of length `n` where `customers[i]` is the\nnumber of new customers arriving just before the `ith` rotation (0-indexed).\nThis means you **must rotate the wheel**`i`**times before\nthe**`customers[i]`**customers arrive**. **You cannot make customers wait if\nthere is room in the gondola**. Each customer pays `boardingCost` dollars when\nthey board on the gondola closest to the ground and will exit once that\ngondola reaches the ground again.\n\nYou can stop the wheel at any time including **before** **serving** **all**\n**customers**. If you decide to stop serving customers **all subsequent\nrotations are free** in order to get all the customers down safely. Note that\nif there are currently more than four customers waiting at the wheel only\nfour will board the gondola and the rest will wait **for the next rotation**.\n\nReturn _the minimum number of rotations you need to perform to maximize your\nprofit._ If there is **no scenario** where the profit is positive return\n`-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/09/wheeldiagram12.png)\n\n    \n    \n    **Input:** customers = [83] boardingCost = 5 runningCost = 6\n    **Output:** 3\n    **Explanation:** The numbers written on the gondolas are the number of people currently there.\n    1. 8 customers arrive 4 board and 4 wait for the next gondola the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n    2. 3 customers arrive the 4 waiting board the wheel and the other 3 wait the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n    3. The final 3 customers board the gondola the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\n    The highest profit was $37 after rotating the wheel 3 times.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** customers = [1096] boardingCost = 6 runningCost = 4\n    **Output:** 7\n    **Explanation:**\n    1. 10 customers arrive 4 board and 6 wait for the next gondola the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n    2. 9 customers arrive 4 board and 11 wait (2 originally waiting 9 newly waiting) the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n    3. The final 6 customers arrive 4 board and 13 wait the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n    4. 4 board and 9 wait the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n    5. 4 board and 5 wait the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n    6. 4 board and 1 waits the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n    7. 1 boards the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\n    The highest profit was $122 after rotating the wheel 7 times.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** customers = [34051] boardingCost = 1 runningCost = 92\n    **Output:** -1\n    **Explanation:**\n    1. 3 customers arrive 3 board and 0 wait the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n    2. 4 customers arrive 4 board and 0 wait the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n    3. 0 customers arrive 0 board and 0 wait the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n    4. 5 customers arrive 4 board and 1 waits the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n    5. 1 customer arrives 2 board and 0 wait the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\n    The profit was never positive so return -1.\n    \n\n\n\n**Constraints:**\n\n  * `n == customers.length`\n  * `1 <= n <= 105`\n  * `0 <= customers[i] <= 50`\n  * `1 <= boardingCost runningCost <= 100`\n\n,import sys\nMIN_INT = -sys.maxsize-1\nclass Solution:\n    def minOperationsMaxProfit(self customers: List[int] boardingCost: int runningCost: int) -> int:\n        maxx = MIN_INT\n        rotate = total =  ans = money = num = i = 0\n        for i in range(len(customers)):\n            total += customers[i]\n            rotate = i+1\n            if total >= 4:\n                num += 4\n                total -= 4\n            else: \n                num += total\n                total = 0\n            money = num * boardingCost - rotate * runningCost\n            if maxx < money:\n                maxx = money\n                ans = rotate\n        i+=1\n        while(total > 0):\n            rotate = i+1\n            if total >= 4:\n                num += 4\n                total -= 4\n            else: \n                num += total\n                total = 0\n            money = num * boardingCost - rotate * runningCost\n            if maxx < money:\n                maxx = money\n                ans = rotate\n            i+=1\n        if maxx < 0: return -1\n        return ans\n
Maximum Repeating Substring,"###  1668\. Maximum Repeating Substring\n\nFor a string `sequence` a string `word` is **`k`-repeating** if `word`\nconcatenated `k` times is a substring of `sequence`. The `word`'s\n**maximum`k`-repeating value** is the highest value `k` where `word` is\n`k`-repeating in `sequence`. If `word` is not a substring of `sequence`\n`word`'s maximum `k`-repeating value is `0`.\n\nGiven strings `sequence` and `word` return _the**maximum`k`-repeating value**\nof `word` in `sequence`_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** sequence = ""ababc"" word = ""ab""\n    **Output:** 2\n    **Explanation:** ""abab"" is a substring in ""_abab_ c"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** sequence = ""ababc"" word = ""ba""\n    **Output:** 1\n    **Explanation:** ""ba"" is a substring in ""a _ba_ bc"". ""baba"" is not a substring in ""ababc"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** sequence = ""ababc"" word = ""ac""\n    **Output:** 0\n    **Explanation:** ""ac"" is not a substring in ""ababc"". \n    \n\n\n\n**Constraints:**\n\n  * `1 <= sequence.length <= 100`\n  * `1 <= word.length <= 100`\n  * `sequence` and `word` contains only lowercase English letters.\n\n",# Runtime: 61 ms (Top 15.28%) | Memory: 13.8 MB (Top 62.83%)\nclass Solution:\n    def maxRepeating(self sequence: str word: str) -> int:\n        if word not in sequence:\n            return 0\n\n        left = 1\n        right = len(sequence) // len(word)\n        while left <= right:\n            mid = (left + right) // 2\n            if word * mid in sequence:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return left - 1
Maximum Score After Splitting a String,"###  1422\. Maximum Score After Splitting a String\n\nGiven a string `s` of zeros and ones _return the maximum score after\nsplitting the string into two**non-empty** substrings_ (i.e. **left**\nsubstring and **right** substring).\n\nThe score after splitting a string is the number of **zeros** in the **left**\nsubstring plus the number of **ones** in the **right** substring.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""011101""\n    **Output:** 5 \n    **Explanation:** \n    All possible ways of splitting s into two non-empty substrings are:\n    left = ""0"" and right = ""11101"" score = 1 + 4 = 5 \n    left = ""01"" and right = ""1101"" score = 1 + 3 = 4 \n    left = ""011"" and right = ""101"" score = 1 + 2 = 3 \n    left = ""0111"" and right = ""01"" score = 1 + 1 = 2 \n    left = ""01110"" and right = ""1"" score = 2 + 1 = 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""00111""\n    **Output:** 5\n    **Explanation:** When left = ""00"" and right = ""111"" we get the maximum score = 2 + 3 = 5\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""1111""\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 500`\n  * The string `s` consists of characters `'0'` and `'1'` only.\n\n","# Runtime: 67 ms (Top 31.53%) | Memory: 13.9 MB (Top 60.59%)\nclass Solution:\n    def maxScore(self s: str) -> int:\n        m0=0\n        m1=0\n        for i in s:\n            if i==""0"":\n                m0+=1\n            else:\n                m1+=1\n        if m0==0 or m1==0:\n            return max(m0-1m1-1)\n        l=len(s)\n        i=0\n        max_=0\n        c0=0\n        c1=m1\n        idx=-1\n        while i <l:\n            if s[i]==""0"":\n                c0+=1\n            else:\n                c1-=1\n            if max_<c1+c0:\n                max_=c1+c0\n                idx=i\n            max_=max(max_c1+c0)\n            i+=1\n        if idx==l-1:\n            return max_-1\n        return max_\n"
Maximum Score from Performing Multiplication Operations,###  1770\. Maximum Score from Performing Multiplication Operations\n\nYou are given two integer arrays `nums` and `multipliers`**** of size `n` and\n`m` respectively where `n >= m`. The arrays are **1-indexed**.\n\nYou begin with a score of `0`. You want to perform **exactly** `m` operations.\nOn the `ith` operation **(1-indexed)**  you will:\n\n  * Choose one integer `x` from **either the start or the end** of the array `nums`.\n  * Add `multipliers[i] * x` to your score.\n  * Remove `x` from the array `nums`.\n\nReturn _the**maximum** score after performing _`m` _operations._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123] multipliers = [321]\n    **Output:** 14\n    **Explanation:**  An optimal solution is as follows:\n    - Choose from the end [12**_3_**] adding 3 * 3 = 9 to the score.\n    - Choose from the end [1**_2_**] adding 2 * 2 = 4 to the score.\n    - Choose from the end [**_1_**] adding 1 * 1 = 1 to the score.\n    The total score is 9 + 4 + 1 = 14.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-5-3-3-271] multipliers = [-10-5346]\n    **Output:** 102\n    **Explanation:** An optimal solution is as follows:\n    - Choose from the start [_**-5**_ -3-3-271] adding -5 * -10 = 50 to the score.\n    - Choose from the start [**_-3_** -3-271] adding -3 * -5 = 15 to the score.\n    - Choose from the start [**_-3_** -271] adding -3 * 3 = -9 to the score.\n    - Choose from the end [-27**_1_**] adding 1 * 4 = 4 to the score.\n    - Choose from the end [-2**_7_**] adding 7 * 6 = 42 to the score. \n    The total score is 50 + 15 - 9 + 4 + 42 = 102.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `m == multipliers.length`\n  * `1 <= m <= 103`\n  * `m <= n <= 105`` `\n  * `-1000 <= nums[i] multipliers[i] <= 1000`\n\n,class Solution:\n    def maximumScore(self nums: List[int] multipliers: List[int]) -> int:\n        n = len(nums)\n        m = len(multipliers)\n        \n        @lru_cache(None)\n        #To Save Computed Result\n        \n        def X(i left):\n            \n            if i==m:\n                return 0\n            \n            return max  (   (multipliers[i] * nums[left])          + X(i + 1 left + 1) \n                            (multipliers[i] * nums[n-1-(i-left)])  + X(i + 1 left)       )        \n                \n        #Start from Zero operations\n        return X(00)\n
Maximum Score From Removing Stones,###  1753\. Maximum Score From Removing Stones\n\nYou are playing a solitaire game with **three piles** of stones of sizes\n`a`​​​​​​ `b`​​​​​​ and `c`​​​​​​\nrespectively. Each turn you choose two **different non-empty** piles take one\nstone from each and add `1` point to your score. The game stops when there\nare **fewer than two non-empty** piles (meaning there are no more available\nmoves).\n\nGiven three integers `a`​​​​​ `b`​​​​​ and\n`c`​​​​​ return _the_ **_maximum_ **_**score** you can get._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** a = 2 b = 4 c = 6\n    **Output:** 6\n    **Explanation:** The starting state is (2 4 6). One optimal set of moves is:\n    - Take from 1st and 3rd piles state is now (1 4 5)\n    - Take from 1st and 3rd piles state is now (0 4 4)\n    - Take from 2nd and 3rd piles state is now (0 3 3)\n    - Take from 2nd and 3rd piles state is now (0 2 2)\n    - Take from 2nd and 3rd piles state is now (0 1 1)\n    - Take from 2nd and 3rd piles state is now (0 0 0)\n    There are fewer than two non-empty piles so the game ends. Total: 6 points.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** a = 4 b = 4 c = 6\n    **Output:** 7\n    **Explanation:** The starting state is (4 4 6). One optimal set of moves is:\n    - Take from 1st and 2nd piles state is now (3 3 6)\n    - Take from 1st and 3rd piles state is now (2 3 5)\n    - Take from 1st and 3rd piles state is now (1 3 4)\n    - Take from 1st and 3rd piles state is now (0 3 3)\n    - Take from 2nd and 3rd piles state is now (0 2 2)\n    - Take from 2nd and 3rd piles state is now (0 1 1)\n    - Take from 2nd and 3rd piles state is now (0 0 0)\n    There are fewer than two non-empty piles so the game ends. Total: 7 points.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** a = 1 b = 8 c = 8\n    **Output:** 8\n    **Explanation:** One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\n    After that there are fewer than two non-empty piles so the game ends.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= a b c <= 105`\n\n,class Solution:\n    def maximumScore(self a: int b: int c: int) -> int:\n        a b c = sorted([a b c] reverse=True)\n        ans = 0\n        while a > 0 and b > 0:\n            a -= 1\n            b -= 1\n            ans += 1\n            a b c = sorted([a b c] reverse=True)\n        return ans\n
Maximum Score From Removing Substrings,"###  1717\. Maximum Score From Removing Substrings\n\nYou are given a string `s` and two integers `x` and `y`. You can perform two\ntypes of operations any number of times.\n\n  * Remove substring `""ab""` and gain `x` points. \n    * For example when removing `""ab""` from `""c _ab_ xbae""` it becomes `""cxbae""`.\n  * Remove substring `""ba""` and gain `y` points. \n    * For example when removing `""ba""` from `""cabx _ba_ e""` it becomes `""cabxe""`.\n\nReturn _the maximum points you can gain after applying the above operations\non_ `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""cdbcbbaaabab"" x = 4 y = 5\n    **Output:** 19\n    **Explanation:**\n    - Remove the ""ba"" underlined in ""cdbcbbaaa _ba_ b"". Now s = ""cdbcbbaaab"" and 5 points are added to the score.\n    - Remove the ""ab"" underlined in ""cdbcbbaa _ab_ "". Now s = ""cdbcbbaa"" and 4 points are added to the score.\n    - Remove the ""ba"" underlined in ""cdbcb _ba_ a"". Now s = ""cdbcba"" and 5 points are added to the score.\n    - Remove the ""ba"" underlined in ""cdbc _ba_ "". Now s = ""cdbc"" and 5 points are added to the score.\n    Total score = 5 + 4 + 5 + 5 = 19.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aabbaaxybbaabb"" x = 5 y = 4\n    **Output:** 20\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `1 <= x y <= 104`\n  * `s` consists of lowercase English letters.\n\n",class Solution:\n    def maximumGain(self s: str x: int y: int) -> int:\n        a = 'a'\n        b = 'b'\n        if x < y:\n            x y = y x\n            a b = b a\n        seen = Counter()\n        ans = 0\n        for c in s + 'x':\n            if c in 'ab':\n                if c == b and 0 < seen[a]:\n                    ans += x\n                    seen[a] -= 1\n                else:\n                    seen[c] += 1\n            else:\n                ans += y * min(seen[a] seen[b])\n                seen = Counter()\n\n        return ans\n
Maximum Score of a Good Subarray,###  1793\. Maximum Score of a Good Subarray\n\nYou are given an array of integers `nums` **(0-indexed)** and an integer `k`.\n\nThe **score** of a subarray `(i j)` is defined as `min(nums[i] nums[i+1]\n... nums[j]) * (j - i + 1)`. A **good** subarray is a subarray where `i <= k\n<= j`.\n\nReturn _the maximum possible**score** of a **good** subarray._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [143745] k = 3\n    **Output:** 15\n    **Explanation:** The optimal subarray is (1 5) with a score of min(43745) * (5-1+1) = 3 * 5 = 15. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [55454111] k = 0\n    **Output:** 20\n    **Explanation:** The optimal subarray is (0 4) with a score of min(55454) * (4-0+1) = 4 * 5 = 20.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 2 * 104`\n  * `0 <= k < nums.length`\n\n,"class Solution:\n    def nextSmallerElement(self nums):\n        nextSmaller = [None] * len(nums)\n        stack = [[-sys.maxsize -1]]\n        for i in range(len(nums)-1 -1 -1):\n            while nums[i] <= stack[-1][0]:\n                stack.pop()\n            nextSmaller[i] = stack[-1][1]\n            stack.append([nums[i] i])\n        return nextSmaller\n            \n    \n    def previousSmallerElement(self nums):\n        previousSmaller = [None] * len(nums)\n        stack = [[-sys.maxsize -1]]\n        for i in range(len(nums)):\n            while nums[i] <= stack[-1][0]:\n                stack.pop()\n            previousSmaller[i] = stack[-1][1]\n            stack.append([nums[i] i])\n        return previousSmaller\n    \n    def maximumScore(self nums: List[int] k: int) -> int:\n        nextSmaller = self.nextSmallerElement(nums)\n        previousSmaller = self.previousSmallerElement(nums)\n\n        score = 0\n        for idx num in enumerate(nums):\n			# previousSmaller[idx] (let's say i) and nextSmaller[idx] (let's say j) ensures that the element present at idx is the minimum in range (i -> j)\n            i = previousSmaller[idx]\n            i += 1\n            j = nextSmaller[idx]\n            if j == -1:\n                j = len(nums)\n            j -= 1\n            if i <= k <= j:\n                score = max(score num * (j-i+1))\n        \n        return score\n            \n"
Maximum Score of a Node Sequence,###  2242\. Maximum Score of a Node Sequence\n\nThere is an **undirected** graph with `n` nodes numbered from `0` to `n - 1`.\n\nYou are given a **0-indexed** integer array `scores` of length `n` where\n`scores[i]` denotes the score of node `i`. You are also given a 2D integer\narray `edges` where `edges[i] = [ai bi]` denotes that there exists an\n**undirected** edge connecting nodes `ai` and `bi`.\n\nA node sequence is **valid** if it meets the following conditions:\n\n  * There is an edge connecting every pair of **adjacent** nodes in the sequence.\n  * No node appears more than once in the sequence.\n\nThe score of a node sequence is defined as the **sum** of the scores of the\nnodes in the sequence.\n\nReturn _the**maximum score** of a valid node sequence with a length of _`4`\n_._ If no such sequence exists return __`-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png)\n\n    \n    \n    **Input:** scores = [52984] edges = [[01][12][23][02][13][24]]\n    **Output:** 24\n    **Explanation:** The figure above shows the graph and the chosen node sequence [0123].\n    The score of the node sequence is 5 + 2 + 9 + 8 = 24.\n    It can be shown that no other node sequence has a score of more than 24.\n    Note that the sequences [3120] and [1023] are also valid and have a score of 24.\n    The sequence [0324] is not valid since no edge connects nodes 0 and 3.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/17/ex2.png)\n\n    \n    \n    **Input:** scores = [920641112] edges = [[03][53][24][13]]\n    **Output:** -1\n    **Explanation:** The figure above shows the graph.\n    There are no valid node sequences of length 4 so we return -1.\n    \n\n\n\n**Constraints:**\n\n  * `n == scores.length`\n  * `4 <= n <= 5 * 104`\n  * `1 <= scores[i] <= 108`\n  * `0 <= edges.length <= 5 * 104`\n  * `edges[i].length == 2`\n  * `0 <= ai bi <= n - 1`\n  * `ai != bi`\n  * There are no duplicate edges.\n\n,"# defaultdict is the same as Python's usual dictionary but if an\n# element doesn't exist you can give it a default value to initialize with. \nfrom collections import defaultdict\n# nlargest(n l) - returns the n largest values of collection l.\nfrom heapq import nlargest\n# ""product"" is a function that takes two collections and \n# returns every pair between them.\n# product(""ab"" ""cd"") = [(a c) (a d) (b c) (b d)].\nfrom itertools import product\n\nLet V be the number of nodes and E = len(edges).\n# Time complexity: O(V + E) - we iterate through every vertex \n#                  and every edge a constant number of times.\n# Space complexity: O(V) - we save a constant \n#                   number of neighbors (3) for every node.\nclass Solution:\n    def maximumScore(self scores: List[int] edges: List[List[int]]) -> int:\n        # Turn the edge list into an adjacency graph.\n        m = defaultdict(list)\n        for u v in edges:\n            m[u].append((scores[v] v)) \n            m[v].append((scores[u] u))\n        \n        # Cut down all neighbors of each node to the three\n        # that have the highest value.\n        for u in m:\n            m[u] = nlargest(3 m[u])\n\n        ret = -1\n        # Consider each edge to potentially be (B C) for a quadruplet.\n        for b c in edges:\n            # For every possible A and D in the neighbors of B and C...\n            for (aWeight a) (dWeight d) in product(m[b] m[c]):\n                # ... If we have no redundant nodes it's a quadruplet.\n                # Since it's the highest value quadruplet we could\n                # possibly make with B and C this solution is always accurate.\n                if a not in [b c] and d not in [b c] and a != d:\n                    ret = max(ret scores[b] + scores[c] + aWeight + dWeight)\n                    \n        return ret\n"
Maximum Score Of Spliced Array,###  2321\. Maximum Score Of Spliced Array\n\nYou are given two **0-indexed** integer arrays `nums1` and `nums2` both of\nlength `n`.\n\nYou can choose two integers `left` and `right` where `0 <= left <= right < n`\nand **swap** the subarray `nums1[left...right]` with the subarray\n`nums2[left...right]`.\n\n  * For example if `nums1 = [12345]` and `nums2 = [1112131415]` and you choose `left = 1` and `right = 2` `nums1` becomes `[1**_1213_** 45]` and `nums2` becomes `[11**_23_** 1415]`.\n\nYou may choose to apply the mentioned operation **once** or not do anything.\n\nThe **score** of the arrays is the **maximum** of `sum(nums1)` and\n`sum(nums2)` where `sum(arr)` is the sum of all the elements in the array\n`arr`.\n\nReturn _the**maximum possible score**_.\n\nA **subarray** is a contiguous sequence of elements within an array.\n`arr[left...right]` denotes the subarray that contains the elements of `nums`\nbetween indices `left` and `right` (**inclusive**).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [606060] nums2 = [109010]\n    **Output:** 210\n    **Explanation:** Choosing left = 1 and right = 1 we have nums1 = [60_**90**_ 60] and nums2 = [10_**60**_ 10].\n    The score is max(sum(nums1) sum(nums2)) = max(210 80) = 210.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [2040207030] nums2 = [5020504020]\n    **Output:** 220\n    **Explanation:** Choosing left = 3 right = 4 we have nums1 = [204020_**4020**_] and nums2 = [502050_**7030**_].\n    The score is max(sum(nums1) sum(nums2)) = max(140 220) = 220.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [71113] nums2 = [111]\n    **Output:** 31\n    **Explanation:** We choose not to swap any subarray.\n    The score is max(sum(nums1) sum(nums2)) = max(31 3) = 31.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums1.length == nums2.length`\n  * `1 <= n <= 105`\n  * `1 <= nums1[i] nums2[i] <= 104`\n\n,"class Solution:\n    def maximumsSplicedArray(self nums1: List[int] nums2: List[int]) -> int:\n        n = len(nums1)\n		nums3 = [0]*n\n		nums4 = [0]*n\n		for i in range(n):\n			nums3[i] = nums1[i]-nums2[i]\n			nums4[i] = nums2[i]-nums1[i]\n		maxsubseq1 = maxsubseq2 = 0\n		v1 = v2 = 0 \n		# use kadane algorithm to solve this max subseq problem\n		for i in range(n):\n			maxsubseq1 = max(maxsubseq1 + nums3[i] nums3[i])\n			maxsubseq2 = max(maxsubseq2 + nums4[i] nums4[i])\n			v1 = max(v1 maxsubseq1)\n			v2 = max(v2 maxsubseq2)\n		_sum1 = sum(nums1)\n		_sum2 = sum(nums2)\n		return max(_sum1 + v2 _sum2 + v1)\n"
Maximum Score Words Formed by Letters,"###  1255\. Maximum Score Words Formed by Letters\n\nGiven a list of `words` list of  single `letters` (might be repeating) and\n`score` of every character.\n\nReturn the maximum score of **any** valid set of words formed by using the\ngiven letters (`words[i]` cannot be used two or more times).\n\nIt is not necessary to use all characters in `letters` and each letter can\nonly be used once. Score of letters `'a'` `'b'` `'c'` ... `'z'` is given\nby `score[0]` `score[1]` ...  `score[25]` respectively.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""dog""""cat""""dad""""good""] letters = [""a""""a""""c""""d""""d""""d""""g""""o""""o""] score = [10950030000000200000000000]\n    **Output:** 23\n    **Explanation:**\n    Score  a=1 c=9 d=5 g=3 o=2\n    Given letters we can form the words ""dad"" (5+1+5) and ""good"" (3+2+2+5) with a score of 23.\n    Words ""dad"" and ""dog"" only get a score of 21.\n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""xxxz""""ax""""bx""""cx""] letters = [""z""""a""""b""""c""""x""""x""""x""] score = [444000000000000000000005010]\n    **Output:** 27\n    **Explanation:**\n    Score  a=4 b=4 c=4 x=5 z=10\n    Given letters we can form the words ""ax"" (4+5) ""bx"" (4+5) and ""cx"" (4+5) with a score of 27.\n    Word ""xxxz"" only get a score of 25.\n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""leetcode""] letters = [""l""""e""""t""""c""""o""""d""] score = [00111000000100100001000000]\n    **Output:** 0\n    **Explanation:**\n    Letter ""e"" can only be used once.\n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 14`\n  * `1 <= words[i].length <= 15`\n  * `1 <= letters.length <= 100`\n  * `letters[i].length == 1`\n  * `score.length == 26`\n  * `0 <= score[i] <= 10`\n  * `words[i]` `letters[i]` contains only lower case English letters.\n\n","// Runtime: 61 ms (Top 55.33%) | Memory: 17.40 MB (Top 11.89%)\n\nclass Solution:\n    def maxScoreWords(self words: List[str] letters: List[str] score: List[int]) -> int:\n\n        f ans = lambda x : sum(score[ord(c) - 97] for c in x) 0\n\n        def dfs(wordsletters tally):\n            nonlocal ans\n            \n            for i in range(len(words)):\n                cWord=Counter(words[i])\n				\n                if all(letters[c] >= cWord[c] for c in cWord):\n                    dfs(words[i+1:] letters - cWord tally + f(words[i]))\n\n            ans = max(anstally)\n            return ans\n\n        return dfs(words Counter(letters) 0)\n"
Maximum Side Length of a Square with Sum Less than or Equal to Threshold,###  1292\. Maximum Side Length of a Square with Sum Less than or Equal to\nThreshold\n\nGiven a `m x n` matrix `mat` and an integer `threshold` return _the maximum\nside-length of a square with a sum less than or equal to_`threshold` _or\nreturn_`0` _if there is no such square_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/12/05/e1.png)\n\n    \n    \n    **Input:** mat = [[1132432][1132432][1132432]] threshold = 4\n    **Output:** 2\n    **Explanation:** The maximum side length of square with sum less than 4 is 2 as shown.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mat = [[22222][22222][22222][22222][22222]] threshold = 1\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat[i].length`\n  * `1 <= m n <= 300`\n  * `0 <= mat[i][j] <= 104`\n  * `0 <= threshold <= 105`\n\n,class Solution:\n    def maxSideLength(self mat: List[List[int]] threshold: int) -> int:\n        # prefix matrix\n        dp = [[0]*(len(mat[0])+1) for _ in range(len(mat)+1)]\n        \n        for i in range(1 len(mat)+1):\n            for j in range(1 len(mat[0])+1):\n                dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + mat[i-1][j-1]\n                       \n        #bin search\n        max_side = 0\n        for i in range(1 len(mat) + 1):\n            for j in range(1 len(mat[0]) + 1):\n                if min(i j) < max_side:\n                    continue\n                left = 0\n                right = min(ij)\n                while left <= right:\n                    mid = (left+right)//2\n                    pref_sum = dp[i][j] - dp[i-mid][j] - dp[i][j-mid] + dp[i-mid][j-mid]\n                    if pref_sum <= threshold:\n                        max_side = max(max_side mid)\n                        left = mid + 1\n                    else:\n                        right = mid - 1\n        return max_side\n                    \n
Maximum Split of Positive Even Integers,###  2178\. Maximum Split of Positive Even Integers\n\nYou are given an integer `finalSum`. Split it into a sum of a **maximum**\nnumber of **unique** positive even integers.\n\n  * For example given `finalSum = 12` the following splits are **valid** (unique positive even integers summing up to `finalSum`): `(12)` `(2 + 10)` `(2 + 4 + 6)` and `(4 + 8)`. Among them `(2 + 4 + 6)` contains the maximum number of integers. Note that `finalSum` cannot be split into `(2 + 2 + 4 + 4)` as all the numbers should be unique.\n\nReturn _a list of integers that represent a valid split containing\na**maximum** number of integers_. If no valid split exists for `finalSum`\nreturn _an**empty** list_. You may return the integers in **any** order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** finalSum = 12\n    **Output:** [246]\n    **Explanation:** The following are valid splits: (12) (2 + 10) (2 + 4 + 6) and (4 + 8).\n    (2 + 4 + 6) has the maximum number of integers which is 3. Thus we return [246].\n    Note that [264] [624] etc. are also accepted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** finalSum = 7\n    **Output:** []\n    **Explanation:** There are no valid splits for the given finalSum.\n    Thus we return an empty array.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** finalSum = 28\n    **Output:** [68212]\n    **Explanation:** The following are valid splits: (2 + 26) (6 + 8 + 2 + 12) and (4 + 24). \n    (6 + 8 + 2 + 12) has the maximum number of integers which is 4. Thus we return [68212].\n    Note that [102412] [62416] etc. are also accepted.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= finalSum <= 1010`\n\n,# Runtime: 1817 ms (Top 5.05%) | Memory: 26.8 MB (Top 41.50%)\nclass Solution:\n    def maximumEvenSplit(self finalSum: int) -> List[int]:\n        l=[]\n        if finalSum%2!=0:\n            return l\n        else:\n            s=0\n            i=2 # even pointer 2 4 6 8 10 12...........\n            while(s<finalSum):\n                s+=i #sum\n                l.append(i) # append the i in list\n                i+=2\n            if s==finalSum: #if sum s is equal to finalSum then no modidfication required\n                return l\n            else:\n                l.pop(l.index(s-finalSum)) #Deleting the element which makes s greater than finalSum\n            return l
Maximum Subarray,###  53\. Maximum Subarray\n\nGiven an integer array `nums` find the contiguous subarray (containing at\nleast one number) which has the largest sum and return _its sum_.\n\nA **subarray** is a **contiguous** part of an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [-21-34-121-54]\n    **Output:** 6\n    **Explanation:** [4-121] has the largest sum = 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1]\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [54-178]\n    **Output:** 23\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-104 <= nums[i] <= 104`\n\n\n\n**Follow up:** If you have figured out the `O(n)` solution try coding another\nsolution using the **divide and conquer** approach which is more subtle.\n\n,# Runtime: 782 ms (Top 6.1%) | Memory: 163.13 MB (Top 6.3%)\n\nclass Solution:\n    def maxSubArray(self nums: List[int]) -> int:\n        def kadane(i):\n            if F[i] != None:\n                return F[i]\n            F[i] = max(nums[i]kadane(i-1) + nums[i])\n            return F[i]\n        n = len(nums)\n        F = [None for _ in range(n)]\n        F[0] = nums[0]\n        kadane(n-1)\n        return max(F)
Maximum Sum Circular Subarray,###  918\. Maximum Sum Circular Subarray\n\nGiven a **circular integer array** `nums` of length `n` return _the maximum\npossible sum of a non-empty**subarray** of _`nums`.\n\nA **circular array** means the end of the array connects to the beginning of\nthe array. Formally the next element of `nums[i]` is `nums[(i + 1) % n]` and\nthe previous element of `nums[i]` is `nums[(i - 1 + n) % n]`.\n\nA **subarray** may only include each element of the fixed buffer `nums` at\nmost once. Formally for a subarray `nums[i] nums[i + 1] ... nums[j]`\nthere does not exist `i <= k1` `k2 <= j` with `k1 % n == k2 % n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1-23-2]\n    **Output:** 3\n    **Explanation:** Subarray [3] has maximum sum 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [5-35]\n    **Output:** 10\n    **Explanation:** Subarray [55] has maximum sum 5 + 5 = 10.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [-3-2-3]\n    **Output:** -2\n    **Explanation:** Subarray [-2] has maximum sum -2.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 3 * 104`\n  * `-3 * 104 <= nums[i] <= 3 * 104`\n\n,# Runtime: 729 ms (Top 66.43%) | Memory: 18.9 MB (Top 76.46%)\nclass Solution:\n\n    def kadanes(selfnums):\n\n        #kadanes algo\n\n        max_till_now = nums[0]\n        curr_max = nums[0]\n\n        for i in range(1len(nums)):\n            curr_max = max(curr_max+nums[i]nums[i])\n            max_till_now = max(max_till_nowcurr_max)\n\n        return max_till_now\n\n    def maxSubarraySumCircular(self nums: List[int]) -> int:\n\n        #there will be 2 case\n        #case 1 : our max subarray is not wrapping i.e not circular\n        #case 2: our max subarray is wrapping i.e circular\n\n        # case 1 is easy to find\n        # to find case 2 what we can do is if we multiply each nums element by -1 and\n        # on that find kadanes then we will get sum of elements which is not part of maxsubarray in case2 (not part because we negate)\n        # now subtract this newmax in case 2 from total nums sum we get wrapping sum\n        # max of case1 and case is our ans\n\n        total = sum(nums)\n\n        nonwrappingsum = self.kadanes(nums)\n\n        # edge case when all elements are -ve then return max negative\n        if nonwrappingsum<0:\n            return nonwrappingsum\n\n        #negate\n        for i in range(len(nums)):\n            nums[i]*=-1\n\n        wrappingsum = total-(-self.kadanes(nums)) #-ve because originally it was negated\n\n        return max(nonwrappingsumwrappingsum)\n
Maximum Sum Obtained of Any Permutation,###  1589\. Maximum Sum Obtained of Any Permutation\n\nWe have an array of integers `nums` and an array of `requests` where\n`requests[i] = [starti endi]`. The `ith` request asks for the sum of\n`nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]`. Both\n`starti` and `endi` are _0-indexed_.\n\nReturn _the maximum total sum of all requests**among all permutations** of_\n`nums`.\n\nSince the answer may be too large return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12345] requests = [[13][01]]\n    **Output:** 19\n    **Explanation:** One permutation of nums is [21345] with the following result: \n    requests[0] -> nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8\n    requests[1] -> nums[0] + nums[1] = 2 + 1 = 3\n    Total sum: 8 + 3 = 11.\n    A permutation with a higher total sum is [35421] with the following result:\n    requests[0] -> nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11\n    requests[1] -> nums[0] + nums[1] = 3 + 5  = 8\n    Total sum: 11 + 8 = 19 which is the best that you can do.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [123456] requests = [[01]]\n    **Output:** 11\n    **Explanation:** A permutation with the max total sum is [654321] with request sums [11].\n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1234510] requests = [[02][13][11]]\n    **Output:** 47\n    **Explanation:** A permutation with the max total sum is [4105321] with request sums [191810].\n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 105`\n  * `0 <= nums[i] <= 105`\n  * `1 <= requests.length <= 105`\n  * `requests[i].length == 2`\n  * `0 <= starti <= endi < n`\n\n,# Runtime: 1436 ms (Top 61.0%) | Memory: 50.25 MB (Top 70.4%)\n\nclass Solution:\n    def maxSumRangeQuery(self nums: List[int] requests: List[List[int]]) -> int:\n        count = [0] * len(nums)\n        for i j in requests:\n            count[i] += 1\n            if j + 1 < len(count):\n                count[j+1] -= 1\n        cur = 0\n        for i in range(len(count)):\n            count[i] += cur\n            cur = count[i]\n        return sum(n * c for n c in zip(sorted(nums reverse=True) sorted(count reverse=True))) % (10 ** 9 + 7)
Maximum Sum of 3 Non-Overlapping Subarrays,###  689\. Maximum Sum of 3 Non-Overlapping Subarrays\n\nGiven an integer array `nums` and an integer `k` find three non-overlapping\nsubarrays of length `k` with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of\neach interval (**0-indexed**). If there are multiple answers return the\nlexicographically smallest one.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12126751] k = 2\n    **Output:** [035]\n    **Explanation:** Subarrays [1 2] [2 6] [7 5] correspond to the starting indices [0 3 5].\n    We could have also taken [2 1] but an answer of [1 3 5] would be lexicographically larger.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [121212121] k = 2\n    **Output:** [024]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 104`\n  * `1 <= nums[i] < 216`\n  * `1 <= k <= floor(nums.length / 3)`\n\n,from itertools import accumulate\nfrom functools import lru_cache\n\nclass Solution:\n    def maxSumOfThreeSubarrays(self nums: List[int] k: int) -> List[int]:\n        n = len(nums)\n        windows = list(accumulate(nums))\n        windows = [windows[i+k-1]-(windows[i-1] if i>0 else 0) for i in range(len(windows)-k+1)]\n        \n        @lru_cache(None)\n        def dfs(i t):\n            if t == 0:\n                return 0 []\n            if i >= len(windows):\n                return float('-inf') []\n            cost1 sol1 = dfs(i+k t-1)\n            cost2 sol2 = dfs(i+1 t)\n            if windows[i] + cost1 < cost2:\n                return cost2 sol2\n            return windows[i] + cost1 [i]+sol1\n        return dfs(0 3)[1]
Maximum Total Importance of Roads,###  2285\. Maximum Total Importance of Roads\n\nYou are given an integer `n` denoting the number of cities in a country. The\ncities are numbered from `0` to `n - 1`.\n\nYou are also given a 2D integer array `roads` where `roads[i] = [ai bi]`\ndenotes that there exists a **bidirectional** road connecting cities `ai` and\n`bi`.\n\nYou need to assign each city with an integer value from `1` to `n` where each\nvalue can only be used **once**. The **importance** of a road is then defined\nas the **sum** of the values of the two cities it connects.\n\nReturn _the**maximum total importance** of all roads possible after assigning\nthe values optimally._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/04/07/ex1drawio.png)\n\n    \n    \n    **Input:** n = 5 roads = [[01][12][23][02][13][24]]\n    **Output:** 43\n    **Explanation:** The figure above shows the country and the assigned values of [24531].\n    - The road (01) has an importance of 2 + 4 = 6.\n    - The road (12) has an importance of 4 + 5 = 9.\n    - The road (23) has an importance of 5 + 3 = 8.\n    - The road (02) has an importance of 2 + 5 = 7.\n    - The road (13) has an importance of 4 + 3 = 7.\n    - The road (24) has an importance of 5 + 1 = 6.\n    The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.\n    It can be shown that we cannot obtain a greater total importance than 43.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/04/07/ex2drawio.png)\n\n    \n    \n    **Input:** n = 5 roads = [[03][24][13]]\n    **Output:** 20\n    **Explanation:** The figure above shows the country and the assigned values of [43251].\n    - The road (03) has an importance of 4 + 5 = 9.\n    - The road (24) has an importance of 2 + 1 = 3.\n    - The road (13) has an importance of 3 + 5 = 8.\n    The total importance of all roads is 9 + 3 + 8 = 20.\n    It can be shown that we cannot obtain a greater total importance than 20.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 5 * 104`\n  * `1 <= roads.length <= 5 * 104`\n  * `roads[i].length == 2`\n  * `0 <= ai bi <= n - 1`\n  * `ai != bi`\n  * There are no duplicate roads.\n\n,// Runtime: 1313 ms (Top 92.99%) | Memory: 41.50 MB (Top 72.32%)\n\nclass Solution:\n    def maximumImportance(self n: int roads: List[List[int]]) -> int:\n        Arr = [0] * n  # i-th city has Arr[i] roads\n        for AB in roads:\n            Arr[A] += 1 # Each road increase the road count\n            Arr[B] += 1\n        Arr.sort()  # Cities with most road should receive the most score\n        summ = 0\n        for i in range(len(Arr)):\n            summ += Arr[i] * (i+1)  # Multiply city roads with corresponding score\n        \n        return summ\n
Maximum Trailing Zeros in a Cornered Path,###  2245\. Maximum Trailing Zeros in a Cornered Path\n\nYou are given a 2D integer array `grid` of size `m x n` where each cell\ncontains a positive integer.\n\nA **cornered path** is defined as a set of adjacent cells with **at most** one\nturn. More specifically the path should exclusively move either\n**horizontally** or **vertically** up to the turn (if there is one) without\nreturning to a previously visited cell. After the turn the path will then\nmove exclusively in the **alternate** direction: move vertically if it moved\nhorizontally and vice versa also without returning to a previously visited\ncell.\n\nThe **product** of a path is defined as the product of all the values in the\npath.\n\nReturn _the**maximum** number of **trailing zeros** in the product of a\ncornered path found in _`grid`.\n\nNote:\n\n  * **Horizontal** movement means moving in either the left or right direction.\n  * **Vertical** movement means moving in either the up or down direction.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg)\n\n    \n    \n    **Input:** grid = [[231715320][81202711][946221][4091106][227453]]\n    **Output:** 3\n    **Explanation:** The grid on the left shows a valid cornered path.\n    It has a product of 15 * 20 * 6 * 1 * 10 = 18000 which has 3 trailing zeros.\n    It can be shown that this is the maximum trailing zeros in the product of a cornered path.\n    \n    The grid in the middle is not a cornered path as it has more than one turn.\n    The grid on the right is not a cornered path as it requires a return to a previously visited cell.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg)\n\n    \n    \n    **Input:** grid = [[432][761][888]]\n    **Output:** 0\n    **Explanation:** The grid is shown in the figure above.\n    There are no cornered paths in the grid that result in a product with a trailing zero.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 105`\n  * `1 <= m * n <= 105`\n  * `1 <= grid[i][j] <= 1000`\n\n,import numpy as np\n\nclass Solution:\n    def maxTrailingZeros(self grid: List[List[int]]) -> int:\n        A = np.array(grid)\n        def cumdivs(d):\n            D = sum(A % d**i == 0 for i in range(1 10))\n            return D.cumsum(0) + D.cumsum(1) - D\n        return max(np.minimum(cumdivs(2) cumdivs(5)).max()\n                   for _ in range(4)\n                   if [A := np.rot90(A)])\n
Maximum Twin Sum of a Linked List,###  2130\. Maximum Twin Sum of a Linked List\n\nIn a linked list of size `n` where `n` is **even**  the `ith` node\n(**0-indexed**) of the linked list is known as the **twin** of the `(n-1-i)th`\nnode if `0 <= i <= (n / 2) - 1`.\n\n  * For example if `n = 4` then node `0` is the twin of node `3` and node `1` is the twin of node `2`. These are the only nodes with twins for `n = 4`.\n\nThe **twin sum** is defined as the sum of a node and its twin.\n\nGiven the `head` of a linked list with even length return _the**maximum twin\nsum** of the linked list_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/03/eg1drawio.png)\n\n    \n    \n    **Input:** head = [5421]\n    **Output:** 6\n    **Explanation:**\n    Nodes 0 and 1 are the twins of nodes 3 and 2 respectively. All have twin sum = 6.\n    There are no other nodes with twins in the linked list.\n    Thus the maximum twin sum of the linked list is 6. \n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/03/eg2drawio.png)\n\n    \n    \n    **Input:** head = [4223]\n    **Output:** 7\n    **Explanation:**\n    The nodes with twins present in this linked list are:\n    - Node 0 is the twin of node 3 having a twin sum of 4 + 3 = 7.\n    - Node 1 is the twin of node 2 having a twin sum of 2 + 2 = 4.\n    Thus the maximum twin sum of the linked list is max(7 4) = 7. \n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/12/03/eg3drawio.png)\n\n    \n    \n    **Input:** head = [1100000]\n    **Output:** 100001\n    **Explanation:**\n    There is only one node with a twin in the linked list having twin sum of 1 + 100000 = 100001.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is an **even** integer in the range `[2 105]`.\n  * `1 <= Node.val <= 105`\n\n,# Runtime: 2246 ms (Top 8.54%) | Memory: 54.1 MB (Top 58.68%)\nclass Solution:\n    def pairSum(self head: Optional[ListNode]) -> int:\n        nums = []\n        curr = head\n        while curr:\n            nums.append(curr.val)\n            curr = curr.next\n\n        N = len(nums)\n        res = 0\n        for i in range(N // 2):\n            res = max(res nums[i] + nums[N - i - 1])\n        return res
Maximum Units on a Truck,###  1710\. Maximum Units on a Truck\n\nYou are assigned to put some amount of boxes onto **one truck**. You are given\na 2D array `boxTypes` where `boxTypes[i] = [numberOfBoxesi\nnumberOfUnitsPerBoxi]`:\n\n  * `numberOfBoxesi` is the number of boxes of type `i`.\n  * `numberOfUnitsPerBoxi` is the number of units in each box of the type `i`.\n\nYou are also given an integer `truckSize` which is the **maximum** number of\n**boxes** that can be put on the truck. You can choose any boxes to put on the\ntruck as long as the number of boxes does not exceed `truckSize`.\n\nReturn _the**maximum** total number of **units** that can be put on the\ntruck._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** boxTypes = [[13][22][31]] truckSize = 4\n    **Output:** 8\n    **Explanation:** There are:\n    - 1 box of the first type that contains 3 units.\n    - 2 boxes of the second type that contain 2 units each.\n    - 3 boxes of the third type that contain 1 unit each.\n    You can take all the boxes of the first and second types and one box of the third type.\n    The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** boxTypes = [[510][25][47][39]] truckSize = 10\n    **Output:** 91\n    \n\n\n\n**Constraints:**\n\n  * `1 <= boxTypes.length <= 1000`\n  * `1 <= numberOfBoxesi numberOfUnitsPerBoxi <= 1000`\n  * `1 <= truckSize <= 106`\n\n,class Solution:\n    def maximumUnits(self B: List[List[int]] T: int) -> int:\n        B.sort(key=lambda x: x[1] reverse=True)\n        ans = 0\n        for bn in B:\n            boxes = min(b T)\n            ans += boxes * n\n            T -= boxes\n            if T == 0: return ans\n        return ans\n
Maximum Value after Insertion,"###  1881\. Maximum Value after Insertion\n\nYou are given a very large integer `n` represented as a\nstring​​​​​​ and an integer digit `x`. The digits in `n` and the\ndigit `x` are in the **inclusive** range `[1 9]` and `n` may represent a\n**negative** number.\n\nYou want to **maximize**`n`**'s numerical value** by inserting `x` anywhere in\nthe decimal representation of `n`​​​​​​. You **cannot** insert `x`\nto the left of the negative sign.\n\n  * For example if `n = 73` and `x = 6` it would be best to insert it between `7` and `3` making `n = 763`.\n  * If `n = -55` and `x = 2` it would be best to insert it before the first `5` making `n = -255`.\n\nReturn _a string representing the**maximum** value of _`n` _​​​​​​\nafter the insertion_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = ""99"" x = 9\n    **Output:** ""999""\n    **Explanation:** The result is the same regardless of where you insert 9.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = ""-13"" x = 2\n    **Output:** ""-123""\n    **Explanation:** You can make n one of {-213 -123 -132} and the largest of those three is -123.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n.length <= 105`\n  * `1 <= x <= 9`\n  * The digits in `n`​​​ are in the range `[1 9]`.\n  * `n` is a valid representation of an integer.\n  * In the case of a negative `n`​​​​​​ it will begin with `'-'`.\n\n","class Solution:\n    def maxValue(self n: str x: int) -> str:\n        if int(n)>0:\n            ans = """"\n            flag = False\n            for i in range(len(n)):\n                if int(n[i])>=x:\n                    ans += n[i]\n                else:\n                    a = n[:i]\n                    b = n[i:]\n                    ans = a+str(x)+b\n                \n                    flag = True\n                    break\n            if not flag:\n                ans += str(x)\n        else:\n            n = n[1:]\n            ans = """"\n            flag = False\n            for i in range(len(n)):\n                if int(n[i])<=x:\n                    ans += n[i]\n                else:\n                    a = n[:i]\n                    b = n[i:]\n                    ans = a+str(x)+b\n            \n                    flag = True\n                    break\n            if not flag:\n                ans += str(x)\n            ans = ""-""+ans\n        \n        return ans\n                    \n"
Maximum Value at a Given Index in a Bounded Array,###  1802\. Maximum Value at a Given Index in a Bounded Array\n\nYou are given three positive integers: `n` `index` and `maxSum`. You want to\nconstruct an array `nums` (**0-indexed**)**** that satisfies the following\nconditions:\n\n  * `nums.length == n`\n  * `nums[i]` is a **positive** integer where `0 <= i < n`.\n  * `abs(nums[i] - nums[i+1]) <= 1` where `0 <= i < n-1`.\n  * The sum of all the elements of `nums` does not exceed `maxSum`.\n  * `nums[index]` is **maximized**.\n\nReturn `nums[index]`_of the constructed array_.\n\nNote that `abs(x)` equals `x` if `x >= 0` and `-x` otherwise.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4 index = 2  maxSum = 6\n    **Output:** 2\n    **Explanation:** nums = [12_**2**_ 1] is one array that satisfies all the conditions.\n    There are no arrays that satisfy all the conditions and have nums[2] == 3 so 2 is the maximum nums[2].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 6 index = 1  maxSum = 10\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= maxSum <= 109`\n  * `0 <= index < n`\n\n,class Solution:\n    def maxValue(self n: int index: int maxSum: int) -> int:\n        l = 1\n        r = int(1e9)\n        ans = 0\n\n        while l<=r:\n            mid = (l+r)//2\n            total = 0\n\n            # add left numbers\n            if mid>=index+1:\n                first = mid-index\n                size = index+1\n                total += first*size + size*(size-1)/2\n            else:\n                total += mid*(mid+1)/2\n                total += index+1-mid\n\n\n            # add right numbers\n            size = n-index\n            if mid >= size:\n                last = mid - (n-index-1)\n                total += last*size + size*(size-1)/2\n            else:\n                total += mid*(mid+1)/2\n                total += (size-mid)   \n\n            # deduct mid because it was added twice \n            total -= mid\n            \n            if total <= maxSum:\n                ans = max(ans mid)\n                l = mid+1\n            else:\n                r = mid-1\n\n        return ans
Maximum Value of K Coins From Piles,###  2218\. Maximum Value of K Coins From Piles\n\nThere are `n` **piles** of coins on a table. Each pile consists of a\n**positive number** of coins of assorted denominations.\n\nIn one move you can choose any coin on **top** of any pile remove it and\nadd it to your wallet.\n\nGiven a list `piles` where `piles[i]` is a list of integers denoting the\ncomposition of the `ith` pile from **top to bottom**  and a positive integer\n`k` return _the**maximum total value** of coins you can have in your wallet\nif you choose **exactly**_ `k` _coins optimally_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/11/09/e1.png)\n\n    \n    \n    **Input:** piles = [[11003][789]] k = 2\n    **Output:** 101\n    **Explanation:**\n    The above diagram shows the different ways we can choose k coins.\n    The maximum total we can obtain is 101.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** piles = [[100][100][100][100][100][100][111111700]] k = 7\n    **Output:** 706\n    **Explanation:** The maximum total can be obtained if we choose all coins from the last pile.\n    \n\n\n\n**Constraints:**\n\n  * `n == piles.length`\n  * `1 <= n <= 1000`\n  * `1 <= piles[i][j] <= 105`\n  * `1 <= k <= sum(piles[i].length) <= 2000`\n\n,class Solution:\n    def maxValueOfCoins(self piles: List[List[int]] k: int) -> int:\n        n = len(piles)\n        prefixSum = []\n        for i in range(n):\n            temp = [0]\n            for j in range(len(piles[i])):\n                temp.append(temp[-1] + piles[i][j])\n            prefixSum.append(temp)\n            \n        dp = [[0] * (k + 1) for _ in range(n)]\n        for j in range(1 k + 1):\n            if j < len(prefixSum[0]):\n                dp[0][j] = prefixSum[0][j]\n        \n        for i in range(1 n):\n            for j in range(1 k + 1):\n                for l in range(len(prefixSum[i])):\n                    if l > j:\n                        break\n                    dp[i][j] = max(dp[i][j] prefixSum[i][l] + dp[i - 1][j - l])\n        return dp[n - 1][k]\n
Maximum White Tiles Covered by a Carpet,###  2271\. Maximum White Tiles Covered by a Carpet\n\nYou are given a 2D integer array `tiles` where `tiles[i] = [li ri]`\nrepresents that every tile `j` in the range `li <= j <= ri` is colored white.\n\nYou are also given an integer `carpetLen` the length of a single carpet that\ncan be placed **anywhere**.\n\nReturn _the**maximum** number of white tiles that can be covered by the\ncarpet_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/25/example1drawio3.png)\n\n    \n    \n    **Input:** tiles = [[15][1011][1218][2025][3032]] carpetLen = 10\n    **Output:** 9\n    **Explanation:** Place the carpet starting on tile 10. \n    It covers 9 white tiles so we return 9.\n    Note that there may be other places where the carpet covers 9 white tiles.\n    It can be shown that the carpet cannot cover more than 9 white tiles.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/24/example2drawio.png)\n\n    \n    \n    **Input:** tiles = [[1011][11]] carpetLen = 2\n    **Output:** 2\n    **Explanation:** Place the carpet starting on tile 10. \n    It covers 2 white tiles so we return 2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= tiles.length <= 5 * 104`\n  * `tiles[i].length == 2`\n  * `1 <= li <= ri <= 109`\n  * `1 <= carpetLen <= 109`\n  * The `tiles` are **non-overlapping**.\n\n,"class Solution:\n    def maximumWhiteTiles(self tiles: List[List[int]] carpetLen: int) -> int:\n        tiles.sort()\n		#j: window index\n        j = cover = res = 0\n        for i in range(len(tiles)):\n			#slide the window as far as we can to cover fully the intervals with the carpet\n            while j<len(tiles) and tiles[j][1]-tiles[i][0] + 1 <= carpetLen:\n                cover += tiles[j][1]-tiles[j][0] + 1\n                j += 1\n			#process the remnant that is when the tiles[j] is covered by the carpet partially(not fully)\n            if j<len(tiles) and tiles[j][0]-tiles[i][0] + 1 <= carpetLen:\n                res = max(res cover + carpetLen-(tiles[j][0]-tiles[i][0]))\n            else:\n                res = max(res cover)\n            #when the tiles[j] is covered partially the interval is not added to the variable cover\n			if i!=j:\n                cover -= tiles[i][1]-tiles[i][0]+1\n			j = max(j i+1)\n        return res"
Maximum Width of Binary Tree,###  662\. Maximum Width of Binary Tree\n\nGiven the `root` of a binary tree return _the**maximum width** of the given\ntree_.\n\nThe **maximum width** of a tree is the maximum **width** among all levels.\n\nThe **width** of one level is defined as the length between the end-nodes (the\nleftmost and rightmost non-null nodes) where the null nodes between the end-\nnodes that would be present in a complete binary tree extending down to that\nlevel are also counted into the length calculation.\n\nIt is **guaranteed** that the answer will in the range of a **32-bit** signed\ninteger.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg)\n\n    \n    \n    **Input:** root = [13253null9]\n    **Output:** 4\n    **Explanation:** The maximum width exists in the third level with length 4 (53null9).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/14/maximum-width-of-binary-\ntree-v3.jpg)\n\n    \n    \n    **Input:** root = [1325nullnull96null7]\n    **Output:** 7\n    **Explanation:** The maximum width exists in the fourth level with length 7 (6nullnullnullnullnull7).\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg)\n\n    \n    \n    **Input:** root = [1325]\n    **Output:** 2\n    **Explanation:** The maximum width exists in the second level with length 2 (32).\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 3000]`.\n  * `-100 <= Node.val <= 100`\n\n,# Runtime: 46 ms (Top 93.81%) | Memory: 14.7 MB (Top 75.82%)\n# Definition for a binary tree node.\n# class TreeNode:\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass Solution:\n    def widthOfBinaryTree(self root: Optional[TreeNode]) -> int:\n        q = deque([(root 0)])\n        res = 0\n\n        while q:\n            res = max(res q[-1][1] - q[0][1] + 1)\n            for _ in range(len(q)):\n                curr pos = q.popleft()\n\n                if curr.left:\n                    q.append((curr.left pos*2))\n                if curr.right:\n                    q.append((curr.right pos*2 + 1))\n\n        return res
Maximum Width Ramp,###  962\. Maximum Width Ramp\n\nA **ramp** in an integer array `nums` is a pair `(i j)` for which `i < j` and\n`nums[i] <= nums[j]`. The **width** of such a ramp is `j - i`.\n\nGiven an integer array `nums` return _the maximum width of a**ramp** in\n_`nums`. If there is no **ramp** in `nums` return `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [608215]\n    **Output:** 4\n    **Explanation:** The maximum width ramp is achieved at (i j) = (1 5): nums[1] = 0 and nums[5] = 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [9810194041]\n    **Output:** 7\n    **Explanation:** The maximum width ramp is achieved at (i j) = (2 9): nums[2] = 1 and nums[9] = 1.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 5 * 104`\n  * `0 <= nums[i] <= 5 * 104`\n\n,# Runtime: 635 ms (Top 30.72%) | Memory: 21.1 MB (Top 46.08%)\nclass Solution:\n    def maxWidthRamp(self nums: List[int]):\n        st=[]\n        n=len(nums)\n        for i in range(n):\n            if len(st)==0 or nums[st[-1]]>=nums[i]:\n                st.append(i)\n        print(st)\n        max_idx=-1\n        for j in range(n-1-1-1):\n            while len(st) and nums[st[-1]]<=nums[j]:\n                prev=st.pop()\n                max_idx=max(max_idxj-prev)\n\n        return max_idx\n
Maximum XOR After Operations,###  2317\. Maximum XOR After Operations\n\nYou are given a **0-indexed** integer array `nums`. In one operation select\n**any** non-negative integer `x` and an index `i` then **update** `nums[i]`\nto be equal to `nums[i] AND (nums[i] XOR x)`.\n\nNote that `AND` is the bitwise AND operation and `XOR` is the bitwise XOR\noperation.\n\nReturn _the**maximum** possible bitwise XOR of all elements of _`nums` _after\napplying the operation**any number** of times_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3246]\n    **Output:** 7\n    **Explanation:** Apply the operation with x = 4 and i = 3 num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2.\n    Now nums = [3 2 4 2] and the bitwise XOR of all the elements = 3 XOR 2 XOR 4 XOR 2 = 7.\n    It can be shown that 7 is the maximum possible bitwise XOR.\n    Note that other operations may be used to achieve a bitwise XOR of 7.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12392]\n    **Output:** 11\n    **Explanation:** Apply the operation zero times.\n    The bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11.\n    It can be shown that 11 is the maximum possible bitwise XOR.\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 108`\n\n,class Solution:\n    def maximumXOR(self nums: List[int]) -> int:\n        res=0\n        for i in nums:\n            res |= i\n        return res\n
Maximum XOR for Each Query,###  1829\. Maximum XOR for Each Query\n\nYou are given a **sorted** array `nums` of `n` non-negative integers and an\ninteger `maximumBit`. You want to perform the following query `n` **times** :\n\n  1. Find a non-negative integer `k < 2maximumBit` such that `nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k` is **maximized**. `k` is the answer to the `ith` query.\n  2. Remove the **last** element from the current array `nums`.\n\nReturn _an array_ `answer` _ where_`answer[i]`_is the answer to the_`ith`\n_query_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [0113] maximumBit = 2\n    **Output:** [0323]\n    **Explanation** : The queries are answered as follows:\n    1st query: nums = [0113] k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.\n    2nd query: nums = [011] k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.\n    3rd query: nums = [01] k = 2 since 0 XOR 1 XOR 2 = 3.\n    4th query: nums = [0] k = 3 since 0 XOR 3 = 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2347] maximumBit = 3\n    **Output:** [5265]\n    **Explanation** : The queries are answered as follows:\n    1st query: nums = [2347] k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.\n    2nd query: nums = [234] k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.\n    3rd query: nums = [23] k = 6 since 2 XOR 3 XOR 6 = 7.\n    4th query: nums = [2] k = 5 since 2 XOR 5 = 7.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [012257] maximumBit = 3\n    **Output:** [436467]\n    \n\n\n\n**Constraints:**\n\n  * `nums.length == n`\n  * `1 <= n <= 105`\n  * `1 <= maximumBit <= 20`\n  * `0 <= nums[i] < 2maximumBit`\n  * `nums`​​​ is sorted in **ascending** order.\n\n,# Runtime: 736 ms (Top 100.0%) | Memory: 34.71 MB (Top 50.5%)\n\nclass Solution:\n    def getMaximumXor(self nums: List[int] maximumBit: int) -> List[int]:\n        ans = [(1 << maximumBit) - 1]\n        for n in nums:\n            ans.append(ans[-1] ^ n)\n\n        return ans[len(ans)-1:0:-1]
Maximum XOR of Two Numbers in an Array,###  421\. Maximum XOR of Two Numbers in an Array\n\nGiven an integer array `nums` return _the maximum result of_`nums[i] XOR\nnums[j]` where `0 <= i <= j < n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [31052528]\n    **Output:** 28\n    **Explanation:** The maximum result is 5 XOR 25 = 28.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [147053834991368092516670]\n    **Output:** 127\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 105`\n  * `0 <= nums[i] <= 231 - 1`\n\n,"class Solution:\n	def findMaximumXOR(self nums: List[int]) -> int:\n		TrieNode = lambda: defaultdict(TrieNode)\n		root = TrieNode()\n		for n in nums:\n			cur = root\n			for i in range(31-1-1):\n				bit = 1 if n&(1<<i) else 0\n				cur = cur[bit]\n			cur['val']=n\n\n		ans = 0\n		for n in nums:        \n			cur = root\n			for i in range(31-1-1):\n				bit = 1 if n&(1<<i) else 0\n				if bit == 1:\n					if 0 in cur: cur = cur[0]\n					else: cur = cur[1]\n				else: \n					if 1 in cur: cur = cur[1]\n					else: cur = cur[0]\n			ans = max(anscur['val']^n)\n\n		return ans"
Maximum XOR With an Element From Array,###  1707\. Maximum XOR With an Element From Array\n\nYou are given an array `nums` consisting of non-negative integers. You are\nalso given a `queries` array where `queries[i] = [xi mi]`.\n\nThe answer to the `ith` query is the maximum bitwise `XOR` value of `xi` and\nany element of `nums` that does not exceed `mi`. In other words the answer is\n`max(nums[j] XOR xi)` for all `j` such that `nums[j] <= mi`. If all elements\nin `nums` are larger than `mi` then the answer is `-1`.\n\nReturn _an integer array_`answer` _where_`answer.length == queries.length`\n_and_`answer[i]`_is the answer to the_`ith` _query._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [01234] queries = [[31][13][56]]\n    **Output:** [337]\n    **Explanation:**\n    1) 0 and 1 are the only two integers not greater than 1. 0 XOR 3 = 3 and 1 XOR 3 = 2. The larger of the two is 3.\n    2) 1 XOR 2 = 3.\n    3) 5 XOR 2 = 7.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [524663] queries = [[124][81][63]]\n    **Output:** [15-15]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length queries.length <= 105`\n  * `queries[i].length == 2`\n  * `0 <= nums[j] xi mi <= 109`\n\n,class Trie:\n    def __init__(self):\n        self.root = {}\n        \n    def insert(self num):\n        p = self.root\n        for i in range(31 -1 -1):\n            cur = (num >> i) & 1\n            if cur not in p:\n                p[cur] = {}\n            p = p[cur]\n                \n    def query(self num):\n        if not self.root: \n            return -1\n        p ans = self.root 0\n        for i in range(31 -1 -1):\n            cur = (num >> i) & 1\n            if 1 - cur in p:\n                p = p[1 - cur]\n                ans |= (1 << i)\n            else:\n                p = p[cur]\n        return ans\n\nclass Solution:\n    def maximizeXor(self nums: List[int] queries: List[List[int]]) -> List[int]:\n        nums.sort()\n        queries = sorted(enumerate(queries) key=lambda x: x[1][1])\n        trie = Trie()\n        ans = [-1] * len(queries)\n        j = 0\n        for i (x m) in queries:\n            while j < len(nums) and nums[j] <= m:\n                trie.insert(nums[j])\n                j += 1\n            ans[i] = trie.query(x)\n        return ans\n
Mean of Array After Removing Some Elements,###  1619\. Mean of Array After Removing Some Elements\n\nGiven an integer array `arr` return _the mean of the remaining integers after\nremoving the smallest`5%` and the largest `5%` of the elements._\n\nAnswers within `10-5` of the **actual answer** will be considered accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [12222222222222222223]\n    **Output:** 2.00000\n    **Explanation:** After erasing the minimum and the maximum values of this array all elements are equal to 2 so the mean is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [627512031025055087680]\n    **Output:** 4.00000\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [607075783407816811248195438510866106108234]\n    **Output:** 4.77778\n    \n\n\n\n**Constraints:**\n\n  * `20 <= arr.length <= 1000`\n  * `arr.length`******is a multiple** of `20`.\n  * `0 <= arr[i] <= 105`\n\n,# Runtime: 137 ms (Top 11.43%) | Memory: 14.1 MB (Top 36.03%)\nclass Solution:\n    def trimMean(self arr: List[int]) -> float:\n        arr.sort()\n\n        return statistics.mean(arr[int(len(arr)*5/100):len(arr)-int(len(arr)*5/100)])\n
Median of Two Sorted Arrays,###  4\. Median of Two Sorted Arrays\n\nGiven two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively\nreturn **the median** of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [13] nums2 = [2]\n    **Output:** 2.00000\n    **Explanation:** merged array = [123] and median is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [12] nums2 = [34]\n    **Output:** 2.50000\n    **Explanation:** merged array = [1234] and median is (2 + 3) / 2 = 2.5.\n    \n\n\n\n**Constraints:**\n\n  * `nums1.length == m`\n  * `nums2.length == n`\n  * `0 <= m <= 1000`\n  * `0 <= n <= 1000`\n  * `1 <= m + n <= 2000`\n  * `-106 <= nums1[i] nums2[i] <= 106`\n\n,class Solution(object):\n    def findMedianSortedArrays(self nums1 nums2):\n        lis = nums1 + nums2\n        lis.sort()\n        hi = len(lis)\n        print(5/2)\n        if hi%2 == 0:\n            if (lis[hi/2] + lis[hi/2-1])%2 == 0:\n                return (lis[hi/2] + lis[hi/2-1] )/2\n            return (lis[hi/2] + lis[hi/2-1])/2 + 0.5\n        else:\n            return lis[hi//2]\n
Merge BSTs to Create Single BST,###  1932\. Merge BSTs to Create Single BST\n\nYou are given `n` **BST (binary search tree) root nodes** for `n` separate\nBSTs stored in an array `trees` (**0-indexed**). Each BST in `trees` has **at\nmost 3 nodes**  and no two roots have the same value. In one operation you\ncan:\n\n  * Select two **distinct** indices `i` and `j` such that the value stored at one of the **leaves** of `trees[i]` is equal to the **root value** of `trees[j]`.\n  * Replace the leaf node in `trees[i]` with `trees[j]`.\n  * Remove `trees[j]` from `trees`.\n\nReturn _the**root** of the resulting BST if it is possible to form a valid BST\nafter performing _`n - 1` _operations or_ __`null` _if it is impossible to\ncreate a valid BST_.\n\nA BST (binary search tree) is a binary tree where each node satisfies the\nfollowing property:\n\n  * Every node in the node's left subtree has a value **strictly less**  than the node's value.\n  * Every node in the node's right subtree has a value **strictly greater**  than the node's value.\n\nA leaf is a node that has no children.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/08/d1.png)\n\n    \n    \n    **Input:** trees = [[21][325][54]]\n    **Output:** [3251null4]\n    **Explanation:**\n    In the first operation pick i=1 and j=0 and merge trees[0] into trees[1].\n    Delete trees[0] so trees = [[3251][54]].\n    ![](https://assets.leetcode.com/uploads/2021/06/24/diagram.png)\n    In the second operation pick i=0 and j=1 and merge trees[1] into trees[0].\n    Delete trees[1] so trees = [[3251null4]].\n    ![](https://assets.leetcode.com/uploads/2021/06/24/diagram-2.png)\n    The resulting tree shown above is a valid BST so return its root.\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/08/d2.png)\n\n    \n    \n    **Input:** trees = [[538][326]]\n    **Output:** []\n    **Explanation:**\n    Pick i=0 and j=1 and merge trees[1] into trees[0].\n    Delete trees[1] so trees = [[53826]].\n    ![](https://assets.leetcode.com/uploads/2021/06/24/diagram-3.png)\n    The resulting tree is shown above. This is the only valid operation that can be performed but the resulting tree is not a valid BST so return null.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/06/08/d3.png)\n\n    \n    \n    **Input:** trees = [[54][3]]\n    **Output:** []\n    **Explanation:** It is impossible to perform any operations.\n    \n\n\n\n**Constraints:**\n\n  * `n == trees.length`\n  * `1 <= n <= 5 * 104`\n  * The number of nodes in each tree is in the range `[1 3]`.\n  * Each node in the input may have children but no grandchildren.\n  * No two roots of `trees` have the same value.\n  * All the trees in the input are **valid BSTs**.\n  * `1 <= TreeNode.val <= 5 * 104`.\n\n,# Runtime: 2457 ms (Top 91.30%) | Memory: 66.7 MB (Top 52.17%)\nclass Solution:\n    def canMerge(self trees: List[TreeNode]) -> TreeNode:\n        n = len(trees)\n        if n == 1: return trees[0]\n\n        value_to_root = {} # Map each integer root value to its node\n        appeared_as_middle_child = set() # All values appearing in trees but not in a curr or leaf\n        self.saw_conflict = False # If this is ever true break out of function and return None\n        leaf_value_to_parent_node = {}\n\n        def is_leaf_node(curr: TreeNode) -> bool:\n            return curr.left is None and curr.right is None\n\n        def get_size(curr: TreeNode) -> int: # DFS to count Binary Tree Size\n            if curr is None: return 0\n            return 1 + get_size(curr.left) + get_size(curr.right)\n\n        def is_valid_bst(curr: TreeNode lo=-math.inf hi=math.inf) -> bool: # Standard BST validation code\n            if curr is None: return True\n            return all((lo < curr.val < hi\n                        is_valid_bst(curr.left lo curr.val)\n                        is_valid_bst(curr.right curr.val hi)))\n\n        def process_child(child_node: TreeNode parent: TreeNode) -> None:\n            if child_node is None:\n                return None\n            elif child_node.val in leaf_value_to_parent_node or child_node.val in appeared_as_middle_child:\n                self.saw_conflict = True # Already saw this child node's value in a non-root node\n            elif is_leaf_node(child_node):\n                leaf_value_to_parent_node[child_node.val] = parent\n            elif child_node.val in value_to_root:\n                self.saw_conflict = True\n            else:\n                appeared_as_middle_child.add(child_node.val)\n                process_child(child_node.left child_node)\n                process_child(child_node.right child_node)\n\n        def process_root(curr_root: TreeNode) -> None:\n            value_to_root[curr_root.val] = curr_root\n\n            if curr_root.val in appeared_as_middle_child:\n                self.saw_conflict = True\n            else:\n                process_child(curr_root.left curr_root)\n                process_child(curr_root.right curr_root)\n\n        for root_here in trees:\n            process_root(root_here)\n            if self.saw_conflict: return None\n\n        final_expected_size = len(leaf_value_to_parent_node) + len(appeared_as_middle_child) + 1\n\n        final_root = None # The root of our final BST will be stored here\n        while value_to_root:\n            root_val root_node_to_move = value_to_root.popitem()\n\n            if root_val not in leaf_value_to_parent_node: # Possibly found main root\n                if final_root is None:\n                    final_root = root_node_to_move\n                else:\n                    return None # Found two main roots\n            else:\n                new_parent = leaf_value_to_parent_node.pop(root_val)\n                if new_parent.left is not None and new_parent.left.val == root_val:\n                    new_parent.left = root_node_to_move\n                    continue\n                elif new_parent.right is not None and new_parent.right.val == root_val:\n                    new_parent.right = root_node_to_move\n                else:\n                    return None # Didn't find a place to put this node\n\n        # Didn't find any candidates for main root or have a cycle or didn't use all trees\n        if final_root is None or not is_valid_bst(final_root) or get_size(final_root) != final_expected_size:\n            return None\n\n        return final_root
Merge In Between Linked Lists,###  1669\. Merge In Between Linked Lists\n\nYou are given two linked lists: `list1` and `list2` of sizes `n` and `m`\nrespectively.\n\nRemove `list1`'s nodes from the `ath` node to the `bth` node and put `list2`\nin their place.\n\nThe blue edges and nodes in the following figure indicate the result:\n\n![](https://assets.leetcode.com/uploads/2020/11/05/fig1.png)\n\n_Build the result list and return its head._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/05/merge_linked_list_ex1.png)\n\n    \n    \n    **Input:** list1 = [012345] a = 3 b = 4 list2 = [100000010000011000002]\n    **Output:** [0121000000100000110000025]\n    **Explanation:** We remove the nodes 3 and 4 and put the entire list2 in their place. The blue edges and nodes in the above figure indicate the result.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/05/merge_linked_list_ex2.png)\n\n    \n    \n    **Input:** list1 = [0123456] a = 2 b = 5 list2 = [10000001000001100000210000031000004]\n    **Output:** [01100000010000011000002100000310000046]\n    **Explanation:** The blue edges and nodes in the above figure indicate the result.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= list1.length <= 104`\n  * `1 <= a <= b < list1.length - 1`\n  * `1 <= list2.length <= 104`\n\n,// Runtime: 324 ms (Top 44.4%) | Memory: 22.60 MB (Top 86.42%)\n\nclass Solution:\n    def mergeInBetween(self list1: ListNode a: int b: int list2: ListNode) -> ListNode:\n        head = list1\n        for _ in range(a-1):\n            head = head.next\n        cur = head.next\n        for _ in range(b-a):\n            cur = cur.next\n        head.next = list2\n        while head.next:\n            head = head.next\n        if cur.next:\n            head.next = cur.next\n        return list1\n
Merge Intervals,###  56\. Merge Intervals\n\nGiven an array of `intervals` where `intervals[i] = [starti endi]` merge all\noverlapping intervals and return _an array of the non-overlapping intervals\nthat cover all the intervals in the input_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** intervals = [[13][26][810][1518]]\n    **Output:** [[16][810][1518]]\n    **Explanation:** Since intervals [13] and [26] overlap merge them into [16].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** intervals = [[14][45]]\n    **Output:** [[15]]\n    **Explanation:** Intervals [14] and [45] are considered overlapping.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= intervals.length <= 104`\n  * `intervals[i].length == 2`\n  * `0 <= starti <= endi <= 104`\n\n,"class Solution:\n    def merge(self A: List[List[int]]) -> List[List[int]]:\n	#sort array wrt its 0'th index\n        A.sort(key=lambda x:x[0])\n        i=0\n        while i<(len(A)-1):\n            if A[i][1]>=A[i+1][0]:\n                A[i][1]=max(A[i+1][1]A[i][1])\n                A.pop(i+1)\n            else:\n                i+=1\n        return(A)\n                \n"
Merge k Sorted Lists,###  23\. Merge k Sorted Lists\n\nYou are given an array of `k` linked-lists `lists` each linked-list is sorted\nin ascending order.\n\n_Merge all the linked-lists into one sorted linked-list and return it._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** lists = [[145][134][26]]\n    **Output:** [11234456]\n    **Explanation:** The linked-lists are:\n    [\n      1->4->5\n      1->3->4\n      2->6\n    ]\n    merging them into one sorted list:\n    1->1->2->3->4->4->5->6\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** lists = []\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** lists = [[]]\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * `k == lists.length`\n  * `0 <= k <= 104`\n  * `0 <= lists[i].length <= 500`\n  * `-104 <= lists[i][j] <= 104`\n  * `lists[i]` is sorted in **ascending order**.\n  * The sum of `lists[i].length` will not exceed `104`.\n\n,# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self val=0 next=None):\n#         self.val = val\n#         self.next = next\nfrom heapq import heappushheappop\nclass Solution:\n    def mergeKLists(self lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        heap = []\n        heapq.heapify(heap)\n        start = end = ListNode(-1)\n        for i in lists:\n            if i:\n                heappush(heap(i.valid(i)i))\n        while heap:\n            valiDnode = heappop(heap)\n            end.next = node\n            node = node.next\n            end = end.next\n            if node:\n                heappush(heap(node.valid(node)node))\n                \n        return start.next\n
Merge Nodes in Between Zeros,###  2181\. Merge Nodes in Between Zeros\n\nYou are given the `head` of a linked list which contains a series of integers\n**separated** by `0`'s. The **beginning** and **end** of the linked list will\nhave `Node.val == 0`.\n\nFor **every** two consecutive `0`'s **merge** all the nodes lying in between\nthem into a single node whose value is the **sum** of all the merged nodes.\nThe modified list should not contain any `0`'s.\n\nReturn _the_ `head` _of the modified linked list_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/02/02/ex1-1.png)\n\n    \n    \n    **Input:** head = [03104520]\n    **Output:** [411]\n    **Explanation:** \n    The above figure represents the given linked list. The modified list contains\n    - The sum of the nodes marked in green: 3 + 1 = 4.\n    - The sum of the nodes marked in red: 4 + 5 + 2 = 11.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/02/02/ex2-1.png)\n\n    \n    \n    **Input:** head = [01030220]\n    **Output:** [134]\n    **Explanation:** \n    The above figure represents the given linked list. The modified list contains\n    - The sum of the nodes marked in green: 1 = 1.\n    - The sum of the nodes marked in red: 3 = 3.\n    - The sum of the nodes marked in yellow: 2 + 2 = 4.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[3 2 * 105]`.\n  * `0 <= Node.val <= 1000`\n  * There are **no** two consecutive nodes with `Node.val == 0`.\n  * The **beginning** and **end** of the linked list have `Node.val == 0`.\n\n,class Solution:\n    def mergeNodes(self head: Optional[ListNode]) -> Optional[ListNode]:\n        d=ListNode(0)\n        t=0\n        r=ListNode(0d)\n        while head:\n            if head.val!=0:\n                t+=head.val\n            else:\n                print(t)\n                if t!=0:\n                    d.next=ListNode(t)\n                    d=d.next\n                    t=0\n            head=head.next\n        return r.next.next\n
Merge Similar Items,###  2363\. Merge Similar Items\n\nYou are given two 2D integer arrays `items1` and `items2` representing two\nsets of items. Each array `items` has the following properties:\n\n  * `items[i] = [valuei weighti]` where `valuei` represents the **value** and `weighti` represents the **weight** of the `ith` item.\n  * The value of each item in `items` is **unique**.\n\nReturn _a 2D integer array_ `ret` _where_ `ret[i] = [valuei weighti]`__\n_with_ `weighti` _being the**sum of weights** of all items with value_\n`valuei`.\n\n**Note:** `ret` should be returned in **ascending** order by value.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** items1 = [[11][45][38]] items2 = [[31][15]]\n    **Output:** [[16][39][45]]\n    **Explanation:** \n    The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5 total weight = 1 + 5 = 6.\n    The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1 total weight = 8 + 1 = 9.\n    The item with value = 4 occurs in items1 with weight = 5 total weight = 5.  \n    Therefore we return [[16][39][45]].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** items1 = [[11][32][23]] items2 = [[21][32][13]]\n    **Output:** [[14][24][34]]\n    **Explanation:** \n    The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3 total weight = 1 + 3 = 4.\n    The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1 total weight = 3 + 1 = 4.\n    The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2 total weight = 2 + 2 = 4.\n    Therefore we return [[14][24][34]].\n\n**Example 3:**\n\n    \n    \n    **Input:** items1 = [[13][22]] items2 = [[71][22][14]]\n    **Output:** [[17][24][71]]\n    **Explanation:** The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4 total weight = 3 + 4 = 7. \n    The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2 total weight = 2 + 2 = 4. \n    The item with value = 7 occurs in items2 with weight = 1 total weight = 1.\n    Therefore we return [[17][24][71]].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= items1.length items2.length <= 1000`\n  * `items1[i].length == items2[i].length == 2`\n  * `1 <= valuei weighti <= 1000`\n  * Each `valuei` in `items1` is **unique**.\n  * Each `valuei` in `items2` is **unique**.\n\n,"// Runtime: 118 ms (Top 72.74%) | Memory: 18.10 MB (Top 7.4%)\n\nclass Solution:\n	def mergeSimilarItems(self items1: List[List[int]] items2: List[List[int]]) -> List[List[int]]:\n\n		merge_item = items1 + items2\n\n		d = defaultdict(int)\n\n		for i in merge_item:\n			valueweight = i\n			d[value] = d[value] + weight\n\n		result = []\n\n		for j in sorted(d):\n			result.append([jd[j]])\n\n		return result\n"
Merge Sorted Array,###  88\. Merge Sorted Array\n\nYou are given two integer arrays `nums1` and `nums2` sorted in **non-\ndecreasing order**  and two integers `m` and `n` representing the number of\nelements in `nums1` and `nums2` respectively.\n\n**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing\norder**.\n\nThe final sorted array should not be returned by the function but instead be\n_stored inside the array_`nums1`. To accommodate this `nums1` has a length of\n`m + n` where the first `m` elements denote the elements that should be\nmerged and the last `n` elements are set to `0` and should be ignored.\n`nums2` has a length of `n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [123000] m = 3 nums2 = [256] n = 3\n    **Output:** [122356]\n    **Explanation:** The arrays we are merging are [123] and [256].\n    The result of the merge is [_1_ _2_ 2_3_ 56] with the underlined elements coming from nums1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [1] m = 1 nums2 = [] n = 0\n    **Output:** [1]\n    **Explanation:** The arrays we are merging are [1] and [].\n    The result of the merge is [1].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [0] m = 0 nums2 = [1] n = 1\n    **Output:** [1]\n    **Explanation:** The arrays we are merging are [] and [1].\n    The result of the merge is [1].\n    Note that because m = 0 there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n    \n\n\n\n**Constraints:**\n\n  * `nums1.length == m + n`\n  * `nums2.length == n`\n  * `0 <= m n <= 200`\n  * `1 <= m + n <= 200`\n  * `-109 <= nums1[i] nums2[j] <= 109`\n\n\n\n**Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?\n\n,class Solution(object):\n    def merge(self nums1 m nums2 n):\n        # Initialize nums1's index\n        i = m - 1\n        # Initialize nums2's index\n        j = n - 1\n        # Initialize a variable k to store the last index of the 1st array...\n        k = m + n - 1\n        while j >= 0:\n            if i >= 0 and nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                k -= 1\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                k -= 1\n                j -= 1\n
Merge Strings Alternately,"###  1768\. Merge Strings Alternately\n\nYou are given two strings `word1` and `word2`. Merge the strings by adding\nletters in alternating order starting with `word1`. If a string is longer\nthan the other append the additional letters onto the end of the merged\nstring.\n\nReturn _the merged string._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word1 = ""abc"" word2 = ""pqr""\n    **Output:** ""apbqcr""\n    **Explanation:**  The merged string will be merged as so:\n    word1:  a   b   c\n    word2:    p   q   r\n    merged: a p b q c r\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word1 = ""ab"" word2 = ""pqrs""\n    **Output:** ""apbqrs""\n    **Explanation:**  Notice that as word2 is longer ""rs"" is appended to the end.\n    word1:  a   b \n    word2:    p   q   r   s\n    merged: a p b q   r   s\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** word1 = ""abcd"" word2 = ""pq""\n    **Output:** ""apbqcd""\n    **Explanation:**  Notice that as word1 is longer ""cd"" is appended to the end.\n    word1:  a   b   c   d\n    word2:    p   q \n    merged: a p b q c   d\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word1.length word2.length <= 100`\n  * `word1` and `word2` consist of lowercase English letters.\n\n","# Runtime: 7 ms (Top 98.2%) | Memory: 13.31 MB (Top 45.5%)\n\nclass Solution(object):\n    def mergeAlternately(self word1 word2):\n        i=0\n        j=0\n        st=[]\n        while i<len(word1) and j<len(word2):\n            st.append(word1[i])\n            st.append(word2[j])\n            i+=1\n            j+=1\n        while j<len(word2):\n            st.append(word2[j])\n            j+=1\n        while i<len(word1):\n            st.append(word1[i])\n            i+=1\n        return """".join(st)"
Merge Triplets to Form Target Triplet,###  1899\. Merge Triplets to Form Target Triplet\n\nA **triplet** is an array of three integers. You are given a 2D integer array\n`triplets` where `triplets[i] = [ai bi ci]` describes the `ith`\n**triplet**. You are also given an integer array `target = [x y z]` that\ndescribes the **triplet** you want to obtain.\n\nTo obtain `target` you may apply the following operation on `triplets` **any\nnumber** of times (possibly **zero**):\n\n  * Choose two indices (**0-indexed**) `i` and `j` (`i != j`) and **update** `triplets[j]` to become `[max(ai aj) max(bi bj) max(ci cj)]`. \n    * For example if `triplets[i] = [2 5 3]` and `triplets[j] = [1 7 5]` `triplets[j]` will be updated to `[max(2 1) max(5 7) max(3 5)] = [2 7 5]`.\n\nReturn `true` _if it is possible to obtain the_`target` _**triplet** _`[x y\nz]`_as an**element** of _`triplets` _ or_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** triplets = [[253][184][175]] target = [275]\n    **Output:** true\n    **Explanation:** Perform the following operations:\n    - Choose the first and last triplets [_[253]_ [184]_[175]_]. Update the last triplet to be [max(21) max(57) max(35)] = [275]. triplets = [[253][184]_[275]_]\n    The target triplet [275] is now an element of triplets.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** triplets = [[345][456]] target = [325]\n    **Output:** false\n    **Explanation:** It is impossible to have [325] as an element because there is no 2 in any of the triplets.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** triplets = [[253][234][125][523]] target = [555]\n    **Output:** true\n    **Explanation:** Perform the following operations:\n    - Choose the first and third triplets [_[253]_ [234]_[125]_ [523]]. Update the third triplet to be [max(21) max(52) max(35)] = [255]. triplets = [[253][234]_[255]_ [523]].\n    - Choose the third and fourth triplets [[253][234]_[255]_ _[523]_]. Update the fourth triplet to be [max(25) max(52) max(53)] = [555]. triplets = [[253][234][255]_[555]_].\n    The target triplet [555] is now an element of triplets.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= triplets.length <= 105`\n  * `triplets[i].length == target.length == 3`\n  * `1 <= ai bi ci x y z <= 1000`\n\n,// Runtime: 2191 ms (Top 5.08%) | Memory: 62.60 MB (Top 7.94%)\n\nclass Solution:\n    def mergeTriplets(self triplets: List[List[int]] target: List[int]) -> bool:\n        \n        a b c = 0 0 0\n        for i (x y z) in enumerate(triplets):\n                if not(  x > target[0] or y > target[1] or z > target[2]):\n                     a b c = max(a x) max(b y) max(c z)\n                        \n        return [a b c] == target\n            \n
Merge Two Binary Trees,###  617\. Merge Two Binary Trees\n\nYou are given two binary trees `root1` and `root2`.\n\nImagine that when you put one of them to cover the other some nodes of the\ntwo trees are overlapped while the others are not. You need to merge the two\ntrees into a new binary tree. The merge rule is that if two nodes overlap\nthen sum node values up as the new value of the merged node. Otherwise the\nNOT null node will be used as the node of the new tree.\n\nReturn _the merged tree_.\n\n**Note:** The merging process must start from the root nodes of both trees.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)\n\n    \n    \n    **Input:** root1 = [1325] root2 = [213null4null7]\n    **Output:** [34554null7]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root1 = [1] root2 = [12]\n    **Output:** [22]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in both trees is in the range `[0 2000]`.\n  * `-104 <= Node.val <= 104`\n\n,/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0) left(nullptr) right(nullptr) {}\n *     TreeNode(int x) : val(x) left(nullptr) right(nullptr) {}\n *     TreeNode(int x TreeNode *left TreeNode *right) : val(x) left(left) right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1 TreeNode* root2) {\n        if(root1==NULL) return root2;\n        if(root2==NULL) return root1;\n        root1->val+=root2->val;\n        root1->left=mergeTrees(root1->leftroot2->left);\n        root1->right=mergeTrees(root1->rightroot2->right);\n        return root1;\n    }\n};\n
Merge Two Sorted Lists,###  21\. Merge Two Sorted Lists\n\nYou are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists in a one **sorted** list. The list should be made by\nsplicing together the nodes of the first two lists.\n\nReturn _the head of the merged linked list_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\n\n    \n    \n    **Input:** list1 = [124] list2 = [134]\n    **Output:** [112344]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** list1 = [] list2 = []\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** list1 = [] list2 = [0]\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in both lists is in the range `[0 50]`.\n  * `-100 <= Node.val <= 100`\n  * Both `list1` and `list2` are sorted in **non-decreasing** order.\n\n,# Runtime: 43 ms (Top 67.2%) | Memory: 16.18 MB (Top 97.5%)\n\nclass Solution:\n    def mergeTwoLists(self list1: Optional[ListNode] list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = dummy = ListNode()\n        while list1 and list2:               \n            if list1.val < list2.val:\n                cur.next = list1\n                list1 cur = list1.next list1\n            else:\n                cur.next = list2\n                list2 cur = list2.next list2\n                \n        if list1 or list2:\n            cur.next = list1 if list1 else list2\n            \n        return dummy.next
Middle of the Linked List,###  876\. Middle of the Linked List\n\nGiven the `head` of a singly linked list return _the middle node of the\nlinked list_.\n\nIf there are two middle nodes return **the second middle** node.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist1.jpg)\n\n    \n    \n    **Input:** head = [12345]\n    **Output:** [345]\n    **Explanation:** The middle node of the list is node 3.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/07/23/lc-midlist2.jpg)\n\n    \n    \n    **Input:** head = [123456]\n    **Output:** [456]\n    **Explanation:** Since the list has two middle nodes with values 3 and 4 we return the second one.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[1 100]`.\n  * `1 <= Node.val <= 100`\n\n,// Runtime: 45 ms (Top 13.51%) | Memory: 17.40 MB (Top 21.17%)\n\nclass Solution:\n    def middleNode(self head):\n        Iter N = head 0\n        while Iter:\n            Iter N = Iter.next N + 1\n        for i in range(N//2):\n            head = head.next\n        return head\n
Min Cost Climbing Stairs,###  746\. Min Cost Climbing Stairs\n\nYou are given an integer array `cost` where `cost[i]` is the cost of `ith`\nstep on a staircase. Once you pay the cost you can either climb one or two\nsteps.\n\nYou can either start from the step with index `0` or the step with index `1`.\n\nReturn _the minimum cost to reach the top of the floor_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** cost = [10_15_ 20]\n    **Output:** 15\n    **Explanation:** You will start at index 1.\n    - Pay 15 and climb two steps to reach the top.\n    The total cost is 15.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cost = [_1_ 100_1_ 1_1_ 100_1_ _1_ 100_1_]\n    **Output:** 6\n    **Explanation:** You will start at index 0.\n    - Pay 1 and climb two steps to reach index 2.\n    - Pay 1 and climb two steps to reach index 4.\n    - Pay 1 and climb two steps to reach index 6.\n    - Pay 1 and climb one step to reach index 7.\n    - Pay 1 and climb two steps to reach index 9.\n    - Pay 1 and climb one step to reach the top.\n    The total cost is 6.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= cost.length <= 1000`\n  * `0 <= cost[i] <= 999`\n\n,"// Runtime: 52 ms (Top 87.09%) | Memory: 16.80 MB (Top 65.44%)\n\nclass Solution:\n	def minCostClimbingStairs(self cost: List[int]) -> int:\n		cur = 0 \n		dp0 = cost[0]\n		if len(cost) >= 2:\n			dp1 = cost[1]\n\n		for i in range(2 len(cost)):\n			cur = cost[i] + min(dp0 dp1)\n			dp0 = dp1\n			dp1 = cur\n\n		return min(dp0 dp1)\n"
Min Cost to Connect All Points,###  1584\. Min Cost to Connect All Points\n\nYou are given an array `points` representing integer coordinates of some\npoints on a 2D-plane where `points[i] = [xi yi]`.\n\nThe cost of connecting two points `[xi yi]` and `[xj yj]` is the **manhattan\ndistance** between them: `|xi - xj| + |yi - yj|` where `|val|` denotes the\nabsolute value of `val`.\n\nReturn _the minimum cost to make all points connected._ All points are\nconnected if there is **exactly one** simple path between any two points.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/26/d.png)\n\n    \n    \n    **Input:** points = [[00][22][310][52][70]]\n    **Output:** 20\n    **Explanation:** \n    ![](https://assets.leetcode.com/uploads/2020/08/26/c.png)\n    We can connect the points as shown above to get the minimum cost of 20.\n    Notice that there is a unique path between every pair of points.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** points = [[312][-25][-41]]\n    **Output:** 18\n    \n\n\n\n**Constraints:**\n\n  * `1 <= points.length <= 1000`\n  * `-106 <= xi yi <= 106`\n  * All pairs `(xi yi)` are distinct.\n\n,# Runtime: 2922 ms (Top 60.17%) | Memory: 79.1 MB (Top 76.18%)\nclass Solution:\n    def minCostConnectPoints(self points: List[List[int]]) -> int:\n\n        cost = 0\n        heap = []\n\n        #set to store past points to prevent cycle\n        visited = set([0])\n\n        #i == the index of current point\n        i = 0\n\n        while len(visited) < len(points):\n            #Add all costs from current point to unreached points to min heap\n            for j in range(len(points)):\n                if j == i or j in visited:\n                    continue\n                distance = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n                heapq.heappush(heap (distance j))\n\n            #Add new min cost edge\n            while True:\n                dist point = heapq.heappop(heap)\n                if point not in visited:\n                    cost += dist\n                    #Add point to visited to prevent cycle\n                    visited.add(point)\n                    #Update point\n                    i = point\n                    break\n\n        return cost
Min Max Game,###  2293\. Min Max Game\n\nYou are given a **0-indexed** integer array `nums` whose length is a power of\n`2`.\n\nApply the following algorithm on `nums`:\n\n  1. Let `n` be the length of `nums`. If `n == 1` **end** the process. Otherwise **create** a new **0-indexed** integer array `newNums` of length `n / 2`.\n  2. For every **even** index `i` where `0 <= i < n / 2` **assign** the value of `newNums[i]` as `min(nums[2 * i] nums[2 * i + 1])`.\n  3. For every **odd** index `i` where `0 <= i < n / 2` **assign** the value of `newNums[i]` as `max(nums[2 * i] nums[2 * i + 1])`.\n  4. **Replace** the array `nums` with `newNums`.\n  5. **Repeat** the entire process starting from step 1.\n\nReturn _the last number that remains in_`nums` _after applying the algorithm._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/04/13/example1drawio-1.png)\n\n    \n    \n    **Input:** nums = [13524822]\n    **Output:** 1\n    **Explanation:** The following arrays are the results of applying the algorithm repeatedly.\n    First: nums = [1542]\n    Second: nums = [14]\n    Third: nums = [1]\n    1 is the last remaining number so we return 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [3]\n    **Output:** 3\n    **Explanation:** 3 is already the last remaining number so we return 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1024`\n  * `1 <= nums[i] <= 109`\n  * `nums.length` is a power of `2`.\n\n,class Solution:\n    def minMaxGame(self a: List[int]) -> int:\n        \n        def solve(n):\n            if n==1:\n                return\n            for i in range(n//2):\n                if i%2:\n                    a[i] = max (a[2*i] a[2*i+1])\n                else:\n                    a[i] = min (a[2*i] a[2*i+1])\n            solve(n//2)\n            return\n        solve(len(a))\n        return a[0]\n
Min Stack,"###  155\. Min Stack\n\nDesign a stack that supports push pop top and retrieving the minimum\nelement in constant time.\n\nImplement the `MinStack` class:\n\n  * `MinStack()` initializes the stack object.\n  * `void push(int val)` pushes the element `val` onto the stack.\n  * `void pop()` removes the element on the top of the stack.\n  * `int top()` gets the top element of the stack.\n  * `int getMin()` retrieves the minimum element in the stack.\n\nYou must implement a solution with `O(1)` time complexity for each function.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MinStack""""push""""push""""push""""getMin""""pop""""top""""getMin""]\n    [[][-2][0][-3][][][][]]\n    \n    **Output**\n    [nullnullnullnull-3null0-2]\n    \n    **Explanation**\n    MinStack minStack = new MinStack();\n    minStack.push(-2);\n    minStack.push(0);\n    minStack.push(-3);\n    minStack.getMin(); // return -3\n    minStack.pop();\n    minStack.top();    // return 0\n    minStack.getMin(); // return -2\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= val <= 231 - 1`\n  * Methods `pop` `top` and `getMin` operations will always be called on **non-empty** stacks.\n  * At most `3 * 104` calls will be made to `push` `pop` `top` and `getMin`.\n\n",# Runtime: 117 ms (Top 35.13%) | Memory: 18.5 MB (Top 10.03%)\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self val: int) -> None:\n        if not self.stack:\n            self.stack.append((val val))\n        else:\n            self.stack.append((val min(val self.stack[-1][1])))\n\n    def pop(self) -> None:\n        if self.stack:\n            self.stack.pop()\n\n    def top(self) -> int:\n        if self.stack:\n            return self.stack[-1][0]\n        else:\n            return None\n\n    def getMin(self) -> int:\n        if self.stack:\n            return self.stack[-1][1]\n        else:\n            return None
Minesweeper,"###  529\. Minesweeper\n\nLet's play the minesweeper game\n([Wikipedia](https://en.wikipedia.org/wiki/Minesweeper_\(video_game\))\n[online game](http://minesweeperonline.com))!\n\nYou are given an `m x n` char matrix `board` representing the game board\nwhere:\n\n  * `'M'` represents an unrevealed mine\n  * `'E'` represents an unrevealed empty square\n  * `'B'` represents a revealed blank square that has no adjacent mines (i.e. above below left right and all 4 diagonals)\n  * digit (`'1'` to `'8'`) represents how many mines are adjacent to this revealed square and\n  * `'X'` represents a revealed mine.\n\nYou are also given an integer array `click` where `click = [clickr clickc]`\nrepresents the next click position among all the unrevealed squares (`'M'` or\n`'E'`).\n\nReturn _the board after revealing this position according to the following\nrules_ :\n\n  1. If a mine `'M'` is revealed then the game is over. You should change it to `'X'`.\n  2. If an empty square `'E'` with no adjacent mines is revealed then change it to a revealed blank `'B'` and all of its adjacent unrevealed squares should be revealed recursively.\n  3. If an empty square `'E'` with at least one adjacent mine is revealed then change it to a digit (`'1'` to `'8'`) representing the number of adjacent mines.\n  4. Return the board when no more squares will be revealed.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_1.png)\n\n    \n    \n    **Input:** board = [[""E""""E""""E""""E""""E""][""E""""E""""M""""E""""E""][""E""""E""""E""""E""""E""][""E""""E""""E""""E""""E""]] click = [30]\n    **Output:** [[""B""""1""""E""""1""""B""][""B""""1""""M""""1""""B""][""B""""1""""1""""1""""B""][""B""""B""""B""""B""""B""]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/10/12/minesweeper_example_2.png)\n\n    \n    \n    **Input:** board = [[""B""""1""""E""""1""""B""][""B""""1""""M""""1""""B""][""B""""1""""1""""1""""B""][""B""""B""""B""""B""""B""]] click = [12]\n    **Output:** [[""B""""1""""E""""1""""B""][""B""""1""""X""""1""""B""][""B""""1""""1""""1""""B""][""B""""B""""B""""B""""B""]]\n    \n\n\n\n**Constraints:**\n\n  * `m == board.length`\n  * `n == board[i].length`\n  * `1 <= m n <= 50`\n  * `board[i][j]` is either `'M'` `'E'` `'B'` or a digit from `'1'` to `'8'`.\n  * `click.length == 2`\n  * `0 <= clickr < m`\n  * `0 <= clickc < n`\n  * `board[clickr][clickc]` is either `'M'` or `'E'`.\n\n","class Solution:\n    def calMines(selfboardxy):\n        directions = [(-1-1) (0-1) (1-1) (10) (11) (01) (-11) (-10)]\n        mines = 0\n        for d in directions:\n            r c = x+d[0]y+d[1]\n            if self.isValid(boardrc) and (board[r][c] == 'M' or board[r][c] == 'X'):\n                mines+=1\n        return mines\n\n    def updateBoard(self board: List[List[str]] click: List[int]) -> List[List[str]]:\n        xy = click[0]click[1]\n        options = []\n        if board[x][y] == ""M"":\n            board[x][y] = ""X""\n        else:\n            count = self.calMines(boardxy)\n            if count == 0:\n                board[x][y] = ""B""\n                for r in range(x-1x+2):\n                    for c in range(y-1y+2):\n                        if self.isValid(boardrc) and board[r][c]!='B':\n                            self.updateBoard(board[rc])\n            else:\n                board[x][y] = str(count)\n\n        return board\n    \n    \n    def isValid(selfboardab):\n            return 0<=a<len(board) and 0<=b<len(board[0])\n\n\n        "
Mini Parser,"###  385\. Mini Parser\n\nGiven a string s represents the serialization of a nested list implement a\nparser to deserialize it and return _the deserialized_ `NestedInteger`.\n\nEach element is either an integer or a list whose elements may also be\nintegers or other lists.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""324""\n    **Output:** 324\n    **Explanation:** You should return a NestedInteger object which contains a single integer 324.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""[123[456[789]]]""\n    **Output:** [123[456[789]]]\n    **Explanation:** Return a NestedInteger object containing a nested list with 2 elements:\n    1. An integer containing value 123.\n    2. A nested list containing two elements:\n        i.  An integer containing value 456.\n        ii. A nested list with one element:\n             a. An integer containing value 789\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 5 * 104`\n  * `s` consists of digits square brackets `""[]""` negative sign `'-'` and commas `''`.\n  * `s` is the serialization of valid `NestedInteger`.\n  * All the values in the input are in the range `[-106 106]`.\n\n","class Solution:\n    """"""\n    we can approach this problem using stack\n    """"""\n    \n    def dfs(self i s):\n        res = NestedInteger()\n        while i < len(s):\n            if s[i] == '[':\n                y i = self.dfs(i+1 s)\n                res.add(y)\n            elif i < len(s) and s[i] == ']':\n                i+=1\n                return res i\n            elif i < len(s) and s[i] == '':\n                i+=1\n            else: \n                if i < len(s):\n                    start = i\n                    while s[i] != '' and s[i] != ']':\n                        i+=1\n                    res.add(NestedInteger(int(s[start:i])))\n        return res i\n    \n    def deserialize(self s: str) -> NestedInteger:\n        if s[0] == '[':\n            res i = self.dfs(1 s)\n            return res\n        else:\n            num = int(s)\n            res = NestedInteger()\n            res.setInteger(num)\n            return res\n"
Minimize Deviation in Array,###  1675\. Minimize Deviation in Array\n\nYou are given an array `nums` of `n` positive integers.\n\nYou can perform two types of operations on any element of the array any number\nof times:\n\n  * If the element is **even**  **divide** it by `2`. \n    * For example if the array is `[1234]` then you can do this operation on the last element and the array will be `[123_2_].`\n  * If the element is **odd**  **multiply** it by `2`. \n    * For example if the array is `[1234]` then you can do this operation on the first element and the array will be `[_2_ 234].`\n\nThe **deviation** of the array is the **maximum difference** between any two\nelements in the array.\n\nReturn _the**minimum deviation** the array can have after performing some\nnumber of operations._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** 1\n    **Explanation:** You can transform the array to [123_2_] then to [_2_ 232] then the deviation will be 3 - 2 = 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [415203]\n    **Output:** 3\n    **Explanation:** You can transform the array after two operations to [4_2_ 5_5_ 3] then the deviation will be 5 - 2 = 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [2108]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `2 <= n <= 5 * 104`\n  * `1 <= nums[i] <= 109`\n\n,"class Solution:\n	def minimumDeviation(self nums: List[int]) -> int:\n\n		from sortedcontainers import SortedList\n\n		for i in range(len(nums)):\n\n			if nums[i]%2!=0:\n				nums[i]=nums[i]*2\n\n		nums = SortedList(nums)\n\n		result = 100000000000\n\n		while True:\n			min_value = nums[0]\n			max_value = nums[-1]\n\n			if max_value % 2 == 0:\n				nums.pop()\n				nums.add(max_value // 2)\n				max_value = nums[-1]\n				min_value = nums[0]\n\n				result = min(result  max_value - min_value)\n			else:\n				result = min(result  max_value - min_value)\n				break\n\n		return result\n"
Minimize Hamming Distance After Swap Operations,###  1722\. Minimize Hamming Distance After Swap Operations\n\nYou are given two integer arrays `source` and `target` both of length `n`.\nYou are also given an array `allowedSwaps` where each `allowedSwaps[i] = [ai\nbi]` indicates that you are allowed to swap the elements at index `ai` and\nindex `bi` **(0-indexed)** of array `source`. Note that you can swap elements\nat a specific pair of indices **multiple** times and in **any** order.\n\nThe **Hamming distance** of two arrays of the same length `source` and\n`target` is the number of positions where the elements are different.\nFormally it is the number of indices `i` for `0 <= i <= n-1` where `source[i]\n!= target[i]` **(0-indexed)**.\n\nReturn _the**minimum Hamming distance** of _`source` _and_`target` _after\nperforming**any** amount of swap operations on array _`source` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** source = [1234] target = [2145] allowedSwaps = [[01][23]]\n    **Output:** 1\n    **Explanation:** source can be transformed the following way:\n    - Swap indices 0 and 1: source = [_2_ _1_ 34]\n    - Swap indices 2 and 3: source = [21_4_ _3_]\n    The Hamming distance of source and target is 1 as they differ in 1 position: index 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** source = [1234] target = [1324] allowedSwaps = []\n    **Output:** 2\n    **Explanation:** There are no allowed swaps.\n    The Hamming distance of source and target is 2 as they differ in 2 positions: index 1 and index 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** source = [51243] target = [15423] allowedSwaps = [[04][42][13][14]]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `n == source.length == target.length`\n  * `1 <= n <= 105`\n  * `1 <= source[i] target[i] <= 105`\n  * `0 <= allowedSwaps.length <= 105`\n  * `allowedSwaps[i].length == 2`\n  * `0 <= ai bi <= n - 1`\n  * `ai != bi`\n\n,# Runtime: 1385 ms (Top 99.43%) | Memory: 59.9 MB (Top 71.02%)\nclass UnionFind:\n    def __init__(self n):\n        self.roots = [i for i in range(n)]\n\n    def find(self v):\n        if self.roots[v] != v:\n            self.roots[v] = self.find(self.roots[v])\n\n        return self.roots[v]\n\n    def union(self u v):\n        self.roots[self.find(u)] = self.find(v)\n\nclass Solution:\n    def minimumHammingDistance(self source: List[int] target: List[int] allowedSwaps: List[List[int]]) -> int:\n        uf = UnionFind(len(source))\n        for idx1 idx2 in allowedSwaps:\n            uf.union(idx1 idx2)\n\n        m = collections.defaultdict(set)\n        for i in range(len(source)):\n            m[uf.find(i)].add(i)\n\n        res = 0\n        for indices in m.values():\n            freq = {}\n            for i in indices:\n                freq[source[i]] = freq.get(source[i] 0)+1\n                freq[target[i]] = freq.get(target[i] 0)-1\n            res += sum(val for val in freq.values() if val > 0)\n\n        return res
Minimize Malware Spread,###  924\. Minimize Malware Spread\n\nYou are given a network of `n` nodes represented as an `n x n` adjacency\nmatrix `graph` where the `ith` node is directly connected to the `jth` node\nif `graph[i][j] == 1`.\n\nSome nodes `initial` are initially infected by malware. Whenever two nodes are\ndirectly connected and at least one of those two nodes is infected by\nmalware both nodes will be infected by malware. This spread of malware will\ncontinue until no more nodes can be infected in this manner.\n\nSuppose `M(initial)` is the final number of nodes infected with malware in the\nentire network after the spread of malware stops. We will remove **exactly one\nnode** from `initial`.\n\nReturn the node that if removed would minimize `M(initial)`. If multiple\nnodes could be removed to minimize `M(initial)` return such a node with **the\nsmallest index**.\n\nNote that if a node was removed from the `initial` list of infected nodes it\nmight still be infected later due to the malware spread.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** graph = [[110][110][001]] initial = [01]\n    **Output:** 0\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** graph = [[100][010][001]] initial = [02]\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** graph = [[111][111][111]] initial = [12]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `n == graph.length`\n  * `n == graph[i].length`\n  * `2 <= n <= 300`\n  * `graph[i][j]` is `0` or `1`.\n  * `graph[i][j] == graph[j][i]`\n  * `graph[i][i] == 1`\n  * `1 <= initial.length <= n`\n  * `0 <= initial[i] <= n - 1`\n  * All the integers in `initial` are **unique**.\n\n,# Runtime: 1782 ms (Top 87.91%) | Memory: 16.6 MB (Top 91.21%)\nclass Solution:\n    def minMalwareSpread(self graph: List[List[int]] initial: List[int]) -> int:\n        n = len(graph)\n        uf = UnionFind(n)\n        for i in range(n):\n            for j in range(n):\n                if graph[i][j]:\n                    uf.union(i j)\n\n        max_remove = 0\n\n        initial.sort()\n        min_index = initial[0]\n        for i in range(len(initial)):\n            cur_remove = 0\n            linked = False\n            for j in range(len(initial)):\n                if i == j: continue\n                if uf.find(initial[i]) == uf.find(initial[j]):\n                    linked = True\n            if not linked:\n                cur_remove = uf.rank[uf.find(initial[i])]\n                if max_remove < cur_remove:\n                    max_remove = cur_remove\n                    min_index = initial[i]\n\n        return min_index\n\nclass UnionFind:\n    def __init__(self size):\n        self.parent = {}\n        self.rank = {}\n        for i in range(size):\n            self.parent[i] = i\n            self.rank[i] = 1\n\n    def find(self x):\n        if x != self.parent[x]:\n            x = self.find(self.parent[x])\n        return x\n\n    def union(self x y):\n        px py = self.find(x) self.find(y)\n        if px == py: return\n        if self.rank[px] >= self.rank[py]:\n            self.parent[py] = px\n            self.rank[px] += self.rank[py]\n        else:\n            self.parent[px] = py\n            self.rank[py] += self.rank[px]
Minimize Malware Spread II,###  928\. Minimize Malware Spread II\n\nYou are given a network of `n` nodes represented as an `n x n` adjacency\nmatrix `graph` where the `ith` node is directly connected to the `jth` node\nif `graph[i][j] == 1`.\n\nSome nodes `initial` are initially infected by malware. Whenever two nodes are\ndirectly connected and at least one of those two nodes is infected by\nmalware both nodes will be infected by malware. This spread of malware will\ncontinue until no more nodes can be infected in this manner.\n\nSuppose `M(initial)` is the final number of nodes infected with malware in the\nentire network after the spread of malware stops.\n\nWe will remove **exactly one node** from `initial` **completely removing it\nand any connections from this node to any other node**.\n\nReturn the node that if removed would minimize `M(initial)`. If multiple\nnodes could be removed to minimize `M(initial)` return such a node with **the\nsmallest index**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** graph = [[110][110][001]] initial = [01]\n    **Output:** 0\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** graph = [[110][111][011]] initial = [01]\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** graph = [[1100][1110][0111][0011]] initial = [01]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `n == graph.length`\n  * `n == graph[i].length`\n  * `2 <= n <= 300`\n  * `graph[i][j]` is `0` or `1`.\n  * `graph[i][j] == graph[j][i]`\n  * `graph[i][i] == 1`\n  * `1 <= initial.length < n`\n  * `0 <= initial[i] <= n - 1`\n  * All the integers in `initial` are **unique**.\n\n,from collections import defaultdict\nfrom collections import deque\nclass Solution:\n    def minMalwareSpread(self graph: List[List[int]] initial: List[int]) -> int:\n        n = len(graph)\n        G = defaultdict(list)\n        for v in range(n):\n            for w in range(n):\n                if graph[v][w]:\n                    G[v].append(w)\n                    \n        affect = defaultdict(list)\n        for s in initial:\n            visited = set([v for v in initial if v != s])\n            que = deque([s])\n            while que:\n                v = que.popleft()\n                if v in visited: continue\n                visited.add(v)\n                affect[v].append(s)\n                for w in G[v]:\n                    que.append(w)\n        res = [0]*n\n        for v in affect:\n            if len(affect[v]) == 1:\n                res[affect[v].pop()] += 1\n        if not max(res): return min(initial)\n        return res.index(max(res))
Minimize Result by Adding Parentheses to Expression,"###  2232\. Minimize Result by Adding Parentheses to Expression\n\nYou are given a **0-indexed** string `expression` of the form\n`""<num1>+<num2>""` where `<num1>` and `<num2>` represent positive integers.\n\nAdd a pair of parentheses to `expression` such that after the addition of\nparentheses `expression` is a **valid** mathematical expression and evaluates\nto the **smallest** possible value. The left parenthesis **must** be added to\nthe left of `'+'` and the right parenthesis **must** be added to the right of\n`'+'`.\n\nReturn `expression` _after adding a pair of parentheses such that_`expression`\n_evaluates to the**smallest** possible value._ If there are multiple answers\nthat yield the same result return any of them.\n\nThe input has been generated such that the original value of `expression` and\nthe value of `expression` after adding any pair of parentheses that meets the\nrequirements fits within a signed 32-bit integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** expression = ""247+38""\n    **Output:** ""2(47+38)""\n    **Explanation:** The expression evaluates to 2 * (47 + 38) = 2 * 85 = 170.\n    Note that ""2(4)7+38"" is invalid because the right parenthesis must be to the right of the '+'.\n    It can be shown that 170 is the smallest possible value.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** expression = ""12+34""\n    **Output:** ""1(2+3)4""\n    **Explanation:** The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** expression = ""999+999""\n    **Output:** ""(999+999)""\n    **Explanation:** The expression evaluates to 999 + 999 = 1998.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= expression.length <= 10`\n  * `expression` consists of digits from `'1'` to `'9'` and `'+'`.\n  * `expression` starts and ends with digits.\n  * `expression` contains exactly one `'+'`.\n  * The original value of `expression` and the value of `expression` after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer.\n\n",class Solution:\n    def minimizeResult(self expression: str) -> str:\n        plus_index n ans = expression.find('+') len(expression) [float(inf)expression] \n        def evaluate(exps: str):\n            return eval(exps.replace('(''*(').replace(')' ')*').lstrip('*').rstrip('*'))\n        for l in range(plus_index):\n            for r in range(plus_index+1 n):\n                exps = f'{expression[:l]}({expression[l:plus_index]}+{expression[plus_index+1:r+1]}){expression[r+1:n]}'\n                res = evaluate(exps)\n                if ans[0] > res:\n                    ans[0] ans[1] = res exps\n        return ans[1]\n
Minimum Absolute Difference,###  1200\. Minimum Absolute Difference\n\nGiven an array of **distinct** integers `arr` find all pairs of elements with\nthe minimum absolute difference of any two elements.\n\nReturn a list of pairs in ascending order(with respect to pairs) each pair\n`[a b]` follows\n\n  * `a b` are from `arr`\n  * `a < b`\n  * `b - a` equals to the minimum absolute difference of any two elements in `arr`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [4213]\n    **Output:** [[12][23][34]]\n    **Explanation:** The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.\n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [1361015]\n    **Output:** [[13]]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [38-102319-4-1427]\n    **Output:** [[-14-10][1923][2327]]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= arr.length <= 105`\n  * `-106 <= arr[i] <= 106`\n\n,# Runtime: 574 ms (Top 47.47%) | Memory: 28.9 MB (Top 58.47%)\nclass Solution:\n    def minimumAbsDifference(self arr: List[int]) -> List[List[int]]:\n        arr.sort()\n        diff=float(inf)\n        for i in range(0len(arr)-1):\n            if arr[i+1]-arr[i]<diff:\n                diff=arr[i+1]-arr[i]\n        lst=[]\n        for i in range(0len(arr)-1):\n            if arr[i+1]-arr[i]==diff:\n                lst.append([arr[i]arr[i+1]])\n        return lst\n
Minimum Absolute Difference Queries,###  1906\. Minimum Absolute Difference Queries\n\nThe **minimum absolute difference** of an array `a` is defined as the\n**minimum value** of `|a[i] - a[j]|` where `0 <= i < j < a.length` and `a[i]\n!= a[j]`. If all elements of `a` are the **same**  the minimum absolute\ndifference is `-1`.\n\n  * For example the minimum absolute difference of the array `[5_2_ _3_ 72]` is `|2 - 3| = 1`. Note that it is not `0` because `a[i]` and `a[j]` must be different.\n\nYou are given an integer array `nums` and the array `queries` where\n`queries[i] = [li ri]`. For each query `i` compute the **minimum absolute\ndifference** of the **subarray** `nums[li...ri]` containing the elements of\n`nums` between the **0-based** indices `li` and `ri` (**inclusive**).\n\nReturn _an**array** _`ans` _where_ `ans[i]` _is the answer to the_ `ith`\n_query_.\n\nA **subarray** is a contiguous sequence of elements in an array.\n\nThe value of `|x|` is defined as:\n\n  * `x` if `x >= 0`.\n  * `-x` if `x < 0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1348] queries = [[01][12][23][03]]\n    **Output:** [2141]\n    **Explanation:** The queries are processed as follows:\n    - queries[0] = [01]: The subarray is [_1_ _3_] and the minimum absolute difference is |1-3| = 2.\n    - queries[1] = [12]: The subarray is [_3_ _4_] and the minimum absolute difference is |3-4| = 1.\n    - queries[2] = [23]: The subarray is [_4_ _8_] and the minimum absolute difference is |4-8| = 4.\n    - queries[3] = [03]: The subarray is [1_3_ _4_ 8] and the minimum absolute difference is |3-4| = 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [4522710] queries = [[23][02][05][35]]\n    **Output:** [-1113]\n    **Explanation:** The queries are processed as follows:\n    - queries[0] = [23]: The subarray is [22] and the minimum absolute difference is -1 because all the\n      elements are the same.\n    - queries[1] = [02]: The subarray is [_4_ _5_ 2] and the minimum absolute difference is |4-5| = 1.\n    - queries[2] = [05]: The subarray is [_4_ _5_ 22710] and the minimum absolute difference is |4-5| = 1.\n    - queries[3] = [35]: The subarray is [2_7_ _10_] and the minimum absolute difference is |7-10| = 3.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 105`\n  * `1 <= nums[i] <= 100`\n  * `1 <= queries.length <= 2 * 104`\n  * `0 <= li < ri < nums.length`\n\n,"class Solution:\n    def minDifference(self nums: List[int] queries: List[List[int]]) -> List[int]:\n        # location of number\n        loc = defaultdict(list)\n        for i num in enumerate(nums):\n            loc[num].append(i)\n        \n        # start from sorted key thus keep tracking minimum difference\n        k = sorted(loc)\n        \n        res = []\n        for a b in queries:\n            cands = []\n            ans = float('inf')\n            for c in k:\n                # left and right range overlap means no available locations in range\n                if bisect.bisect_left(loc[c] a) == bisect.bisect(loc[c] b): continue\n                if cands: \n					ans = min(ans c - cands[-1])\n                cands.append(c)\n            if ans == float('inf'): ans = -1\n            res.append(ans)\n        return res"
Minimum Absolute Sum Difference,###  1818\. Minimum Absolute Sum Difference\n\nYou are given two positive integer arrays `nums1` and `nums2` both of length\n`n`.\n\nThe **absolute sum difference** of arrays `nums1` and `nums2` is defined as\nthe **sum** of `|nums1[i] - nums2[i]|` for each `0 <= i < n` (**0-indexed**).\n\nYou can replace **at most one** element of `nums1` with **any** other element\nin `nums1` to **minimize** the absolute sum difference.\n\nReturn the _minimum absolute sum difference**after** replacing at most one****\nelement in the array `nums1`._ Since the answer may be large return it\n**modulo** `109 + 7`.\n\n`|x|` is defined as:\n\n  * `x` if `x >= 0` or\n  * `-x` if `x < 0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [175] nums2 = [235]\n    **Output:** 3\n    **Explanation:** There are two possible optimal solutions:\n    - Replace the second element with the first: [1_**7**_ 5] => [1_**1**_ 5] or\n    - Replace the second element with the third: [1_**7**_ 5] => [1_**5**_ 5].\n    Both will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [246810] nums2 = [246810]\n    **Output:** 0\n    **Explanation:** nums1 is equal to nums2 so no replacement is needed. This will result in an \n    absolute sum difference of 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [1104427] nums2 = [935174]\n    **Output:** 20\n    **Explanation:** Replace the first element with the second: [_**1**_ 104427] => [_**10**_ 104427].\n    This yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20\n    \n\n\n\n**Constraints:**\n\n  * `n == nums1.length`\n  * `n == nums2.length`\n  * `1 <= n <= 105`\n  * `1 <= nums1[i] nums2[i] <= 105`\n\n,# Runtime: 2682 ms (Top 14.06%) | Memory: 30 MB (Top 26.09%)\nclass Solution:\n    def minAbsoluteSumDiff(self nums1: List[int] nums2: List[int]) -> int:\n        n = len(nums1)\n        diff = []\n        sum = 0\n        for i in range(n):\n            temp = abs(nums1[i]-nums2[i])\n            diff.append(temp)\n            sum += temp\n        nums1.sort()\n        best_diff = []\n        for i in range(n):\n            idx = bisect.bisect_left(nums1 nums2[i])\n            if idx != 0 and idx != n:\n                best_diff.append(\n                    min(abs(nums2[i]-nums1[idx]) abs(nums2[i]-nums1[idx-1])))\n            elif idx == 0:\n                best_diff.append(abs(nums2[i]-nums1[idx]))\n            else:\n                best_diff.append(abs(nums2[i]-nums1[idx-1]))\n        saved = 0\n        for i in range(n):\n            saved = max(saved diff[i]-best_diff[i])\n        return (sum-saved) % ((10**9)+(7))
Minimum Add to Make Parentheses Valid,"###  921\. Minimum Add to Make Parentheses Valid\n\nA parentheses string is valid if and only if:\n\n  * It is the empty string\n  * It can be written as `AB` (`A` concatenated with `B`) where `A` and `B` are valid strings or\n  * It can be written as `(A)` where `A` is a valid string.\n\nYou are given a parentheses string `s`. In one move you can insert a\nparenthesis at any position of the string.\n\n  * For example if `s = ""()))""` you can insert an opening parenthesis to be `""(**(**)))""` or a closing parenthesis to be `""())**)**)""`.\n\nReturn _the minimum number of moves required to make_`s` _valid_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""())""\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""(((""\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s[i]` is either `'('` or `')'`.\n\n","// Runtime: 29 ms (Top 94.21%) | Memory: 16.40 MB (Top 63.56%)\n\nclass Solution:\n    def minAddToMakeValid(self s: str) -> int:\n        l r = list() list()\n        for i in s:\n            if i == ""("":\n                l.append(i)\n            else:\n                if l:\n                    l.pop()\n                else:\n                    r.append(i)\n        return len(l) + len(r)\n"
Minimum Adjacent Swaps to Reach the Kth Smallest Number,"###  1850\. Minimum Adjacent Swaps to Reach the Kth Smallest Number\n\nYou are given a string `num` representing a large integer and an integer\n`k`.\n\nWe call some integer **wonderful** if it is a **permutation** of the digits in\n`num` and is **greater in value** than `num`. There can be many wonderful\nintegers. However we only care about the **smallest-valued** ones.\n\n  * For example when `num = ""5489355142""`: \n    * The 1st smallest wonderful integer is `""5489355214""`.\n    * The 2nd smallest wonderful integer is `""5489355241""`.\n    * The 3rd smallest wonderful integer is `""5489355412""`.\n    * The 4th smallest wonderful integer is `""5489355421""`.\n\nReturn _the**minimum number of adjacent digit swaps** that needs to be applied\nto _`num` _to reach the_`kth` _**smallest wonderful** integer_.\n\nThe tests are generated in such a way that `kth` smallest wonderful integer\nexists.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = ""5489355142"" k = 4\n    **Output:** 2\n    **Explanation:** The 4th smallest wonderful number is ""5489355421"". To get this number:\n    - Swap index 7 with index 8: ""5489355 _14_ 2"" -> ""5489355 _41_ 2""\n    - Swap index 8 with index 9: ""54893554 _12_ "" -> ""54893554 _21_ ""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = ""11112"" k = 4\n    **Output:** 4\n    **Explanation:** The 4th smallest wonderful number is ""21111"". To get this number:\n    - Swap index 3 with index 4: ""111 _12_ "" -> ""111 _21_ ""\n    - Swap index 2 with index 3: ""11 _12_ 1"" -> ""11 _21_ 1""\n    - Swap index 1 with index 2: ""1 _12_ 11"" -> ""1 _21_ 11""\n    - Swap index 0 with index 1: ""_12_ 111"" -> ""_21_ 111""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = ""00123"" k = 1\n    **Output:** 1\n    **Explanation:** The 1st smallest wonderful number is ""00132"". To get this number:\n    - Swap index 3 with index 4: ""001 _23_ "" -> ""001 _32_ ""\n    \n\n\n\n**Constraints:**\n\n  * `2 <= num.length <= 1000`\n  * `1 <= k <= 1000`\n  * `num` only consists of digits.\n\n",# Runtime: 1243 ms (Top 52.9%) | Memory: 16.52 MB (Top 32.4%)\n\nclass Solution:\n    def getMinSwaps(self num: str k: int) -> int:\n        num = list(num)\n        orig = num.copy()\n        \n        for _ in range(k): \n            for i in reversed(range(len(num)-1)): \n                if num[i] < num[i+1]: \n                    ii = i+1 \n                    while ii < len(num) and num[i] < num[ii]: ii += 1\n                    num[i] num[ii-1] = num[ii-1] num[i]\n                    lo hi = i+1 len(num)-1\n                    while lo < hi: \n                        num[lo] num[hi] = num[hi] num[lo]\n                        lo += 1\n                        hi -= 1\n                    break \n        \n        ans = 0\n        for i in range(len(num)): \n            ii = i\n            while orig[i] != num[i]: \n                ans += 1\n                ii += 1\n                num[i] num[ii] = num[ii] num[i]\n        return ans 
Minimum Amount of Time to Fill Cups,###  2335\. Minimum Amount of Time to Fill Cups\n\nYou have a water dispenser that can dispense cold warm and hot water. Every\nsecond you can either fill up `2` cups with **different** types of water or\n`1` cup of any type of water.\n\nYou are given a **0-indexed** integer array `amount` of length `3` where\n`amount[0]` `amount[1]` and `amount[2]` denote the number of cold warm and\nhot water cups you need to fill respectively. Return _the**minimum** number of\nseconds needed to fill up all the cups_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** amount = [142]\n    **Output:** 4\n    **Explanation:** One way to fill up the cups is:\n    Second 1: Fill up a cold cup and a warm cup.\n    Second 2: Fill up a warm cup and a hot cup.\n    Second 3: Fill up a warm cup and a hot cup.\n    Second 4: Fill up a warm cup.\n    It can be proven that 4 is the minimum number of seconds needed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** amount = [544]\n    **Output:** 7\n    **Explanation:** One way to fill up the cups is:\n    Second 1: Fill up a cold cup and a hot cup.\n    Second 2: Fill up a cold cup and a warm cup.\n    Second 3: Fill up a cold cup and a warm cup.\n    Second 4: Fill up a warm cup and a hot cup.\n    Second 5: Fill up a cold cup and a hot cup.\n    Second 6: Fill up a cold cup and a warm cup.\n    Second 7: Fill up a hot cup.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** amount = [500]\n    **Output:** 5\n    **Explanation:** Every second we fill up a cold cup.\n    \n\n\n\n**Constraints:**\n\n  * `amount.length == 3`\n  * `0 <= amount[i] <= 100`\n\n,# Runtime: 42 ms (Top 62.11%) | Memory: 13.9 MB (Top 56.09%)\nclass Solution:\n    def fillCups(self amount: List[int]) -> int:\n\n        count = 0\n        amount = sorted(amount reverse=True)\n        while amount[0] > 0:\n            amount[0] -= 1\n            amount[1] -= 1\n            count += 1\n            amount = sorted(amount reverse=True)\n        return count
Minimum Area Rectangle,###  939\. Minimum Area Rectangle\n\nYou are given an array of points in the **X-Y** plane `points` where\n`points[i] = [xi yi]`.\n\nReturn _the minimum area of a rectangle formed from these points with sides\nparallel to the X and Y axes_. If there is not any such rectangle return `0`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/08/03/rec1.JPG)\n\n    \n    \n    **Input:** points = [[11][13][31][33][22]]\n    **Output:** 4\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/08/03/rec2.JPG)\n\n    \n    \n    **Input:** points = [[11][13][31][33][41][43]]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= points.length <= 500`\n  * `points[i].length == 2`\n  * `0 <= xi yi <= 4 * 104`\n  * All the given points are **unique**.\n\n,class Solution:\n    def minAreaRect(self points: List[List[int]]) -> int:\n        points = sorted(points key=lambda item: (item[0] item[1]))\n        cols = defaultdict(list)\n        \n        for xy in points:\n            cols[x].append(y)\n        \n        lastx = {}\n        ans = float('inf')\n        \n        for x in cols:\n            col = cols[x]\n            for i y1 in enumerate(col):\n                for j in range(i):\n                    y2 = col[j]\n                    if (y2y1) in lastx:\n                        ans = min(ans abs((x-lastx[y2y1])*(y2-y1)))\n                    lastx[y2y1] = x\n            \n        return 0 if ans==float('inf') else ans
Minimum Area Rectangle II,###  963\. Minimum Area Rectangle II\n\nYou are given an array of points in the **X-Y** plane `points` where\n`points[i] = [xi yi]`.\n\nReturn _the minimum area of any rectangle formed from these points with\nsides**not necessarily parallel** to the X and Y axes_. If there is not any\nsuch rectangle return `0`.\n\nAnswers within `10-5` of the actual answer will be accepted.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/21/1a.png)\n\n    \n    \n    **Input:** points = [[12][21][10][01]]\n    **Output:** 2.00000\n    **Explanation:** The minimum area rectangle occurs at [12][21][10][01] with an area of 2.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/22/2.png)\n\n    \n    \n    **Input:** points = [[01][21][11][10][20]]\n    **Output:** 1.00000\n    **Explanation:** The minimum area rectangle occurs at [10][11][21][20] with an area of 1.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2018/12/22/3.png)\n\n    \n    \n    **Input:** points = [[03][12][31][13][21]]\n    **Output:** 0\n    **Explanation:** There is no possible rectangle to form from these points.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= points.length <= 50`\n  * `points[i].length == 2`\n  * `0 <= xi yi <= 4 * 104`\n  * All the given points are **unique**.\n\n,class Solution:\n    def minAreaFreeRect(self points: List[List[int]]) -> float:\n        N = len(points)\n        \n        seen = set()\n        for point in points:\n            seen.add(tuple(point))\n\n        # length^2\n        def length2(a b):\n            return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1])\n        \n        best = 1e30\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    continue\n                \n                lij = length2(points[i] points[j])\n                for k in range(N):\n                    if i == k or j == k:\n                        continue\n                    \n                    # given i->j line add to k to find l\n                    dx dy = points[j][0] - points[i][0] points[j][1] - points[i][1]\n                    \n                    pl = (points[k][0] + dx points[k][1] + dy)\n                    if pl not in seen:\n                        continue\n                    \n                    lik = length2(points[i] points[k])\n                    ljk = length2(points[j] points[k])\n\n                    lil = length2(points[i] pl)\n                    ljl = length2(points[j] pl)\n                    lkl = length2(points[k] pl)\n                    \n                    if lij == lkl and lik == ljl and lil == ljk:\n                        best = min(best sqrt(lij * lik * lil) / sqrt(max(lij lik lil)))\n                    \n        if best >= 1e29:\n            return 0\n        return best\n
Minimum ASCII Delete Sum for Two Strings,"###  712\. Minimum ASCII Delete Sum for Two Strings\n\nGiven two strings `s1` and `s2` return _the lowest**ASCII** sum of deleted\ncharacters to make two strings equal_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s1 = ""sea"" s2 = ""eat""\n    **Output:** 231\n    **Explanation:** Deleting ""s"" from ""sea"" adds the ASCII value of ""s"" (115) to the sum.\n    Deleting ""t"" from ""eat"" adds 116 to the sum.\n    At the end both strings are equal and 115 + 116 = 231 is the minimum sum possible to achieve this.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""delete"" s2 = ""leet""\n    **Output:** 403\n    **Explanation:** Deleting ""dee"" from ""delete"" to turn the string into ""let""\n    adds 100[d] + 101[e] + 101[e] to the sum.\n    Deleting ""e"" from ""leet"" adds 101[e] to the sum.\n    At the end both strings are equal to ""let"" and the answer is 100+101+101+101 = 403.\n    If instead we turned both strings into ""lee"" or ""eet"" we would get answers of 433 or 417 which are higher.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s1.length s2.length <= 1000`\n  * `s1` and `s2` consist of lowercase English letters.\n\n",# Runtime: 4020 ms (Top 5.03%) | Memory: 205.5 MB (Top 14.36%)\nclass Solution:\n    def minimumDeleteSum(self s1: str s2: str) -> int:\n        m n lookup = len(s1) len(s2) {}\n        def fun(i j):\n            if (ij) in lookup:\n                return lookup[(ij)]\n            if i < 0:\n                return sum([ord(char) for char in s2[:j+1]])\n            if j < 0:\n                return sum([ord(char) for char in s1[:i+1]])\n            if s1[i] == s2[j]:\n                res = fun(i-1 j-1)\n            else:\n                res = min(ord(s1[i]) + fun(i-1j) ord(s2[j]) + fun(ij-1))\n            lookup[(ij)] = res\n            return lookup[(ij)]\n        return fun(m-1 n-1)
Minimum Average Difference,###  2256\. Minimum Average Difference\n\nYou are given a **0-indexed** integer array `nums` of length `n`.\n\nThe **average difference** of the index `i` is the **absolute** **difference**\nbetween the average of the **first** `i + 1` elements of `nums` and the\naverage of the **last** `n - i - 1` elements. Both averages should be\n**rounded down** to the nearest integer.\n\nReturn _the index with the**minimum average difference**_. If there are\nmultiple such indices return the **smallest** one.\n\n**Note:**\n\n  * The **absolute difference** of two numbers is the absolute value of their difference.\n  * The **average** of `n` elements is the **sum** of the `n` elements divided (**integer division**) by `n`.\n  * The average of `0` elements is considered to be `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [253953]\n    **Output:** 3\n    **Explanation:**\n    - The average difference of index 0 is: |2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3.\n    - The average difference of index 1 is: |(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2.\n    - The average difference of index 2 is: |(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2.\n    - The average difference of index 3 is: |(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0.\n    - The average difference of index 4 is: |(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1.\n    - The average difference of index 5 is: |(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4.\n    The average difference of index 3 is the minimum average difference so return 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0]\n    **Output:** 0\n    **Explanation:**\n    The only index is 0 so return 0.\n    The average difference of index 0 is: |0 / 1 - 0| = |0 - 0| = 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 105`\n\n,from itertools import accumulate\n\nclass Solution:\n    def minimumAverageDifference(self nums: List[int]) -> int:\n        size = len(nums)\n\n        nums[::] = list(accumulate(nums))\n        total = nums[-1]\n        \n        min_tuple = [0 sys.maxsize]\n        \n        for (i n) in enumerate(nums):\n            i = i + 1\n            avg_i = floor(n/i)\n            \n            diff = size - i\n            total_avg = floor((total - n) / (diff if diff>0 else 1))\n\n            avg = abs( avg_i - total_avg) \n            if min_tuple[1] > avg:\n                min_tuple[1] = avg\n                min_tuple[0] = i - 1\n            \n        return min_tuple[0]\n
Minimum Bit Flips to Convert Number,###  2220\. Minimum Bit Flips to Convert Number\n\nA **bit flip** of a number `x` is choosing a bit in the binary representation\nof `x` and **flipping** it from either `0` to `1` or `1` to `0`.\n\n  * For example for `x = 7` the binary representation is `111` and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get `110` flip the second bit from the right to get `101` flip the fifth bit from the right (a leading zero) to get `10111` etc.\n\nGiven two integers `start` and `goal` return _the**minimum** number of **bit\nflips** to convert _`start` _to_`goal`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** start = 10 goal = 7\n    **Output:** 3\n    **Explanation:** The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n    - Flip the first bit from the right: 101 _0_ -> 101 _1_.\n    - Flip the third bit from the right: 1 _0_ 11 -> 1 _1_ 11.\n    - Flip the fourth bit from the right: _1_ 111 -> _0_ 111.\n    It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence we return 3.\n\n**Example 2:**\n\n    \n    \n    **Input:** start = 3 goal = 4\n    **Output:** 3\n    **Explanation:** The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n    - Flip the first bit from the right: 01 _1_ -> 01 _0_.\n    - Flip the second bit from the right: 0 _1_ 0 -> 0 _0_ 0.\n    - Flip the third bit from the right: _0_ 00 -> _1_ 00.\n    It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence we return 3.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= start goal <= 109`\n\n,class Solution:\n    def minBitFlips(self s: int g: int) -> int:\n        count = 0 \n        while s or g:\n            if s%2 != g%2: count+=1\n            s g = s//2 g//2\n        return count
Minimum Changes To Make Alternating Binary String,"###  1758\. Minimum Changes To Make Alternating Binary String\n\nYou are given a string `s` consisting only of the characters `'0'` and `'1'`.\nIn one operation you can change any `'0'` to `'1'` or vice versa.\n\nThe string is called alternating if no two adjacent characters are equal. For\nexample the string `""010""` is alternating while the string `""0100""` is not.\n\nReturn _the**minimum** number of operations needed to make_ `s` _alternating_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""0100""\n    **Output:** 1\n    **Explanation:** If you change the last character to '1' s will be ""0101"" which is alternating.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""10""\n    **Output:** 0\n    **Explanation:** s is already alternating.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""1111""\n    **Output:** 2\n    **Explanation:** You need two operations to reach ""0101"" or ""1010"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `s[i]` is either `'0'` or `'1'`.\n\n",# Runtime: 52 ms (Top 66.2%) | Memory: 16.53 MB (Top 16.1%)\n\nclass Solution:\n    def minOperations(self s: str) -> int:\n        count = 0\n        count1 = 0\n        for i in range(len(s)):\n            if i % 2 == 0:\n                if s[i] == '1':\n                    count += 1\n                if s[i] == '0':\n                    count1 += 1\n            else:\n                if s[i] == '0':\n                    count += 1\n                if s[i] == '1':\n                    count1 += 1\n        return min(count count1)
Minimum Cost For Tickets,###  983\. Minimum Cost For Tickets\n\nYou have planned some train traveling one year in advance. The days of the\nyear in which you will travel are given as an integer array `days`. Each day\nis an integer from `1` to `365`.\n\nTrain tickets are sold in **three different ways** :\n\n  * a **1-day** pass is sold for `costs[0]` dollars\n  * a **7-day** pass is sold for `costs[1]` dollars and\n  * a **30-day** pass is sold for `costs[2]` dollars.\n\nThe passes allow that many days of consecutive travel.\n\n  * For example if we get a **7-day** pass on day `2` then we can travel for `7` days: `2` `3` `4` `5` `6` `7` and `8`.\n\nReturn _the minimum number of dollars you need to travel every day in the\ngiven list of days_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** days = [1467820] costs = [2715]\n    **Output:** 11\n    **Explanation:** For example here is one way to buy passes that lets you travel your travel plan:\n    On day 1 you bought a 1-day pass for costs[0] = $2 which covered day 1.\n    On day 3 you bought a 7-day pass for costs[1] = $7 which covered days 3 4 ... 9.\n    On day 20 you bought a 1-day pass for costs[0] = $2 which covered day 20.\n    In total you spent $11 and covered all the days of your travel.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** days = [123456789103031] costs = [2715]\n    **Output:** 17\n    **Explanation:** For example here is one way to buy passes that lets you travel your travel plan:\n    On day 1 you bought a 30-day pass for costs[2] = $15 which covered days 1 2 ... 30.\n    On day 31 you bought a 1-day pass for costs[0] = $2 which covered day 31.\n    In total you spent $17 and covered all the days of your travel.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= days.length <= 365`\n  * `1 <= days[i] <= 365`\n  * `days` is in strictly increasing order.\n  * `costs.length == 3`\n  * `1 <= costs[i] <= 1000`\n\n,// Runtime: 44 ms (Top 83.24%) | Memory: 17.30 MB (Top 40.22%)\n\nclass Solution:\n    def mincostTickets(self days: List[int] costs: List[int]) -> int:\n        cost = 0\n        last7 = deque()\n        last30 = deque()\n        for day in days:\n            while last7 and last7[0][0] + 7 <= day:\n                last7.popleft()\n            while last30 and last30[0][0] + 30 <= day:\n                last30.popleft()\n            last7.append((day cost + costs[1]))\n            last30.append((day cost + costs[2]))\n            cost = min(cost + costs[0]\n                      last7[0][1]\n                      last30[0][1])\n        return cost\n
Minimum Cost Homecoming of a Robot in a Grid,###  2087\. Minimum Cost Homecoming of a Robot in a Grid\n\nThere is an `m x n` grid where `(0 0)` is the top-left cell and `(m - 1 n -\n1)` is the bottom-right cell. You are given an integer array `startPos` where\n`startPos = [startrow startcol]` indicates that **initially**  a **robot**\nis at the cell `(startrow startcol)`. You are also given an integer array\n`homePos` where `homePos = [homerow homecol]` indicates that its **home** is\nat the cell `(homerow homecol)`.\n\nThe robot needs to go to its home. It can move one cell in four directions:\n**left**  **right**  **up**  or **down**  and it can not move outside the\nboundary. Every move incurs some cost. You are further given two **0-indexed**\ninteger arrays: `rowCosts` of length `m` and `colCosts` of length `n`.\n\n  * If the robot moves **up** or **down** into a cell whose **row** is `r` then this move costs `rowCosts[r]`.\n  * If the robot moves **left** or **right** into a cell whose **column** is `c` then this move costs `colCosts[c]`.\n\nReturn _the**minimum total cost** for this robot to return home_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/10/11/eg-1.png)\n\n    \n    \n    **Input:** startPos = [1 0] homePos = [2 3] rowCosts = [5 4 3] colCosts = [8 2 6 7]\n    **Output:** 18\n    **Explanation:** One optimal path is that:\n    Starting from (1 0)\n    -> It goes down to (_**2**_  0). This move costs rowCosts[2] = 3.\n    -> It goes right to (2 _**1**_). This move costs colCosts[1] = 2.\n    -> It goes right to (2 _**2**_). This move costs colCosts[2] = 6.\n    -> It goes right to (2 _**3**_). This move costs colCosts[3] = 7.\n    The total cost is 3 + 2 + 6 + 7 = 18\n\n**Example 2:**\n\n    \n    \n    **Input:** startPos = [0 0] homePos = [0 0] rowCosts = [5] colCosts = [26]\n    **Output:** 0\n    **Explanation:** The robot is already at its home. Since no moves occur the total cost is 0.\n    \n\n\n\n**Constraints:**\n\n  * `m == rowCosts.length`\n  * `n == colCosts.length`\n  * `1 <= m n <= 105`\n  * `0 <= rowCosts[r] colCosts[c] <= 104`\n  * `startPos.length == 2`\n  * `homePos.length == 2`\n  * `0 <= startrow homerow < m`\n  * `0 <= startcol homecol < n`\n\n,class Solution:\n    def minCost(self startPos: List[int] homePos: List[int] rowCosts: List[int] colCosts: List[int]) -> int:\n        def getRange(left right array):\n            if left > right:\n                right left = left right\n            return sum((array[i] for i in range(leftright+1)))\n        \n        totalRowCost = getRange(startPos[0] homePos[0] rowCosts)\n        totalColCost = getRange(startPos[1] homePos[1] colCosts)\n        \n        #Don't pay for the position you start out on\n        return totalRowCost + totalColCost - rowCosts[startPos[0]] - colCosts[startPos[1]]\n
Minimum Cost of Buying Candies With Discount,###  2144\. Minimum Cost of Buying Candies With Discount\n\nA shop is selling candies at a discount. For **every two** candies sold the\nshop gives a **third** candy for **free**.\n\nThe customer can choose **any** candy to take away for free as long as the\ncost of the chosen candy is less than or equal to the **minimum** cost of the\ntwo candies bought.\n\n  * For example if there are `4` candies with costs `1` `2` `3` and `4` and the customer buys candies with costs `2` and `3` they can take the candy with cost `1` for free but not the candy with cost `4`.\n\nGiven a **0-indexed** integer array `cost` where `cost[i]` denotes the cost\nof the `ith` candy return _the**minimum cost** of buying **all** the\ncandies_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** cost = [123]\n    **Output:** 5\n    **Explanation:** We buy the candies with costs 2 and 3 and take the candy with cost 1 for free.\n    The total cost of buying all candies is 2 + 3 = 5. This is the **only** way we can buy the candies.\n    Note that we cannot buy candies with costs 1 and 3 and then take the candy with cost 2 for free.\n    The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cost = [657922]\n    **Output:** 23\n    **Explanation:** The way in which we can get the minimum cost is described below:\n    - Buy candies with costs 9 and 7\n    - Take the candy with cost 6 for free\n    - We buy candies with costs 5 and 2\n    - Take the last remaining candy with cost 2 for free\n    Hence the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** cost = [55]\n    **Output:** 10\n    **Explanation:** Since there are only 2 candies we buy both of them. There is not a third candy we can take for free.\n    Hence the minimum cost to buy all candies is 5 + 5 = 10.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= cost.length <= 100`\n  * `1 <= cost[i] <= 100`\n\n,# Runtime: 72 ms (Top 49.84%) | Memory: 13.8 MB (Top 58.81%)\nclass Solution:\n    def minimumCost(self cost: List[int]) -> int:\n        cost.sort(reverse=True)\n        res i N = 0 0 len(cost)\n        while i < N:\n            res += sum(cost[i : i + 2])\n            i += 3\n        return res
Minimum Cost to Change the Final Value of Expression,"###  1896\. Minimum Cost to Change the Final Value of Expression\n\nYou are given a **valid** boolean expression as a string `expression`\nconsisting of the characters `'1'``'0'``'&'` (bitwise **AND**\noperator)`'|'` (bitwise **OR** operator)`'('` and `')'`.\n\n  * For example `""()1|1""` and `""(1)&()""` are **not valid** while `""1""` `""(((1))|(0))""` and `""1|(0&(1))""` are **valid** expressions.\n\nReturn _the**minimum cost** to change the final value of the expression_.\n\n  * For example if `expression = ""1|1|(0&0)&1""` its **value** is `1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1`. We want to apply operations so that the**new** expression evaluates to `0`.\n\nThe **cost** of changing the final value of an expression is the **number of\noperations** performed on the expression. The types of **operations** are\ndescribed as follows:\n\n  * Turn a `'1'` into a `'0'`.\n  * Turn a `'0'` into a `'1'`.\n  * Turn a `'&'` into a `'|'`.\n  * Turn a `'|'` into a `'&'`.\n\n**Note:** `'&'` does **not** take precedence over `'|'` in the **order of\ncalculation**. Evaluate parentheses **first**  then in **left-to-right**\norder.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** expression = ""1&(0|1)""\n    **Output:** 1\n    **Explanation:** We can turn ""1&(0 _**|**_ 1)"" into ""1&(0 _**&**_ 1)"" by changing the '|' to a '&' using 1 operation.\n    The new expression evaluates to 0. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** expression = ""(0&0)&(0&0&0)""\n    **Output:** 3\n    **Explanation:** We can turn ""(0 _**& 0**_)**_&_**(0&0&0)"" into ""(0 _**|1**_)_**|**_(0&0&0)"" using 3 operations.\n    The new expression evaluates to 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** expression = ""(0|(1|0&1))""\n    **Output:** 1\n    **Explanation:** We can turn ""(0|(_**1**_ |0&1))"" into ""(0|(_**0**_ |0&1))"" using 1 operation.\n    The new expression evaluates to 0.\n\n\n\n**Constraints:**\n\n  * `1 <= expression.length <= 105`\n  * `expression` only contains `'1'``'0'``'&'``'|'``'('` and `')'`\n  * All parentheses are properly matched.\n  * There will be no empty parentheses (i.e: `""()""` is not a substring of `expression`).\n\n","class Solution:\n    def minOperationsToFlip(self expression: str) -> int:\n        loc = {}\n        stack = []\n        for i in reversed(range(len(expression))):\n            if expression[i] == "")"": stack.append(i)\n            elif expression[i] == ""("": loc[stack.pop()] = i \n        \n        def fn(lo hi): \n            """"""Return value and min op to change value.""""""\n            if lo == hi: return int(expression[lo]) 1\n            if expression[hi] == "")"" and loc[hi] == lo: return fn(lo+1 hi-1) # strip parenthesis \n            mid = loc.get(hi hi) - 1 \n            v c = fn(mid+1 hi)\n            vv cc = fn(lo mid-1)\n            if expression[mid] == ""|"": \n                val = v | vv \n                if v == vv == 0: chg = min(c cc)\n                elif v == vv == 1: chg = 1 + min(c cc)\n                else: chg = 1 \n            else: # expression[k] == ""&""\n                val = v & vv\n                if v == vv == 0: chg = 1 + min(c cc)\n                elif v == vv == 1: chg = min(c cc)\n                else: chg = 1\n            return val chg\n                    \n        return fn(0 len(expression)-1)[1]\n"
Minimum Cost to Connect Two Groups of Points,###  1595\. Minimum Cost to Connect Two Groups of Points\n\nYou are given two groups of points where the first group has `size1` points\nthe second group has `size2` points and `size1 >= size2`.\n\nThe `cost` of the connection between any two points are given in an `size1 x\nsize2` matrix where `cost[i][j]` is the cost of connecting point `i` of the\nfirst group and point `j` of the second group. The groups are connected if\n**each point in both groups is connected to one or more points in the opposite\ngroup**. In other words each point in the first group must be connected to at\nleast one point in the second group and each point in the second group must\nbe connected to at least one point in the first group.\n\nReturn _the minimum cost it takes to connect the two groups_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/03/ex1.jpg)\n\n    \n    \n    **Input:** cost = [[15 96] [36 2]]\n    **Output:** 17\n    **Explanation** : The optimal way of connecting the groups is:\n    1--A\n    2--B\n    This results in a total cost of 17.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/03/ex2.jpg)\n\n    \n    \n    **Input:** cost = [[1 3 5] [4 1 1] [1 5 3]]\n    **Output:** 4\n    **Explanation** : The optimal way of connecting the groups is:\n    1--A\n    2--B\n    2--C\n    3--A\n    This results in a total cost of 4.\n    Note that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** cost = [[2 5 1] [3 4 7] [8 1 2] [6 2 4] [3 8 8]]\n    **Output:** 10\n    \n\n\n\n**Constraints:**\n\n  * `size1 == cost.length`\n  * `size2 == cost[i].length`\n  * `1 <= size1 size2 <= 12`\n  * `size1 >= size2`\n  * `0 <= cost[i][j] <= 100`\n\n,"// Runtime: 345 ms (Top 92.68%) | Memory: 29.40 MB (Top 24.39%)\n\nclass Solution:\n    def connectTwoGroups(self cost: List[List[int]]) -> int:\n        m n = len(cost) len(cost[0])\n        mn = [min(x) for x in zip(*cost)] # min cost of connecting points in 2nd group \n        \n        @lru_cache(None)\n        def fn(i mask):\n            """"""Return min cost of connecting group1[i:] and group2 represented as mask.""""""\n            if i == m: return sum(mn[j] for j in range(n) if not (mask & (1<<j)))\n            return min(cost[i][j] + fn(i+1 mask | 1<<j) for j in range(n))\n                \n        return fn(0 0)\n"
Minimum Cost to Cut a Stick,###  1547\. Minimum Cost to Cut a Stick\n\nGiven a wooden stick of length `n` units. The stick is labelled from `0` to\n`n`. For example a stick of length **6** is labelled as follows:\n\n![](https://assets.leetcode.com/uploads/2020/07/21/statement.jpg)\n\nGiven an integer array `cuts` where `cuts[i]` denotes a position you should\nperform a cut at.\n\nYou should perform the cuts in order you can change the order of the cuts as\nyou wish.\n\nThe cost of one cut is the length of the stick to be cut the total cost is\nthe sum of costs of all cuts. When you cut a stick it will be split into two\nsmaller sticks (i.e. the sum of their lengths is the length of the stick\nbefore the cut). Please refer to the first example for a better explanation.\n\nReturn _the minimum total cost_ of the cuts.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/07/23/e1.jpg)\n\n    \n    \n    **Input:** n = 7 cuts = [1345]\n    **Output:** 16\n    **Explanation:** Using cuts order = [1 3 4 5] as in the input leads to the following scenario:\n    ![](https://assets.leetcode.com/uploads/2020/07/21/e11.jpg)\n    The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut) the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\n    Rearranging the cuts to be [3 5 1 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\n**Example 2:**\n\n    \n    \n    **Input:** n = 9 cuts = [56142]\n    **Output:** 22\n    **Explanation:** If you try the given cuts ordering the cost will be 25.\n    There are much ordering with total cost <= 25 for example the order [4 6 5 2 1] has total cost = 22 which is the minimum possible.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 106`\n  * `1 <= cuts.length <= min(n - 1 100)`\n  * `1 <= cuts[i] <= n - 1`\n  * All the integers in `cuts` array are **distinct**.\n\n,class Solution:\n    def minCost(self n: int cuts: List[int]) -> int:\n        cuts = [0] + sorted(cuts) + [n]\n        k = len(cuts)\n        dp = [[float('inf')] * k for _ in range(k)]\n        for l in range(1 k + 1):\n            for beg in range(k - l):\n                end = beg + l\n                if l == 1:\n                    dp[beg][end] = 0\n                    continue\n                for i in range(beg + 1 end):\n                    currcost = cuts[end] - cuts[beg]\n                    currcost += dp[beg][i] + dp[i][end]\n                    dp[beg][end] = min(dp[beg][end] currcost)\n        return dp[0][k - 1]\n
Minimum Cost to Hire K Workers,###  857\. Minimum Cost to Hire K Workers\n\nThere are `n` workers. You are given two integer arrays `quality` and `wage`\nwhere `quality[i]` is the quality of the `ith` worker and `wage[i]` is the\nminimum wage expectation for the `ith` worker.\n\nWe want to hire exactly `k` workers to form a paid group. To hire a group of\n`k` workers we must pay them according to the following rules:\n\n  1. Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n  2. Every worker in the paid group must be paid at least their minimum wage expectation.\n\nGiven the integer `k` return _the least amount of money needed to form a paid\ngroup satisfying the above conditions_. Answers within `10-5` of the actual\nanswer will be accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** quality = [10205] wage = [705030] k = 2\n    **Output:** 105.00000\n    **Explanation:** We pay 70 to 0th worker and 35 to 2nd worker.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** quality = [3110101] wage = [48227] k = 3\n    **Output:** 30.66667\n    **Explanation:** We pay 4 to 0th worker 13.33333 to 2nd and 3rd workers separately.\n    \n\n\n\n**Constraints:**\n\n  * `n == quality.length == wage.length`\n  * `1 <= k <= n <= 104`\n  * `1 <= quality[i] wage[i] <= 104`\n\n,// Runtime: 147 ms (Top 96.67%) | Memory: 19.20 MB (Top 63.7%)\n\nclass Solution:\n    def mincostToHireWorkers(self quality: List[int] wage: List[int] k: int) -> float:\n        n=len(wage)\n        arr=[[wage[i]/quality[i]quality[i]] for i in range(n)]\n        arr.sort(key=lambda x:x[0])\n        kSmallest=0\n        pq=[]\n        for i in range(k):\n            heapq.heappush(pq-arr[i][1])\n            kSmallest+=arr[i][1]\n        minCost=arr[k-1][0]*kSmallest\n        for c in range(kn):\n            if pq and abs(pq[0])>arr[c][1]:\n                qRem=-heappop(pq)\n                kSmallest-=qRem\n                kSmallest+=arr[c][1]\n                heappush(pq-arr[c][1])\n            minCost=min(minCostarr[c][0]*kSmallest)\n        return minCost\n            \n        \n        \n
Minimum Cost to Reach Destination in Time,###  1928\. Minimum Cost to Reach Destination in Time\n\nThere is a country of `n` cities numbered from `0` to `n - 1` where **all the\ncities are connected** by bi-directional roads. The roads are represented as a\n2D integer array `edges` where `edges[i] = [xi yi timei]` denotes a road\nbetween cities `xi` and `yi` that takes `timei` minutes to travel. There may\nbe multiple roads of differing travel times connecting the same two cities\nbut no road connects a city to itself.\n\nEach time you pass through a city you must pay a passing fee. This is\nrepresented as a **0-indexed** integer array `passingFees` of length `n` where\n`passingFees[j]` is the amount of dollars you must pay when you pass through\ncity `j`.\n\nIn the beginning you are at city `0` and want to reach city `n - 1` in\n`maxTime`**minutes or less**. The **cost** of your journey is the **summation\nof passing fees** for each city that you passed through at some moment of your\njourney (**including** the source and destination cities).\n\nGiven `maxTime` `edges` and `passingFees` return _the**minimum cost** to\ncomplete your journey or _`-1` _if you cannot complete it within_`maxTime`\n_minutes_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/04/leetgraph1-1.png)\n\n    \n    \n    **Input:** maxTime = 30 edges = [[0110][1210][2510][031][3410][4515]] passingFees = [51220203]\n    **Output:** 11\n    **Explanation:** The path to take is 0 -> 1 -> 2 -> 5 which takes 30 minutes and has $11 worth of passing fees.\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2021/06/04/copy-of-\nleetgraph1-1.png)**\n\n    \n    \n    **Input:** maxTime = 29 edges = [[0110][1210][2510][031][3410][4515]] passingFees = [51220203]\n    **Output:** 48\n    **Explanation:** The path to take is 0 -> 3 -> 4 -> 5 which takes 26 minutes and has $48 worth of passing fees.\n    You cannot take path 0 -> 1 -> 2 -> 5 since it would take too long.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** maxTime = 25 edges = [[0110][1210][2510][031][3410][4515]] passingFees = [51220203]\n    **Output:** -1\n    **Explanation:** There is no way to reach city 5 from city 0 within 25 minutes.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= maxTime <= 1000`\n  * `n == passingFees.length`\n  * `2 <= n <= 1000`\n  * `n - 1 <= edges.length <= 1000`\n  * `0 <= xi yi <= n - 1`\n  * `1 <= timei <= 1000`\n  * `1 <= passingFees[j] <= 1000` \n  * The graph may contain multiple edges between two nodes.\n  * The graph does not contain self loops.\n\n,class Solution:\n    def minCost(self maxTime: int edges: List[List[int]] passingFees: List[int]) -> int:\n        '''\n        Time: O((m+n)* maxtime) where m is length of edges\n        Space: O(n*maxtime)\n        '''\n        n = len(passingFees)\n        dp = [[math.inf]*(n) for _ in range(maxTime+1)]\n        dp[0][0] = passingFees[0]\n\n        ans = math.inf\n        for k in range(1 maxTime+1):\n            for x y time in edges:\n                if k >= time:\n                    # dual direction\n                    dp[k][y] = min(dp[k][y] dp[k-time][x] + passingFees[y])\n                    dp[k][x] = min(dp[k][x] dp[k-time][y] + passingFees[x])\n                \n            ans = min(ans dp[k][n-1])\n        \n        if ans == math.inf:\n            return -1\n        return ans\n
Minimum Cost to Set Cooking Time,###  2162\. Minimum Cost to Set Cooking Time\n\nA generic microwave supports cooking times for:\n\n  * at least `1` second.\n  * at most `99` minutes and `99` seconds.\n\nTo set the cooking time you push **at most four digits**. The microwave\nnormalizes what you push as four digits by **prepending zeroes**. It\ninterprets the **first** two digits as the minutes and the **last** two digits\nas the seconds. It then **adds** them up as the cooking time. For example\n\n  * You push `9` `5` `4` (three digits). It is normalized as `0954` and interpreted as `9` minutes and `54` seconds.\n  * You push `0` `0` `0` `8` (four digits). It is interpreted as `0` minutes and `8` seconds.\n  * You push `8` `0` `9` `0`. It is interpreted as `80` minutes and `90` seconds.\n  * You push `8` `1` `3` `0`. It is interpreted as `81` minutes and `30` seconds.\n\nYou are given integers `startAt` `moveCost` `pushCost` and `targetSeconds`.\n**Initially**  your finger is on the digit `startAt`. Moving the finger above\n**any specific digit** costs `moveCost` units of fatigue. Pushing the digit\nbelow the finger **once** costs `pushCost` units of fatigue.\n\nThere can be multiple ways to set the microwave to cook for `targetSeconds`\nseconds but you are interested in the way with the minimum cost.\n\nReturn _the**minimum cost** to set_ `targetSeconds` _seconds of cooking time_.\n\nRemember that one minute consists of `60` seconds.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/30/1.png)\n\n    \n    \n    **Input:** startAt = 1 moveCost = 2 pushCost = 1 targetSeconds = 600\n    **Output:** 6\n    **Explanation:** The following are the possible ways to set the cooking time.\n    - 1 0 0 0 interpreted as 10 minutes and 0 seconds.\n      The finger is already on digit 1 pushes 1 (with cost 1) moves to 0 (with cost 2) pushes 0 (with cost 1) pushes 0 (with cost 1) and pushes 0 (with cost 1).\n      The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.\n    - 0 9 6 0 interpreted as 9 minutes and 60 seconds. That is also 600 seconds.\n      The finger moves to 0 (with cost 2) pushes 0 (with cost 1) moves to 9 (with cost 2) pushes 9 (with cost 1) moves to 6 (with cost 2) pushes 6 (with cost 1) moves to 0 (with cost 2) and pushes 0 (with cost 1).\n      The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.\n    - 9 6 0 normalized as 0960 and interpreted as 9 minutes and 60 seconds.\n      The finger moves to 9 (with cost 2) pushes 9 (with cost 1) moves to 6 (with cost 2) pushes 6 (with cost 1) moves to 0 (with cost 2) and pushes 0 (with cost 1).\n      The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/30/2.png)\n\n    \n    \n    **Input:** startAt = 0 moveCost = 1 pushCost = 2 targetSeconds = 76\n    **Output:** 6\n    **Explanation:** The optimal way is to push two digits: 7 6 interpreted as 76 seconds.\n    The finger moves to 7 (with cost 1) pushes 7 (with cost 2) moves to 6 (with cost 1) and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6\n    Note other possible ways are 0076 076 0116 and 116 but none of them produces the minimum cost.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= startAt <= 9`\n  * `1 <= moveCost pushCost <= 105`\n  * `1 <= targetSeconds <= 6039`\n\n,"class Solution:\n    def minCostSetTime(self startAt: int moveCost: int pushCost: int targetSeconds: int) -> int:\n        poss = [(targetSeconds // 60 targetSeconds % 60)]  # store possibilities as (minutes seconds)\n        \n        if poss[0][0] > 99:  # for when targetSeconds >= 6000\n            poss = [(99 poss[0][1]+60)]\n            \n        if poss[0][0] >= 1 and (poss[0][1]+60) <= 99:\n			# adding a second possibility e.g. (01 16) -> (0 76)\n            poss.append((poss[0][0]-1 poss[0][1]+60))\n            \n        costs = list()\n        \n        for i in poss:\n            curr_start = startAt\n            curr_cost = 0\n            \n            minutes = str(i[0])\n            if i[0] != 0:  # 0s are prepended so no need to push 0s\n                for j in minutes:\n                    if int(j) != curr_start:\n                        curr_cost += moveCost\n                        curr_start = int(j)\n                    curr_cost += pushCost\n                    \n            seconds = str(i[1])\n            if len(seconds) == 1 and i[0] != 0:  # seconds is a single digit prepend a ""0"" to it\n                seconds = ""0"" + seconds\n            \n            for j in seconds:\n                if int(j) != curr_start:\n                    curr_cost += moveCost\n                    curr_start = int(j)\n                curr_cost += pushCost\n            costs.append(curr_cost)\n            \n        return min(costs)"
Minimum Deletions to Make Array Beautiful,###  2216\. Minimum Deletions to Make Array Beautiful\n\nYou are given a **0-indexed** integer array `nums`. The array `nums` is\n**beautiful** if:\n\n  * `nums.length` is even.\n  * `nums[i] != nums[i + 1]` for all `i % 2 == 0`.\n\nNote that an empty array is considered beautiful.\n\nYou can delete any number of elements from `nums`. When you delete an element\nall the elements to the right of the deleted element will be **shifted one\nunit to the left** to fill the gap created and all the elements to the left of\nthe deleted element will remain **unchanged**.\n\nReturn _the**minimum** number of elements to delete from _`nums` _to make it_\n_beautiful._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [11235]\n    **Output:** 1\n    **Explanation:** You can delete either nums[0] or nums[1] to make nums = [1235] which is beautiful. It can be proven you need at least 1 deletion to make nums beautiful.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [112233]\n    **Output:** 2\n    **Explanation:** You can delete nums[0] and nums[5] to make nums = [1223] which is beautiful. It can be proven you need at least 2 deletions to make nums beautiful.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 105`\n\n,class Solution:\n    def minDeletion(self nums: List[int]) -> int:\n        # Greedy !\n        # we first only consider requirement 2: nums[i] != nums[i + 1] for all i % 2 == 0\n        # at the begining we consider the num on the even index\n        # when we delete a num we need consider the num on the odd index\n        # then repeat this process\n        # at the end we check the requirement 1: nums.length is even or not\n        \n        n = len(nums)\n        count = 0\n        # flag is true then check the even index\n        # flag is false then check the odd index\n        flag = True\n        \n        for i in range(n):\n            # check the even index\n            if flag:\n                if i % 2 == 0 and i != n -1 and nums[i] == nums[i + 1]:\n                    count += 1\n                    flag = False\n            # check the odd index\n            elif not flag:\n                if i % 2 == 1 and i != n -1 and nums[i] == nums[i + 1]:\n                    count += 1\n                    flag = True\n        \n        curLength = n - count\n        \n        return count if curLength % 2 == 0 else count + 1
Minimum Deletions to Make Array Divisible,###  2344\. Minimum Deletions to Make Array Divisible\n\nYou are given two positive integer arrays `nums` and `numsDivide`. You can\ndelete any number of elements from `nums`.\n\nReturn _the**minimum** number of deletions such that the **smallest** element\nin _`nums` _**divides** all the elements of _`numsDivide`. If this is not\npossible return `-1`.\n\nNote that an integer `x` divides `y` if `y % x == 0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [23243] numsDivide = [969315]\n    **Output:** 2\n    **Explanation:** \n    The smallest element in [23243] is 2 which does not divide all the elements of numsDivide.\n    We use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [343].\n    The smallest element in [343] is 3 which divides all the elements of numsDivide.\n    It can be shown that 2 is the minimum number of deletions needed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [436] numsDivide = [82610]\n    **Output:** -1\n    **Explanation:** \n    We want the smallest element in nums to divide all the elements of numsDivide.\n    There is no way to delete elements from nums to allow this.\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length numsDivide.length <= 105`\n  * `1 <= nums[i] numsDivide[i] <= 109`\n\n,# Runtime: 1147 ms (Top 45.35%) | Memory: 25.8 MB (Top 79.68%)\nclass Solution:\n    def minOperations(self nums: List[int] divs: List[int]) -> int:\n        div = reduce(gcd divs)\n        return next((i for i n in enumerate(sorted(nums)) if div % n == 0) -1)
Minimum Deletions to Make Character Frequencies Unique,"###  1647\. Minimum Deletions to Make Character Frequencies Unique\n\nA string `s` is called **good** if there are no two different characters in\n`s` that have the same **frequency**.\n\nGiven a string `s` return _the**minimum** number of characters you need to\ndelete to make _`s` _**good**._\n\nThe **frequency** of a character in a string is the number of times it appears\nin the string. For example in the string `""aab""` the **frequency** of `'a'`\nis `2` while the **frequency** of `'b'` is `1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aab""\n    **Output:** 0\n    **Explanation:** s is already good.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aaabbbcc""\n    **Output:** 2\n    **Explanation:** You can delete two 'b's resulting in the good string ""aaabcc"".\n    Another way it to delete one 'b' and one 'c' resulting in the good string ""aaabbc"".\n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""ceabaacb""\n    **Output:** 2\n    **Explanation:** You can delete both 'c's resulting in the good string ""eabaab"".\n    Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` contains only lowercase English letters.\n\n",class Solution:\n    def minDeletions(self s: str) -> int:\n        # Get the frequency of each character sorted in reverse order\n        frequencies = sorted(Counter(s).values() reverse=True)\n        \n        total_deletions = 0\n        next_unused_freq = len(s)\n        for freq in frequencies:\n            # It is impossible for the frequency to be higher\n            next_unused_freq = min(next_unused_freq freq)\n            total_deletions += freq - next_unused_freq\n\n            # We cannot have another character with this frequency\n            # so decrement next_unused_freq\n            if next_unused_freq > 0:\n                next_unused_freq -= 1\n\n        return total_deletions\n
Minimum Deletions to Make String Balanced,"###  1653\. Minimum Deletions to Make String Balanced\n\nYou are given a string `s` consisting only of characters `'a'` and\n`'b'`​​​​.\n\nYou can delete any number of characters in `s` to make `s` **balanced**. `s`\nis **balanced** if there is no pair of indices `(ij)` such that `i < j` and\n`s[i] = 'b'` and `s[j]= 'a'`.\n\nReturn _the**minimum** number of deletions needed to make _`s` _**balanced**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aababbab""\n    **Output:** 2\n    **Explanation:** You can either:\n    Delete the characters at 0-indexed positions 2 and 6 (""aa _b_ abb _a_ b"" -> ""aaabbb"") or\n    Delete the characters at 0-indexed positions 3 and 6 (""aab _a_ bb _a_ b"" -> ""aabbbb"").\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""bbaaaaabb""\n    **Output:** 2\n    **Explanation:** The only solution is to delete the first two characters.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is `'a'` or `'b'`​​.\n\n","class Solution:\n	def minimumDeletions(self s: str) -> int:\n		preSum = [0] * (len(s) + 1)\n		sufSum = [0] * (len(s) + 1)\n\n		for i in range(len(s)):\n			if s[i] == ""a"":\n				preSum[i] += 1 + preSum[i-1]\n\n			else:\n				preSum[i] = preSum[i-1]\n\n			if s[len(s)-i-1] == ""b"":\n				sufSum[len(s)-i-1] += 1 + sufSum[len(s)-i]\n\n			else:\n				sufSum[len(s)-i-1] += sufSum[len(s)-i]\n\n		maxStringLength = 0\n		for i in range(len(s)):\n			if preSum[i] + sufSum[i] > maxStringLength:\n				maxStringLength = preSum[i] + sufSum[i]\n\n		return len(s) - maxStringLength"
Minimum Depth of Binary Tree,###  111\. Minimum Depth of Binary Tree\n\nGiven a binary tree find its minimum depth.\n\nThe minimum depth is the number of nodes along the shortest path from the root\nnode down to the nearest leaf node.\n\n**Note:**  A leaf is a node with no children.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)\n\n    \n    \n    **Input:** root = [3920nullnull157]\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [2null3null4null5null6]\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 105]`.\n  * `-1000 <= Node.val <= 1000`\n\n,class Solution(object):\n    def minDepth(self root):\n        # Base case...\n        # If the subtree is empty i.e. root is NULL return depth as 0...\n        if root is None:  return 0\n        # Initialize the depth of two subtrees...\n        leftDepth = self.minDepth(root.left)\n        rightDepth = self.minDepth(root.right)\n        # If the both subtrees are empty...\n        if root.left is None and root.right is None:\n            return 1\n        # If the left subtree is empty return the depth of right subtree after adding 1 to it...\n        if root.left is None:\n            return 1 + rightDepth\n        # If the right subtree is empty return the depth of left subtree after adding 1 to it...\n        if root.right is None:\n            return 1 + leftDepth\n        # When the two child function return its depth...\n        # Pick the minimum out of these two subtrees and return this value after adding 1 to it...\n        return min(leftDepth rightDepth) + 1;    # Adding 1 is the current node which is the parent of the two subtrees...
Minimum Difference Between Highest and Lowest of K Scores,###  1984\. Minimum Difference Between Highest and Lowest of K Scores\n\nYou are given a **0-indexed** integer array `nums` where `nums[i]` represents\nthe score of the `ith` student. You are also given an integer `k`.\n\nPick the scores of any `k` students from the array so that the **difference**\nbetween the **highest** and the **lowest** of the `k` scores is **minimized**.\n\nReturn _the**minimum** possible difference_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [90] k = 1\n    **Output:** 0\n    **Explanation:** There is one way to pick score(s) of one student:\n    - [**_90_**]. The difference between the highest and lowest score is 90 - 90 = 0.\n    The minimum possible difference is 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [9417] k = 2\n    **Output:** 2\n    **Explanation:** There are six ways to pick score(s) of two students:\n    - [**_9_** **_4_** 17]. The difference between the highest and lowest score is 9 - 4 = 5.\n    - [**_9_** 4**_1_** 7]. The difference between the highest and lowest score is 9 - 1 = 8.\n    - [**_9_** 41**_7_**]. The difference between the highest and lowest score is 9 - 7 = 2.\n    - [9**_4_** **_1_** 7]. The difference between the highest and lowest score is 4 - 1 = 3.\n    - [9**_4_** 1**_7_**]. The difference between the highest and lowest score is 7 - 4 = 3.\n    - [94**_1_** **_7_**]. The difference between the highest and lowest score is 7 - 1 = 6.\n    The minimum possible difference is 2.\n\n\n\n**Constraints:**\n\n  * `1 <= k <= nums.length <= 1000`\n  * `0 <= nums[i] <= 105`\n\n,// Runtime: 118 ms (Top 7.93%) | Memory: 17.50 MB (Top 9.64%)\n\nclass Solution:\n    def minimumDifference(self nums: List[int] k: int) -> int:\n        nums.sort()\n        mn=100001len(nums)\n        ij=0k-1\n        while j<n:\n            m=min(mnums[j]-nums[i])\n            i+=1\n            j+=1\n        return m\n
Minimum Difference Between Largest and Smallest Value in Three Moves,###  1509\. Minimum Difference Between Largest and Smallest Value in Three\nMoves\n\nYou are given an integer array `nums`. In one move you can choose one element\nof `nums` and change it by **any value**.\n\nReturn _the minimum difference between the largest and smallest value of`nums`\nafter performing **at most three moves**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [5324]\n    **Output:** 0\n    **Explanation:** Change the array [5324] to [**2** **2** 2**2**].\n    The difference between the maximum and minimum is 2-2 = 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1501014]\n    **Output:** 1\n    **Explanation:** Change the array [1501014] to [1**1** 0**1** **1**]. \n    The difference between the maximum and minimum is 1-0 = 1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-109 <= nums[i] <= 109`\n\n,# Runtime: 942 ms (Top 5.03%) | Memory: 24.7 MB (Top 96.65%)\nclass Solution:\n    def minDifference(self nums: List[int]) -> int:\n        if len(nums) <= 3:\n            return 0\n\n        nums.sort()\n        t1 = nums[-1] - nums[3]\n        t2 = nums[-4] - nums[0]\n        t3 = nums[-2] - nums[2]\n        t4 = nums[-3] - nums[1]\n\n        return min(t1t2t3t4)
Minimum Difference in Sums After Removal of Elements,###  2163\. Minimum Difference in Sums After Removal of Elements\n\nYou are given a **0-indexed** integer array `nums` consisting of `3 * n`\nelements.\n\nYou are allowed to remove any **subsequence** of elements of size **exactly**\n`n` from `nums`. The remaining `2 * n` elements will be divided into two\n**equal** parts:\n\n  * The first `n` elements belonging to the first part and their sum is `sumfirst`.\n  * The next `n` elements belonging to the second part and their sum is `sumsecond`.\n\nThe **difference in sums** of the two parts is denoted as `sumfirst -\nsumsecond`.\n\n  * For example if `sumfirst = 3` and `sumsecond = 2` their difference is `1`.\n  * Similarly if `sumfirst = 2` and `sumsecond = 3` their difference is `-1`.\n\nReturn _the**minimum difference** possible between the sums of the two parts\nafter the removal of _`n` _elements_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [312]\n    **Output:** -1\n    **Explanation:** Here nums has 3 elements so n = 1. \n    Thus we have to remove 1 element from nums and divide the array into two equal parts.\n    - If we remove nums[0] = 3 the array will be [12]. The difference in sums of the two parts will be 1 - 2 = -1.\n    - If we remove nums[1] = 1 the array will be [32]. The difference in sums of the two parts will be 3 - 2 = 1.\n    - If we remove nums[2] = 2 the array will be [31]. The difference in sums of the two parts will be 3 - 1 = 2.\n    The minimum difference between sums of the two parts is min(-112) = -1. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [795813]\n    **Output:** 1\n    **Explanation:** Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.\n    If we remove nums[2] = 5 and nums[3] = 8 the resultant array will be [7913]. The difference in sums will be (7+9) - (1+3) = 12.\n    To obtain the minimum difference we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7583]. The difference in sums of the two parts is (7+5) - (8+3) = 1.\n    It can be shown that it is not possible to obtain a difference smaller than 1.\n    \n\n\n\n**Constraints:**\n\n  * `nums.length == 3 * n`\n  * `1 <= n <= 105`\n  * `1 <= nums[i] <= 105`\n\n,class Solution:\n    def minimumDifference(self nums: List[int]) -> int:\n        h=heapq\n        k=len(nums)//3\n        min_heap max_heap min_sol max_sol min_sum max_sum sol=[]  []  []  []  0  0 []\n        h.heapify(max_heap)  h.heapify(min_heap)\n        for x in nums[:-k]:\n            h.heappush(min_heap-x)\n            min_sum+=x\n            if len(min_heap)>k: min_sum+=h.heappop(min_heap)\n            min_sol.append(min_sum)\n        for x in nums[::-1][:-k]:\n            h.heappush(max_heapx)\n            max_sum+=x\n            if len(max_heap)>k: max_sum-=h.heappop(max_heap)\n            max_sol.append(max_sum)\n        min_sol =min_sol[k-1:]\n        max_sol=max_sol[k-1:][::-1]\n        return min( min_value - max_value for min_value  max_value in zip(min_solmax_sol) )\n
Minimum Difficulty of a Job Schedule,###  1335\. Minimum Difficulty of a Job Schedule\n\nYou want to schedule a list of jobs in `d` days. Jobs are dependent (i.e To\nwork on the `ith` job you have to finish all the jobs `j` where `0 <= j <\ni`).\n\nYou have to finish **at least** one task every day. The difficulty of a job\nschedule is the sum of difficulties of each day of the `d` days. The\ndifficulty of a day is the maximum difficulty of a job done on that day.\n\nYou are given an integer array `jobDifficulty` and an integer `d`. The\ndifficulty of the `ith` job is `jobDifficulty[i]`.\n\nReturn _the minimum difficulty of a job schedule_. If you cannot find a\nschedule for the jobs return `-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/01/16/untitled.png)\n\n    \n    \n    **Input:** jobDifficulty = [654321] d = 2\n    **Output:** 7\n    **Explanation:** First day you can finish the first 5 jobs total difficulty = 6.\n    Second day you can finish the last job total difficulty = 1.\n    The difficulty of the schedule = 6 + 1 = 7 \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** jobDifficulty = [999] d = 4\n    **Output:** -1\n    **Explanation:** If you finish a job per day you will still have a free day. you cannot find a schedule for the given jobs.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** jobDifficulty = [111] d = 3\n    **Output:** 3\n    **Explanation:** The schedule is one job per day. total difficulty will be 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= jobDifficulty.length <= 300`\n  * `0 <= jobDifficulty[i] <= 1000`\n  * `1 <= d <= 10`\n\n,// Runtime: 483 ms (Top 81.04%) | Memory: 16.60 MB (Top 99.3%)\n\nclass Solution:\n    def minDifficulty(self jobDifficulty days):\n        length = len(jobDifficulty)\n        if days > length:\n            return -1\n\n        min_difficulties = [[float('inf')] * length for _ in range(days)]\n\n        max_diff = 0\n        i = 0\n        while i <= length - days:\n            max_diff = max(max_diff jobDifficulty[i])\n            min_difficulties[0][i] = max_diff\n            i += 1\n\n        current_day = 1\n        while current_day < days:\n            to = current_day\n            while to <= length - days + current_day:\n                current_job_difficulty = jobDifficulty[to]\n                result = float('inf')\n                j = to - 1\n                while j >= current_day - 1:\n                    result = min(result min_difficulties[current_day - 1][j] + current_job_difficulty)\n                    current_job_difficulty = max(current_job_difficulty jobDifficulty[j])\n                    j -= 1\n                min_difficulties[current_day][to] = result\n                to += 1\n            current_day += 1\n\n        return min_difficulties[days - 1][length - 1]\n\n\n\n
Minimum Distance Between BST Nodes,###  783\. Minimum Distance Between BST Nodes\n\nGiven the `root` of a Binary Search Tree (BST) return _the minimum difference\nbetween the values of any two different nodes in the tree_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)\n\n    \n    \n    **Input:** root = [42613]\n    **Output:** 1\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)\n\n    \n    \n    **Input:** root = [1048nullnull1249]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[2 100]`.\n  * `0 <= Node.val <= 105`\n\n\n\n**Note:** This question is the same as 530:\n<https://leetcode.com/problems/minimum-absolute-difference-in-bst/>\n\n,# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def minDiffInBST(self root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        temp1=float(inf)\n        from collections import deque\n        a=deque([root])\n        b=[]\n        while a:\n            node=a.popleft()\n            b.append(node.val)\n            if node.left:\n                a.append(node.left)\n            if node.right:\n                a.append(node.right)\n        b.sort()\n        for i in range(0len(b)-1):\n            if b[i+1]-b[i]
Minimum Distance to the Target Element,###  1848\. Minimum Distance to the Target Element\n\nGiven an integer array `nums` **(0-indexed)** and two integers `target` and\n`start` find an index `i` such that `nums[i] == target` and `abs(i - start)`\nis **minimized**. Note that `abs(x)` is the absolute value of `x`.\n\nReturn `abs(i - start)`.\n\nIt is **guaranteed** that `target` exists in `nums`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12345] target = 5 start = 3\n    **Output:** 1\n    **Explanation:** nums[4] = 5 is the only value equal to target so the answer is abs(4 - 3) = 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1] target = 1 start = 0\n    **Output:** 0\n    **Explanation:** nums[0] = 1 is the only value equal to target so the answer is abs(0 - 0) = 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1111111111] target = 1 start = 0\n    **Output:** 0\n    **Explanation:** Every value of nums is 1 but nums[0] minimizes abs(i - start) which is abs(0 - 0) = 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 104`\n  * `0 <= start < nums.length`\n  * `target` is in `nums`.\n\n,class Solution:\n    def getMinDistance(self nums: List[int] target: int start: int) -> int:\n        if nums[start] == target: return 0\n        left right = start-1 start+1\n        N = len(nums)\n        while True:\n            if left >=0 and nums[left] == target:\n                return start - left\n            if right < N and nums[right] == target:\n                return right - start\n            left -= 1\n            right += 1\n
Minimum Distance to Type a Word Using Two Fingers,"###  1320\. Minimum Distance to Type a Word Using Two Fingers\n\n![](https://assets.leetcode.com/uploads/2020/01/02/leetcode_keyboard.png)\n\nYou have a keyboard layout as shown above in the **X-Y** plane where each\nEnglish uppercase letter is located at some coordinate.\n\n  * For example the letter `'A'` is located at coordinate `(0 0)` the letter `'B'` is located at coordinate `(0 1)` the letter `'P'` is located at coordinate `(2 3)` and the letter `'Z'` is located at coordinate `(4 1)`.\n\nGiven the string `word` return _the minimum total**distance** to type such\nstring using only two fingers_.\n\nThe **distance** between coordinates `(x1 y1)` and `(x2 y2)` is `|x1 - x2| +\n|y1 - y2|`.\n\n**Note** that the initial positions of your two fingers are considered free so\ndo not count towards your total distance also your two fingers do not have to\nstart at the first letter or the first two letters.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word = ""CAKE""\n    **Output:** 3\n    **Explanation:** Using two fingers one optimal way to type ""CAKE"" is: \n    Finger 1 on letter 'C' -> cost = 0 \n    Finger 1 on letter 'A' -> cost = Distance from letter 'C' to letter 'A' = 2 \n    Finger 2 on letter 'K' -> cost = 0 \n    Finger 2 on letter 'E' -> cost = Distance from letter 'K' to letter 'E' = 1 \n    Total distance = 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word = ""HAPPY""\n    **Output:** 6\n    **Explanation:** Using two fingers one optimal way to type ""HAPPY"" is:\n    Finger 1 on letter 'H' -> cost = 0\n    Finger 1 on letter 'A' -> cost = Distance from letter 'H' to letter 'A' = 2\n    Finger 2 on letter 'P' -> cost = 0\n    Finger 2 on letter 'P' -> cost = Distance from letter 'P' to letter 'P' = 0\n    Finger 1 on letter 'Y' -> cost = Distance from letter 'A' to letter 'Y' = 4\n    Total distance = 6\n    \n\n\n\n**Constraints:**\n\n  * `2 <= word.length <= 300`\n  * `word` consists of uppercase English letters.\n\n","from functools import cache\nclass Solution:\n    def minimumDistance(self word: str) -> int:\n        alphabets = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ""\n        COL = 6\n        index = { c:(i//COL i%COL) for i c in enumerate(alphabets)}\n        def dist(a b):\n            return abs(index[a][0] - index[b][0]) + abs(index[a][1] - index[b][1])\n        @cache\n        def dfs(lhand rhand i):\n            if i == len(word): return 0\n            res = float('inf')\n            res = min(res dfs(word[i] rhand i+1)) if lhand == -1 else min(res dist(lhand word[i])+dfs(word[i] rhand i+1))\n            res = min(res dfs(lhand word[i]i+1)) if rhand == -1 else min(res dist(word[i] rhand) + dfs(lhand word[i] i+1))\n            return res\n        return dfs(-1 -1 0)"
Minimum Domino Rotations For Equal Row,###  1007\. Minimum Domino Rotations For Equal Row\n\nIn a row of dominoes `tops[i]` and `bottoms[i]` represent the top and bottom\nhalves of the `ith` domino. (A domino is a tile with two numbers from 1 to 6 -\none on each half of the tile.)\n\nWe may rotate the `ith` domino so that `tops[i]` and `bottoms[i]` swap\nvalues.\n\nReturn the minimum number of rotations so that all the values in `tops` are\nthe same or all the values in `bottoms` are the same.\n\nIf it cannot be done return `-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/14/domino.png)\n\n    \n    \n    **Input:** tops = [212422] bottoms = [526232]\n    **Output:** 2\n    **Explanation:** \n    The first figure represents the dominoes as given by tops and bottoms: before we do any rotations.\n    If we rotate the second and fourth dominoes we can make every value in the top row equal to 2 as indicated by the second figure.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** tops = [35123] bottoms = [36334]\n    **Output:** -1\n    **Explanation:** \n    In this case it is not possible to rotate the dominoes to make one row of values equal.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= tops.length <= 2 * 104`\n  * `bottoms.length == tops.length`\n  * `1 <= tops[i] bottoms[i] <= 6`\n\n,"class Solution:\n    def minDominoRotations(self tops: List[int] bottoms: List[int]) -> int:\n        sames = [tops[i] for i in range(len(tops)) if tops[i] == bottoms[i]]\n		\n        same_count = collections.Counter(sames)\n        bottom_count = collections.Counter(bottoms)\n        top_count = collections.Counter(tops)\n        \n        for n in range(17):\n            if bottom_count[n] + top_count[n] - same_count[n] == len(tops):\n                return min(bottom_count[n] top_count[n]) - same_count[n]\n            \n        return -1\n"
Minimum Elements to Add to Form a Given Sum,###  1785\. Minimum Elements to Add to Form a Given Sum\n\nYou are given an integer array `nums` and two integers `limit` and `goal`. The\narray `nums` has an interesting property that `abs(nums[i]) <= limit`.\n\nReturn _the minimum number of elements you need to add to make the sum of the\narray equal to_`goal`. The array must maintain its property that `abs(nums[i])\n<= limit`.\n\nNote that `abs(x)` equals `x` if `x >= 0` and `-x` otherwise.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1-11] limit = 3 goal = -4\n    **Output:** 2\n    **Explanation:** You can add -2 and -3 then the sum of the array will be 1 - 1 + 1 - 2 - 3 = -4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1-1091] limit = 100 goal = 0\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= limit <= 106`\n  * `-limit <= nums[i] <= limit`\n  * `-109 <= goal <= 109`\n\n,class Solution:\n    def minElements(self nums: List[int] limit: int goal: int) -> int:\n        return math.ceil(abs(goal - sum(nums)) / limit)\n
Minimum Falling Path Sum,###  931\. Minimum Falling Path Sum\n\nGiven an `n x n` array of integers `matrix` return _the**minimum sum** of any\n**falling path** through_ `matrix`.\n\nA **falling path** starts at any element in the first row and chooses the\nelement in the next row that is either directly below or diagonally\nleft/right. Specifically the next element from position `(row col)` will be\n`(row + 1 col - 1)` `(row + 1 col)` or `(row + 1 col + 1)`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/11/03/failing1-grid.jpg)\n\n    \n    \n    **Input:** matrix = [[213][654][789]]\n    **Output:** 13\n    **Explanation:** There are two falling paths with a minimum sum as shown.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/11/03/failing2-grid.jpg)\n\n    \n    \n    **Input:** matrix = [[-1957][-40-5]]\n    **Output:** -59\n    **Explanation:** The falling path with a minimum sum is shown.\n    \n\n\n\n**Constraints:**\n\n  * `n == matrix.length == matrix[i].length`\n  * `1 <= n <= 100`\n  * `-100 <= matrix[i][j] <= 100`\n\n,class Solution:\n    def minFallingPathSum(self matrix: List[List[int]]) -> int:\n        for row in range(1 len(matrix)):\n            for col in range(0 len(matrix[row])):\n                if col == 0:\n                    matrix[row][col] += min(matrix[row-1][col+1] matrix[row-1][col])\n                elif col == len(matrix[row]) - 1:\n                    matrix[row][col] += min(matrix[row-1][col-1] matrix[row-1][col])\n                else:\n                    matrix[row][col] += min(matrix[row-1][col-1] matrix[row-1][col] matrix[row-1][col+1])\n                \n        return min(matrix[-1])\n
Minimum Falling Path Sum II,###  1289\. Minimum Falling Path Sum II\n\nGiven an `n x n` integer matrix `grid` return _the minimum sum of a**falling\npath with non-zero shifts**_.\n\nA **falling path with non-zero shifts** is a choice of exactly one element\nfrom each row of `grid` such that no two elements chosen in adjacent rows are\nin the same column.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/08/10/falling-grid.jpg)\n\n    \n    \n    **Input:** arr = [[123][456][789]]\n    **Output:** 13\n    **Explanation:** \n    The possible falling paths are:\n    [159] [157] [167] [168]\n    [248] [249] [267] [268]\n    [348] [349] [357] [359]\n    The falling path with the smallest sum is [157] so the answer is 13.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[7]]\n    **Output:** 7\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length == grid[i].length`\n  * `1 <= n <= 200`\n  * `-99 <= grid[i][j] <= 99`\n\n,class Solution:\n    def minFallingPathSum(self grid: List[List[int]]) -> int:\n        m n = len(grid) len(grid[0])\n        if m == 1 and n == 1:\n            return grid[0][0]\n        min_arr = [0 for _ in range(n)]\n        for i in range(m):\n            prefix = [float('inf') for _ in range(n)]\n            suffix = [float('inf') for _ in range(n)]\n            current_row = [elem1+elem2 for elem1 elem2 in zip(grid[i] min_arr)]\n            for i in range(1 n):\n                prefix[i] = min(prefix[i-1] current_row[i-1])\n            for i in range(n-2 -1 -1):\n                suffix[i] = min(suffix[i+1] current_row[i+1])\n            min_arr = [min(pre suff) for pre suff in zip(prefix suffix)]\n        return min(min_arr)\n
Minimum Flips to Make a OR b Equal to c,###  1318\. Minimum Flips to Make a OR b Equal to c\n\nGiven 3 positives numbers `a` `b` and `c`. Return the minimum flips required\nin some bits of `a` and `b` to make ( `a` OR `b` == `c` ). (bitwise OR\noperation).  \nFlip operation consists of change **any**  single bit 1 to 0 or change the bit\n0 to 1 in their binary representation.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/01/06/sample_3_1676.png)\n\n    \n    \n    **Input:** a = 2 b = 6 c = 5\n    **Output:** 3\n    **Explanation:** After flips a = 1  b = 4  c = 5 such that (a OR b == c)\n\n**Example 2:**\n\n    \n    \n    **Input:** a = 4 b = 2 c = 7\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** a = 1 b = 2 c = 3\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= a <= 10^9`\n  * `1 <= b <= 10^9`\n  * `1 <= c <= 10^9`\n\n,# Runtime: 37 ms (Top 81.40%) | Memory: 13.8 MB (Top 80.93%)\nclass Solution:\n    def minFlips(self a: int b: int c: int) -> int:\n        res = 0\n        for i in range(32):\n            if (a & 1) | (b & 1) != (c & 1):\n                if (c & 1) == 1: # (a & 1) | (b & 1) should be == 1 ; so changing any of a b we can get 1\n                    res += 1\n                else: # (a & 1) | (b & 1) should be == 0 ; is (a & 1) == 1 and (b & 1) == 1 we need to change both to 0 so res += 1; if any of them is 1 then change only 1 i.e. res += 1\n                    res += (a & 1) + (b & 1)\n            a b c = a>>1 b>>1 c>>1 # right-shift by 1\n\n        return res\n\n# Time: O(1)\n# Space: O(1)
Minimum Garden Perimeter to Collect Enough Apples,###  1954\. Minimum Garden Perimeter to Collect Enough Apples\n\nIn a garden represented as an infinite 2D grid there is an apple tree planted\nat **every** integer coordinate. The apple tree planted at an integer\ncoordinate `(i j)` has `|i| + |j|` apples growing on it.\n\nYou will buy an axis-aligned **square plot** of land that is centered at `(0\n0)`.\n\nGiven an integer `neededApples` return _the**minimum perimeter** of a plot\nsuch that **at least**_****`neededApples` _apples are**inside or on** the\nperimeter of that plot_.\n\nThe value of `|x|` is defined as:\n\n  * `x` if `x >= 0`\n  * `-x` if `x < 0`\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/08/30/1527_example_1_2.png)\n\n    \n    \n    **Input:** neededApples = 1\n    **Output:** 8\n    **Explanation:** A square plot of side length 1 does not contain any apples.\n    However a square plot of side length 2 has 12 apples inside (as depicted in the image above).\n    The perimeter is 2 * 4 = 8.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** neededApples = 13\n    **Output:** 16\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** neededApples = 1000000000\n    **Output:** 5040\n    \n\n\n\n**Constraints:**\n\n  * `1 <= neededApples <= 1015`\n\n,class Solution:\n    def minimumPerimeter(self nap: int) -> int:\n        \n        \n#         here for n = 2  there are two series :  \n#         (1) Diagnal points for n=3  diagnal apples = 2*n = 6\n#         (2) there is series =   233 =  2+ (sigma(3)-sigma(2))*2\n        \n#         how to solve:\n            \n#             here 3  =  sigma(n+(n-1))-sigma(n) = sigma(2*n-1)-sigma(n) =  0.5*2n*(2n-1)-0.5*n*n-1\n#         (3) so our final 233 =   3*2+2 =   (0.5*2n*(2n-1)-0.5*n*n-1)*2+n\n#         (4) so final 233 =  3*n*n - 2*n\n#         (5) we have 4 times repitation of (233)  = 4*(233)  =   4*(3*n*n - 2*n)   =  12*n*n - 8*n\n#         (6) we have 4 diagnal points so their sum(4 diagnal)  = 4*(2*n)\n#         (7)  so final sum(total) = 4 diagnal sum + 4(233)    =   4(2*n)   + 12*n*n - 8*n    =  12*n*n\n        \n#         so at nth distance we have total  12*n*n  apples at the circumfrance\n        \n#         so net sum =  sigma(12*n*n)  = 2*n*(n+1)*(2*n+1)\n        \n        \n        n=1\n        val=2*n*(n+1)*(2*n+1)\n        while(val<nap):\n            n+=1\n            val=val=2*n*(n+1)*(2*n+1)\n        return n*8\n
Minimum Genetic Mutation,"###  433\. Minimum Genetic Mutation\n\nA gene string can be represented by an 8-character long string with choices\nfrom `'A'` `'C'` `'G'` and `'T'`.\n\nSuppose we need to investigate a mutation from a gene string `start` to a gene\nstring `end` where one mutation is defined as one single character changed in\nthe gene string.\n\n  * For example `""AACCGGTT"" --> ""AACCGGTA""` is one mutation.\n\nThere is also a gene bank `bank` that records all the valid gene mutations. A\ngene must be in `bank` to make it a valid gene string.\n\nGiven the two gene strings `start` and `end` and the gene bank `bank` return\n_the minimum number of mutations needed to mutate from_`start` _to_`end`. If\nthere is no such a mutation return `-1`.\n\nNote that the starting point is assumed to be valid so it might not be\nincluded in the bank.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** start = ""AACCGGTT"" end = ""AACCGGTA"" bank = [""AACCGGTA""]\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** start = ""AACCGGTT"" end = ""AAACGGTA"" bank = [""AACCGGTA""""AACCGCTA""""AAACGGTA""]\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** start = ""AAAAACCC"" end = ""AACCCCCC"" bank = [""AAAACCCC""""AAACCCCC""""AACCCCCC""]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `start.length == 8`\n  * `end.length == 8`\n  * `0 <= bank.length <= 10`\n  * `bank[i].length == 8`\n  * `start` `end` and `bank[i]` consist of only the characters `['A' 'C' 'G' 'T']`.\n\n",class Solution:\n    def minMutation(self start: str end: str bank: List[str]) -> int:\n        q = deque()\n        q.append(start)\n        n = len(bank)\n        last = 0\n        used = [False] * n\n        for i x in enumerate(bank):\n            if start == x:\n                used[i] = True\n            if end == x:\n                last = i\n        dist = 0\n        while q:\n            dist += 1\n            for _ in range(len(q)):\n                w = q.popleft()\n                for i x in enumerate(bank):\n                    if used[i]:\n                        continue\n                    bad = 0\n                    for j in range(8):\n                        if w[j] != x[j]:\n                            bad += 1\n                            if bad == 2:\n                                break\n                    if bad == 1:\n                        if last == i:\n                            return dist\n                        used[i] = True\n                        q.append(x)\n        return -1\n
Minimum Height Trees,###  310\. Minimum Height Trees\n\nA tree is an undirected graph in which any two vertices are connected by\n_exactly_  one path. In other words any connected graph without simple cycles\nis a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1` and an array of `n -\n1` `edges` where `edges[i] = [ai bi]` indicates that there is an undirected\nedge between the two nodes `ai` and `bi` in the tree you can choose any node\nof the tree as the root. When you select a node `x` as the root the result\ntree has height `h`. Among all possible rooted trees those with minimum\nheight (i.e. `min(h)`)  are called **minimum height trees** (MHTs).\n\nReturn _a list of all**MHTs'** root labels_. You can return the answer in\n**any order**.\n\nThe **height** of a rooted tree is the number of edges on the longest downward\npath between the root and a leaf.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/01/e1.jpg)\n\n    \n    \n    **Input:** n = 4 edges = [[10][12][13]]\n    **Output:** [1]\n    **Explanation:** As shown the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/01/e2.jpg)\n\n    \n    \n    **Input:** n = 6 edges = [[30][31][32][34][54]]\n    **Output:** [34]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 2 * 104`\n  * `edges.length == n - 1`\n  * `0 <= ai bi < n`\n  * `ai != bi`\n  * All the pairs `(ai bi)` are distinct.\n  * The given input is **guaranteed** to be a tree and there will be **no repeated** edges.\n\n,class Solution:\n    def findMinHeightTrees(self n: int edges: List[List[int]]) -> List[int]:\n        if n==0:\n            return []\n        if n==1:return [0]\n        adj=[[] for i in range (n)]\n        degree=[0]*n\n        for i in edges:\n            adj[i[0]].append(i[1])\n            adj[i[1]].append(i[0])\n            degree[i[0]]+=1\n            degree[i[1]]+=1\n            \n        print(adj)\n        q=[]\n        for i in range(n):\n            if degree[i]==1:\n                q.append(i)\n                \n        while n>2:\n            size=len(q)\n            n-=size\n            while size>0:\n                v=q.pop(0)\n                for i in adj[v]:\n                    degree[i]-=1\n                    if degree[i]==1:\n                        q.append(i)\n                size-=1\n        return q\n                \n            \n        \n
Minimum Increment to Make Array Unique,###  945\. Minimum Increment to Make Array Unique\n\nYou are given an integer array `nums`. In one move you can pick an index `i`\nwhere `0 <= i < nums.length` and increment `nums[i]` by `1`.\n\nReturn _the minimum number of moves to make every value in_`nums`\n_**unique**_.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [122]\n    **Output:** 1\n    **Explanation:** After 1 move the array could be [1 2 3].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [321217]\n    **Output:** 6\n    **Explanation:** After 6 moves the array could be [3 4 1 2 5 7].\n    It can be shown with 5 or less moves that it is impossible for the array to have all unique values.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 105`\n\n,class Solution:\n    def minIncrementForUnique(self nums: List[int]) -> int:\n        nums.sort()\n        c=0\n        i=1\n        num=[]\n        \n        while i<len(nums):\n            if nums[i]<=nums[i-1]:\n                a=nums[i-1]+1\n                c+=(a-nums[i])\n                nums[i]=a\n            i+=1\n        return c\n    \n
Minimum Initial Energy to Finish Tasks,###  1665\. Minimum Initial Energy to Finish Tasks\n\nYou are given an array `tasks` where `tasks[i] = [actuali minimumi]`:\n\n  * `actuali` is the actual amount of energy you **spend to finish** the `ith` task.\n  * `minimumi` is the minimum amount of energy you **require to begin** the `ith` task.\n\nFor example if the task is `[10 12]` and your current energy is `11` you\ncannot start this task. However if your current energy is `13` you can\ncomplete this task and your energy will be `3` after finishing it.\n\nYou can finish the tasks in **any order** you like.\n\nReturn _the**minimum** initial amount of energy you will need_ _to finish all\nthe tasks_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** tasks = [[12][24][48]]\n    **Output:** 8\n    **Explanation:**\n    Starting with 8 energy we finish the tasks in the following order:\n        - 3rd task. Now energy = 8 - 4 = 4.\n        - 2nd task. Now energy = 4 - 2 = 2.\n        - 1st task. Now energy = 2 - 1 = 1.\n    Notice that even though we have leftover energy starting with 7 energy does not work because we cannot do the 3rd task.\n\n**Example 2:**\n\n    \n    \n    **Input:** tasks = [[13][24][1011][1012][89]]\n    **Output:** 32\n    **Explanation:**\n    Starting with 32 energy we finish the tasks in the following order:\n        - 1st task. Now energy = 32 - 1 = 31.\n        - 2nd task. Now energy = 31 - 2 = 29.\n        - 3rd task. Now energy = 29 - 10 = 19.\n        - 4th task. Now energy = 19 - 10 = 9.\n        - 5th task. Now energy = 9 - 8 = 1.\n\n**Example 3:**\n\n    \n    \n    **Input:** tasks = [[17][28][39][410][511][612]]\n    **Output:** 27\n    **Explanation:**\n    Starting with 27 energy we finish the tasks in the following order:\n        - 5th task. Now energy = 27 - 5 = 22.\n        - 2nd task. Now energy = 22 - 2 = 20.\n        - 3rd task. Now energy = 20 - 3 = 17.\n        - 1st task. Now energy = 17 - 1 = 16.\n        - 4th task. Now energy = 16 - 4 = 12.\n        - 6th task. Now energy = 12 - 6 = 6.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= tasks.length <= 105`\n  * `1 <= actual​i <= minimumi <= 104`\n\n,// Runtime: 4002 ms (Top 5.39%) | Memory: 59.1 MB (Top 9.23%)\nclass Solution:\n    def minimumEffort(self tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda x: x[0]-x[1])\n        def ok(mid):\n            for actual minimum in tasks:\n                if minimum > mid or actual > mid: return False\n                if minimum <= mid: mid -= actual\n            return True\n        l r = 0 10 ** 9\n        while l <= r:\n            mid = (l+r) // 2\n            if ok(mid): r = mid - 1\n            else: l = mid + 1\n        return l
Minimum Insertion Steps to Make a String Palindrome,"###  1312\. Minimum Insertion Steps to Make a String Palindrome\n\nGiven a string `s`. In one step you can insert any character at any index of\nthe string.\n\nReturn _the minimum number of steps_ to make `s` palindrome.\n\nA **Palindrome String**  is one that reads the same backward as well as\nforward.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""zzazz""\n    **Output:** 0\n    **Explanation:** The string ""zzazz"" is already palindrome we don't need any insertions.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""mbadm""\n    **Output:** 2\n    **Explanation:** String can be ""mbdadbm"" or ""mdbabdm"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""leetcode""\n    **Output:** 5\n    **Explanation:** Inserting 5 characters the string becomes ""leetcodocteel"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 500`\n  * `s` consists of lowercase English letters.\n\n",class Solution:\n    def minInsertions(self s: str) -> int:\n        n = len(s)\n        prev_prev = [0]*n\n        prev = [0]*n\n        curr = [0] * n\n\n        for l in range(1 n):\n            for i in range(l n):\n                if s[i] == s[i-l]:\n                    curr[i] = prev_prev[i-1]\n                else:\n                    curr[i] = min(prev[i-1] prev[i])+1\n            # print(curr)\n            prev_prev prev curr = prev curr prev_prev\n        \n        return prev[-1]
Minimum Insertions to Balance a Parentheses String,"###  1541\. Minimum Insertions to Balance a Parentheses String\n\nGiven a parentheses string `s` containing only the characters `'('` and `')'`.\nA parentheses string is **balanced** if:\n\n  * Any left parenthesis `'('` must have a corresponding two consecutive right parenthesis `'))'`.\n  * Left parenthesis `'('` must go before the corresponding two consecutive right parenthesis `'))'`.\n\nIn other words we treat `'('` as an opening parenthesis and `'))'` as a\nclosing parenthesis.\n\n  * For example `""())""` `""())(())))""` and `""(())())))""` are balanced `"")()""` `""()))""` and `""(()))""` are not balanced.\n\nYou can insert the characters `'('` and `')'` at any position of the string to\nbalance it if needed.\n\nReturn _the minimum number of insertions_ needed to make `s` balanced.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""(()))""\n    **Output:** 1\n    **Explanation:** The second '(' has two matching '))' but the first '(' has only ')' matching. We need to add one more ')' at the end of the string to be ""(())))"" which is balanced.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""())""\n    **Output:** 0\n    **Explanation:** The string is already balanced.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""))())(""\n    **Output:** 3\n    **Explanation:** Add '(' to match the first '))' Add '))' to match the last '('.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of `'('` and `')'` only.\n\n",class Solution:\n    def minInsertions(self s: str) -> int:\n        leftbrackets = insertions = 0\n        i n = 0 len(s)\n\n        while i < n:\n            if s[i] == '(':\n                leftbrackets += 1\n            elif s[i] == ')':\n                if i == n-1 or s[i+1] != ')': insertions += 1\n                else: i += 1\n                    \n                if not leftbrackets: insertions += 1\n                else: leftbrackets -= 1\n                    \n            i += 1\n        \n        return leftbrackets * 2 + insertions
Minimum Interval to Include Each Query,###  1851\. Minimum Interval to Include Each Query\n\nYou are given a 2D integer array `intervals` where `intervals[i] = [lefti\nrighti]` describes the `ith` interval starting at `lefti` and ending at\n`righti` **(inclusive)**. The **size** of an interval is defined as the number\nof integers it contains or more formally `righti - lefti + 1`.\n\nYou are also given an integer array `queries`. The answer to the `jth` query\nis the **size of the smallest interval** `i` such that `lefti <= queries[j] <=\nrighti`. If no such interval exists the answer is `-1`.\n\nReturn _an array containing the answers to the queries_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** intervals = [[14][24][36][44]] queries = [2345]\n    **Output:** [3314]\n    **Explanation:** The queries are processed as follows:\n    - Query = 2: The interval [24] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\n    - Query = 3: The interval [24] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\n    - Query = 4: The interval [44] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\n    - Query = 5: The interval [36] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** intervals = [[23][25][18][2025]] queries = [219522]\n    **Output:** [2-146]\n    **Explanation:** The queries are processed as follows:\n    - Query = 2: The interval [23] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\n    - Query = 19: None of the intervals contain 19. The answer is -1.\n    - Query = 5: The interval [25] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\n    - Query = 22: The interval [2025] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= intervals.length <= 105`\n  * `1 <= queries.length <= 105`\n  * `intervals[i].length == 2`\n  * `1 <= lefti <= righti <= 107`\n  * `1 <= queries[j] <= 107`\n\n,class Solution:\n    def minInterval(self intervals: List[List[int]] queries: List[int]) -> List[int]:\n        \n        # sort queries from small to large\n        q = deque(sorted([(x i) for i x in enumerate(queries)]))\n        \n        # answer to queries initial state set to -1\n        ans = [-1] * len(queries)\n\n        # sort intervals by low high and size\n        ivals = deque(sorted([(a b b - a + 1) for a b in intervals]))\n        \n        # available intervals\n        cands = []\n\n        \n        while q:\n            x i = q.popleft()\n            \n            # if lower bound of intervals on the top of stack <= current query\n            while ivals and x >= ivals[0][0]:\n                a b c = ivals.popleft()\n                # if higher bound of intervals also meets the requirements\n                # if not then discard the interval\n                if x <= b:\n                    heappush(cands (c b a))\n            \n            # udpate available intervals by removing old ones which no longer has a eligible higher bound\n            while cands:\n                c b a = heappop(cands)\n                if x <= b:\n                    ans[i] = c\n                    heappush(cands (c b a))\n                    break\n\n        return ans
Minimum Jumps to Reach Home,###  1654\. Minimum Jumps to Reach Home\n\nA certain bug's home is on the x-axis at position `x`. Help them get there\nfrom position `0`.\n\nThe bug jumps according to the following rules:\n\n  * It can jump exactly `a` positions **forward** (to the right).\n  * It can jump exactly `b` positions **backward** (to the left).\n  * It cannot jump backward twice in a row.\n  * It cannot jump to any `forbidden` positions.\n\nThe bug may jump forward **beyond** its home but it **cannot jump** to\npositions numbered with **negative** integers.\n\nGiven an array of integers `forbidden` where `forbidden[i]` means that the\nbug cannot jump to the position `forbidden[i]` and integers `a` `b` and\n`x` return _the minimum number of jumps needed for the bug to reach its\nhome_. If there is no possible sequence of jumps that lands the bug on\nposition `x` return `-1.`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** forbidden = [14418115] a = 3 b = 15 x = 9\n    **Output:** 3\n    **Explanation:** 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** forbidden = [831661220] a = 15 b = 13 x = 11\n    **Output:** -1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** forbidden = [162145174] a = 16 b = 9 x = 7\n    **Output:** 2\n    **Explanation:** One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= forbidden.length <= 1000`\n  * `1 <= a b forbidden[i] <= 2000`\n  * `0 <= x <= 2000`\n  * All the elements in `forbidden` are distinct.\n  * Position `x` is not forbidden.\n\n,class Solution:\n    def minimumJumps(self fb: List[int] a: int b: int x: int) -> int:\n        fb = set(fb)\n        q = deque([[00True]])\n        while(q):\n            nlisf = q.popleft()\n            if(n<0 or n in fb or n>2000+2*b):\n                continue\n            fb.add(n)\n            if(n==x):\n                return l\n            if isf and n-b>0:\n                q.append([n-bl+1False])                \n            q.append([n+al+1True])\n        return -1
Minimum Length of String After Deleting Similar Ends,"###  1750\. Minimum Length of String After Deleting Similar Ends\n\nGiven a string `s` consisting only of characters `'a'` `'b'` and `'c'`. You\nare asked to apply the following algorithm on the string any number of times:\n\n  1. Pick a **non-empty** prefix from the string `s` where all the characters in the prefix are equal.\n  2. Pick a **non-empty** suffix from the string `s` where all the characters in this suffix are equal.\n  3. The prefix and the suffix should not intersect at any index.\n  4. The characters from the prefix and suffix must be the same.\n  5. Delete both the prefix and the suffix.\n\nReturn _the**minimum length** of _`s` _after performing the above operation\nany number of times (possibly zero times)_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ca""\n    **Output:** 2\n    **Explanation:** You can't remove any characters so the string stays as is.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""cabaabac""\n    **Output:** 0\n    **Explanation:** An optimal sequence of operations is:\n    - Take prefix = ""c"" and suffix = ""c"" and remove them s = ""abaaba"".\n    - Take prefix = ""a"" and suffix = ""a"" and remove them s = ""baab"".\n    - Take prefix = ""b"" and suffix = ""b"" and remove them s = ""aa"".\n    - Take prefix = ""a"" and suffix = ""a"" and remove them s = """".\n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""aabccabba""\n    **Output:** 3\n    **Explanation:** An optimal sequence of operations is:\n    - Take prefix = ""aa"" and suffix = ""a"" and remove them s = ""bccabb"".\n    - Take prefix = ""b"" and suffix = ""bb"" and remove them s = ""cca"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` only consists of characters `'a'` `'b'` and `'c'`.\n\n",class Solution:\n    def minimumLength(self s: str) -> int:\n        while(len(s)>1 and s[0]==s[-1]):\n            s=s.strip(s[0])\n        else:\n            return len(s)\n
Minimum Limit of Balls in a Bag,###  1760\. Minimum Limit of Balls in a Bag\n\nYou are given an integer array `nums` where the `ith` bag contains `nums[i]`\nballs. You are also given an integer `maxOperations`.\n\nYou can perform the following operation at most `maxOperations` times:\n\n  * Take any bag of balls and divide it into two new bags with a **positive** number of balls. \n    * For example a bag of `5` balls can become two new bags of `1` and `4` balls or two new bags of `2` and `3` balls.\n\nYour penalty is the **maximum** number of balls in a bag. You want to\n**minimize** your penalty after the operations.\n\nReturn _the minimum possible penalty  after performing the operations_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [9] maxOperations = 2\n    **Output:** 3\n    **Explanation:** \n    - Divide the bag with 9 balls into two bags of sizes 6 and 3. [**_9_**] -> [63].\n    - Divide the bag with 6 balls into two bags of sizes 3 and 3. [**_6_** 3] -> [333].\n    The bag with the most number of balls has 3 balls so your penalty is 3 and you should return 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2482] maxOperations = 4\n    **Output:** 2\n    **Explanation:**\n    - Divide the bag with 8 balls into two bags of sizes 4 and 4. [24**_8_** 2] -> [24442].\n    - Divide the bag with 4 balls into two bags of sizes 2 and 2. [2**_4_** 442] -> [222442].\n    - Divide the bag with 4 balls into two bags of sizes 2 and 2. [222**_4_** 42] -> [2222242].\n    - Divide the bag with 4 balls into two bags of sizes 2 and 2. [22222**_4_** 2] -> [22222222].\n    The bag with the most number of balls has 2 balls so your penalty is 2 an you should return 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [717] maxOperations = 2\n    **Output:** 7\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= maxOperations nums[i] <= 109`\n\n,class Solution:\n    def minimumSize(self nums: List[int] maxOperations: int) -> int:\n        l r = 1 max(nums)\n        while l < r:\n            mid = (l + r) // 2\n            if sum([(n - 1) // mid for n in nums]) > maxOperations: \n                l = mid + 1\n            else:\n                r = mid\n        return l\n
Minimum Lines to Represent a Line Chart,###  2280\. Minimum Lines to Represent a Line Chart\n\nYou are given a 2D integer array `stockPrices` where `stockPrices[i] = [dayi\npricei]` indicates the price of the stock on day `dayi` is `pricei`. A **line\nchart** is created from the array by plotting the points on an XY plane with\nthe X-axis representing the day and the Y-axis representing the price and\nconnecting adjacent points. One such example is shown below:\n\n![](https://assets.leetcode.com/uploads/2022/03/30/1920px-\npushkin_population_historysvg.png)\n\nReturn _the**minimum number of lines** needed to represent the line chart_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/30/ex0.png)\n\n    \n    \n    **Input:** stockPrices = [[17][26][35][44][54][63][72][81]]\n    **Output:** 3\n    **Explanation:**\n    The diagram above represents the input with the X-axis representing the day and Y-axis representing the price.\n    The following 3 lines can be drawn to represent the line chart:\n    - Line 1 (in red) from (17) to (44) passing through (17) (26) (35) and (44).\n    - Line 2 (in blue) from (44) to (54).\n    - Line 3 (in green) from (54) to (81) passing through (54) (63) (72) and (81).\n    It can be shown that it is not possible to represent the line chart using less than 3 lines.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/30/ex1.png)\n\n    \n    \n    **Input:** stockPrices = [[34][12][78][23]]\n    **Output:** 1\n    **Explanation:**\n    As shown in the diagram above the line chart can be represented with a single line.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= stockPrices.length <= 105`\n  * `stockPrices[i].length == 2`\n  * `1 <= dayi pricei <= 109`\n  * All `dayi` are **distinct**.\n\n,from fractions import Fraction\nfrom itertools import pairwise\nfrom math import inf\nfrom operator import itemgetter\n\nPoint = tuple[int int]\n\n\nclass Solution:\n    def minimumLines(self prices: list[Point]) -> int:\n        if len(prices) == 1:\n            return 0\n        else:\n            prices.sort(key=itemgetter(0))\n\n            return self.using_slope(prices)\n            # return self.using_cross_product(prices)\n\n    @staticmethod\n    def using_slope(prices: list[Point]) -> int:\n        output slope = 1 Solution.dy_by_dx\n\n        ab = next(pairs := pairwise(prices))\n\n        for bc in pairs:\n            if slope(ab) != slope(bc):\n                output += 1\n\n            ab = bc\n\n        return output\n\n    @staticmethod\n    def dy_by_dx(ab: tuple[Point Point]) -> float | Fraction:\n        (x1 y1) (x2 y2) = ab\n\n        dx dy = x2 - x1 y2 - y1\n\n        if dx == 0:\n            # 1. dx is 0 it means we have a vertical line going from (x1 y1). So whether dy is positive or\n            #    negative it does not matter\n            # 2. infinity can not be represented by fraction module so returning it directly from math module\n            return inf\n        else:\n            # To avoid floating point error we use fraction module.\n\n            # (Simple divisions can give same results for example (apparently one of the test cases)\n            # 499999998/499999999 and 499999999/500000000 gives same result and that is where Fraction\n            # class shines)\n            return Fraction(dy dx)\n\n    @staticmethod\n    def using_cross_product(prices: list[Point]) -> int:\n        output on_line = 1 Solution.lie_on_same_line\n\n        a = next(itr := iter(prices))\n\n        for b c in pairwise(itr):\n            if not on_line(a b c):\n                output += 1\n\n            a = b\n\n        return output\n\n    @staticmethod\n    def lie_on_same_line(a: Point b: Point c: Point) -> bool:\n        (x1 y1) (x2 y2) (x3 y3) = a b c\n\n        return (y2 - y1) * (x3 - x2) == (x2 - x1) * (y3 - y2)
Minimum Moves to Equal Array Elements,###  453\. Minimum Moves to Equal Array Elements\n\nGiven an integer array `nums` of size `n` return _the minimum number of moves\nrequired to make all array elements equal_.\n\nIn one move you can increment `n - 1` elements of the array by `1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** 3\n    **Explanation:** Only three moves are needed (remember each move increments two elements):\n    [123]  =>  [233]  =>  [343]  =>  [444]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [111]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= nums.length <= 105`\n  * `-109 <= nums[i] <= 109`\n  * The answer is guaranteed to fit in a **32-bit** integer.\n\n,class Solution:\n    def minMoves(self nums: List[int]) -> int:\n        return sum(nums)-min(nums)*len(nums)\n
Minimum Moves to Equal Array Elements II,###  462\. Minimum Moves to Equal Array Elements II\n\nGiven an integer array `nums` of size `n` return _the minimum number of moves\nrequired to make all array elements equal_.\n\nIn one move you can increment or decrement an element of the array by `1`.\n\nTest cases are designed so that the answer will fit in a **32-bit** integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** 2\n    **Explanation:**\n    Only two moves are needed (remember each move increments or decrements one element):\n    [_1_ 23]  =>  [22_3_]  =>  [222]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [11029]\n    **Output:** 16\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= nums.length <= 105`\n  * `-109 <= nums[i] <= 109`\n\n,class Solution:\n    def minMoves2(self nums: List[int]) -> int:\n        \n        n=len(nums)\n        nums.sort()\n        \n        if n%2==1:\n            median=nums[n//2]\n        else:\n            median = (nums[n//2 - 1] + nums[n//2]) // 2\n        \n        ans=0\n        \n        for val in nums:\n            ans+=abs(val-median)\n        \n        return ans\n        \n
Minimum Moves to Make Array Complementary,###  1674\. Minimum Moves to Make Array Complementary\n\nYou are given an integer array `nums` of **even** length `n` and an integer\n`limit`. In one move you can replace any integer from `nums` with another\ninteger between `1` and `limit` inclusive.\n\nThe array `nums` is **complementary** if for all indices `i` (**0-indexed**)\n`nums[i] + nums[n - 1 - i]` equals the same number. For example the array\n`[1234]` is complementary because for all indices `i` `nums[i] + nums[n -\n1 - i] = 5`.\n\nReturn the _**minimum** number of moves required to make _`nums`\n_**complementary**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1243] limit = 4\n    **Output:** 1\n    **Explanation:** In 1 move you can change nums to [12_2_ 3] (underlined elements are changed).\n    nums[0] + nums[3] = 1 + 3 = 4.\n    nums[1] + nums[2] = 2 + 2 = 4.\n    nums[2] + nums[1] = 2 + 2 = 4.\n    nums[3] + nums[0] = 3 + 1 = 4.\n    Therefore nums[i] + nums[n-1-i] = 4 for every i so nums is complementary.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1221] limit = 2\n    **Output:** 2\n    **Explanation:** In 2 moves you can change nums to [_2_ 22_2_]. You cannot change any number to 3 since 3 > limit.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1212] limit = 2\n    **Output:** 0\n    **Explanation:** nums is already complementary.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `2 <= n <= 105`\n  * `1 <= nums[i] <= limit <= 105`\n  * `n` is even.\n\n,"class Solution:  \n    def minMoves(self nums: List[int] limit: int) -> int:\n        n = len(nums)\n        overlay_arr = [0] * (2*limit+2)\n        for i in range(n//2):\n            left_boundary = min(nums[i] nums[n-1-i]) + 1\n            no_move_value = nums[i] + nums[n-1-i]\n            right_boundary = max(nums[i] nums[n-1-i]) + limit\n            overlay_arr[left_boundary] -= 1\n            overlay_arr[no_move_value] -= 1\n            overlay_arr[no_move_value+1] += 1\n            overlay_arr[right_boundary+1] += 1\n        curr_moves = n   #initial assumption of two moves for each pair\n        res = float(""inf"")\n		# start Sweeping\n        for i in range(2 2*limit+1):\n            curr_moves += overlay_arr[i]\n            res = min(res curr_moves)\n        return res\n"
Minimum Moves to Move a Box to Their Target Location,"###  1263\. Minimum Moves to Move a Box to Their Target Location\n\nA storekeeper is a game in which the player pushes boxes around in a warehouse\ntrying to get them to target locations.\n\nThe game is represented by an `m x n` grid of characters `grid` where each\nelement is a wall floor or box.\n\nYour task is to move the box `'B'` to the target position `'T'` under the\nfollowing rules:\n\n  * The character `'S'` represents the player. The player can move up down left right in `grid` if it is a floor (empty cell).\n  * The character `'.'` represents the floor which means a free cell to walk.\n  * The character `'#' `represents the wall which means an obstacle (impossible to walk there).\n  * There is only one box `'B'` and one target cell `'T'` in the `grid`.\n  * The box can be moved to an adjacent free cell by standing next to the box and then moving in the direction of the box. This is a **push**.\n  * The player cannot walk through the box.\n\nReturn _the minimum number of**pushes** to move the box to the target_. If\nthere is no way to reach the target return `-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/11/06/sample_1_1620.png)\n\n    \n    \n    **Input:** grid = [[""#""""#""""#""""#""""#""""#""]\n                   [""#""""T""""#""""#""""#""""#""]\n                   [""#""""."""".""""B"""".""""#""]\n                   [""#"""".""""#""""#"""".""""#""]\n                   [""#"""".""""."""".""""S""""#""]\n                   [""#""""#""""#""""#""""#""""#""]]\n    **Output:** 3\n    **Explanation:** We return only the number of times the box is pushed.\n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[""#""""#""""#""""#""""#""""#""]\n                   [""#""""T""""#""""#""""#""""#""]\n                   [""#""""."""".""""B"""".""""#""]\n                   [""#""""#""""#""""#"""".""""#""]\n                   [""#"""".""""."""".""""S""""#""]\n                   [""#""""#""""#""""#""""#""""#""]]\n    **Output:** -1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[""#""""#""""#""""#""""#""""#""]\n                   [""#""""T""""."""".""""#""""#""]\n                   [""#"""".""""#""""B"""".""""#""]\n                   [""#""""."""".""""."""".""""#""]\n                   [""#"""".""""."""".""""S""""#""]\n                   [""#""""#""""#""""#""""#""""#""]]\n    **Output:** 5\n    **Explanation:** push the box down left left up and up.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 20`\n  * `grid` contains only characters `'.'` `'#'` `'S'` `'T'` or `'B'`.\n  * There is only one character `'S'` `'B'` and `'T'` in the `grid`.\n\n","class Solution:\n    def minPushBox(self grid: List[List[str]]) -> int:\n        mn=len(grid)len(grid[0])\n        q=deque()\n        starttargetbox=(00)(00)(00)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==""B"":\n                    box=(ij)\n                elif grid[i][j]==""T"":\n                    target=(ij)\n                elif grid[i][j]==""S"":\n                    start=(ij)\n        q.append((box[0]box[1]0start[0]start[1]))\n        visited=set()\n        directions=((10-10)(010-1)(-1010)(0-101))\n        visited.add(box+box)\n        def solve(ijbibj):\n            nonlocal seen\n            if (ij)==(bibj):\n                return True\n            ans=False\n            for d in directions:\n                ninj=i+d[0]j+d[1]\n                if 0<=ni<m and 0<=nj<n and (ninj) not in seen and grid[ni][nj]!=""#"":\n                    seen.add((ninj))\n                    ans=ans or solve(ninjbibj)\n                    if ans: return ans\n            return ans\n        while q:\n            ijpushessisj=q.popleft()\n            if (ij)==target:\n                return pushes\n            if pushes>m+n:\n                return -1\n            for d in directions:\n                ninjbibj=i+d[0]j+d[1]i+d[2]j+d[3]\n                if 0<=ni<m and 0<=nj<n and (ninjij) not in visited and grid[ni][nj]!=""#"" and 0<=bi<m and 0<=bj<n and grid[bi][bj]!=""#"":\n                    seen=set()\n                    seen.add((ij))\n                    grid[i][j]==""#""\n                    res=solve(sisjbibj)\n                    grid[i][j]="".""\n                    if not res:\n                        continue\n                    visited.add((ninjij))\n                    q.append((ninjpushes+1ij))\n        return -1\n"
Minimum Moves to Reach Target Score,###  2139\. Minimum Moves to Reach Target Score\n\nYou are playing a game with integers. You start with the integer `1` and you\nwant to reach the integer `target`.\n\nIn one move you can either:\n\n  * **Increment** the current integer by one (i.e. `x = x + 1`).\n  * **Double** the current integer (i.e. `x = 2 * x`).\n\nYou can use the **increment** operation **any** number of times however you\ncan only use the **double** operation **at most** `maxDoubles` times.\n\nGiven the two integers `target` and `maxDoubles` return _the minimum number\nof moves needed to reach_`target` _starting with_`1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = 5 maxDoubles = 0\n    **Output:** 4\n    **Explanation:** Keep incrementing by 1 until you reach target.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = 19 maxDoubles = 2\n    **Output:** 7\n    **Explanation:** Initially x = 1\n    Increment 3 times so x = 4\n    Double once so x = 8\n    Increment once so x = 9\n    Double again so x = 18\n    Increment once so x = 19\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** target = 10 maxDoubles = 4\n    **Output:** 4\n    **Explanation:****** Initially x = 1\n    Increment once so x = 2\n    Double once so x = 4\n    Increment once so x = 5\n    Double again so x = 10\n    \n\n\n\n**Constraints:**\n\n  * `1 <= target <= 109`\n  * `0 <= maxDoubles <= 100`\n\n,# Runtime: 58 ms (Top 30.40%) | Memory: 14 MB (Top 14.20%)\nclass Solution:\n    def minMoves(self target: int maxDoubles: int) -> int:\n        c=0\n        while(maxDoubles>0 and target>1):\n            c += target%2\n            target //= 2\n            c += 1\n            maxDoubles -=1\n        return c + target-1
Minimum Moves to Reach Target with Rotations,###  1210\. Minimum Moves to Reach Target with Rotations\n\nIn an `n*n` grid there is a snake that spans 2 cells and starts moving from\nthe top left corner at `(0 0)` and `(0 1)`. The grid has empty cells\nrepresented by zeros and blocked cells represented by ones. The snake wants to\nreach the lower right corner at `(n-1 n-2)` and `(n-1 n-1)`.\n\nIn one move the snake can:\n\n  * Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n  * Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\n  * Rotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from `(r c)` and `(r c+1)` to `(r c)` and `(r+1 c)`.  \n![](https://assets.leetcode.com/uploads/2019/09/24/image-2.png)\n\n  * Rotate counterclockwise if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from `(r c)` and `(r+1 c)` to `(r c)` and `(r c+1)`.  \n![](https://assets.leetcode.com/uploads/2019/09/24/image-1.png)\n\nReturn the minimum number of moves to reach the target.\n\nIf there is no way to reach the target return `-1`.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2019/09/24/image.png)**\n\n    \n    \n    **Input:** grid = [[000001]\n                   [110010]\n                   [000011]\n                   [001010]\n                   [011000]\n                   [011000]]\n    **Output:** 11\n    **Explanation:** One possible solution is [right right rotate clockwise right down down down down rotate counterclockwise right down].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[001111]\n                   [000011]\n                   [110001]\n                   [111001]\n                   [111001]\n                   [111000]]\n    **Output:** 9\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 100`\n  * `0 <= grid[i][j] <= 1`\n  * It is guaranteed that the snake starts at empty cells.\n\n,class Solution:\n    def minimumMoves(self grid: List[List[int]]) -> int:\n        queue  vis  n = [(0100)]  {}  len(grid)\n        while queue:\n            xyposmoves = queue.pop(0)\n            if x == y == n-1 and pos == 0: return moves\n            if pos == 0:\n                if y + 1 < n and grid[x][y+1] == 0 and (xy+10) not in vis:\n                    vis[(xy+10)] = True\n                    queue.append((xy+10moves+1))\n                \n                if x + 1 < n and grid[x+1][y-1] == 0 and grid[x+1][y] == 0:\n                    if (x+1y-11) not in vis:\n                        vis[(x+1y-11)] = True\n                        queue.append((x+1y-11moves+1))\n                    if (x+1y0) not in vis:\n                        vis[(x+1y0)] = True\n                        queue.append((x+1y0moves+1))\n            else:\n                if x + 1 < n and grid[x+1][y] == 0 and (x+1y1) not in vis:\n                    vis[(x+1y1)] = True\n                    queue.append((x+1y1moves+1))\n                if y + 1 < n and grid[x-1][y+1] == grid[x][y+1] == 0:\n                    if (x-1y+10) not in vis:\n                        vis[(x-1y+10)] = True\n                        queue.append((x-1y+10moves+1))\n                    if (xy+11) not in vis:\n                        vis[(xy+11)] = True\n                        queue.append((xy+11moves+1))\n        return -1\n
Minimum Non-Zero Product of the Array Elements,###  1969\. Minimum Non-Zero Product of the Array Elements\n\nYou are given a positive integer `p`. Consider an array `nums` (**1-indexed**)\nthat consists of the integers in the **inclusive** range `[1 2p - 1]` in\ntheir binary representations. You are allowed to do the following operation\n**any** number of times:\n\n  * Choose two elements `x` and `y` from `nums`.\n  * Choose a bit in `x` and swap it with its corresponding bit in `y`. Corresponding bit refers to the bit that is in the **same position** in the other integer.\n\nFor example if `x = 11 _0_ 1` and `y = 00 _1_ 1` after swapping the `2nd`\nbit from the right we have `x = 11 _1_ 1` and `y = 00 _0_ 1`.\n\nFind the **minimum non-zero** product of `nums` after performing the above\noperation **any** number of times. Return _this product_ _**modulo** _`109 +\n7`.\n\n**Note:** The answer should be the minimum product **before** the modulo\noperation is done.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** p = 1\n    **Output:** 1\n    **Explanation:** nums = [1].\n    There is only one element so the product equals that element.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** p = 2\n    **Output:** 6\n    **Explanation:** nums = [01 10 11].\n    Any swap would either make the product 0 or stay the same.\n    Thus the array product of 1 * 2 * 3 = 6 is already minimized.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** p = 3\n    **Output:** 1512\n    **Explanation:** nums = [001 010 011 100 101 110 111]\n    - In the first operation we can swap the leftmost bit of the second and fifth elements.\n        - The resulting array is [001 _1_ 10 011 100 _0_ 01 110 111].\n    - In the second operation we can swap the middle bit of the third and fourth elements.\n        - The resulting array is [001 110 0 _0_ 1 1 _1_ 0 001 110 111].\n    The array product is 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512 which is the minimum possible product.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= p <= 60`\n\n,class Solution:\n    def minNonZeroProduct(self p: int) -> int:\n        mod = 10**9+7\n        return (pow(2**p-22**(p-1)-1mod)*(2**p-1))%mod\n
Minimum Number of Buckets Required to Collect Rainwater from Houses,"###  2086\. Minimum Number of Buckets Required to Collect Rainwater from\nHouses\n\nYou are given a **0-index****ed** string `street`. Each character in `street`\nis either `'H'` representing a house or `'.'` representing an empty space.\n\nYou can place buckets on the **empty spaces** to collect rainwater that falls\nfrom the adjacent houses. The rainwater from a house at index `i` is collected\nif a bucket is placed at index `i - 1` **and/or** index `i + 1`. A single\nbucket if placed adjacent to two houses can collect the rainwater from\n**both** houses.\n\nReturn _the**minimum** number of buckets needed so that for **every** house\nthere is **at least** one bucket collecting rainwater from it or _`-1` _if it\nis impossible._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** street = ""H..H""\n    **Output:** 2\n    **Explanation:**\n    We can put buckets at index 1 and index 2.\n    ""H..H"" -> ""HBBH"" ('B' denotes where a bucket is placed).\n    The house at index 0 has a bucket to its right and the house at index 3 has a bucket to its left.\n    Thus for every house there is at least one bucket collecting rainwater from it.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** street = "".H.H.""\n    **Output:** 1\n    **Explanation:**\n    We can put a bucket at index 2.\n    "".H.H."" -> "".HBH."" ('B' denotes where a bucket is placed).\n    The house at index 1 has a bucket to its right and the house at index 3 has a bucket to its left.\n    Thus for every house there is at least one bucket collecting rainwater from it.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** street = "".HHH.""\n    **Output:** -1\n    **Explanation:**\n    There is no empty space to place a bucket to collect the rainwater from the house at index 2.\n    Thus it is impossible to collect the rainwater from all the houses.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= street.length <= 105`\n  * `street[i]` is either`'H'` or `'.'`.\n\n","class Solution:\n    def minimumBuckets(self street: str) -> int:\n        street = list(street)\n        print(street)\n        num = 0\n        for i in range(len(street)):\n            if street[i] == ""H"":\n                if i > 0 and street[i-1] == ""B"":\n                    continue\n                if i < len(street) - 1 and street[i+1] == ""."":\n                    street[i+1] = ""B""\n                    num += 1\n                    continue\n                if i > 0 and street[i-1] == ""."":\n                    street[i-1] = ""B""\n                    num += 1\n                    continue\n                return -1\n        return num"
Minimum Number of Days to Disconnect Island,###  1568\. Minimum Number of Days to Disconnect Island\n\nYou are given an `m x n` binary grid `grid` where `1` represents land and `0`\nrepresents water. An **island** is a maximal **4-directionally** (horizontal\nor vertical) connected group of `1`'s.\n\nThe grid is said to be **connected** if we have **exactly one island** \notherwise is said **disconnected**.\n\nIn one day we are allowed to change **any** single land cell `(1)` into a\nwater cell `(0)`.\n\nReturn _the minimum number of days to disconnect the grid_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/24/land1.jpg)\n\n    \n    \n    **Input:** grid = [[0110][0110][0000]]\n    \n    **Output:** 2\n    **Explanation:** We need at least 2 days to get a disconnected grid.\n    Change land grid[1][1] and grid[0][2] to water and get 2 disconnected island.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/24/land2.jpg)\n\n    \n    \n    **Input:** grid = [[11]]\n    **Output:** 2\n    **Explanation:** Grid of full water is also disconnected ([[11]] -> [[00]]) 0 islands.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 30`\n  * `grid[i][j]` is either `0` or `1`.\n\n,// Runtime: 70 ms (Top 98.46%) | Memory: 18.30 MB (Top 33.85%)\n\nclass Solution:\n    def minDays(self grid: List[List[int]]) -> int:\n        rows cols = len(grid) len(grid[0])\n\n        disc_time = [[-1 for _ in range(cols)] for _ in range(rows)]\n        low_value = [[-1 for _ in range(cols)] for _ in range(rows)]\n        parents = [[(-1 -1) for _ in range(cols)] for _ in range(rows)]\n        is_ap = [[False for _ in range(cols)] for _ in range(rows)]\n        dirs = [(1 0) (0 1) (-1 0) (0 -1)]\n\n        time = 0\n        has_ap = False\n        def dfs(i j):\n            if grid[i][j] == 0:\n                return\n            nonlocal time\n            nonlocal has_ap\n            disc_time[i][j] = time\n            low_value[i][j] = time\n            time += 1\n\n            child = 0\n            for di dj in dirs:\n                ni nj = i + di j + dj\n                if not (0 <= ni < rows) or not (0 <= nj < cols):\n                    continue\n                if grid[ni][nj] != 1:\n                    continue\n\n                if disc_time[ni][nj] == -1: # not visited\n                    child += 1\n                    parents[ni][nj] = (i j)\n                    dfs(ni nj)\n                    low_value[i][j] = min(low_value[i][j] low_value[ni][nj])\n\n                    if parents[i][j] == (-1 -1) and child > 1:\n                        is_ap[i][j] = True\n                        has_ap = True\n\n                    if parents[i][j] != (-1 -1) and low_value[ni][nj] >= disc_time[i][j]:\n                        is_ap[i][j] = True\n                        has_ap = True\n                elif (ni nj) != parents[i][j]:\n                    low_value[i][j] = min(low_value[i][j] disc_time[ni][nj])\n\n        sccs = 0\n        num_ones = 0\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] == 1:\n                    num_ones += 1\n                if disc_time[i][j] == -1 and grid[i][j] == 1:\n                    dfs(i j)\n                    sccs += 1\n\n\n        if sccs > 1:\n            return 0\n        elif has_ap:\n            return 1\n        else:\n            if num_ones == 1:\n                return 1\n            elif num_ones == 0:\n                return 0\n        return 2\n\n\n
Minimum Number of Days to Eat N Oranges,###  1553\. Minimum Number of Days to Eat N Oranges\n\nThere are `n` oranges in the kitchen and you decided to eat some of these\noranges every day as follows:\n\n  * Eat one orange.\n  * If the number of remaining oranges `n` is divisible by `2` then you can eat `n / 2` oranges.\n  * If the number of remaining oranges `n` is divisible by `3` then you can eat `2 * (n / 3)` oranges.\n\nYou can only choose one of the actions per day.\n\nGiven the integer `n` return _the minimum number of days to eat_ `n`\n_oranges_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 4\n    **Explanation:** You have 10 oranges.\n    Day 1: Eat 1 orange  10 - 1 = 9.  \n    Day 2: Eat 6 oranges 9 - 2*(9/3) = 9 - 6 = 3. (Since 9 is divisible by 3)\n    Day 3: Eat 2 oranges 3 - 2*(3/3) = 3 - 2 = 1. \n    Day 4: Eat the last orange  1 - 1  = 0.\n    You need at least 4 days to eat the 10 oranges.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 6\n    **Output:** 3\n    **Explanation:** You have 6 oranges.\n    Day 1: Eat 3 oranges 6 - 6/2 = 6 - 3 = 3. (Since 6 is divisible by 2).\n    Day 2: Eat 2 oranges 3 - 2*(3/3) = 3 - 2 = 1. (Since 3 is divisible by 3)\n    Day 3: Eat the last orange  1 - 1  = 0.\n    You need at least 3 days to eat the 6 oranges.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 2 * 109`\n\n,from collections import deque\nfrom math import log2 ceil\nclass Solution:\n    def minDays(self n: int) -> int:\n        maxd = 2*ceil(log2(n))\n        que = deque([(11)])\n        seen = set()\n        while que:\n            v d = que.popleft()\n            seen.add(v)\n            if v == n:\n                return d\n            for w in [v+1 2*v 3*v]:\n                if w not in seen and d <= maxd and w <= n:\n                    que.append((wd+1))\n
Minimum Number of Days to Make m Bouquets,###  1482\. Minimum Number of Days to Make m Bouquets\n\nYou are given an integer array `bloomDay` an integer `m` and an integer `k`.\n\nYou want to make `m` bouquets. To make a bouquet you need to use `k`\n**adjacent flowers** from the garden.\n\nThe garden consists of `n` flowers the `ith` flower will bloom in the\n`bloomDay[i]` and then can be used in **exactly one** bouquet.\n\nReturn _the minimum number of days you need to wait to be able to make_`m`\n_bouquets from the garden_. If it is impossible to make m bouquets return\n`-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** bloomDay = [1103102] m = 3 k = 1\n    **Output:** 3\n    **Explanation:** Let us see what happened in the first three days. x means flower bloomed and _ means flower did not bloom in the garden.\n    We need 3 bouquets each should contain 1 flower.\n    After day 1: [x _ _ _ _]   // we can only make one bouquet.\n    After day 2: [x _ _ _ x]   // we can only make two bouquets.\n    After day 3: [x _ x _ x]   // we can make 3 bouquets. The answer is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** bloomDay = [1103102] m = 3 k = 2\n    **Output:** -1\n    **Explanation:** We need 3 bouquets each has 2 flowers that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** bloomDay = [77771277] m = 2 k = 3\n    **Output:** 12\n    **Explanation:** We need 2 bouquets each should have 3 flowers.\n    Here is the garden after the 7 and 12 days:\n    After day 7: [x x x x _ x x]\n    We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\n    After day 12: [x x x x x x x]\n    It is obvious that we can make two bouquets in different ways.\n    \n\n\n\n**Constraints:**\n\n  * `bloomDay.length == n`\n  * `1 <= n <= 105`\n  * `1 <= bloomDay[i] <= 109`\n  * `1 <= m <= 106`\n  * `1 <= k <= n`\n\n,"class Solution:\n    \n    def minDays(self listOfFlowerBloomDays: List[int] targetNumberOfBouquets: int flowersPerBouquet: int) -> int:\n        \n        def numberOfBouquetsWeCanMakeOnThisDay(dayThatWeAreChecking):\n            \n            currentListOfAdjacentBloomedFlowers = []\n            numberOfBouquetsWeCanMakeOnThisDay = 0\n            \n            for dayThatFlowerBlooms in listOfFlowerBloomDays:\n                \n                # check if the flower has bloomed on this day \n                if dayThatFlowerBlooms <= dayThatWeAreChecking:\n                    \n                    # add to the list an adjacent bloomed flowers I use 'x' because the description uses an 'x'\n                    currentListOfAdjacentBloomedFlowers.append('x')\n                    \n                else:\n                    # we've hit a day where we don't have a bloomed flower so the list of adjacent bloomed flowers has to be reset\n                    # BUT FIRST figure out how many bouquets we can make with this list of adjacent bloomed flowers\n                    numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\n                    \n                    # RESET list of adjacent bloomed flowers cause we're on a day where the a flower has not bloomed yet\n                    currentListOfAdjacentBloomedFlowers = []\n            \n            # we've gone through the entire listOfFlowerBloomDays list and need to check if the ""residual"" current list \n            # of adjacent bloomed flowers can make a bouquet ... so handle it here\n            numberOfBouquetsWeCanMakeOnThisDay += len(currentListOfAdjacentBloomedFlowers)//flowersPerBouquet\n                    \n            return numberOfBouquetsWeCanMakeOnThisDay\n        \n        \n        # if the TOTAL amount of flowers we need doesn't match the number of possible flowers we can grow\n        # then the given inputs are impossible for making enough bouquets (we don't have enough flowers)\n        totalNumberOfFlowersNeeded = targetNumberOfBouquets*flowersPerBouquet\n        numberOfFlowersWeCanGrow = len(listOfFlowerBloomDays)\n        if numberOfFlowersWeCanGrow < totalNumberOfFlowersNeeded: \n            return -1\n        \n        # no need to go past the day of the flower with the longest bloom date\n        leftDay = 0\n        rightDay = max(listOfFlowerBloomDays)\n        \n        while leftDay < rightDay:\n            \n            # currentDay is functioning as the ""mid"" of a binary search\n            currentDay = leftDay + (rightDay-leftDay)//2\n            \n            # as in most binary searches we check if the mid (which I'm calling 'currentDay') satisfies the constraint\n            # that is if we can make the target amount of bouquets on this day\n            if numberOfBouquetsWeCanMakeOnThisDay(currentDay) < targetNumberOfBouquets:\n                \n                # womp womp we can't make enough bouquets on this day so set up for next iteration\n                # the ""correct day"" is on the right side so we get rid of all the ""incorrect days"" on the left side\n                # by updating the left to the currentDay+1\n                leftDay = currentDay+1\n            else:\n                \n                # yay we can make enough bouquets on this day but we don't know if this is the ""minimum day""\n                # we discard the right side to keep searching\n                rightDay = currentDay\n        \n        # leftDay >= rightDay so we've found the ""minimum day""\n        return leftDay\n		"
Minimum Number of Flips to Convert Binary Matrix to Zero Matrix,###  1284\. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix\n\nGiven a `m x n` binary matrix `mat`. In one step you can choose one cell and\nflip it and all the four neighbors of it if they exist (Flip is changing `1`\nto `0` and `0` to `1`). A pair of cells are called neighbors if they share one\nedge.\n\nReturn the _minimum number of steps_ required to convert `mat` to a zero\nmatrix or `-1` if you cannot.\n\nA **binary matrix** is a matrix with all cells equal to `0` or `1` only.\n\nA **zero matrix** is a matrix with all cells equal to `0`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/11/28/matrix.png)\n\n    \n    \n    **Input:** mat = [[00][01]]\n    **Output:** 3\n    **Explanation:** One possible solution is to flip (1 0) then (0 1) and finally (1 1) as shown.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mat = [[0]]\n    **Output:** 0\n    **Explanation:** Given matrix is a zero matrix. We do not need to change it.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** mat = [[100][100]]\n    **Output:** -1\n    **Explanation:** Given matrix cannot be a zero matrix.\n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat[i].length`\n  * `1 <= m n <= 3`\n  * `mat[i][j]` is either `0` or `1`.\n\n,class Solution:\n    flips = [11 23 38 89 186 308 200 464 416]\n    \n    def minFlips(self mat: List[List[int]]) -> int:\n        mask = self.make_mask(mat)\n        check = self.make_mask([[1 for c in r] for r in mat])\n        min_steps = -1\n        last = 0\n        for x in range(2**9):\n            x = x & check\n            flips = last ^ x\n            last = x\n            if not flips:\n                continue\n            for i in range(len(mat)):\n                for j in range(len(mat[0])):\n                    index = (i * 3 + j)\n                    if 1 << index & flips:\n                        mask ^= self.flips[index]\n            if check & ~mask == check:\n                steps = self.count_bits(x & check)\n                if min_steps < 0 or steps < min_steps:\n                    min_steps = steps\n        return min_steps\n    \n    def make_mask(self mat):\n        d = 0\n        for i in range(3):\n            for j in range(3):\n                if i < len(mat) and j < len(mat[0]):\n                    d |= mat[i][j] << (i * 3 + j)\n        return d\n\n    def count_bits(self x):\n        count = 0\n        i = 1\n        while i <= x:\n            count += int(bool(x & i))\n            i <<= 1\n        return count\n
Minimum Number of Flips to Make the Binary String Alternating,"###  1888\. Minimum Number of Flips to Make the Binary String Alternating\n\nYou are given a binary string `s`. You are allowed to perform two types of\noperations on the string in any sequence:\n\n  * **Type-1: Remove** the character at the start of the string `s` and **append** it to the end of the string.\n  * **Type-2: Pick** any character in `s` and **flip** its value i.e. if its value is `'0'` it becomes `'1'` and vice-versa.\n\nReturn _the**minimum** number of **type-2** operations you need to perform_\n_such that_`s` _becomes**alternating**._\n\nThe string is called **alternating** if no two adjacent characters are equal.\n\n  * For example the strings `""010""` and `""1010""` are alternating while the string `""0100""` is not.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""111000""\n    **Output:** 2\n    **Explanation** : Use the first operation two times to make s = ""100011"".\n    Then use the second operation on the third and sixth elements to make s = ""10 _1_ 01 _0_ "".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""010""\n    **Output:** 0\n    **Explanation** : The string is already alternating.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""1110""\n    **Output:** 1\n    **Explanation** : Use the second operation on the second element to make s = ""1 _0_ 10"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is either `'0'` or `'1'`.\n\n",# Runtime: 631 ms (Top 87.94%) | Memory: 14.8 MB (Top 94.52%)\nclass Solution:\n    def minFlips(self s: str) -> int:\n        prev = 0\n        start_1 start_0 start_1_odd start_0_odd = 00sys.maxsizesys.maxsize\n        odd = len(s)%2\n        for val in s:\n            val = int(val)\n            if val == prev:\n                if odd:\n                    start_0_odd = min(start_0_odd start_1)\n                    start_1_odd += 1\n                start_1 += 1\n            else:\n                if odd:\n                    start_1_odd = min(start_1_odd start_0)\n                    start_0_odd += 1\n                start_0 += 1\n            prev = 1 - prev\n        return min([start_1 start_0 start_1_odd start_0_odd])
Minimum Number of Increments on Subarrays to Form a Target Array,###  1526\. Minimum Number of Increments on Subarrays to Form a Target Array\n\nYou are given an integer array `target`. You have an integer array `initial`\nof the same size as `target` with all elements initially zeros.\n\nIn one operation you can choose **any** subarray from `initial` and increment\neach value by one.\n\nReturn _the minimum number of operations to form a_`target` _array\nfrom_`initial`.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = [12321]\n    **Output:** 3\n    **Explanation:** We need at least 3 operations to form the target array from the initial array.\n    [**_00000_**] increment 1 from index 0 to 4 (inclusive).\n    [1**_111_** 1] increment 1 from index 1 to 3 (inclusive).\n    [12**_2_** 21] increment 1 at index 2.\n    [12321] target array is formed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = [3112]\n    **Output:** 4\n    **Explanation:** [**_0000_**] -> [111**_1_**] -> [**_1_** 112] -> [**_2_** 112] -> [3112]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** target = [31542]\n    **Output:** 7\n    **Explanation:** [**_00000_**] -> [**_1_** 1111] -> [**_2_** 1111] -> [31**_111_**] -> [31**_22_** 2] -> [31**_33_** 2] -> [31**_4_** 42] -> [31542].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= target.length <= 105`\n  * `1 <= target[i] <= 105`\n\n,class Solution:\n    def minNumberOperations(self nums: List[int]) -> int:\n        res=nums[0]\n        prev=nums[0]\n        for i in range(1len(nums)):\n            res += max(0nums[i]-prev)\n            prev=nums[i]\n        return res\n
Minimum Number of K Consecutive Bit Flips,###  995\. Minimum Number of K Consecutive Bit Flips\n\nYou are given a binary array `nums` and an integer `k`.\n\nA **k-bit flip** is choosing a **subarray** of length `k` from `nums` and\nsimultaneously changing every `0` in the subarray to `1` and every `1` in the\nsubarray to `0`.\n\nReturn _the minimum number of**k-bit flips** required so that there is no _`0`\n_in the array_. If it is not possible return `-1`.\n\nA **subarray** is a **contiguous** part of an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [010] k = 1\n    **Output:** 2\n    **Explanation:** Flip nums[0] then flip nums[2].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [110] k = 2\n    **Output:** -1\n    **Explanation:** No matter how we flip subarrays of size 2 we cannot make the array become [111].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [00010110] k = 3\n    **Output:** 3\n    **Explanation:** \n    Flip nums[0]nums[1]nums[2]: nums becomes [11110110]\n    Flip nums[4]nums[5]nums[6]: nums becomes [11111000]\n    Flip nums[5]nums[6]nums[7]: nums becomes [11111111]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= k <= nums.length`\n\n,# Runtime: 2365 ms (Top 19.91%) | Memory: 17.1 MB (Top 67.10%)\nclass Solution:\n    def minKBitFlips(self nums: List[int] k: int) -> int:\n        flips = [0]*len(nums)\n        csum = 0\n\n        for left in range(0 len(nums)-k+1):\n            if (nums[left] + csum) % 2 == 0:\n                flips[left] += 1\n                csum += 1\n            if left >= k-1:\n                csum -= flips[left-k+1]\n\n        for check in range(len(nums)-k+1 len(nums)):\n            if (nums[check] + csum) % 2 == 0:\n                return -1\n            if check >= k-1:\n                csum -= flips[check-k+1]\n\n        return sum(flips)\n
Minimum Number of Moves to Make Palindrome,"###  2193\. Minimum Number of Moves to Make Palindrome\n\nYou are given a string `s` consisting only of lowercase English letters.\n\nIn one **move**  you can select any two **adjacent** characters of `s` and\nswap them.\n\nReturn _the**minimum number of moves** needed to make_ `s` _a palindrome_.\n\n**Note** that the input will be generated such that `s` can always be\nconverted to a palindrome.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aabb""\n    **Output:** 2\n    **Explanation:**\n    We can obtain two palindromes from s ""abba"" and ""baab"". \n    - We can obtain ""abba"" from s in 2 moves: ""a _**ab**_ b"" -> ""ab _**ab**_ "" -> ""abba"".\n    - We can obtain ""baab"" from s in 2 moves: ""a _**ab**_ b"" -> ""_**ab**_ ab"" -> ""baab"".\n    Thus the minimum number of moves needed to make s a palindrome is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""letelt""\n    **Output:** 2\n    **Explanation:**\n    One of the palindromes we can obtain from s in 2 moves is ""lettel"".\n    One of the ways we can obtain it is ""lete _**lt**_ "" -> ""let _**et**_ l"" -> ""lettel"".\n    Other palindromes such as ""tleelt"" can also be obtained in 2 moves.\n    It can be shown that it is not possible to obtain a palindrome in less than 2 moves.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 2000`\n  * `s` consists only of lowercase English letters.\n  * `s` can be converted to a palindrome using a finite number of moves.\n\n","class Solution(object):\n    def minMovesToMakePalindrome(self s):\n        """"""\n        :type s: str\n        :rtype: int\n        """"""\n        count length_of_s = 0 len(s)\n        if length_of_s <= 2:\n            return count\n        for i in reversed(range(length_of_s)):\n            if s[i] != s[0]:\n                continue\n            if i == 0:\n				# move to middle is a speical case which takes len(s)/2 moves then do recursive for remaining part\n                count += len(s)/2 + self.minMovesToMakePalindrome(s[1:])  \n            else:\n			    # this move takes len(s)-1 - i (move from i to last index len(s)-1)and then do recursive for remaining part\n                count += len(s)-1-i + self.minMovesToMakePalindrome(s[1:i]+s[i+1:])\n            break\n        return count\n"
Minimum Number of Moves to Seat Everyone,###  2037\. Minimum Number of Moves to Seat Everyone\n\nThere are `n` seats and `n` students in a room. You are given an array `seats`\nof length `n` where `seats[i]` is the position of the `ith` seat. You are\nalso given the array `students` of length `n` where `students[j]` is the\nposition of the `jth` student.\n\nYou may perform the following move any number of times:\n\n  * Increase or decrease the position of the `ith` student by `1` (i.e. moving the `ith` student from position `x` to `x + 1` or `x - 1`)\n\nReturn _the**minimum number of moves** required to move each student to a\nseat_ _such that no two students are in the same seat._\n\nNote that there may be **multiple** seats or students in the **same** position\nat the beginning.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** seats = [315] students = [274]\n    **Output:** 4\n    **Explanation:** The students are moved as follows:\n    - The first student is moved from from position 2 to position 1 using 1 move.\n    - The second student is moved from from position 7 to position 5 using 2 moves.\n    - The third student is moved from from position 4 to position 3 using 1 move.\n    In total 1 + 2 + 1 = 4 moves were used.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** seats = [4159] students = [1326]\n    **Output:** 7\n    **Explanation:** The students are moved as follows:\n    - The first student is not moved.\n    - The second student is moved from from position 3 to position 4 using 1 move.\n    - The third student is moved from from position 2 to position 5 using 3 moves.\n    - The fourth student is moved from from position 6 to position 9 using 3 moves.\n    In total 0 + 1 + 3 + 3 = 7 moves were used.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** seats = [2266] students = [1326]\n    **Output:** 4\n    **Explanation:** Note that there are two seats at position 2 and two seats at position 6.\n    The students are moved as follows:\n    - The first student is moved from from position 1 to position 2 using 1 move.\n    - The second student is moved from from position 3 to position 6 using 3 moves.\n    - The third student is not moved.\n    - The fourth student is not moved.\n    In total 1 + 3 + 0 + 0 = 4 moves were used.\n    \n\n\n\n**Constraints:**\n\n  * `n == seats.length == students.length`\n  * `1 <= n <= 100`\n  * `1 <= seats[i] students[j] <= 100`\n\n,class Solution:\n    def minMovesToSeat(self seats: List[int] students: List[int]) -> int:\n        seats.sort()\n        students.sort()\n        return sum(abs(seat - student) for seat student in zip(seats students))\n
Minimum Number of Operations to Convert Time,"###  2224\. Minimum Number of Operations to Convert Time\n\nYou are given two strings `current` and `correct` representing two **24-hour\ntimes**.\n\n24-hour times are formatted as `""HH:MM""` where `HH` is between `00` and `23`\nand `MM` is between `00` and `59`. The earliest 24-hour time is `00:00` and\nthe latest is `23:59`.\n\nIn one operation you can increase the time `current` by `1` `5` `15` or\n`60` minutes. You can perform this operation **any** number of times.\n\nReturn _the**minimum number of operations** needed to convert _`current`\n_to_`correct`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** current = ""02:30"" correct = ""04:35""\n    **Output:** 3\n    **Explanation:** We can convert current to correct in 3 operations as follows:\n    - Add 60 minutes to current. current becomes ""03:30"".\n    - Add 60 minutes to current. current becomes ""04:30"".\n    - Add 5 minutes to current. current becomes ""04:35"".\n    It can be proven that it is not possible to convert current to correct in fewer than 3 operations.\n\n**Example 2:**\n\n    \n    \n    **Input:** current = ""11:00"" correct = ""11:01""\n    **Output:** 1\n    **Explanation:** We only have to add one minute to current so the minimum number of operations needed is 1.\n    \n\n\n\n**Constraints:**\n\n  * `current` and `correct` are in the format `""HH:MM""`\n  * `current <= correct`\n\n",// Runtime: 34 ms (Top 83.44%) | Memory: 17.40 MB (Top 22.74%)\n\nclass Solution:\n    def convertTime(self current: str correct: str) -> int:\n        def get_time(t):\n            hh mm = t.split(':')\n            return int(hh) * 60 + int(mm)\n        \n        current correct = get_time(current) get_time(correct)\n        operations = 0\n        diff = correct - current\n        \n        for mins in [60 15 5 1]:\n            quotient remainder = divmod(diff mins)\n            operations += quotient\n            diff = remainder\n                \n        return operations\n
Minimum Number of Operations to Move All Balls to Each Box,"###  1769\. Minimum Number of Operations to Move All Balls to Each Box\n\nYou have `n` boxes. You are given a binary string `boxes` of length `n` where\n`boxes[i]` is `'0'` if the `ith` box is **empty**  and `'1'` if it contains\n**one** ball.\n\nIn one operation you can move **one** ball from a box to an adjacent box. Box\n`i` is adjacent to box `j` if `abs(i - j) == 1`. Note that after doing so\nthere may be more than one ball in some boxes.\n\nReturn an array `answer` of size `n` where `answer[i]` is the **minimum**\nnumber of operations needed to move all the balls to the `ith` box.\n\nEach `answer[i]` is calculated considering the **initial** state of the boxes.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** boxes = ""110""\n    **Output:** [113]\n    **Explanation:** The answer for each box is as follows:\n    1) First box: you will have to move one ball from the second box to the first box in one operation.\n    2) Second box: you will have to move one ball from the first box to the second box in one operation.\n    3) Third box: you will have to move one ball from the first box to the third box in two operations and move one ball from the second box to the third box in one operation.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** boxes = ""001011""\n    **Output:** [1185434]\n\n\n\n**Constraints:**\n\n  * `n == boxes.length`\n  * `1 <= n <= 2000`\n  * `boxes[i]` is either `'0'` or `'1'`.\n\n",# Runtime: 68 ms (Top 97.39%) | Memory: 14.2 MB (Top 53.70%)\nclass Solution:\n    def minOperations(self boxes: str) -> List[int]:\n        ans = [0]*len(boxes)\n        leftCount leftCost rightCount rightCost n = 0 0 0 0 len(boxes)\n        for i in range(1 n):\n            if boxes[i-1] == '1': leftCount += 1\n            leftCost += leftCount # each step move to right the cost increases by # of 1s on the left\n            ans[i] = leftCost\n        for i in range(n-2 -1 -1):\n            if boxes[i+1] == '1': rightCount += 1\n            rightCost += rightCount\n            ans[i] += rightCost\n        return ans
Minimum Number of Operations to Reinitialize a Permutation,###  1806\. Minimum Number of Operations to Reinitialize a Permutation\n\nYou are given an **even** integer `n`​​​​​​. You initially have a\npermutation `perm` of size `n`​​ where `perm[i] == i`​ **(0-indexed)**\n​​​​.\n\nIn one operation you will create a new array `arr` and for each `i`:\n\n  * If `i % 2 == 0` then `arr[i] = perm[i / 2]`.\n  * If `i % 2 == 1` then `arr[i] = perm[n / 2 + (i - 1) / 2]`.\n\nYou will then assign `arr`​​​​ to `perm`.\n\nReturn _the minimum**non-zero** number of operations you need to perform on\n_`perm` _to return the permutation to its initial value._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 1\n    **Explanation:** perm = [01] initially.\n    After the 1st operation perm = [01]\n    So it takes only 1 operation.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** 2\n    **Explanation:** perm = [0123] initially.\n    After the 1st operation perm = [0213]\n    After the 2nd operation perm = [0123]\n    So it takes only 2 operations.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 6\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 1000`\n  * `n`​​​​​​ is even.\n\n,// Runtime: 341 ms (Top 53.7%) | Memory: 16.20 MB (Top 72.22%)\n\nclass Solution:\n    def reinitializePermutation(self n: int) -> int:\n        ans = 0\n        perm = list(range(n))\n        while True: \n            ans += 1\n            perm = [perm[n//2+(i-1)//2] if i&1 else perm[i//2] for i in range(n)]\n            if all(perm[i] == i for i in range(n)): return ans\n
Minimum Number of People to Teach,###  1733\. Minimum Number of People to Teach\n\nOn a social network consisting of `m` users and some friendships between\nusers two users can communicate with each other if they know a common\nlanguage.\n\nYou are given an integer `n` an array `languages` and an array `friendships`\nwhere:\n\n  * There are `n` languages numbered `1` through `n`\n  * `languages[i]` is the set of languages the `i​​​​​​th`​​​​ user knows and\n  * `friendships[i] = [u​​​​​​i​​​ v​​​​​​i]` denotes a friendship between the users `u​​​​​​​​​​​i`​​​​​ and `vi`.\n\nYou can choose **one** language and teach it to some users so that all friends\ncan communicate with each other. Return _the_ _**minimum** __number of users\nyou need to teach._\n\nNote that friendships are not transitive meaning if `x` is a friend of `y`\nand `y` is a friend of `z` this doesn't guarantee that `x` is a friend of\n`z`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2 languages = [[1][2][12]] friendships = [[12][13][23]]\n    **Output:** 1\n    **Explanation:** You can either teach user 1 the second language or user 2 the first language.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3 languages = [[2][13][12][3]] friendships = [[14][12][34][23]]\n    **Output:** 2\n    **Explanation:** Teach the third language to users 1 and 3 yielding two users to teach.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 500`\n  * `languages.length == m`\n  * `1 <= m <= 500`\n  * `1 <= languages[i].length <= n`\n  * `1 <= languages[i][j] <= n`\n  * `1 <= u​​​​​​i < v​​​​​​i <= languages.length`\n  * `1 <= friendships.length <= 500`\n  * All tuples `(u​​​​​i v​​​​​​i)` are unique\n  * `languages[i]` contains only unique values\n\n,"# Runtime: 2444 ms (Top 20.45%) | Memory: 28.6 MB (Top 5.68%)\nclass Solution:\n    def minimumTeachings(self n: int languages: List[List[int]] friendships: List[List[int]]) -> int:\n        """"""\n        1. Find out users who need to be taught\n        2. If no user needs to be taught return 0\n        3. For all users who need to be taught a language find the most popular language among them\n        4. Teach that language to rest of the users who need to be taught.\n        """"""\n        need_to_be_taught = set()\n        languages = [set(language) for language in languages]\n\n        # 1. Find out users who needs to be taught\n        for user1 user2 in friendships:\n            # Adjust the 1 based indexing to 0 based indexing\n            user1 = user1 - 1\n            user2 = user2 - 1\n            if not (languages[user1] & languages[user2]):\n                need_to_be_taught.update([user1 user2])\n\n        # 2. If no user needs to be taught return 0\n        if not need_to_be_taught:\n            return 0\n\n        # 3. For all users who needs to be taught a language find the most popular language among them\n        language_spoken_by = collections.defaultdict(int)\n        for user in need_to_be_taught:\n            # for each user increment the count of languages he can speak\n            for language in languages[user]:\n                language_spoken_by[language] += 1\n\n        # find occurrence of language spoken by maximum users who can't communicate with each other\n        popular_language_count = max(language_spoken_by.values())\n\n        # 4. Teach that language to rest of the users who need to be taught.\n        return len(need_to_be_taught)- popular_language_count\n"
Minimum Number of Refueling Stops,###  871\. Minimum Number of Refueling Stops\n\nA car travels from a starting position to a destination which is `target`\nmiles east of the starting position.\n\nThere are gas stations along the way. The gas stations are represented as an\narray `stations` where `stations[i] = [positioni fueli]` indicates that the\n`ith` gas station is `positioni` miles east of the starting position and has\n`fueli` liters of gas.\n\nThe car starts with an infinite tank of gas which initially has `startFuel`\nliters of fuel in it. It uses one liter of gas per one mile that it drives.\nWhen the car reaches a gas station it may stop and refuel transferring all\nthe gas from the station into the car.\n\nReturn _the minimum number of refueling stops the car must make in order to\nreach its destination_. If it cannot reach the destination return `-1`.\n\nNote that if the car reaches a gas station with `0` fuel left the car can\nstill refuel there. If the car reaches the destination with `0` fuel left it\nis still considered to have arrived.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = 1 startFuel = 1 stations = []\n    **Output:** 0\n    **Explanation:** We can reach the target without refueling.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = 100 startFuel = 1 stations = [[10100]]\n    **Output:** -1\n    **Explanation:** We can not reach the target (or even the first gas station).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** target = 100 startFuel = 10 stations = [[1060][2030][3030][6040]]\n    **Output:** 2\n    **Explanation:** We start with 10 liters of fuel.\n    We drive to position 10 expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\n    Then we drive from position 10 to position 60 (expending 50 liters of fuel)\n    and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\n    We made 2 refueling stops along the way so we return 2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= target startFuel <= 109`\n  * `0 <= stations.length <= 500`\n  * `0 <= positioni <= positioni+1 < target`\n  * `1 <= fueli < 109`\n\n,class Solution:\n    def minRefuelStops(self t F S):\n        S.append([t 0])\n        heap ans = [] 0\n        for pf in S:\n            while heap and p > F:\n                F -= heapq.heappop(heap)\n                ans += 1\n            if p > F: return -1\n            heapq.heappush(heap -f)\n        return ans\n
Minimum Number of Removals to Make Mountain Array,###  1671\. Minimum Number of Removals to Make Mountain Array\n\nYou may recall that an array `arr` is a **mountain array** if and only if:\n\n  * `arr.length >= 3`\n  * There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that: \n    * `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    * `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `nums`​​​ return _the**minimum** number of\nelements to remove to make _`nums _​​​_` ___a**mountain array**._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [131]\n    **Output:** 0\n    **Explanation:** The array itself is a mountain array so we do not need to remove any elements.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [21156231]\n    **Output:** 3\n    **Explanation:** One solution is to remove the elements at indices 0 1 and 5 making the array nums = [15631].\n    \n\n\n\n**Constraints:**\n\n  * `3 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 109`\n  * It is guaranteed that you can make a mountain array out of `nums`.\n\n,class Solution:\n    def minimumMountainRemovals(self nums: List[int]) -> int:\n        n = len(nums)\n        inc = [0] * n\n        dec = [0] * n\n        \n#  Longest Increasing Subsequence\n        for i in range(1n):\n            for j in range(0i):\n                if nums[i] > nums[j]:\n                    inc[i] = max(inc[i] inc[j] + 1)\n                \n#  Longest Decreasing Subsequence\n        for i in range(n-2-1-1):\n            for j in range(n-1i-1):\n                if nums[i] > nums[j]:\n                    dec[i] = max(dec[i] dec[j] + 1)\n        \n# Final calculation\n        res = 0\n        for i in range(0n):\n            if inc[i] > 0 and dec[i] > 0:\n                res = max(res inc[i] + dec[i])\n                \n# Final conclusion        \n        return n - res - 1\n
Minimum Number of Steps to Make Two Strings Anagram,"###  1347\. Minimum Number of Steps to Make Two Strings Anagram\n\nYou are given two strings of the same length `s` and `t`. In one step you can\nchoose **any character** of `t` and replace it with **another character**.\n\nReturn _the minimum number of steps_ to make `t` an anagram of `s`.\n\nAn **Anagram** of a string is a string that contains the same characters with\na different (or the same) ordering.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""bab"" t = ""aba""\n    **Output:** 1\n    **Explanation:** Replace the first 'a' in t with b t = ""bba"" which is anagram of s.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""leetcode"" t = ""practice""\n    **Output:** 5\n    **Explanation:** Replace 'p' 'r' 'a' 'i' and 'c' from t with proper characters to make t anagram of s.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""anagram"" t = ""mangaar""\n    **Output:** 0\n    **Explanation:** ""anagram"" and ""mangaar"" are anagrams. \n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 5 * 104`\n  * `s.length == t.length`\n  * `s` and `t` consist of lowercase English letters only.\n\n","class Solution:\n    def minSteps(self s: str t: str) -> int:\n        for ch in s:\n		    # Find and replace only one occurence of this character in t\n            t = t.replace(ch '' 1)\n            \n        return len(t)"
Minimum Number of Steps to Make Two Strings Anagram II,"###  2186\. Minimum Number of Steps to Make Two Strings Anagram II\n\nYou are given two strings `s` and `t`. In one step you can append **any\ncharacter** to either `s` or `t`.\n\nReturn _the minimum number of steps to make_`s` _and_`t` _**anagrams** of each\nother._\n\nAn **anagram** of a string is a string that contains the same characters with\na different (or the same) ordering.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""**_lee_** tco _**de**_ "" t = ""co _**a**_ t _**s**_ ""\n    **Output:** 7\n    **Explanation:** \n    - In 2 steps we can append the letters in ""as"" onto s = ""leetcode"" forming s = ""leetcode** _as_** "".\n    - In 5 steps we can append the letters in ""leede"" onto t = ""coats"" forming t = ""coats _**leede**_ "".\n    ""leetcodeas"" and ""coatsleede"" are now anagrams of each other.\n    We used a total of 2 + 5 = 7 steps.\n    It can be shown that there is no way to make them anagrams of each other with less than 7 steps.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""night"" t = ""thing""\n    **Output:** 0\n    **Explanation:** The given strings are already anagrams of each other. Thus we do not need any further steps.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length t.length <= 2 * 105`\n  * `s` and `t` consist of lowercase English letters.\n\n",class Solution:\n    def minSteps(self s: str t: str) -> int:\n        sMap = dict()\n        tMap = dict()\n        \n        for character in s:\n            sMap[character] = sMap.get(character 0) + 1\n        \n        for character in t:\n            tMap[character] = tMap.get(character 0) + 1\n            \n        count = 0\n        \n        for key value in sMap.items():\n            if value >= tMap.get(key 0):\n                count += (value - tMap.get(key 0))\n        \n        for key value in tMap.items():\n            if value >= sMap.get(key 0):\n                count += (value - sMap.get(key 0))\n        \n        return count\n
Minimum Number of Swaps to Make the Binary String Alternating,"###  1864\. Minimum Number of Swaps to Make the Binary String Alternating\n\nGiven a binary string `s` return _the**minimum** number of character swaps to\nmake it **alternating**  or _`-1` _if it is impossible._\n\nThe string is called **alternating** if no two adjacent characters are equal.\nFor example the strings `""010""` and `""1010""` are alternating while the\nstring `""0100""` is not.\n\nAny two characters may be swapped even if they are **not adjacent**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""111000""\n    **Output:** 1\n    **Explanation:** Swap positions 1 and 4: ""1 _1_ 10 _0_ 0"" -> ""1 _0_ 10 _1_ 0""\n    The string is now alternating.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""010""\n    **Output:** 0\n    **Explanation:** The string is already alternating no swaps are needed.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""1110""\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s[i]` is either `'0'` or `'1'`.\n\n",class Solution:\ndef minSwaps(self st: str) -> int:\n    \n    def swap(stc):\n        n = len(st)\n        mis = 0\n        for i in range(n):\n            if i%2==0 and st[i]!=c:\n                mis+=1\n            if i%2==1 and st[i]==c:\n                mis+=1\n        return mis//2\n            \n    dic = Counter(st)\n    z = dic['0']\n    o = dic['1']\n    res=0\n    if abs(z-o)>1:\n        return -1\n    elif z>o:\n        res = swap(st'0')\n    elif o>z:\n        res = swap(st'1')\n    else:\n        res = min(swap(st'0')swap(st'1'))\n    \n    return res\n
Minimum Number of Swaps to Make the String Balanced,"###  1963\. Minimum Number of Swaps to Make the String Balanced\n\nYou are given a **0-indexed** string `s` of **even** length `n`. The string\nconsists of **exactly** `n / 2` opening brackets `'['` and `n / 2` closing\nbrackets `']'`.\n\nA string is called **balanced** if and only if:\n\n  * It is the empty string or\n  * It can be written as `AB` where both `A` and `B` are **balanced** strings or\n  * It can be written as `[C]` where `C` is a **balanced** string.\n\nYou may swap the brackets at **any** two indices **any** number of times.\n\nReturn _the**minimum** number of swaps to make _`s` _**balanced**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""][][""\n    **Output:** 1\n    **Explanation:** You can make the string balanced by swapping index 0 with index 3.\n    The resulting string is ""[[]]"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""]]][[[""\n    **Output:** 2\n    **Explanation:** You can do the following to make the string balanced:\n    - Swap index 0 with index 4. s = ""[]][]["".\n    - Swap index 1 with index 5. s = ""[[][]]"".\n    The resulting string is ""[[][]]"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""[]""\n    **Output:** 0\n    **Explanation:** The string is already balanced.\n    \n\n\n\n**Constraints:**\n\n  * `n == s.length`\n  * `2 <= n <= 106`\n  * `n` is even.\n  * `s[i]` is either `'[' `or `']'`.\n  * The number of opening brackets `'['` equals `n / 2` and the number of closing brackets `']'` equals `n / 2`.\n\n",class Solution:\n    def minSwaps(self s: str) -> int:\n        res bal = 0 0\n        for ch in s:\n            bal += 1 if ch == '[' else -1\n            if bal == -1:\n                res += 1\n                bal = 1\n        return res\n
Minimum Number of Taps to Open to Water a Garden,###  1326\. Minimum Number of Taps to Open to Water a Garden\n\nThere is a one-dimensional garden on the x-axis. The garden starts at the\npoint `0` and ends at the point `n`. (i.e The length of the garden is `n`).\n\nThere are `n + 1` taps located at points `[0 1 ... n]` in the garden.\n\nGiven an integer `n` and an integer array `ranges` of length `n + 1` where\n`ranges[i]` (0-indexed) means the `i-th` tap can water the area `[i -\nranges[i] i + ranges[i]]` if it was open.\n\nReturn _the minimum number of taps_ that should be open to water the whole\ngarden If the garden cannot be watered return **-1**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/01/16/1685_example_1.png)\n\n    \n    \n    **Input:** n = 5 ranges = [341100]\n    **Output:** 1\n    **Explanation:** The tap at point 0 can cover the interval [-33]\n    The tap at point 1 can cover the interval [-35]\n    The tap at point 2 can cover the interval [13]\n    The tap at point 3 can cover the interval [24]\n    The tap at point 4 can cover the interval [44]\n    The tap at point 5 can cover the interval [55]\n    Opening Only the second tap will water the whole garden [05]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3 ranges = [0000]\n    **Output:** -1\n    **Explanation:** Even if you activate all the four taps you cannot water the whole garden.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n  * `ranges.length == n + 1`\n  * `0 <= ranges[i] <= 100`\n\n,"// Runtime: 110 ms (Top 96.18%) | Memory: 17.60 MB (Top 51.23%)\n\nclass Solution:\n    def minTaps(self n: int ranges: List[int]) -> int:\n        max_range = [0] * (n + 1)\n        \n        for i r in enumerate(ranges):\n            left right = max(0 i - r) min(n i + r)\n            max_range[left] = max(max_range[left] right - left)\n        \n		# it's a jump game now\n        start = end = step = 0\n        \n        while end < n:\n            step += 1\n            start end = end max(i + max_range[i] for i in range(start end + 1))\n            if start == end:\n                return -1\n            \n        return step\n"
Minimum Number of Vertices to Reach All Nodes,###  1557\. Minimum Number of Vertices to Reach All Nodes\n\nGiven a**  directed acyclic graph** with `n` vertices numbered from `0` to\n`n-1` and an array `edges` where `edges[i] = [fromi toi]` represents a\ndirected edge from node `fromi` to node `toi`.\n\nFind _the smallest set of vertices from which all nodes in the graph are\nreachable_. It's guaranteed that a unique solution exists.\n\nNotice that you can return the vertices in any order.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/07/07/untitled22.png)\n\n    \n    \n    **Input:** n = 6 edges = [[01][02][25][34][42]]\n    **Output:** [03]\n    **Explanation:** It's not possible to reach all the nodes from a single vertex. From 0 we can reach [0125]. From 3 we can reach [3425]. So we output [03].\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/07/07/untitled.png)\n\n    \n    \n    **Input:** n = 5 edges = [[01][21][31][14][24]]\n    **Output:** [023]\n    **Explanation:** Notice that vertices 0 3 and 2 are not reachable from any other node so we must include them. Also any of these vertices can reach nodes 1 and 4.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 10^5`\n  * `1 <= edges.length <= min(10^5 n * (n - 1) / 2)`\n  * `edges[i].length == 2`\n  * `0 <= fromi toi < n`\n  * All pairs `(fromi toi)` are distinct.\n\n,"class Solution:\n	def findSmallestSetOfVertices(self n: int edges: List[List[int]]) -> List[int]:\n\n		parent=[[] for i in range(n)]\n		for i in edges:\n			parent[i[1]].append(i[0])\n		ans=[]\n		for i in range(n):\n			if len(parent[i])==0:\n				ans.append(i)\n		return ans\n"
Minimum Numbers of Function Calls to Make Target Array,###  1558\. Minimum Numbers of Function Calls to Make Target Array\n\nYou are given an integer array `nums`. You have an integer array `arr` of the\nsame length with all values set to `0` initially. You also have the following\n`modify` function:\n\n![](https://assets.leetcode.com/uploads/2020/07/10/sample_2_1887.png)\n\nYou want to use the modify function to covert `arr` to `nums` using the\nminimum number of calls.\n\nReturn _the minimum number of function calls to make_`nums` _from_`arr`.\n\nThe test cases are generated so that the answer fits in a **32-bit** signed\ninteger.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [15]\n    **Output:** 5\n    **Explanation:** Increment by 1 (second element): [0 0] to get [0 1] (1 operation).\n    Double all the elements: [0 1] -> [0 2] -> [0 4] (2 operations).\n    Increment by 1 (both elements)  [0 4] -> [1 4] -> **[1 5]** (2 operations).\n    Total of operations: 1 + 2 + 2 = 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [22]\n    **Output:** 3\n    **Explanation:** Increment by 1 (both elements) [0 0] -> [0 1] -> [1 1] (2 operations).\n    Double all the elements: [1 1] -> **[2 2]** (1 operation).\n    Total of operations: 2 + 1 = 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [425]\n    **Output:** 6\n    **Explanation:** (initial)[000] -> [100] -> [101] -> [202] -> [212] -> [424] -> **[425]**(nums).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 109`\n\n,# Observe that:\n#   +1  places a 1 to the end of the int's binary representation\n#       (assuming a 0 there previously)\n#   x2  is a bitshift left\n# So you basically just need to count all the ones in the binary representations\n# and find how many shifts are required (largest bit length minus one).\n\nclass Solution:\n    def minOperations(self nums: List[int]) -> int:\n        if max(nums) == 0:\n            return 0\n        \n        return sum([x.bit_count() for x in nums]) + max([x.bit_length() for x in nums]) - 1\n\n
Minimum Obstacle Removal to Reach Corner,###  2290\. Minimum Obstacle Removal to Reach Corner\n\nYou are given a **0-indexed** 2D integer array `grid` of size `m x n`. Each\ncell has one of two values:\n\n  * `0` represents an **empty** cell\n  * `1` represents an **obstacle** that may be removed.\n\nYou can move up down left or right from and to an empty cell.\n\nReturn _the**minimum** number of **obstacles** to **remove** so you can move\nfrom the upper left corner _`(0 0)`_to the lower right corner_`(m - 1 n -\n1)`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png)\n\n    \n    \n    **Input:** grid = [[011][110][110]]\n    **Output:** 2\n    **Explanation:** We can remove the obstacles at (0 1) and (0 2) to create a path from (0 0) to (2 2).\n    It can be shown that we need to remove at least 2 obstacles so we return 2.\n    Note that there may be other ways to remove 2 obstacles to create a path.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png)\n\n    \n    \n    **Input:** grid = [[01000][01010][00010]]\n    **Output:** 0\n    **Explanation:** We can move from (0 0) to (2 4) without removing any obstacles so we return 0.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 105`\n  * `2 <= m * n <= 105`\n  * `grid[i][j]` is either `0` **or** `1`.\n  * `grid[0][0] == grid[m - 1][n - 1] == 0`\n\n,// Runtime: 4890 ms (Top 15.42%) | Memory: 42.20 MB (Top 64.95%)\n\nclass Solution:\n    def minimumObstacles(self grid: List[List[int]]) -> int:\n        m n = len(grid) len(grid[0])\n        q = [(0 0 0)]\n        dist = [[float('inf') for _ in range(n)] for _ in range(m)]\n\n        while q:\n            size = len(q)\n            for _ in range(size):\n                obs x y = heapq.heappop(q)\n                if dist[x][y] < float('inf'): continue\n                obs += grid[x][y]\n                dist[x][y] = obs\n                if x + 1 < m: heapq.heappush(q (obs x + 1 y))\n                if x > 0: heapq.heappush(q (obs x - 1 y))\n                if y + 1 < n: heapq.heappush(q (obs x y + 1))\n                if y > 0: heapq.heappush(q (obs x y - 1))\n        return dist[m - 1][n - 1]\n
Minimum One Bit Operations to Make Integers Zero,"###  1611\. Minimum One Bit Operations to Make Integers Zero\n\nGiven an integer `n` you must transform it into `0` using the following\noperations any number of times:\n\n  * Change the rightmost (`0th`) bit in the binary representation of `n`.\n  * Change the `ith` bit in the binary representation of `n` if the `(i-1)th` bit is set to `1` and the `(i-2)th` through `0th` bits are set to `0`.\n\nReturn _the minimum number of operations to transform_`n` _into_`0` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** 2\n    **Explanation:** The binary representation of 3 is ""11"".\n    ""_1_ 1"" -> ""_0_ 1"" with the 2nd operation since the 0th bit is 1.\n    ""0 _1_ "" -> ""0 _0_ "" with the 1st operation.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 6\n    **Output:** 4\n    **Explanation:** The binary representation of 6 is ""110"".\n    ""_1_ 10"" -> ""_0_ 10"" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.\n    ""01 _0_ "" -> ""01 _1_ "" with the 1st operation.\n    ""0 _1_ 1"" -> ""0 _0_ 1"" with the 2nd operation since the 0th bit is 1.\n    ""00 _1_ "" -> ""00 _0_ "" with the 1st operation.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 109`\n\n",class Solution:\n    def minimumOneBitOperations(self n: int) -> int:\n        if n <= 1:\n            return n\n        def leftmostbit(x):\n            x |= x >> 1\n            x |= x >> 2\n            x |= x >> 4\n            x |= x >> 8\n            x |= x >> 16\n            x += 1\n            x >>= 1\n            return x\n        x = leftmostbit(n)\n        return ((x << 1) - 1) - self.minimumOneBitOperations(n - x)\n
Minimum Operations to Convert Number,###  2059\. Minimum Operations to Convert Number\n\nYou are given a **0-indexed** integer array `nums` containing **distinct**\nnumbers an integer `start` and an integer `goal`. There is an integer `x`\nthat is initially set to `start` and you want to perform operations on `x`\nsuch that it is converted to `goal`. You can perform the following operation\nrepeatedly on the number `x`:\n\nIf `0 <= x <= 1000` then for any index `i` in the array (`0 <= i <\nnums.length`) you can set `x` to any of the following:\n\n  * `x + nums[i]`\n  * `x - nums[i]`\n  * `x ^ nums[i]` (bitwise-XOR)\n\nNote that you can use each `nums[i]` any number of times in any order.\nOperations that set `x` to be out of the range `0 <= x <= 1000` are valid but\nno more operations can be done afterward.\n\nReturn _the**minimum** number of operations needed to convert _`x = start`\n_into_`goal` _ and_`-1` _if it is not possible_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [2412] start = 2 goal = 12\n    **Output:** 2\n    **Explanation:** We can go from 2 → 14 → 12 with the following 2 operations.\n    - 2 + 12 = 14\n    - 14 - 2 = 12\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [357] start = 0 goal = -4\n    **Output:** 2\n    **Explanation:** We can go from 0 → 3 → -4 with the following 2 operations. \n    - 0 + 3 = 3\n    - 3 - 7 = -4\n    Note that the last operation sets x out of the range 0 <= x <= 1000 which is valid.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [2816] start = 0 goal = 1\n    **Output:** -1\n    **Explanation:** There is no way to convert 0 into 1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `-109 <= nums[i] goal <= 109`\n  * `0 <= start <= 1000`\n  * `start != goal`\n  * All the integers in `nums` are distinct.\n\n,# Runtime: 4131 ms (Top 24.3%) | Memory: 185.60 MB (Top 35.5%)\n\nclass Solution:\n    def minimumOperations(self nums: List[int] start: int goal: int) -> int:\n        ans = 0\n        seen = {start}\n        queue = deque([start])\n        while queue: \n            for _ in range(len(queue)): \n                val = queue.popleft()\n                if val == goal: return ans \n                if 0 <= val <= 1000: \n                    for x in nums: \n                        for op in (add sub xor): \n                            if op(val x) not in seen: \n                                seen.add(op(val x))\n                                queue.append(op(val x))\n            ans += 1\n        return -1 
Minimum Operations to Halve Array Sum,###  2208\. Minimum Operations to Halve Array Sum\n\nYou are given an array `nums` of positive integers. In one operation you can\nchoose **any** number from `nums` and reduce it to **exactly** half the\nnumber. (Note that you may choose this reduced number in future operations.)\n\nReturn _the**minimum** number of operations to reduce the sum of _`nums`\n_by**at least** half._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [51981]\n    **Output:** 3\n    **Explanation:** The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.\n    The following is one of the ways to reduce the sum by at least half:\n    Pick the number 19 and reduce it to 9.5.\n    Pick the number 9.5 and reduce it to 4.75.\n    Pick the number 8 and reduce it to 4.\n    The final array is [5 4.75 4 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. \n    The sum of nums has been reduced by 33 - 14.75 = 18.25 which is at least half of the initial sum 18.25 >= 33/2 = 16.5.\n    Overall 3 operations were used so we return 3.\n    It can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [3820]\n    **Output:** 3\n    **Explanation:** The initial sum of nums is equal to 3 + 8 + 20 = 31.\n    The following is one of the ways to reduce the sum by at least half:\n    Pick the number 20 and reduce it to 10.\n    Pick the number 10 and reduce it to 5.\n    Pick the number 3 and reduce it to 1.5.\n    The final array is [1.5 8 5] with a total sum of 1.5 + 8 + 5 = 14.5. \n    The sum of nums has been reduced by 31 - 14.5 = 16.5 which is at least half of the initial sum 16.5 >= 31/2 = 16.5.\n    Overall 3 operations were used so we return 3.\n    It can be shown that we cannot reduce the sum by at least half in less than 3 operations.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 107`\n\n,class Solution:\n    def halveArray(self nums: List[int]) -> int:\n        # Creating empty heap\n        maxHeap = []\n        heapify(maxHeap) # Creates minHeap \n        \n        totalSum = 0\n        for i in nums:\n            # Adding items to the heap using heappush\n            # for maxHeap function by multiplying them with -1\n            heappush(maxHeap -1*i) \n            totalSum += i\n        \n        requiredSum = totalSum / 2\n        minOps = 0\n        \n        while totalSum > requiredSum:\n            x = -1*heappop(maxHeap) # Got negative value make it positive\n            x /= 2\n            totalSum -= x\n            heappush(maxHeap -1*x) \n            minOps += 1\n        \n        return minOps\n
Minimum Operations to Make a Uni-Value Grid,###  2033\. Minimum Operations to Make a Uni-Value Grid\n\nYou are given a 2D integer `grid` of size `m x n` and an integer `x`. In one\noperation you can **add** `x` to or **subtract** `x` from any element in the\n`grid`.\n\nA **uni-value grid** is a grid where all the elements of it are equal.\n\nReturn _the**minimum** number of operations to make the grid **uni-value**_.\nIf it is not possible return `-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/09/21/gridtxt.png)\n\n    \n    \n    **Input:** grid = [[24][68]] x = 2\n    **Output:** 4\n    **Explanation:** We can make every element equal to 4 by doing the following: \n    - Add x to 2 once.\n    - Subtract x from 6 once.\n    - Subtract x from 8 twice.\n    A total of 4 operations were used.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/09/21/gridtxt-1.png)\n\n    \n    \n    **Input:** grid = [[15][23]] x = 1\n    **Output:** 5\n    **Explanation:** We can make every element equal to 3.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/09/21/gridtxt-2.png)\n\n    \n    \n    **Input:** grid = [[12][34]] x = 2\n    **Output:** -1\n    **Explanation:** It is impossible to make every element equal.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 105`\n  * `1 <= m * n <= 105`\n  * `1 <= x grid[i][j] <= 104`\n\n,"\nclass Solution:\n    def minOperations(self grid: List[List[int]] x: int) -> int:\n        \n        m = len(grid)\n        n = len(grid[0])\n		\n		# handle the edge case\n        if m==1 and n==1: return 0\n		\n		# transform grid to array easier to operate\n        arr = [] \n        for i in range(m):\n            arr+=grid[i]\n        \n        arr.sort()\n        \n		# the median is arr[len(arr)//2] when len(arr) is odd\n		# or may be arr[len(arr)//2] and arr[len(arr)//2-1] when len(arr) is even.\n        cand1 = arr[len(arr)//2]\n        cand2 = arr[len(arr)//2-1]\n        \n        return min(\n            self.get_num_operations_to_target(grid cand1 x)\n            self.get_num_operations_to_target(grid cand2 x)\n        )\n        \n        \n    def get_num_operations_to_target(self grid targetx):\n		""""""Get the total number of operations to transform all grid elements to the target value.""""""\n        ans = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if abs(grid[i][j]-target)%x!=0:\n                    return -1\n                else:\n                    ans+=abs(grid[i][j]-target)//x\n\n        return ans\n                \n"
Minimum Operations to Make the Array Increasing,###  1827\. Minimum Operations to Make the Array Increasing\n\nYou are given an integer array `nums` (**0-indexed**). In one operation you\ncan choose an element of the array and increment it by `1`.\n\n  * For example if `nums = [123]` you can choose to increment `nums[1]` to make `nums = [1_**3**_ 3]`.\n\nReturn _the**minimum** number of operations needed to make_ `nums`\n_**strictly** **increasing**._\n\nAn array `nums` is **strictly increasing** if `nums[i] < nums[i+1]` for all `0\n<= i < nums.length - 1`. An array of length `1` is trivially strictly\nincreasing.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [111]\n    **Output:** 3\n    **Explanation:** You can do the following operations:\n    1) Increment nums[2] so nums becomes [11_**2**_].\n    2) Increment nums[1] so nums becomes [1_**2**_ 2].\n    3) Increment nums[2] so nums becomes [12_**3**_].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [15241]\n    **Output:** 14\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [8]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5000`\n  * `1 <= nums[i] <= 104`\n\n,class Solution:\n    def minOperations(self nums: List[int]) -> int:\n        sol = 0\n        last = nums[0]\n\n        for i in range(len(nums) - 1):\n            if last >= nums[i + 1]:\n                sol += last - nums[i + 1] + 1\n                last = last + 1\n            else:\n                last = nums[i + 1]\n        \n        return sol
Minimum Operations to Make the Array K-Increasing,###  2111\. Minimum Operations to Make the Array K-Increasing\n\nYou are given a **0-indexed** array `arr` consisting of `n` positive integers\nand a positive integer `k`.\n\nThe array `arr` is called **K-increasing** if `arr[i-k] <= arr[i]` holds for\nevery index `i` where `k <= i <= n-1`.\n\n  * For example `arr = [4 1 5 2 6 2]` is K-increasing for `k = 2` because: \n    * `arr[0] <= arr[2] (4 <= 5)`\n    * `arr[1] <= arr[3] (1 <= 2)`\n    * `arr[2] <= arr[4] (5 <= 6)`\n    * `arr[3] <= arr[5] (2 <= 2)`\n  * However the same `arr` is not K-increasing for `k = 1` (because `arr[0] > arr[1]`) or `k = 3` (because `arr[0] > arr[3]`).\n\nIn one **operation**  you can choose an index `i` and **change** `arr[i]`\ninto **any** positive integer.\n\nReturn _the**minimum number of operations** required to make the array\nK-increasing for the given _`k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [54321] k = 1\n    **Output:** 4\n    **Explanation:** For k = 1 the resultant array has to be non-decreasing.\n    Some of the K-increasing arrays that can be formed are [5_**6**_ _**7**_ _**8**_ _**9**_] [_**1**_ _**1**_ _**1**_ _**1**_ 1] [_**2**_ _**2**_ 3_**4**_ _**4**_]. All of them require 4 operations.\n    It is suboptimal to change the array to for example [_**6**_ _**7**_ _**8**_ _**9**_ _**10**_] because it would take 5 operations.\n    It can be shown that we cannot make the array K-increasing in less than 4 operations.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [415262] k = 2\n    **Output:** 0\n    **Explanation:**\n    This is the same example as the one in the problem description.\n    Here for every index i where 2 <= i <= 5 arr[i-2] <=**** arr[i].\n    Since the given array is already K-increasing we do not need to perform any operations.\n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [415262] k = 3\n    **Output:** 2\n    **Explanation:**\n    Indices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5.\n    One of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5.\n    The array will now be [415_**4**_ 6_**5**_].\n    Note that there can be other ways to make the array K-increasing but none of them require less than 2 operations.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 105`\n  * `1 <= arr[i] k <= arr.length`\n\n,class Solution:       \n    def kIncreasing(self arr: List[int] k: int) -> int:\n        def LNDS(arr: List[int]) -> int:\n            mono = []\n            for n in arr:\n                if not mono or mono[-1] <= n:\n                    mono.append(n)\n                else:\n                    mono[bisect_right(mono n)] = n\n            return len(mono)         \n        return len(arr) - sum(LNDS(arr[i::k]) for i in range(k))\n
Minimum Path Cost in a Grid,###  2304\. Minimum Path Cost in a Grid\n\nYou are given a **0-indexed** `m x n` integer matrix `grid` consisting of\n**distinct** integers from `0` to `m * n - 1`. You can move in this matrix\nfrom a cell to any other cell in the **next** row. That is if you are in cell\n`(x y)` such that `x < m - 1` you can move to any of the cells `(x + 1 0)`\n`(x + 1 1)` ... `(x + 1 n - 1)`. **Note** that it is not possible to move\nfrom cells in the last row.\n\nEach possible move has a cost given by a **0-indexed** 2D array `moveCost` of\nsize `(m * n) x n` where `moveCost[i][j]` is the cost of moving from a cell\nwith value `i` to a cell in column `j` of the next row. The cost of moving\nfrom cells in the last row of `grid` can be ignored.\n\nThe cost of a path in `grid` is the **sum** of all values of cells visited\nplus the **sum** of costs of all the moves made. Return _the**minimum** cost\nof a path that starts from any cell in the **first** row and ends at any cell\nin the **last** row._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/04/28/griddrawio-2.png)\n\n    \n    \n    **Input:** grid = [[53][40][21]] moveCost = [[98][15][1012][186][24][143]]\n    **Output:** 17\n    **Explanation:** The path with the minimum possible cost is the path 5 -> 0 -> 1.\n    - The sum of the values of cells visited is 5 + 0 + 1 = 6.\n    - The cost of moving from 5 to 0 is 3.\n    - The cost of moving from 0 to 1 is 8.\n    So the total cost of the path is 6 + 3 + 8 = 17.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[512][403]] moveCost = [[121015][20238][2171][8113][91025][532]]\n    **Output:** 6\n    **Explanation:** The path with the minimum possible cost is the path 2 -> 3.\n    - The sum of the values of cells visited is 2 + 3 = 5.\n    - The cost of moving from 2 to 3 is 1.\n    So the total cost of this path is 5 + 1 = 6.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `2 <= m n <= 50`\n  * `grid` consists of distinct integers from `0` to `m * n - 1`.\n  * `moveCost.length == m * n`\n  * `moveCost[i].length == n`\n  * `1 <= moveCost[i][j] <= 100`\n\n,class Solution:\n    def minPathCost(self grid: List[List[int]] moveCost: List[List[int]]) -> int:\n        max_row max_col = len(grid) len(grid[0])\n        dp = [[-1] * max_col for _ in range(max_row)] \n\n        def recursion(row col):\n            if row == max_row - 1: # If last row then return nodes value\n                return grid[row][col]\n            if dp[row][col] == -1: # If DP for this node is not computed then we will do so now.\n                current = grid[row][col] # Current Node Value\n                res = float('inf') # To store best path from Current Node\n                for c in range(max_col): # Traverse all path from Current Node\n                    val = moveCost[current][c] + recursion(row + 1 c) # Move cost + Target Node Value\n                    res = min(res val)\n                dp[row][col] = res + current # DP[current node] = Best Path + Target Node Val + Current Node Val\n            return dp[row][col]\n\n        for c in range(max_col):\n            recursion(0 c) # Start recursion from all nodes in 1st row\n        return min(dp[0]) # Return min value from 1st row\n
Minimum Path Sum,###  64\. Minimum Path Sum\n\nGiven a `m x n` `grid` filled with non-negative numbers find a path from top\nleft to bottom right which minimizes the sum of all numbers along its path.\n\n**Note:** You can only move either down or right at any point in time.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)\n\n    \n    \n    **Input:** grid = [[131][151][421]]\n    **Output:** 7\n    **Explanation:** Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[123][456]]\n    **Output:** 12\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 200`\n  * `0 <= grid[i][j] <= 100`\n\n,class Solution:\n\n    def minPathSum(self grid: List[List[int]]) -> int:\n        prev=[0]*len(grid[0])\n        for i in range(len(grid)):\n            temp=[0]*len(grid[0])\n            for j in range(len(grid[0])):\n                if i==0 and j==0:\n                    temp[j]=grid[i][j]\n                    continue\n                if i>0:\n                    lft=grid[i][j]+prev[j]\n                else:\n                    lft=grid[i][j]+1000\n                if j>0:\n                    up=grid[i][j]+temp[j-1]\n                else:\n                    up=grid[i][j]+1000\n                temp[j]=min(uplft)\n            prev=temp\n        return prev[-1]\n    \n        \n
Minimum Replacements to Sort the Array,###  2366\. Minimum Replacements to Sort the Array\n\nYou are given a **0-indexed** integer array `nums`. In one operation you can\nreplace any element of the array with **any two** elements that **sum** to it.\n\n  * For example consider `nums = [567]`. In one operation we can replace `nums[1]` with `2` and `4` and convert `nums` to `[5247]`.\n\nReturn _the minimum number of operations to make an array that is sorted\nin**non-decreasing** order_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [393]\n    **Output:** 2\n    **Explanation:** Here are the steps to sort the array in non-decreasing order:\n    - From [393] replace the 9 with 3 and 6 so the array becomes [3363]\n    - From [3363] replace the 6 with 3 and 3 so the array becomes [33333]\n    There are 2 steps to sort the array in non-decreasing order. Therefore we return 2.\n    \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12345]\n    **Output:** 0\n    **Explanation:** The array is already in non-decreasing order. Therefore we return 0. \n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 109`\n\n,class Solution:\n    def minimumReplacement(self nums) -> int:\n        ans = 0\n        n = len(nums)\n        curr = nums[-1]\n        for i in range(n - 2 -1 -1):\n            if nums[i] > curr:\n                q = nums[i] // curr\n                if nums[i] == curr * q:\n                    nums[i] = curr\n                    ans += q - 1\n                else:\n                    nums[i] = nums[i] // (q + 1)\n                    ans += q\n            curr = nums[i]\n        return ans\n
Minimum Score After Removals on a Tree,###  2322\. Minimum Score After Removals on a Tree\n\nThere is an undirected connected tree with `n` nodes labeled from `0` to `n -\n1` and `n - 1` edges.\n\nYou are given a **0-indexed** integer array `nums` of length `n` where\n`nums[i]` represents the value of the `ith` node. You are also given a 2D\ninteger array `edges` of length `n - 1` where `edges[i] = [ai bi]` indicates\nthat there is an edge between nodes `ai` and `bi` in the tree.\n\nRemove two **distinct** edges of the tree to form three connected components.\nFor a pair of removed edges the following steps are defined:\n\n  1. Get the XOR of all the values of the nodes for **each** of the three components respectively.\n  2. The **difference** between the **largest** XOR value and the **smallest** XOR value is the **score** of the pair.\n\n  * For example say the three components have the node values: `[457]` `[19]` and `[333]`. The three XOR values are `4 ^ 5 ^ 7 = _**6**_` `1 ^ 9 = _**8**_` and `3 ^ 3 ^ 3 = _**3**_`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.\n\nReturn _the**minimum** score of any possible pair of edge removals on the\ngiven tree_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/05/03/ex1drawio.png)\n\n    \n    \n    **Input:** nums = [155411] edges = [[01][12][13][34]]\n    **Output:** 9\n    **Explanation:** The diagram above shows a way to make a pair of removals.\n    - The 1st component has nodes [134] with values [5411]. Its XOR value is 5 ^ 4 ^ 11 = 10.\n    - The 2nd component has node [0] with value [1]. Its XOR value is 1 = 1.\n    - The 3rd component has node [2] with value [5]. Its XOR value is 5 = 5.\n    The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.\n    It can be shown that no other pair of removals will obtain a smaller score than 9.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/05/03/ex2drawio.png)\n\n    \n    \n    **Input:** nums = [552442] edges = [[01][12][52][43][13]]\n    **Output:** 0\n    **Explanation:** The diagram above shows a way to make a pair of removals.\n    - The 1st component has nodes [34] with values [44]. Its XOR value is 4 ^ 4 = 0.\n    - The 2nd component has nodes [10] with values [55]. Its XOR value is 5 ^ 5 = 0.\n    - The 3rd component has nodes [25] with values [22]. Its XOR value is 2 ^ 2 = 0.\n    The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.\n    We cannot obtain a smaller score than 0.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `3 <= n <= 1000`\n  * `1 <= nums[i] <= 108`\n  * `edges.length == n - 1`\n  * `edges[i].length == 2`\n  * `0 <= ai bi < n`\n  * `ai != bi`\n  * `edges` represents a valid tree.\n\n,# Runtime: 1682 ms (Top 100.0%) | Memory: 18.40 MB (Top 71.7%)\n\nclass Solution:\n    def minimumScore(self nums: List[int] edges: List[List[int]]) -> int:        \n        n = len(nums)\n        graph = [[] for _ in range(n)]\n        for u v in edges: \n            graph[u].append(v)\n            graph[v].append(u)\n            \n        def fn(u p): \n            nonlocal t\n            score[u] = nums[u]\n            tin[u] = (t := t+1) # time to enter\n            for v in graph[u]: \n                if v != p: \n                    fn(v u)\n                    score[u] ^= score[v]\n            tout[u] = t # time to exit \n        \n        t = 0 \n        score = [0]*n\n        tin = [0]*n \n        tout = [0]*n \n        fn(0 -1)\n        \n        ans = inf \n        for u in range(1 n): \n            for v in range(u+1 n): \n                if tin[v] <= tin[u] and tout[v] >= tout[u]: # enter earlier & exit later == parent \n                    uu = score[u]\n                    vv = score[v] ^ score[u]\n                    xx = score[0] ^ score[v]\n                elif tin[v] >= tin[u] and tout[v] <= tout[u]: \n                    uu = score[u] ^ score[v]\n                    vv = score[v]\n                    xx = score[0] ^ score[u]\n                else: \n                    uu = score[u]\n                    vv = score[v]\n                    xx = score[0] ^ score[u] ^ score[v]\n                ans = min(ans max(uu vv xx) - min(uu vv xx))\n        return ans  
Minimum Size Subarray Sum,###  209\. Minimum Size Subarray Sum\n\nGiven an array of positive integers `nums` and a positive integer `target`\nreturn the minimal length of a **contiguous subarray** `[numsl numsl+1 ...\nnumsr-1 numsr]` of which the sum is greater than or equal to `target`. If\nthere is no such subarray return `0` instead.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = 7 nums = [231243]\n    **Output:** 2\n    **Explanation:** The subarray [43] has the minimal length under the problem constraint.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = 4 nums = [144]\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** target = 11 nums = [11111111]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= target <= 109`\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 104`\n\n\n\n**Follow up:** If you have figured out the `O(n)` solution try coding another\nsolution of which the time complexity is `O(n log(n))`.\n\n,"class Solution:\n    def minSubArrayLen(self target nums):\n		# Init left pointer and answer\n        l ans = 0 len(nums) + 1\n		# Init sum of subarray\n        s = 0 \n		# Iterate through all numbers as right subarray \n        for r in range(len(nums)):\n			# Add right number to sum\n            s += nums[r]\n			# Check for subarray greater than or equal to target\n            while s >= target:\n				# Calculate new min\n                ans = min(ans r - l + 1)\n				# Remove current left nubmer from sum\n                s -= nums[l]\n				# Move left index up one\n                l += 1\n		# No solution\n        if ans == len(nums) + 1:\n            return 0\n		# Solution\n        return ans \n"
Minimum Skips to Arrive at Meeting On Time,###  1883\. Minimum Skips to Arrive at Meeting On Time\n\nYou are given an integer `hoursBefore` the number of hours you have to travel\nto your meeting. To arrive at your meeting you have to travel through `n`\nroads. The road lengths are given as an integer array `dist` of length `n`\nwhere `dist[i]` describes the length of the `ith` road in **kilometers**. In\naddition you are given an integer `speed` which is the speed (in **km/h**)\nyou will travel at.\n\nAfter you travel road `i` you must rest and wait for the **next integer\nhour** before you can begin traveling on the next road. Note that you do not\nhave to rest after traveling the last road because you are already at the\nmeeting.\n\n  * For example if traveling a road takes `1.4` hours you must wait until the `2` hour mark before traveling the next road. If traveling a road takes exactly `2` hours you do not need to wait.\n\nHowever you are allowed to **skip** some rests to be able to arrive on time\nmeaning you do not need to wait for the next integer hour. Note that this\nmeans you may finish traveling future roads at different hour marks.\n\n  * For example suppose traveling the first road takes `1.4` hours and traveling the second road takes `0.6` hours. Skipping the rest after the first road will mean you finish traveling the second road right at the `2` hour mark letting you start traveling the third road immediately.\n\nReturn _the**minimum number of skips required** to arrive at the meeting on\ntime or_ `-1` _if it is**impossible**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** dist = [132] speed = 4 hoursBefore = 2\n    **Output:** 1\n    **Explanation:**\n    Without skipping any rests you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.\n    You can skip the first rest to arrive in ((1/4 + _0_) + (3/4 + 0)) + (2/4) = 1.5 hours.\n    Note that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** dist = [7355] speed = 2 hoursBefore = 10\n    **Output:** 2\n    **Explanation:**\n    Without skipping any rests you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.\n    You can skip the first and third rest to arrive in ((7/2 + _0_) + (3/2 + 0)) + ((5/2 + _0_) + (5/2)) = 10 hours.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** dist = [7355] speed = 1 hoursBefore = 10\n    **Output:** -1\n    **Explanation:** It is impossible to arrive at the meeting on time even if you skip all the rests.\n    \n\n\n\n**Constraints:**\n\n  * `n == dist.length`\n  * `1 <= n <= 1000`\n  * `1 <= dist[i] <= 105`\n  * `1 <= speed <= 106`\n  * `1 <= hoursBefore <= 107`\n\n,"// Runtime: 1024 ms (Top 91.67%) | Memory: 285.50 MB (Top 27.78%)\n\nclass Solution:\n    def minSkips(self dist: List[int] speed: int hoursBefore: int) -> int:\n        if sum(dist)/speed > hoursBefore: return -1 # impossible \n        \n        @cache\n        def fn(i k): \n            """"""Return min time (in distance) of traveling first i roads with k skips.""""""\n            if k < 0: return inf # impossible \n            if i == 0: return 0 \n            return min(ceil((fn(i-1 k) + dist[i-1])/speed) * speed dist[i-1] + fn(i-1 k-1))\n        \n        for k in range(len(dist)):\n            if fn(len(dist)-1 k) + dist[-1] <= hoursBefore*speed: return k \n"
Minimum Space Wasted From Packaging,###  1889\. Minimum Space Wasted From Packaging\n\nYou have `n` packages that you are trying to place in boxes **one package in\neach box**. There are `m` suppliers that each produce boxes of **different\nsizes** (with infinite supply). A package can be placed in a box if the size\nof the package is **less than or equal to** the size of the box.\n\nThe package sizes are given as an integer array `packages` where\n`packages[i]` is the **size** of the `ith` package. The suppliers are given as\na 2D integer array `boxes` where `boxes[j]` is an array of **box sizes** that\nthe `jth` supplier produces.\n\nYou want to choose a **single supplier** and use boxes from them such that the\n**total wasted space** is **minimized**. For each package in a box we define\nthe space **wasted** to be `size of the box - size of the package`. The\n**total wasted space** is the sum of the space wasted in **all** the boxes.\n\n  * For example if you have to fit packages with sizes `[235]` and the supplier offers boxes of sizes `[48]` you can fit the packages of size-`2` and size-`3` into two boxes of size-`4` and the package with size-`5` into a box of size-`8`. This would result in a waste of `(4-2) + (4-3) + (8-5) = 6`.\n\nReturn _the**minimum total wasted space** by choosing the box supplier\n**optimally**  or _`-1` _if it is**impossible** to fit all the packages\ninside boxes. _Since the answer may be **large**  return it **modulo**`109 +\n7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** packages = [235] boxes = [[48][28]]\n    **Output:** 6\n    **Explanation** : It is optimal to choose the first supplier using two size-4 boxes and one size-8 box.\n    The total waste is (4-2) + (4-3) + (8-5) = 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** packages = [235] boxes = [[14][23][34]]\n    **Output:** -1\n    **Explanation:** There is no box that the package of size 5 can fit in.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** packages = [358101112] boxes = [[12][119][10514]]\n    **Output:** 9\n    **Explanation:** It is optimal to choose the third supplier using two size-5 boxes two size-10 boxes and two size-14 boxes.\n    The total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.\n    \n\n\n\n**Constraints:**\n\n  * `n == packages.length`\n  * `m == boxes.length`\n  * `1 <= n <= 105`\n  * `1 <= m <= 105`\n  * `1 <= packages[i] <= 105`\n  * `1 <= boxes[j].length <= 105`\n  * `1 <= boxes[j][k] <= 105`\n  * `sum(boxes[j].length) <= 105`\n  * The elements in `boxes[j]` are **distinct**.\n\n,# Runtime: 2545 ms (Top 38.89%) | Memory: 37.8 MB (Top 95.24%)\nclass Solution:\n    def minWastedSpace(self packages: List[int] boxes: List[List[int]]) -> int:\n        # prefix sum to save time\n        acc = [0] + [*accumulate(packages)]\n        packages.sort()\n\n        ans = float('inf')\n        for box in boxes:\n            tmp = 0\n            # deal with smallest box first\n            box.sort()\n\n            # record number of packages already dealt with\n            start = 0\n\n            for b in box:\n                loc = bisect.bisect(packages b)\n                if loc == 0: continue\n                tmp += b * (loc - start) - (acc[loc] - acc[start])\n\n                # all are packaged\n                if loc == len(packages):\n                    ans = min(ans tmp)\n                    break\n\n                start = loc\n\n        return ans % (10 **9+7) if ans != float('inf') else -1
Minimum Speed to Arrive on Time,###  1870\. Minimum Speed to Arrive on Time\n\nYou are given a floating-point number `hour` representing the amount of time\nyou have to reach the office. To commute to the office you must take `n`\ntrains in sequential order. You are also given an integer array `dist` of\nlength `n` where `dist[i]` describes the distance (in kilometers) of the\n`ith` train ride.\n\nEach train can only depart at an integer hour so you may need to wait in\nbetween each train ride.\n\n  * For example if the `1st` train ride takes `1.5` hours you must wait for an additional `0.5` hours before you can depart on the `2nd` train ride at the 2 hour mark.\n\nReturn _the**minimum positive integer** speed **(in kilometers per hour)**\nthat all the trains must travel at for you to reach the office on time or\n_`-1` _if it is impossible to be on time_.\n\nTests are generated such that the answer will not exceed `107` and `hour` will\nhave **at most two digits after the decimal point**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** dist = [132] hour = 6\n    **Output:** 1\n    **Explanation:** At speed 1:\n    - The first train ride takes 1/1 = 1 hour.\n    - Since we are already at an integer hour we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n    - Since we are already at an integer hour we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n    - You will arrive at exactly the 6 hour mark.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** dist = [132] hour = 2.7\n    **Output:** 3\n    **Explanation:** At speed 3:\n    - The first train ride takes 1/3 = 0.33333 hours.\n    - Since we are not at an integer hour we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n    - Since we are already at an integer hour we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n    - You will arrive at the 2.66667 hour mark.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** dist = [132] hour = 1.9\n    **Output:** -1\n    **Explanation:** It is impossible because the earliest the third train can depart is at the 2 hour mark.\n    \n\n\n\n**Constraints:**\n\n  * `n == dist.length`\n  * `1 <= n <= 105`\n  * `1 <= dist[i] <= 105`\n  * `1 <= hour <= 109`\n  * There will be at most two digits after the decimal point in `hour`.\n\n,"# Runtime: 5298 ms (Top 60.74%) | Memory: 27.4 MB (Top 98.14%)\n\nclass Solution:\n    def minSpeedOnTime(self dist: List[int] hour: float) -> int:\n        # the speed upper is either the longest train ride: max(dist)\n        # or the last train ride divide by 0.01: ceil(dist[-1] / 0.01).\n        # notice: ""hour will have at most two digits after the decimal point""\n        upper = max(max(dist) ceil(dist[-1] / 0.01))\n        #\n        # the function to calcute total time consumed\n        total = lambda speed: sum(map(lambda x: ceil(x / speed) dist[:-1])) + (dist[-1] / speed)\n        # the case of impossible to arrive office on time\n        if total(upper) > hour:\n            return -1\n        #\n        # binary search: find the mimimal among ""all"" feasible answers\n        left right = 1 upper\n        while left < right:\n            mid = left + (right - left) // 2\n            if total(mid) > hour:\n                left = mid + 1 # should be larger\n            else:\n                right = mid # should explore a smaller one\n        return right"
Minimum Sum of Four Digit Number After Splitting Digits,###  2160\. Minimum Sum of Four Digit Number After Splitting Digits\n\nYou are given a **positive** integer `num` consisting of exactly four digits.\nSplit `num` into two new integers `new1` and `new2` by using the **digits**\nfound in `num`. **Leading zeros** are allowed in `new1` and `new2` and\n**all** the digits found in `num` must be used.\n\n  * For example given `num = 2932` you have the following digits: two `2`'s one `9` and one `3`. Some of the possible pairs `[new1 new2]` are `[22 93]` `[23 92]` `[223 9]` and `[2 329]`.\n\nReturn _the**minimum** possible sum of _`new1` _and_`new2`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 2932\n    **Output:** 52\n    **Explanation:** Some possible pairs [new1 new2] are [29 23] [223 9] etc.\n    The minimum sum can be obtained by the pair [29 23]: 29 + 23 = 52.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 4009\n    **Output:** 13\n    **Explanation:** Some possible pairs [new1 new2] are [0 49] [490 0] etc. \n    The minimum sum can be obtained by the pair [4 9]: 4 + 9 = 13.\n    \n\n\n\n**Constraints:**\n\n  * `1000 <= num <= 9999`\n\n,class Solution:\n    def minimumSum(self num: int) -> int:\n        s=list(str(num))\n        s.sort()\n        return int(s[0]+s[2])+int(s[1]+s[3])
Minimum Sum of Squared Difference,###  2333\. Minimum Sum of Squared Difference\n\nYou are given two positive **0-indexed** integer arrays `nums1` and `nums2`\nboth of length `n`.\n\nThe **sum of squared difference** of arrays `nums1` and `nums2` is defined as\nthe **sum** of `(nums1[i] - nums2[i])2` for each `0 <= i < n`.\n\nYou are also given two positive integers `k1` and `k2`. You can modify any of\nthe elements of `nums1` by `+1` or `-1` at most `k1` times. Similarly you can\nmodify any of the elements of `nums2` by `+1` or `-1` at most `k2` times.\n\nReturn _the minimum**sum of squared difference** after modifying array\n_`nums1` _at most_`k1` _times and modifying array_`nums2` _at most_`k2`\n_times_.\n\n**Note** : You are allowed to modify the array elements to become **negative**\nintegers.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [1234] nums2 = [2102019] k1 = 0 k2 = 0\n    **Output:** 579\n    **Explanation:** The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. \n    The sum of square difference will be: (1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [141012] nums2 = [5869] k1 = 1 k2 = 1\n    **Output:** 43\n    **Explanation:** One way to obtain the minimum sum of square difference is: \n    - Increase nums1[0] once.\n    - Increase nums2[2] once.\n    The minimum of the sum of square difference will be: \n    (2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43.\n    Note that there are other ways to obtain the minimum of the sum of square difference but there is no way to obtain a sum smaller than 43.\n\n\n\n**Constraints:**\n\n  * `n == nums1.length == nums2.length`\n  * `1 <= n <= 105`\n  * `0 <= nums1[i] nums2[i] <= 105`\n  * `0 <= k1 k2 <= 109`\n\n,# Runtime: 1506 ms (Top 29.6%) | Memory: 34.22 MB (Top 74.0%)\n\nclass Solution:\n    def minSumSquareDiff(self nums1: List[int] nums2: List[int] k1: int k2: int) -> int:\n        n = len(nums1)\n        k = k1+k2 # can combine k's because items can be turned negative\n        diffs = sorted((abs(x - y) for x y in zip(nums1 nums2)))\n        \n        # First binary search to find our new max for our diffs array\n        l r = 0 max(diffs)\n        while l < r:\n            mid = (l+r)//2\n            \n            # steps needed to reduce all nums greater than newMax\n            steps = sum(max(0 num-mid) for num in diffs)\n            \n            if steps <= k:\n                r = mid\n            else:\n                l = mid+1\n                \n        newMax = l\n        k -= sum(max(0 num-newMax) for num in diffs) # remove used k\n\n        # Second binary search to find first index to replace with max val\n        l r = 0 n-1\n        while l < r:\n            mid = (l+r)//2\n            if diffs[mid] < newMax:\n                l = mid+1\n            else:\n                r = mid\n\n        # Replace items at index >= l with newMax\n        diffs = diffs[:l]+[newMax]*(n-l)\n        \n        # Use remaining steps to reduce overall score\n        for i in range(len(diffs)-1-1-1):\n            if k == 0 or diffs[i] == 0: break\n            diffs[i] -= 1\n            k -= 1\n            \n        return sum(diff*diff for diff in diffs)
Minimum Swaps to Arrange a Binary Grid,###  1536\. Minimum Swaps to Arrange a Binary Grid\n\nGiven an `n x n` binary `grid` in one step you can choose two **adjacent\nrows** of the grid and swap them.\n\nA grid is said to be **valid** if all the cells above the main diagonal are\n**zeros**.\n\nReturn _the minimum number of steps_ needed to make the grid valid or **-1**\nif the grid cannot be valid.\n\nThe main diagonal of a grid is the diagonal that starts at cell `(1 1)` and\nends at cell `(n n)`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/07/28/fw.jpg)\n\n    \n    \n    **Input:** grid = [[001][110][100]]\n    **Output:** 3\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/07/16/e2.jpg)\n\n    \n    \n    **Input:** grid = [[0110][0110][0110][0110]]\n    **Output:** -1\n    **Explanation:** All rows are similar swaps have no effect on the grid.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/07/16/e3.jpg)\n\n    \n    \n    **Input:** grid = [[100][110][111]]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length` `== grid[i].length`\n  * `1 <= n <= 200`\n  * `grid[i][j]` is either `0` or `1`\n\n,# Runtime: 1405 ms (Top 5.77%) | Memory: 15.2 MB (Top 23.08%)\nclass Solution:\n    def minSwaps(self grid) -> int:\n        n = len(grid)\n        max_right = [-1] * n\n        for r row in enumerate(grid):\n            for c in range(n - 1 -1 -1):\n                if row[c] == 1:\n                    max_right[r] = c\n                    break\n        if all(v <= i for i v in enumerate(sorted(max_right))):\n            swaps = 0\n            i = 0\n            while i < n:\n                while i < n and max_right[i] <= i:\n                    i += 1\n                if i == n:\n                    break\n                j = i\n                while j < n and max_right[j] > i:\n                    j += 1\n                swaps += j - i\n                max_right[i] max_right[i + 1: j + 1] = (max_right[j]\n                                                         max_right[i: j])\n                i += 1\n            return swaps\n        return -1
Minimum Swaps to Group All 1's Together II,###  2134\. Minimum Swaps to Group All 1's Together II\n\nA **swap** is defined as taking two **distinct** positions in an array and\nswapping the values in them.\n\nA **circular** array is defined as an array where we consider the **first**\nelement and the **last** element to be **adjacent**.\n\nGiven a **binary** **circular** array `nums` return _the minimum number of\nswaps required to group all_`1` _'s present in the array together at**any\nlocation**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [0101100]\n    **Output:** 1\n    **Explanation:** Here are a few of the ways to group all the 1's together:\n    [0_0_ _1_ 1100] using 1 swap.\n    [01_1_ 1_0_ 00] using 1 swap.\n    [1100001] using 2 swaps (using the circular property of the array).\n    There is no way to group all 1's together with 0 swaps.\n    Thus the minimum number of swaps required is 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [011100110]\n    **Output:** 2\n    **Explanation:** Here are a few of the ways to group all the 1's together:\n    [111000011] using 2 swaps (using the circular property of the array).\n    [111110000] using 2 swaps.\n    There is no way to group all 1's together with 0 or 1 swaps.\n    Thus the minimum number of swaps required is 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [11001]\n    **Output:** 0\n    **Explanation:** All the 1's are already grouped together due to the circular property of the array.\n    Thus the minimum number of swaps required is 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `nums[i]` is either `0` or `1`.\n\n,class Solution:\n    def minSwaps(self nums: List[int]) -> int:\n        width = sum(num == 1 for num in nums) #width of the window\n        nums += nums\n        res = width\n        curr_zeros = sum(num == 0 for num in nums[:width]) #the first window is nums[:width]\n        \n        for i in range(width len(nums)):\n            curr_zeros -= (nums[i - width] == 0) #remove the leftmost 0 if exists\n            curr_zeros += (nums[i] == 0) #add the rightmost 0 if exists\n            res = min(res curr_zeros) #update if needed\n        \n        return res\n
Minimum Swaps to Make Strings Equal,"###  1247\. Minimum Swaps to Make Strings Equal\n\nYou are given two strings `s1` and `s2` of equal length consisting of letters\n`""x""` and `""y""` **only**. Your task is to make these two strings equal to each\nother. You can swap any two characters that belong to **different** strings\nwhich means: swap `s1[i]` and `s2[j]`.\n\nReturn the minimum number of swaps required to make `s1` and `s2` equal or\nreturn `-1` if it is impossible to do so.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s1 = ""xx"" s2 = ""yy""\n    **Output:** 1\n    **Explanation:** Swap s1[0] and s2[1] s1 = ""yx"" s2 = ""yx"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""xy"" s2 = ""yx""\n    **Output:** 2\n    **Explanation:** Swap s1[0] and s2[0] s1 = ""yy"" s2 = ""xx"".\n    Swap s1[0] and s2[1] s1 = ""xy"" s2 = ""xy"".\n    Note that you cannot swap s1[0] and s1[1] to make s1 equal to ""yx"" cause we can only swap chars in different strings.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s1 = ""xx"" s2 = ""xy""\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s1.length s2.length <= 1000`\n  * `s1 s2` only contain `'x'` or `'y'`.\n\n",class Solution:\n    def minimumSwap(self s1: str s2: str) -> int:\n        h = defaultdict(int)\n        count = 0    # variable to keep track of the number of mismatches; it is impossible to make strings equal if count is odd\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                count += 1\n                h[s1[i]] += 1\n        if count % 2 != 0:     \n            return -1\n        res a b = 0 h['x'] h['y']\n        res += a // 2 + b // 2\n        if a % 2 == 0:\n            return res\n        return res + 2
Minimum Time Difference,"###  539\. Minimum Time Difference\n\nGiven a list of 24-hour clock time points in **""HH:MM""** format return _the\nminimum**minutes** difference between any two time-points in the list_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** timePoints = [""23:59""""00:00""]\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** timePoints = [""00:00""""23:59""""00:00""]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `2 <= timePoints.length <= 2 * 104`\n  * `timePoints[i]` is in the format **""HH:MM""**.\n\n",// Runtime: 68 ms (Top 91.63%) | Memory: 20.60 MB (Top 5.75%)\n\nclass Solution:\n    def findMinDifference(self timePoints: List[str]) -> int:\n        # Convert time points to minutes since midnight and sort the list\n        minutes = sorted([int(time[:2]) * 60 + int(time[3:]) for time in timePoints])\n        \n        # Calculate the minimum difference between adjacent time points\n        min_diff = float('inf')\n        for i in range(len(minutes) - 1):\n            diff = minutes[i+1] - minutes[i]\n            if diff < min_diff:\n                min_diff = diff\n        \n        # Calculate the difference between the first and last time points\n        diff = (24*60 - minutes[-1] + minutes[0]) % (24*60)\n        if diff < min_diff:\n            min_diff = diff\n        \n        return min_diff\n\n
Minimum Time to Collect All Apples in a Tree,###  1443\. Minimum Time to Collect All Apples in a Tree\n\nGiven an undirected tree consisting of `n` vertices numbered from `0` to\n`n-1` which has some apples in their vertices. You spend 1 second to walk\nover one edge of the tree. _Return the minimum time in seconds you have to\nspend to collect all apples in the tree starting at**vertex 0** and coming\nback to this vertex._\n\nThe edges of the undirected tree are given in the array `edges` where\n`edges[i] = [ai bi]` means that exists an edge connecting the vertices `ai`\nand `bi`. Additionally there is a boolean array `hasApple` where\n`hasApple[i] = true` means that vertex `i` has an apple; otherwise it does\nnot have any apple.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_1.png)\n\n    \n    \n    **Input:** n = 7 edges = [[01][02][14][15][23][26]] hasApple = [falsefalsetruefalsetruetruefalse]\n    **Output:** 8 \n    **Explanation:** The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  \n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/04/23/min_time_collect_apple_2.png)\n\n    \n    \n    **Input:** n = 7 edges = [[01][02][14][15][23][26]] hasApple = [falsefalsetruefalsefalsetruefalse]\n    **Output:** 6\n    **Explanation:** The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows.  \n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 7 edges = [[01][02][14][15][23][26]] hasApple = [falsefalsefalsefalsefalsefalsefalse]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `edges.length == n - 1`\n  * `edges[i].length == 2`\n  * `0 <= ai < bi <= n - 1`\n  * `fromi < toi`\n  * `hasApple.length == n`\n\n,"# Runtime: 1818 ms (Top 5.15%) | Memory: 87.1 MB (Top 5.14%)\nclass Solution:\n\n    def minTime(self n: int edges: List[List[int]] hasApple: List[bool]) -> int:\n        graph_map = {i: set() for i in range(n)}\n        for edge in edges:\n            graph_map[edge[0]].add(edge[1])\n            graph_map[edge[1]].add(edge[0])\n\n        self.result = set()\n        visited = set()\n        def dfs(node path):\n            visited.add(node)\n            if hasApple[node]:\n                temp = path + '|' + str(node)\n                temp = temp.split('|')[1:]\n                # print(temp)\n                for i in range(1 len(temp)):\n                    self.result.add((temp[i] temp[i-1]))\n            for nei in graph_map[node]:\n                if nei not in visited:\n                    dfs(nei path + '|' + str(node))\n\n        dfs(0 """")\n        # print(self.result)\n        return len(self.result) * 2"
Minimum Time to Finish the Race,###  2188\. Minimum Time to Finish the Race\n\nYou are given a **0-indexed** 2D integer array `tires` where `tires[i] = [fi\nri]` indicates that the `ith` tire can finish its `xth` successive lap in `fi\n* ri(x-1)` seconds.\n\n  * For example if `fi = 3` and `ri = 2` then the tire would finish its `1st` lap in `3` seconds its `2nd` lap in `3 * 2 = 6` seconds its `3rd` lap in `3 * 22 = 12` seconds etc.\n\nYou are also given an integer `changeTime` and an integer `numLaps`.\n\nThe race consists of `numLaps` laps and you may start the race with **any**\ntire. You have an **unlimited** supply of each tire and after every lap you\nmay **change** to any given tire (including the current tire type) if you wait\n`changeTime` seconds.\n\nReturn _the**minimum** time to finish the race._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** tires = [[23][34]] changeTime = 5 numLaps = 4\n    **Output:** 21\n    **Explanation:** \n    Lap 1: Start with tire 0 and finish the lap in 2 seconds.\n    Lap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.\n    Lap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds.\n    Lap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds.\n    Total time = 2 + 6 + 5 + 2 + 6 = 21 seconds.\n    The minimum time to complete the race is 21 seconds.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** tires = [[110][22][34]] changeTime = 6 numLaps = 5\n    **Output:** 25\n    **Explanation:** \n    Lap 1: Start with tire 1 and finish the lap in 2 seconds.\n    Lap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\n    Lap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds.\n    Lap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds.\n    Lap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second.\n    Total time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds.\n    The minimum time to complete the race is 25 seconds. \n    \n\n\n\n**Constraints:**\n\n  * `1 <= tires.length <= 105`\n  * `tires[i].length == 2`\n  * `1 <= fi changeTime <= 105`\n  * `2 <= ri <= 105`\n  * `1 <= numLaps <= 1000`\n\n,"class Solution:\n    def minimumFinishTime(self tires: List[List[int]] changeTime: int numLaps: int) -> int:\n        # by observation we can try to find out the optimal usage within certain numLaps\n        # use DP\n        # the optimal usage of this lap = min(change tire  no change)\n        # dp(laps) = min( dp(laps-1)+dp(1) + dp(laps-2)+dp(2) + ...)\n        \n        # we don't want to use tires too many laps which will create unrealistic single lap time\n		# we can evaluate single lap time by using changeTime <= 100000 and r >= 2\n		# x = minimal continously laps\n		# single lap time = 1*2^x <= 100000 -> x can't go more than 19\n		limit = 19\n        tires = list(set([(t1 t2) for t1 t2 in tires]))\n        memo = [[(-1-1) for _ in range(min(limitnumLaps)+1)] for _ in range(len(tires))]\n        \n        for i in range(len(tires)):\n            for j in range(1 min(limitnumLaps)+1):                   # lap 1 to numLaps\n                if j == 1:\n                    memo[i][j] = (tires[i][0] tires[i][0])            # total time lap time\n                else:\n                    # print('i j' i j)\n                    tmp = memo[i][j-1][1]*tires[i][1]                  # cost of continuously use tire this lap\n                    memo[i][j] = (memo[i][j-1][0]+tmp tmp)\n        \n        @cache\n        def dp(laps):\n            if laps == 1:\n                return min(memo[i][1][0] for i in range(len(tires)))\n            \n            # no change:\n            best_time = min(memo[i][laps][0] for i in range(len(tires))) if laps <= limit else float('inf')\n            \n            # change tire:\n			# e.g. change tire at this lap and see if it'll be faster -> dp(laps-1) + changeTime + dp(1)\n            # check all previous laps: dp(a) + changeTime + dp(b) until a < b\n            for j in range(1 laps):\n                a b = laps-j j\n                if a >= b:\n                    ta = dp(a)\n                    tb = dp(b)\n                    if ta+tb+changeTime < best_time:\n                        best_time = ta+tb+changeTime\n            return best_time\n                \n        return dp(numLaps)\n"
Minimum Time to Remove All Cars Containing Illegal Goods,"###  2167\. Minimum Time to Remove All Cars Containing Illegal Goods\n\nYou are given a **0-indexed** binary string `s` which represents a sequence of\ntrain cars. `s[i] = '0'` denotes that the `ith` car does **not** contain\nillegal goods and `s[i] = '1'` denotes that the `ith` car does contain illegal\ngoods.\n\nAs the train conductor you would like to get rid of all the cars containing\nillegal goods. You can do any of the following three operations **any** number\nof times:\n\n  1. Remove a train car from the **left** end (i.e. remove `s[0]`) which takes 1 unit of time.\n  2. Remove a train car from the **right** end (i.e. remove `s[s.length - 1]`) which takes 1 unit of time.\n  3. Remove a train car from **anywhere** in the sequence which takes 2 units of time.\n\nReturn _the**minimum** time to remove all the cars containing illegal goods_.\n\nNote that an empty sequence of cars is considered to have no cars containing\nillegal goods.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""**_11_** 00** _1_** 0** _1_** ""\n    **Output:** 5\n    **Explanation:** \n    One way to remove all the cars containing illegal goods from the sequence is to\n    - remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n    - remove a car from the right end. Time taken is 1.\n    - remove the car containing illegal goods found in the middle. Time taken is 2.\n    This obtains a total time of 2 + 1 + 2 = 5. \n    \n    An alternative way is to\n    - remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n    - remove a car from the right end 3 times. Time taken is 3 * 1 = 3.\n    This also obtains a total time of 2 + 3 = 5.\n    \n    5 is the minimum time taken to remove all the cars containing illegal goods. \n    There are no other ways to remove them with less time.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""00** _1_** 0""\n    **Output:** 2\n    **Explanation:**\n    One way to remove all the cars containing illegal goods from the sequence is to\n    - remove a car from the left end 3 times. Time taken is 3 * 1 = 3.\n    This obtains a total time of 3.\n    \n    Another way to remove all the cars containing illegal goods from the sequence is to\n    - remove the car containing illegal goods found in the middle. Time taken is 2.\n    This obtains a total time of 2.\n    \n    Another way to remove all the cars containing illegal goods from the sequence is to \n    - remove a car from the right end 2 times. Time taken is 2 * 1 = 2. \n    This obtains a total time of 2.\n    \n    2 is the minimum time taken to remove all the cars containing illegal goods. \n    There are no other ways to remove them with less time.\n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 2 * 105`\n  * `s[i]` is either `'0'` or `'1'`.\n\n","class Solution:\n    def minimumTime(self s):\n        def minSum(nums):\n            dp = [0]*len(nums)\n            dp[0] = nums[0]\n            for i in range(1 len(nums)):\n                dp[i] = min(nums[i] nums[i] + dp[i-1])\n            return min(0 min(dp))\n\n        n = len(s)\n        s1 = [1 if i == ""1"" else -1 for i in s]\n        score = minSum(s1)\n       \n        return n + score\n"
Minimum Value to Get Positive Step by Step Sum,###  1413\. Minimum Value to Get Positive Step by Step Sum\n\nGiven an array of integers `nums` you start with an initial **positive**\nvalue _startValue_ _._\n\nIn each iteration you calculate the step by step sum of _startValue_  plus\nelements in `nums` (from left to right).\n\nReturn the minimum **positive** value of _startValue_ such that the step by\nstep sum is never less than 1.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [-32-342]\n    **Output:** 5\n    **Explanation:** If you choose startValue = 4 in the third iteration your step by step sum is less than 1.\n    **step by step sum**\n    **startValue = 4 | startValue = 5 | nums**\n      (4 **-3** ) = 1  | (5 **-3** ) = 2    |  -3\n      (1 **+2** ) = 3  | (2 **+2** ) = 4    |   2\n      (3 **-3** ) = 0  | (4 **-3** ) = 1    |  -3\n      (0 **+4** ) = 4  | (1 **+4** ) = 5    |   4\n      (4 **+2** ) = 6  | (5 **+2** ) = 7    |   2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12]\n    **Output:** 1\n    **Explanation:** Minimum start value should be positive. \n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1-2-3]\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `-100 <= nums[i] <= 100`\n\n,# Runtime: 42 ms (Top 60.3%) | Memory: 16.30 MB (Top 27.0%)\n\nclass Solution:\n    def minStartValue(self nums: List[int]) -> int:\n        return max(1 1 - min(accumulate(nums)))
Minimum Weighted Subgraph With the Required Paths,###  2203\. Minimum Weighted Subgraph With the Required Paths\n\nYou are given an integer `n` denoting the number of nodes of a **weighted\ndirected** graph. The nodes are numbered from `0` to `n - 1`.\n\nYou are also given a 2D integer array `edges` where `edges[i] = [fromi toi\nweighti]` denotes that there exists a **directed** edge from `fromi` to `toi`\nwith weight `weighti`.\n\nLastly you are given three **distinct** integers `src1` `src2` and `dest`\ndenoting three distinct nodes of the graph.\n\nReturn _the**minimum weight** of a subgraph of the graph such that it is\n**possible** to reach_ `dest` _from both_ `src1` _and_ `src2` _via a set of\nedges of this subgraph_. In case such a subgraph does not exist return `-1`.\n\nA **subgraph** is a graph whose vertices and edges are subsets of the original\ngraph. The **weight** of a subgraph is the sum of weights of its constituent\nedges.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png)\n\n    \n    \n    **Input:** n = 6 edges = [[022][056][103][145][211][233][234][342][451]] src1 = 0 src2 = 1 dest = 5\n    **Output:** 9\n    **Explanation:**\n    The above figure represents the input graph.\n    The blue edges represent one of the subgraphs that yield the optimal answer.\n    Note that the subgraph [[103][056]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png)\n\n    \n    \n    **Input:** n = 3 edges = [[011][211]] src1 = 0 src2 = 1 dest = 2\n    **Output:** -1\n    **Explanation:**\n    The above figure represents the input graph.\n    It can be seen that there does not exist any path from node 1 to node 2 hence there are no subgraphs satisfying all the constraints.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= n <= 105`\n  * `0 <= edges.length <= 105`\n  * `edges[i].length == 3`\n  * `0 <= fromi toi src1 src2 dest <= n - 1`\n  * `fromi != toi`\n  * `src1` `src2` and `dest` are pairwise distinct.\n  * `1 <= weight[i] <= 105`\n\n,"class Solution:\n    def minimumWeight(self n edges s1 s2 dest):\n        G1 = defaultdict(list)\n        G2 = defaultdict(list)\n        for a b w in edges:\n            G1[a].append((b w))\n            G2[b].append((a w))\n\n        def Dijkstra(graph K):\n            q t = [(0 K)] {}\n            while q:\n                time node = heappop(q)\n                if node not in t:\n                    t[node] = time\n                    for v w in graph[node]:\n                        heappush(q (time + w v))\n            return [t.get(i float(""inf"")) for i in range(n)]\n        \n        arr1 = Dijkstra(G1 s1)\n        arr2 = Dijkstra(G1 s2)\n        arr3 = Dijkstra(G2 dest)\n        \n        ans = float(""inf"")\n        for i in range(n):\n            ans = min(ans arr1[i] + arr2[i] + arr3[i])\n        \n        return ans if ans != float(""inf"") else -1\n"
Minimum White Tiles After Covering With Carpets,"###  2209\. Minimum White Tiles After Covering With Carpets\n\nYou are given a **0-indexed binary** string `floor` which represents the\ncolors of tiles on a floor:\n\n  * `floor[i] = '0'` denotes that the `ith` tile of the floor is colored **black**.\n  * On the other hand `floor[i] = '1'` denotes that the `ith` tile of the floor is colored **white**.\n\nYou are also given `numCarpets` and `carpetLen`. You have `numCarpets`\n**black** carpets each of length `carpetLen` tiles. Cover the tiles with the\ngiven carpets such that the number of **white** tiles still visible is\n**minimum**. Carpets may overlap one another.\n\nReturn _the**minimum** number of white tiles still visible._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png)\n\n    \n    \n    **Input:** floor = ""10110101"" numCarpets = 2 carpetLen = 2\n    **Output:** 2\n    **Explanation:** \n    The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible.\n    No other way of covering the tiles with the carpets can leave less than 2 white tiles visible.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/02/10/ex2.png)\n\n    \n    \n    **Input:** floor = ""11111"" numCarpets = 2 carpetLen = 3\n    **Output:** 0\n    **Explanation:** \n    The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible.\n    Note that the carpets are able to overlap one another.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= carpetLen <= floor.length <= 1000`\n  * `floor[i]` is either `'0'` or `'1'`.\n  * `1 <= numCarpets <= 1000`\n\n","class Solution:\n    def minimumWhiteTiles(self floor: str numCarpets: int carpetLen: int) -> int:\n		n = len(floor)\n		#Using memo table to store predefined computations\n        memo = [[-1 for x in range(numCarpets+1)] for x in range(len(floor)+1)] \n        def solve(NnumCarpets):\n			#Base Case\n            if N>=n:\n                return 0\n			#If calculated previously use that solution\n            if memo[N][numCarpets]!=-1:\n                return memo[N][numCarpets]\n				\n            used = 0 # If you use the carpet\n            notused = 0 # If you donot use the carpet\n			\n            if floor[N]=='1': # We might use the carpet in this part\n                if numCarpets>0: #Whether we even have some carpets or not\n				    """"""\n					Optimization Part\n					We are finding the number of ones present in this part of the floor.\n					prefix[lastInd] - Number of ones till lastInd\n					prefix[N] - Number of ones till Nth Index.\n					\n					Their difference gives us how many ones present between the two.\n				    """"""\n                    lastInd = min(N+carpetLenlen(floor)) \n                    ans = prefix[lastInd] - prefix[N]\n                    \n					""""""\n					Find the max if we use or donot use carpet at this index\n					If we do we add  --- ans and decrement remaining carpets\n					else we donot\n					""""""\n                    used = max(solve(N+carpetLennumCarpets-1)+anssolve(N+1numCarpets))\n                            \n                else:\n                    used = 0\n            \n            else:\n			#If we donot use the carpet although I feel this might be redundant code\n                notused = solve(N+1numCarpets)\n            \n			#Using max function to find the number of white tiles removed\n            memo[N][numCarpets] = max(usednotused)\n            return memo[N][numCarpets]\n		\n		#Total White tiles\n        ones = 0\n        for x in floor:\n            if x == '1':\n                ones+=1\n        \n		#Using Prefix array to store number of ones till i th index\n        prefix = [0]*(n+1)\n        for i in range(1n+1):\n            if floor[i-1]=='1':\n                prefix[i] = prefix[i-1]+1\n            else:\n                prefix[i] = prefix[i-1]\n				\n       \n        removed = solve(0numCarpets)\n        \n        return ones-removed\n"
Minimum Window Substring,"###  76\. Minimum Window Substring\n\nGiven two strings `s` and `t` of lengths `m` and `n` respectively return\n_the**minimum window substring** of _`s` _such that every character in_`t`\n_(**including duplicates**) is included in the window. If there is no such\nsubstring_ _ return the empty string_`""""`_._\n\nThe testcases will be generated such that the answer is **unique**.\n\nA **substring** is a contiguous sequence of characters within the string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ADOBECODEBANC"" t = ""ABC""\n    **Output:** ""BANC""\n    **Explanation:** The minimum window substring ""BANC"" includes 'A' 'B' and 'C' from string t.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""a"" t = ""a""\n    **Output:** ""a""\n    **Explanation:** The entire string s is the minimum window.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""a"" t = ""aa""\n    **Output:** """"\n    **Explanation:** Both 'a's from t must be included in the window.\n    Since the largest window of s only has one 'a' return empty string.\n    \n\n\n\n**Constraints:**\n\n  * `m == s.length`\n  * `n == t.length`\n  * `1 <= m n <= 105`\n  * `s` and `t` consist of uppercase and lowercase English letters.\n\n\n\n**Follow up:** Could you find an algorithm that runs in `O(m + n)` time?\n\n",# Added on 2022-08-18 15:51:55.963915\n\nvar minWindow = function(s t) {\n    const tf = {} sf = {};\n    for(let c of t) {\n        tf[c] = (tf[c] || 0) + 1;\n    }\n    let l = 0 r = 0 rs = t.length;\n    let ml = -1 mr = -1;\n    for(; r < s.length; r++) {\n        const c = s[r];\n\n        if(!tf[c]) continue;\n\n        const sc = sf[c] || 0;\n        sf[c] = sc + 1;\n        if(sf[c] <= tf[c]) {\n            rs--;\n        }\n\n        if(rs == 0) {\n            while(true) {\n                if(mr == -1 || mr - ml > r - l) {\n                    [mr ml] = [r l];\n                }\n\n                const c = s[l];\n                if(!tf[c]) {\n                    l++;\n                }\n                else if(sf[c] - 1 < tf[c]) {\n                    sf[c]-- l++ rs++;\n                    break;\n                } else {\n                    sf[c]--;\n                    l++;\n                }\n            }\n        }\n    }\n    if(mr == -1) return '';\n    return s.slice(ml mr + 1);\n};
Minimum XOR Sum of Two Arrays,###  1879\. Minimum XOR Sum of Two Arrays\n\nYou are given two integer arrays `nums1` and `nums2` of length `n`.\n\nThe **XOR sum** of the two integer arrays is `(nums1[0] XOR nums2[0]) +\n(nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])`\n(**0-indexed**).\n\n  * For example the **XOR sum** of `[123]` and `[321]` is equal to `(1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4`.\n\nRearrange the elements of `nums2` such that the resulting **XOR sum** is\n**minimized**.\n\nReturn _the**XOR sum** after the rearrangement_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [12] nums2 = [23]\n    **Output:** 2\n    **Explanation:** Rearrange nums2 so that it becomes [32].\n    The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [103] nums2 = [534]\n    **Output:** 8\n    **Explanation:** Rearrange nums2 so that it becomes [543]. \n    The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums1.length`\n  * `n == nums2.length`\n  * `1 <= n <= 14`\n  * `0 <= nums1[i] nums2[i] <= 107`\n\n,"class Solution:\n    def minimumXORSum(self a: List[int] b: List[int]) -> int:\n        @cache\n        def dp(mask: int) -> int:\n            i = bin(mask).count(""1"")\n            if i >= len(a):\n                return 0\n            return min((a[i] ^ b[j]) + dp(mask + (1 << j)) \n                       for j in range(len(b)) if mask & (1 << j) == 0)\n        return dp(0)\n"
Mirror Reflection,###  858\. Mirror Reflection\n\nThere is a special square room with mirrors on each of the four walls. Except\nfor the southwest corner there are receptors on each of the remaining\ncorners numbered `0` `1` and `2`.\n\nThe square room has walls of length `p` and a laser ray from the southwest\ncorner first meets the east wall at a distance `q` from the `0th` receptor.\n\nGiven the two integers `p` and `q` return _the number of the receptor that\nthe ray meets first_.\n\nThe test cases are guaranteed so that the ray will meet a receptor eventually.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/18/reflection.png)\n\n    \n    \n    **Input:** p = 2 q = 1\n    **Output:** 2\n    **Explanation:** The ray meets receptor 2 the first time it gets reflected back to the left wall.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** p = 3 q = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= q <= p <= 1000`\n\n,class Solution:\n    def mirrorReflection(self p: int q: int) -> int:\n\n        L = lcm(pq)\n\n        if (L//q)%2 == 0:\n            return 2\n\n        return (L//p)%2
Missing Number,###  268\. Missing Number\n\nGiven an array `nums` containing `n` distinct numbers in the range `[0 n]`\nreturn _the only number in the range that is missing from the array._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [301]\n    **Output:** 2\n    **Explanation:** n = 3 since there are 3 numbers so all numbers are in the range [03]. 2 is the missing number in the range since it does not appear in nums.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [01]\n    **Output:** 2\n    **Explanation:** n = 2 since there are 2 numbers so all numbers are in the range [02]. 2 is the missing number in the range since it does not appear in nums.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [964235701]\n    **Output:** 8\n    **Explanation:** n = 9 since there are 9 numbers so all numbers are in the range [09]. 8 is the missing number in the range since it does not appear in nums.\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 104`\n  * `0 <= nums[i] <= n`\n  * All the numbers of `nums` are **unique**.\n\n\n\n**Follow up:** Could you implement a solution using only `O(1)` extra space\ncomplexity and `O(n)` runtime complexity?\n\n,class Solution:\n    def missingNumber(self nums: List[int]) -> int:\n        # T.C = O(n) S.C = O(1)\n        actualsum = 0\n        currentsum = 0\n        i = 1\n        for num in nums:\n            currentsum += num\n            actualsum += i\n            i += 1\n        \n        return actualsum - currentsum
Monotone Increasing Digits,###  738\. Monotone Increasing Digits\n\nAn integer has **monotone increasing digits** if and only if each pair of\nadjacent digits `x` and `y` satisfy `x <= y`.\n\nGiven an integer `n` return _the largest number that is less than or equal\nto_`n` _with**monotone increasing digits**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 9\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1234\n    **Output:** 1234\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 332\n    **Output:** 299\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 109`\n\n,# Runtime: 43 ms (Top 69.04%) | Memory: 13.9 MB (Top 20.57%)\nclass Solution:\n    def monotoneIncreasingDigits(self n: int) -> int:\n        num = list(str(n))\n        for i in range(len(num)-1):\n            # Step1: When don't meet the condition num[i]-=1 and repalce all num left into '9' and directly return\n            # However there is the case that num[i-1]==num[i] which will make num[i]-1<num[i-1]\n            # So traverse back to find the num that its num[i-1] != num[i](to make sure num[i-1]<=num[i]-1) then do step1 and return\n            if num[i] > num[i+1]:\n                while i >= 1 and num[i-1] == num[i]:\n                    i -= 1\n                num[i] = chr(ord(num[i])-1)\n                return int(''.join(num[:i+1]+['9']*(len(num)-i-1)))\n        return n
Monotonic Array,###  896\. Monotonic Array\n\nAn array is **monotonic** if it is either monotone increasing or monotone\ndecreasing.\n\nAn array `nums` is monotone increasing if for all `i <= j` `nums[i] <=\nnums[j]`. An array `nums` is monotone decreasing if for all `i <= j` `nums[i]\n>= nums[j]`.\n\nGiven an integer array `nums` return `true` _if the given array is monotonic\nor_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1223]\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [6544]\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [132]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-105 <= nums[i] <= 105`\n\n,class Solution:\n    def isMonotonic(self nums: List[int]) -> bool:\n        counter = 0\n        for i in range(len(nums) - 1):\n            if nums[i] >= nums[i + 1]:\n                counter += 1\n        if counter == len(nums) - 1:\n            return True\n        counter = 0\n        for i in range(len(nums) - 1):\n            if nums[i] <= nums[i + 1]:\n                counter += 1\n        if counter == len(nums) - 1:\n            return True\n        return False\n
Most Beautiful Item for Each Query,###  2070\. Most Beautiful Item for Each Query\n\nYou are given a 2D integer array `items` where `items[i] = [pricei beautyi]`\ndenotes the **price** and **beauty** of an item respectively.\n\nYou are also given a **0-indexed** integer array `queries`. For each\n`queries[j]` you want to determine the **maximum beauty** of an item whose\n**price** is **less than or equal** to `queries[j]`. If no such item exists\nthen the answer to this query is `0`.\n\nReturn _an array_`answer` _of the same length as_`queries`\n_where_`answer[j]`_is the answer to the_`jth` _query_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** items = [[12][32][24][56][35]] queries = [123456]\n    **Output:** [245566]\n    **Explanation:**\n    - For queries[0]=1 [12] is the only item which has price <= 1. Hence the answer for this query is 2.\n    - For queries[1]=2 the items which can be considered are [12] and [24]. \n      The maximum beauty among them is 4.\n    - For queries[2]=3 and queries[3]=4 the items which can be considered are [12] [32] [24] and [35].\n      The maximum beauty among them is 5.\n    - For queries[4]=5 and queries[5]=6 all items can be considered.\n      Hence the answer for them is the maximum beauty of all items i.e. 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** items = [[12][12][13][14]] queries = [1]\n    **Output:** [4]\n    **Explanation:** \n    The price of every item is equal to 1 so we choose the item with the maximum beauty 4. \n    Note that multiple items can have the same price and/or beauty.  \n    \n\n**Example 3:**\n\n    \n    \n    **Input:** items = [[101000]] queries = [5]\n    **Output:** [0]\n    **Explanation:**\n    No item has a price less than or equal to 5 so no item can be chosen.\n    Hence the answer to the query is 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= items.length queries.length <= 105`\n  * `items[i].length == 2`\n  * `1 <= pricei beautyi queries[j] <= 109`\n\n,# Runtime: 2544 ms (Top 32.35%) | Memory: 73.6 MB (Top 48.94%)\nclass Solution:\n    def maximumBeauty(self items: List[List[int]] queries: List[int]) -> List[int]:\n\n        items.sort()\n        dic = dict()\n        res = []\n        gmax = 0\n        for pb in items:\n            gmax = max(bgmax)\n            dic[p] = gmax\n\n        keys = sorted(dic.keys())\n        for q in queries:\n            ind = bisect.bisect_left(keysq)\n            if ind<len(keys) and keys[ind]==q:\n                res.append(dic[q])\n            elif ind==0:\n                res.append(0)\n            else:\n                res.append(dic[keys[ind-1]])\n\n        return res
Most Common Word,"###  819\. Most Common Word\n\nGiven a string `paragraph` and a string array of the banned words `banned`\nreturn _the most frequent word that is not banned_. It is **guaranteed** there\nis **at least one word** that is not banned and that the answer is\n**unique**.\n\nThe words in `paragraph` are **case-insensitive** and the answer should be\nreturned in **lowercase**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** paragraph = ""Bob hit a ball the hit BALL flew far after it was hit."" banned = [""hit""]\n    **Output:** ""ball""\n    **Explanation:** \n    ""hit"" occurs 3 times but it is a banned word.\n    ""ball"" occurs twice (and no other word does) so it is the most frequent non-banned word in the paragraph. \n    Note that words in the paragraph are not case sensitive\n    that punctuation is ignored (even if adjacent to words such as ""ball"") \n    and that ""hit"" isn't the answer even though it occurs more because it is banned.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** paragraph = ""a."" banned = []\n    **Output:** ""a""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= paragraph.length <= 1000`\n  * paragraph consists of English letters space `' '` or one of the symbols: `""!?';.""`.\n  * `0 <= banned.length <= 100`\n  * `1 <= banned[i].length <= 10`\n  * `banned[i]` consists of only lowercase English letters.\n\n","class Solution:\n    import string\n    from collections import Counter\n    def mostCommonWord(self paragraph: str banned: List[str]) -> str:\n        #sunday morning hangover solution haha\n        \n        #calling this twice seems unnecesary but whatevs\n        #replace """" with "" "" (apparently translate() is much quicker than replace)\n        para = paragraph.translate(str.maketrans("""""" ""))\n        #strip out rest of punctuation and make it lower case\n        para = para.translate(str.maketrans(' ' ' ' string.punctuation)).lower()\n        #split on the sapces\n        para = para.split()\n        #staple counter function\n        para_count = Counter(para)\n        #loop thru banned words if they're in para_count pop the off\n        for word in banned:\n            if word in para_count:\n                para_count.pop(word)\n        #return val from most common\n        return para_count.most_common(1)[0][0]\n"
Most Frequent Subtree Sum,###  508\. Most Frequent Subtree Sum\n\nGiven the `root` of a binary tree return the most frequent **subtree sum**.\nIf there is a tie return all the values with the highest frequency in any\norder.\n\nThe **subtree sum** of a node is defined as the sum of all the node values\nformed by the subtree rooted at that node (including the node itself).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg)\n\n    \n    \n    **Input:** root = [52-3]\n    **Output:** [2-34]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/freq2-tree.jpg)\n\n    \n    \n    **Input:** root = [52-5]\n    **Output:** [2]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `-105 <= Node.val <= 105`\n\n,"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findFrequentTreeSum(self root: Optional[TreeNode]) -> List[int]:\n        def dfs(root):\n            \n            if not root: return 0\n            \n            l = dfs(root.left)\n            r = dfs(root.right)\n            res = root.val + l + r\n            \n            d[res] += 1\n            return res\n        \n        d = collections.Counter()\n        dfs(root)\n        maxi = max(d.values())\n        return [i for i in d if d[i] == maxi]\n        \n		# An Upvote will be encouraging\n        \n        \n"
Most Visited Sector in  a Circular Track,###  1560\. Most Visited Sector in a Circular Track\n\nGiven an integer `n` and an integer array `rounds`. We have a circular track\nwhich consists of `n` sectors labeled from `1` to `n`. A marathon will be held\non this track the marathon consists of `m` rounds. The `ith` round starts at\nsector `rounds[i - 1]` and ends at sector `rounds[i]`. For example round 1\nstarts at sector `rounds[0]` and ends at sector `rounds[1]`\n\nReturn _an array of the most visited sectors_ sorted in **ascending** order.\n\nNotice that you circulate the track in ascending order of sector numbers in\nthe counter-clockwise direction (See the first example).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/14/tmp.jpg)\n\n    \n    \n    **Input:** n = 4 rounds = [1312]\n    **Output:** [12]\n    **Explanation:** The marathon starts at sector 1. The order of the visited sectors is as follows:\n    1 --> 2 --> 3 (end of round 1) --> 4 --> 1 (end of round 2) --> 2 (end of round 3 and the marathon)\n    We can see that both sectors 1 and 2 are visited twice and they are the most visited sectors. Sectors 3 and 4 are visited only once.\n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 rounds = [212121212]\n    **Output:** [2]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 7 rounds = [1357]\n    **Output:** [1234567]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 100`\n  * `1 <= m <= 100`\n  * `rounds.length == m + 1`\n  * `1 <= rounds[i] <= n`\n  * `rounds[i] != rounds[i + 1]` for `0 <= i < m`\n\n,class Solution:\n    def mostVisited(self n: int rounds: List[int]) -> List[int]:\n        hash_map = {}\n        for i in range(0  len(rounds)-1):\n            if i == 0:\n                start = rounds[i]\n            elif rounds[i] == n:\n                start = 1\n            else:\n                start = rounds[i] + 1\n            end = rounds[i+1]\n            if start <= end:\n                for i in range(start  end + 1):\n                    if i in hash_map:\n                        hash_map[i] += 1\n                    else:\n                        hash_map[i] = 1\n            else:\n                for i in range(start  n + 1):\n                    if i in hash_map:\n                        hash_map[i] += 1\n                    else:\n                        hash_map[i] = 1\n                for i in range(1  end + 1):\n                    if i in hash_map:\n                        hash_map[i] += 1\n                    else:\n                        hash_map[i] = 1\n        k = list(hash_map.keys())\n        v = list(hash_map.values())\n        ans = []\n        m = -1\n        i = 0\n        j = 0\n        while i < len(k) and j < len(v):\n            if len(ans) == 0:\n                ans.append(k[i])\n                m = v[j]\n            elif m < v[j]:\n                ans = []\n                ans.append(k[i])\n                m = v[j]\n            elif m == v[j]:\n                ans.append(k[i])\n            i += 1\n            j += 1\n        ans = sorted(ans)\n        return ans\n\n
Move Zeroes,###  283\. Move Zeroes\n\nGiven an integer array `nums` move all `0`'s to the end of it while\nmaintaining the relative order of the non-zero elements.\n\n**Note** that you must do this in-place without making a copy of the array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [010312]\n    **Output:** [131200]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0]\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-231 <= nums[i] <= 231 - 1`\n\n\n\n**Follow up:** Could you minimize the total number of operations done?\n\n,"# Runtime: 408 ms (Top 21.69%) | Memory: 15.6 MB (Top 65.11%)\nclass Solution:\n    def moveZeroes(self nums: List[int]) -> None:\n        """"""\n        Do not return anything modify nums in-place instead.\n\n        """"""\n        notzero = 0\n        zero = 0\n\n        while notzero < len(nums):\n            if nums[notzero] != 0:\n                nums[zero]  nums[notzero] = nums[notzero] nums[zero]\n                zero += 1\n            notzero += 1"
Moving Stones Until Consecutive II,###  1040\. Moving Stones Until Consecutive II\n\nThere are some stones in different positions on the X-axis. You are given an\ninteger array `stones` the positions of the stones.\n\nCall a stone an **endpoint stone** if it has the smallest or largest position.\nIn one move you pick up an **endpoint stone** and move it to an unoccupied\nposition so that it is no longer an **endpoint stone**.\n\n  * In particular if the stones are at say `stones = [125]` you cannot move the endpoint stone at position `5` since moving it to any position (such as `0` or `3`) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e. the stones are in\nthree consecutive positions).\n\nReturn _an integer array_`answer` _of length_`2` _where_ :\n\n  * `answer[0]` _is the minimum number of moves you can play and_\n  * `answer[1]` _is the maximum number of moves you can play_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** stones = [749]\n    **Output:** [12]\n    **Explanation:** We can move 4 -> 8 for one move to finish the game.\n    Or we can move 9 -> 5 4 -> 6 for two moves to finish the game.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** stones = [654310]\n    **Output:** [23]\n    **Explanation:** We can move 3 -> 8 then 10 -> 7 to finish the game.\n    Or we can move 3 -> 7 4 -> 8 5 -> 9 to finish the game.\n    Notice we cannot move 10 -> 2 to finish the game because that would be an illegal move.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= stones.length <= 104`\n  * `1 <= stones[i] <= 109`\n  * All the values of `stones` are **unique**.\n\n,// Runtime: 100 ms (Top 85.48%) | Memory: 18.80 MB (Top 11.29%)\n\nclass Solution:\n    '''\n        Test cases walk through \n        Given 7 4 9 prove 1 2                                                            6 5 4 3 10 prove 2 3 \n\n        Sort stones -> 4 7 9                                                              3 4 5 6 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0 so we cannot return for sure                                          Move penultimate is 0 so move final is assured \n                                                                                            This means we can return [min(2 3) 3] -> [2 3]\n\n        Max legal moves is 0                                                                For completeness max legal moves is 0 max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0 stone is 4                                                             index is 0 stone is 3 \n            stones[0] lte 4 - 3 ? No skip while loop                                          stones[0] lte 3 - 5 ? No skip while \n            max legal moves is min of (max of self and 0 - 0 + 1 most moves)                  max legal moves is min of (max of self and 0 - 0 + 1) max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1 stone is 7                                                             index is 1 stone is 4 \n            stones[0] <= 7 - 3 ? Yes enter while                                              stones[0] lte 4 - 5 ? No skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1) max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1) max_moves \n                -> max legal moves is 1                                                        index is 2 stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2 stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1) max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1) max_moves\n                 -> max legal moves is 2                                                       index is 3 stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1) max_moves -> max legal moves is 3 \n        Return [3 - 2 2] -> [1 2] checks out                                                  \n                                                                                               index is 4 stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1) max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3 3] -> [2 3]\n    '''\n    def numMovesStonesII(self stones: List[int]) -> List[int] :\n        # order does not need to be maintained so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate move_final)\n        # since the stones are unique if either is 0 the one that we have must be max legal moves \n        # if move penultimate is 0 that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone which must be at least one larger than the largest less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a b c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1 b is 2 and c is 3  \n        # in this case move final is also 0 so we get 0 0 \n        # if a = 4 b = 5 c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0 and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2 we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2 most_moves)\n            return [min_legal_moves most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves index - starting_index + 1) most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves most_moves]\n
Multiply Strings,"###  43\. Multiply Strings\n\nGiven two non-negative integers `num1` and `num2` represented as strings\nreturn the product of `num1` and `num2` also represented as a string.\n\n**Note:**  You must not use any built-in BigInteger library or convert the\ninputs to integer directly.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num1 = ""2"" num2 = ""3""\n    **Output:** ""6""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num1 = ""123"" num2 = ""456""\n    **Output:** ""56088""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num1.length num2.length <= 200`\n  * `num1` and `num2` consist of digits only.\n  * Both `num1` and `num2` do not contain any leading zero except the number `0` itself.\n\n",class Solution:\n    def multiply(self num1: str num2: str) -> str:\n        def convertToInt(numStr):\n            currNum = 0\n            N = len(numStr)\n            for i in range(N - 1 -1 -1):\n                digit = ord(numStr[i]) - ord('0')\n                currNum += pow(10 N-i-1) * digit\n                \n            return currNum\n        \n        n1 = convertToInt(num1)\n        n2 = convertToInt(num2)\n        return str(n1 * n2)\n      \n
My Calendar I,"###  729\. My Calendar I\n\nYou are implementing a program to use as your calendar. We can add a new event\nif adding the event will not cause a **double booking**.\n\nA **double booking** happens when two events have some non-empty intersection\n(i.e. some moment is common to both events.).\n\nThe event can be represented as a pair of integers `start` and `end` that\nrepresents a booking on the half-open interval `[start end)` the range of\nreal numbers `x` such that `start <= x < end`.\n\nImplement the `MyCalendar` class:\n\n  * `MyCalendar()` Initializes the calendar object.\n  * `boolean book(int start int end)` Returns `true` if the event can be added to the calendar successfully without causing a **double booking**. Otherwise return `false` and do not add the event to the calendar.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MyCalendar"" ""book"" ""book"" ""book""]\n    [[] [10 20] [15 25] [20 30]]\n    **Output**\n    [null true false true]\n    \n    **Explanation**\n    MyCalendar myCalendar = new MyCalendar();\n    myCalendar.book(10 20); // return True\n    myCalendar.book(15 25); // return False It can not be booked because time 15 is already booked by another event.\n    myCalendar.book(20 30); // return True The event can be booked as the first event takes every time less than 20 but not including 20.\n\n\n\n**Constraints:**\n\n  * `0 <= start < end <= 109`\n  * At most `1000` calls will be made to `book`.\n\n",class MyCalendar(object):\n    def __init__(self):\n        self.booking = []\n\n    def book(self start end):\n        for i j in self.booking:\n            if i < end and start < j:\n                return False\n        self.booking.append((start end))\n        return True\n
My Calendar II,"###  731\. My Calendar II\n\nYou are implementing a program to use as your calendar. We can add a new event\nif adding the event will not cause a **triple booking**.\n\nA **triple booking** happens when three events have some non-empty\nintersection (i.e. some moment is common to all the three events.).\n\nThe event can be represented as a pair of integers `start` and `end` that\nrepresents a booking on the half-open interval `[start end)` the range of\nreal numbers `x` such that `start <= x < end`.\n\nImplement the `MyCalendarTwo` class:\n\n  * `MyCalendarTwo()` Initializes the calendar object.\n  * `boolean book(int start int end)` Returns `true` if the event can be added to the calendar successfully without causing a **triple booking**. Otherwise return `false` and do not add the event to the calendar.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MyCalendarTwo"" ""book"" ""book"" ""book"" ""book"" ""book"" ""book""]\n    [[] [10 20] [50 60] [10 40] [5 15] [5 10] [25 55]]\n    **Output**\n    [null true true true false true true]\n    \n    **Explanation**\n    MyCalendarTwo myCalendarTwo = new MyCalendarTwo();\n    myCalendarTwo.book(10 20); // return True The event can be booked. \n    myCalendarTwo.book(50 60); // return True The event can be booked. \n    myCalendarTwo.book(10 40); // return True The event can be double booked. \n    myCalendarTwo.book(5 15);  // return False The event cannot be booked because it would result in a triple booking.\n    myCalendarTwo.book(5 10); // return True The event can be booked as it does not use time 10 which is already double booked.\n    myCalendarTwo.book(25 55); // return True The event can be booked as the time in [25 40) will be double booked with the third event the time [40 50) will be single booked and the time [50 55) will be double booked with the second event.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= start < end <= 109`\n  * At most `1000` calls will be made to `book`.\n\n",// Runtime: 175 ms (Top 97.99%) | Memory: 17.50 MB (Top 58.54%)\n\nclass Node:\n    def __init__(self start end val):\n        self.start = start\n        self.end = end\n        self.val = val\n        self.left = None\n        self.right = None\n    \n    def insertable(self node):\n        if node.end <= node.start:\n            return True\n        if node.end <= self.start:\n            if not self.left:\n                return True\n            else:\n                return self.left.insertable(node)\n        elif node.start >= self.end:\n            if not self.right:\n                return True\n            else:\n                return self.right.insertable(node)\n        else:\n            if self.val == 1:\n                leftS = min(self.start node.start)\n                leftE = max(self.start node.start)\n                rightS = min(self.end node.end)\n                rightE = max(self.end node.end)\n                if not self.left and not self.right:\n                    return True\n                elif not self.left:\n                    return self.right.insertable(Node(rightS rightE 1))\n                elif not self.right:\n                    return self.left.insertable(Node(leftS leftE 1))\n                else:\n                    resL = self.left.insertable(Node(leftS leftE 1))\n                    resR = self.right.insertable(Node(rightS rightE 1))\n                    if resL and resR:\n                        return True\n                    return False\n            else:\n                return False\n\n    def insert(self node):\n        if node.end <= node.start:\n            return\n        \n        if node.end <= self.start:\n            if not self.left:\n                self.left = node\n            else:\n                self.left.insert(node)\n        elif node.start >= self.end:\n            if not self.right:\n                self.right = node\n            else:\n                self.right.insert(node)\n        else:\n            leftS = min(self.start node.start)\n            leftE = max(self.start node.start)\n            rightS = min(self.end node.end)\n            rightE = max(self.end node.end)\n            self.val += 1\n            self.start self.end = leftE rightS  \n            if not self.left and not self.right:  \n                self.left = Node(leftS leftE 1) if leftS < leftE else None\n                self.right = Node(rightS rightE 1) if rightS < rightE else None\n            elif not self.left:\n                self.left = Node(leftS leftE 1) if leftS < leftE else None\n                self.right.insert(Node(rightS rightE 1))\n            elif not self.right:\n                self.right = Node(rightS rightE 1) if rightS < rightE else None\n                self.left.insert(Node(leftS leftE 1))\n            else:\n                self.left.insert(Node(leftS leftE 1))\n                self.right.insert(Node(rightS rightE 1))\n        return\n\n\nclass MyCalendarTwo:\n\n    def __init__(self):\n        self.root = None\n\n    def book(self start: int end: int) -> bool:\n        if not self.root:\n            self.root = Node(start end 1)\n            return True\n        else:\n            newNode = Node(start end 1)\n            if self.root.insertable(newNode):\n                self.root.insert(newNode)\n                return True\n            return False\n
My Calendar III,"###  732\. My Calendar III\n\nA `k`-booking happens when `k` events have some non-empty intersection (i.e.\nthere is some time that is common to all `k` events.)\n\nYou are given some events `[start end)` after each given event return an\ninteger `k` representing the maximum `k`-booking between all the previous\nevents.\n\nImplement the `MyCalendarThree` class:\n\n  * `MyCalendarThree()` Initializes the object.\n  * `int book(int start int end)` Returns an integer `k` representing the largest integer such that there exists a `k`-booking in the calendar.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MyCalendarThree"" ""book"" ""book"" ""book"" ""book"" ""book"" ""book""]\n    [[] [10 20] [50 60] [10 40] [5 15] [5 10] [25 55]]\n    **Output**\n    [null 1 1 2 3 3 3]\n    \n    **Explanation**\n    MyCalendarThree myCalendarThree = new MyCalendarThree();\n    myCalendarThree.book(10 20); // return 1 The first event can be booked and is disjoint so the maximum k-booking is a 1-booking.\n    myCalendarThree.book(50 60); // return 1 The second event can be booked and is disjoint so the maximum k-booking is a 1-booking.\n    myCalendarThree.book(10 40); // return 2 The third event [10 40) intersects the first event and the maximum k-booking is a 2-booking.\n    myCalendarThree.book(5 15); // return 3 The remaining events cause the maximum K-booking to be only a 3-booking.\n    myCalendarThree.book(5 10); // return 3\n    myCalendarThree.book(25 55); // return 3\n    \n\n\n\n**Constraints:**\n\n  * `0 <= start < end <= 109`\n  * At most `400` calls will be made to `book`.\n\n",import bisect\nclass MyCalendarThree:\n\n    def __init__(self):\n        self.events = []        \n\n    def book(self start: int end: int) -> int:\n        L R = 1 0\n        bisect.insort(self.events (start L))\n        bisect.insort(self.events (end R))\n        res = 0\n        cnt = 0\n        for _ state in self.events:\n            #if an interval starts increase the counter\n            #othewise decreas the counter\n            cnt += 1 if state == L else -1\n            res = max(res cnt)\n        return res
N-ary Tree Level Order Traversal,###  429\. N-ary Tree Level Order Traversal\n\nGiven an n-ary tree return the _level order_ traversal of its nodes' values.\n\n_Nary-Tree input serialization is represented in their level order traversal\neach group of children is separated by the null value (See examples)._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n\n    \n    \n    **Input:** root = [1null324null56]\n    **Output:** [[1][324][56]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n\n    \n    \n    **Input:** root = [1null2345nullnull67null8null910nullnull11null12null13nullnull14]\n    **Output:** [[1][2345][678910][111213][14]]\n    \n\n\n\n**Constraints:**\n\n  * The height of the n-ary tree is less than or equal to `1000`\n  * The total number of nodes is between `[0 104]`\n\n,from collections import defaultdict\nclass Solution:\n    def levelOrder(self root: 'Node') -> List[List[int]]:\n        self.d=defaultdict(list)\n        def check(rootind):\n            self.d[ind].append(root.val)\n            if root.children:\n                for x in root.children:\n                    check(xind+1)\n        if root==None:\n            return []\n        check(root0)\n        l=[]\n        for x in sorted(self.d.keys()):\n            l.append(self.d[x])\n        return l\n
N-ary Tree Postorder Traversal,###  590\. N-ary Tree Postorder Traversal\n\nGiven the `root` of an n-ary tree return _the postorder traversal of its\nnodes' values_.\n\nNary-Tree input serialization is represented in their level order traversal.\nEach group of children is separated by the null value (See examples)\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n\n    \n    \n    **Input:** root = [1null324null56]\n    **Output:** [563241]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n\n    \n    \n    **Input:** root = [1null2345nullnull67null8null910nullnull11null12null13nullnull14]\n    **Output:** [2614117312841391051]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 104]`.\n  * `0 <= Node.val <= 104`\n  * The height of the n-ary tree is less than or equal to `1000`.\n\n\n\n**Follow up:** Recursive solution is trivial could you do it iteratively?\n\n,"""\n# Definition for a Node.\nclass Node:\n    def __init__(self val=None children=None):\n        self.val = val\n        self.children = children\n""\n\nclass Solution:\n    def postorder(self root: 'Node') -> List[int]:\n        ans=[]\n        def post(root):\n            nonlocal ans\n            if not root:\n                return\n            for i in root.children:\n                post(i)\n            ans.append(root.val)\n        post(root)\n        return ans\n"
N-ary Tree Preorder Traversal,###  589\. N-ary Tree Preorder Traversal\n\nGiven the `root` of an n-ary tree return _the preorder traversal of its\nnodes' values_.\n\nNary-Tree input serialization is represented in their level order traversal.\nEach group of children is separated by the null value (See examples)\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)\n\n    \n    \n    **Input:** root = [1null324null56]\n    **Output:** [135624]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)\n\n    \n    \n    **Input:** root = [1null2345nullnull67null8null910nullnull11null12null13nullnull14]\n    **Output:** [1236711144812591310]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 104]`.\n  * `0 <= Node.val <= 104`\n  * The height of the n-ary tree is less than or equal to `1000`.\n\n\n\n**Follow up:** Recursive solution is trivial could you do it iteratively?\n\n,function preorder(root: Node | null): number[] {\n  const res: number[] = [];\n\n  const getNodeVal = (node: Node | null): void => {\n    if (node) {\n      res.push(node.val);\n\n      for (let i = 0; i < node.children.length; i++) {\n        getNodeVal(node.children[i]);\n      }\n    }\n  };\n\n  getNodeVal(root);\n\n  return res;\n}\n\n
N-Queens,"###  51\. N-Queens\n\nThe **n-queens** puzzle is the problem of placing `n` queens on an `n x n`\nchessboard such that no two queens attack each other.\n\nGiven an integer `n` return _all distinct solutions to the**n-queens\npuzzle**_. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens'\nplacement where `'Q'` and `'.'` both indicate a queen and an empty space\nrespectively.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)\n\n    \n    \n    **Input:** n = 4\n    **Output:** [["".Q..""""...Q""""Q...""""..Q.""][""..Q.""""Q...""""...Q"""".Q..""]]\n    **Explanation:** There exist two distinct solutions to the 4-queens puzzle as shown above\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** [[""Q""]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 9`\n\n","class Solution:\n    def solveNQueens(self n: int) -> List[List[str]]:\n        coord = self.findNextRows(0 n)\n        ans = []\n        for c in coord:\n            temp = []\n            for j in c:\n                temp.append("".""*j+""Q""+"".""*(n-j-1))\n            ans.append(temp)\n        return ans\n                        \n    def findNextRows(self i n h_occ=set() d_occ=set() ad_occ=set()):\n		'''\n		h_occ: occupied horizontal coordinate\n		d_occ: occupied diagonal\n		ad_occ: occupied anti-diagonal\n		'''\n        ans = []\n        if i==n:\n            return [[]]\n        for j in range(n):\n             if (j not in h_occ) and (j-i not in d_occ) and ((j-n+1)+i not in ad_occ):\n                    h_occ.add(j)\n                    d_occ.add(j-i)\n                    ad_occ.add((j-n+1)+i)\n                    temp = self.findNextRows(i+1 n h_occ d_occ ad_occ)\n                    h_occ.remove(j)\n                    d_occ.remove(j-i)\n                    ad_occ.remove((j-n+1)+i)\n                    ans += [[j]+l for l in temp]\n        return ans\n                \n                \n"
N-th Tribonacci Number,###  1137\. N-th Tribonacci Number\n\nThe Tribonacci sequence Tn is defined as follows:\n\nT0 = 0 T1 = 1 T2 = 1 and Tn+3 = Tn \+ Tn+1 \+ Tn+2 for n >= 0.\n\nGiven `n` return the value of Tn.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** 4\n    **Explanation:**\n    T_3 = 0 + 1 + 1 = 2\n    T_4 = 1 + 1 + 2 = 4\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 25\n    **Output:** 1389537\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 37`\n  * The answer is guaranteed to fit within a 32-bit integer ie. `answer <= 2^31 - 1`.\n\n,class Solution:\n    def tribonacci(self n: int q={}) -> int:\n        if n<3:\n            q[0]=0 #Initialize first 3 values \n            q[1]=1\n            q[2]=1\n        if n not in q:  #Have faith that last 3 calls will give the answer :)\n            q[n]=self.tribonacci(n-1q)+self.tribonacci(n-2q)+self.tribonacci(n-3q)\n        return q[n]\n
Naming a Company,"###  2306\. Naming a Company\n\nYou are given an array of strings `ideas` that represents a list of names to\nbe used in the process of naming a company. The process of naming a company is\nas follows:\n\n  1. Choose 2 **distinct** names from `ideas` call them `ideaA` and `ideaB`.\n  2. Swap the first letters of `ideaA` and `ideaB` with each other.\n  3. If **both** of the new names are not found in the original `ideas` then the name `ideaA ideaB` (the **concatenation** of `ideaA` and `ideaB` separated by a space) is a valid company name.\n  4. Otherwise it is not a valid name.\n\nReturn _the number of**distinct** valid names for the company_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** ideas = [""coffee""""donuts""""time""""toffee""]\n    **Output:** 6\n    **Explanation:** The following selections are valid:\n    - (""coffee"" ""donuts""): The company name created is ""doffee conuts"".\n    - (""donuts"" ""coffee""): The company name created is ""conuts doffee"".\n    - (""donuts"" ""time""): The company name created is ""tonuts dime"".\n    - (""donuts"" ""toffee""): The company name created is ""tonuts doffee"".\n    - (""time"" ""donuts""): The company name created is ""dime tonuts"".\n    - (""toffee"" ""donuts""): The company name created is ""doffee tonuts"".\n    Therefore there are a total of 6 distinct company names.\n    \n    The following are some examples of invalid selections:\n    - (""coffee"" ""time""): The name ""toffee"" formed after swapping already exists in the original array.\n    - (""time"" ""toffee""): Both names are still the same after swapping and exist in the original array.\n    - (""coffee"" ""toffee""): Both names formed after swapping already exist in the original array.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** ideas = [""lack""""back""]\n    **Output:** 0\n    **Explanation:** There are no valid selections. Therefore 0 is returned.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= ideas.length <= 5 * 104`\n  * `1 <= ideas[i].length <= 10`\n  * `ideas[i]` consists of lowercase English letters.\n  * All the strings in `ideas` are **unique**.\n\n","class Solution:\n    def distinctNames(self ideas: List[str]) -> int:\n        \n        names=defaultdict(set)\n        res=0  \n        \n        #to store first letter as key and followed suffix as val\n        for i in ideas:\n            names[i[0]].add(i[1:])\n            \n        #list of distinct first-letters available in ideas (may or may not contain all alphabetsdepends upon elements in ideas)\n        arr=list(names.keys())\n        ansn=0len(arr)\n        \n        for i in range(n):\n            for j in range(i+1n):\n                #ab => 2 distinct first letters\n                ab=arr[i]arr[j]\n                # adding the number of distinct posssible suffixes and multiplying by 2 as the new word formed might be ""newword1 newword2"" or ""newword2 newword1""\n                res+=len(names[a]-names[b])*len(names[b]-names[a])*2\n                \n        return res\n	\n"
New 21 Game,"###  837\. New 21 Game\n\nAlice plays the following game loosely based on the card game **""21""**.\n\nAlice starts with `0` points and draws numbers while she has less than `k`\npoints. During each draw she gains an integer number of points randomly from\nthe range `[1 maxPts]` where `maxPts` is an integer. Each draw is\nindependent and the outcomes have equal probabilities.\n\nAlice stops drawing numbers when she gets `k` **or more points**.\n\nReturn the probability that Alice has `n` or fewer points.\n\nAnswers within `10-5` of the actual answer are considered accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 10 k = 1 maxPts = 10\n    **Output:** 1.00000\n    **Explanation:** Alice gets a single card then stops.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 6 k = 1 maxPts = 10\n    **Output:** 0.60000\n    **Explanation:** Alice gets a single card then stops.\n    In 6 out of 10 possibilities she is at or below 6 points.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 21 k = 17 maxPts = 10\n    **Output:** 0.73278\n    \n\n\n\n**Constraints:**\n\n  * `0 <= k <= n <= 104`\n  * `1 <= maxPts <= 104`\n\n",# Runtime: 110 ms (Top 69.47%) | Memory: 14.5 MB (Top 12.98%)\nclass Solution:\n    def new21Game(self n: int k: int maxPts: int) -> float:\n        dp = collections.deque([float(i <= n) for i in range(k k + maxPts)])\n        s = sum(dp)\n        for i in range(k):\n            dp.appendleft(s / maxPts)\n            s += dp[0] - dp.pop()\n\n        return dp[0]
Next Greater Element I,###  496\. Next Greater Element I\n\nThe **next greater element** of some element `x` in an array is the **first\ngreater** element that is **to the right** of `x` in the same array.\n\nYou are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`\nwhere `nums1` is a subset of `nums2`.\n\nFor each `0 <= i < nums1.length` find the index `j` such that `nums1[i] ==\nnums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`.\nIf there is no next greater element then the answer for this query is `-1`.\n\nReturn _an array_`ans` _of length_`nums1.length` _such that_`ans[i]`_is\nthe**next greater element** as described above._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [412] nums2 = [1342]\n    **Output:** [-13-1]\n    **Explanation:** The next greater element for each value of nums1 is as follows:\n    - 4 is underlined in nums2 = [13_4_ 2]. There is no next greater element so the answer is -1.\n    - 1 is underlined in nums2 = [_1_ 342]. The next greater element is 3.\n    - 2 is underlined in nums2 = [134_2_]. There is no next greater element so the answer is -1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [24] nums2 = [1234]\n    **Output:** [3-1]\n    **Explanation:** The next greater element for each value of nums1 is as follows:\n    - 2 is underlined in nums2 = [1_2_ 34]. The next greater element is 3.\n    - 4 is underlined in nums2 = [123_4_]. There is no next greater element so the answer is -1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length <= nums2.length <= 1000`\n  * `0 <= nums1[i] nums2[i] <= 104`\n  * All integers in `nums1` and `nums2` are **unique**.\n  * All the integers of `nums1` also appear in `nums2`.\n\n\n\n**Follow up:** Could you find an `O(nums1.length + nums2.length)` solution?\n\n,// Runtime: 50 ms (Top 80.48%) | Memory: 16.70 MB (Top 24.94%)\n\nclass Solution:\n    def nextGreaterElement(self nums1 nums2):\n        dic stack = {} []\n        \n        for num in nums2[::-1]:\n            while stack and num > stack[-1]:\n                stack.pop()\n            if stack:\n                dic[num] = stack[-1]\n            stack.append(num)\n            \n        return [dic.get(num -1) for num in nums1]\n
Next Greater Element II,###  503\. Next Greater Element II\n\nGiven a circular integer array `nums` (i.e. the next element of\n`nums[nums.length - 1]` is `nums[0]`) return _the**next greater number** for\nevery element in_ `nums`.\n\nThe **next greater number** of a number `x` is the first greater number to its\ntraversing-order next in the array which means you could search circularly to\nfind its next greater number. If it doesn't exist return `-1` for this\nnumber.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [121]\n    **Output:** [2-12]\n    Explanation: The first 1's next greater number is 2; \n    The number 2 can't find next greater number. \n    The second 1's next greater number needs to search circularly which is also 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12343]\n    **Output:** [234-14]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-109 <= nums[i] <= 109`\n\n,// Runtime: 151 ms (Top 99.29%) | Memory: 19.30 MB (Top 5.84%)\n\nclass Solution:\n    def nextGreaterElements(self nums: List[int]) -> List[int]:\n        st = []\n        n = len(nums)\n        ans = [-1] * n\n        for i in range(2*n-1 -1 -1):\n            while st and st[-1] <= nums[i%n]:\n                st.pop()\n            if st and i < n:\n                ans[i] = st[-1]\n            st.append(nums[i%n])\n        return ans\n
Next Greater Element III,###  556\. Next Greater Element III\n\nGiven a positive integer `n` find _the smallest integer which has exactly the\nsame digits existing in the integer_ `n` _and is greater in value than_ `n`.\nIf no such positive integer exists return `-1`.\n\n**Note** that the returned integer should fit in **32-bit integer**  if there\nis a valid answer but it does not fit in **32-bit integer**  return `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 12\n    **Output:** 21\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 21\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 231 - 1`\n\n,// Runtime: 42 ms (Top 26.09%) | Memory: 16.30 MB (Top 30.04%)\n\nclass Solution:\n    def nextGreaterElement(self n):\n        digits = list(str(n))\n        i = len(digits) - 1\n        while i-1 >= 0 and digits[i] <= digits[i-1]:\n            i -= 1\n            \n        if i == 0: return -1\n        \n        j = i\n        while j+1 < len(digits) and digits[j+1] > digits[i-1]:\n            j += 1\n        \n        digits[i-1] digits[j] = digits[j] digits[i-1]\n        digits[i:] = digits[i:][::-1]\n        ret = int(''.join(digits))\n        \n        return ret if ret < 1<<31 else -1\n
Next Greater Node In Linked List,###  1019\. Next Greater Node In Linked List\n\nYou are given the `head` of a linked list with `n` nodes.\n\nFor each node in the list find the value of the **next greater node**. That\nis for each node find the value of the first node that is next to it and has\na **strictly larger** value than it.\n\nReturn an integer array `answer` where `answer[i]` is the value of the next\ngreater node of the `ith` node (**1-indexed**). If the `ith` node does not\nhave a next greater node set `answer[i] = 0`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg)\n\n    \n    \n    **Input:** head = [215]\n    **Output:** [550]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg)\n\n    \n    \n    **Input:** head = [27435]\n    **Output:** [70550]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is `n`.\n  * `1 <= n <= 104`\n  * `1 <= Node.val <= 109`\n\n,class Solution:\n    def nextLargerNodes(self head: Optional[ListNode]) -> List[int]:\n        stack = []\n        ans = []\n        node = head\n        \n        i = 0\n        while node is not None:\n            while stack and stack[-1][0] < node.val:\n                ans[stack[-1][1]] = node.val\n                stack.pop()\n            \n            stack.append((node.val i))\n            ans.append(0)\n            i += 1\n            node = node.next\n            \n        return ans
Next Greater Numerically Balanced Number,###  2048\. Next Greater Numerically Balanced Number\n\nAn integer `x` is **numerically balanced** if for every digit `d` in the\nnumber `x` there are **exactly** `d` occurrences of that digit in `x`.\n\nGiven an integer `n` return _the**smallest numerically balanced** number\n**strictly greater** than _`n` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 22\n    **Explanation:** \n    22 is numerically balanced since:\n    - The digit 2 occurs 2 times. \n    It is also the smallest numerically balanced number strictly greater than 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1000\n    **Output:** 1333\n    **Explanation:** \n    1333 is numerically balanced since:\n    - The digit 1 occurs 1 time.\n    - The digit 3 occurs 3 times. \n    It is also the smallest numerically balanced number strictly greater than 1000.\n    Note that 1022 cannot be the answer because 0 appeared more than 0 times.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3000\n    **Output:** 3133\n    **Explanation:** \n    3133 is numerically balanced since:\n    - The digit 1 occurs 1 time.\n    - The digit 3 occurs 3 times.\n    It is also the smallest numerically balanced number strictly greater than 3000.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 106`\n\n,"class Solution:\n    def nextBeautifulNumber(self n: int) -> int:\n        n_digits = len(str(n))\n        \n        next_max = {\n            1: [1]\n            2: [22]\n            3: [122 333]\n            4: [1333 4444]\n            5: [14444 22333 55555]\n            6: [122333 224444 666666 155555]\n            7: [1224444 2255555 3334444 1666666 7777777]\n                }\n        \n        if n >= int(str(n_digits) * n_digits):\n            n_digits += 1\n            return min(next_max[n_digits])\n        \n        ans = float('inf')\n        for num in sorted(next_max[n_digits]):      \n            cands = set(permutations(str(num)))\n            cands = sorted(map(lambda x: int("""".join(x)) cands))\n        \n            loc = bisect.bisect(cands n)\n            if loc < len(cands):           \n                ans = min(ans cands[loc])\n        \n        return ans\n"
Next Permutation,###  31\. Next Permutation\n\nA **permutation** of an array of integers is an arrangement of its members\ninto a sequence or linear order.\n\n  * For example for `arr = [123]` the following are considered permutations of `arr`: `[123]` `[132]` `[312]` `[231]`.\n\nThe **next permutation** of an array of integers is the next lexicographically\ngreater permutation of its integer. More formally if all the permutations of\nthe array are sorted in one container according to their lexicographical\norder then the **next permutation** of that array is the permutation that\nfollows it in the sorted container. If such arrangement is not possible the\narray must be rearranged as the lowest possible order (i.e. sorted in\nascending order).\n\n  * For example the next permutation of `arr = [123]` is `[132]`.\n  * Similarly the next permutation of `arr = [231]` is `[312]`.\n  * While the next permutation of `arr = [321]` is `[123]` because `[321]` does not have a lexicographical larger rearrangement.\n\nGiven an array of integers `nums` _find the next permutation of_ `nums`.\n\nThe replacement must be **[in place](http://en.wikipedia.org/wiki/In-\nplace_algorithm)** and use only constant extra memory.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** [132]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [321]\n    **Output:** [123]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [115]\n    **Output:** [151]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `0 <= nums[i] <= 100`\n\n,class Solution:\n    def nextPermutation(self nums) -> None:\n        firstDecreasingElement = -1\n        toSwapWith = -1\n        lastIndex = len(nums) - 1\n\n        # Looking for an element that is less than its follower\n        for i in range(lastIndex 0 -1):\n            if nums[i] > nums[i - 1]:\n                firstDecreasingElement = i - 1\n                break\n\n        # If there is not any then reverse the array to make initial permutation\n        if firstDecreasingElement == -1:\n            for i in range(0 lastIndex // 2 + 1):\n                nums[i] nums[lastIndex - i] = nums[lastIndex - i] nums[i]\n            return\n\n        # Looking for an element to swap it with firstDecreasingElement\n        for i in range(lastIndex 0 -1):\n            if nums[i] > nums[firstDecreasingElement]:\n                toSwapWith = i\n                break\n\n        # Swap found elements\n        nums[firstDecreasingElement] nums[toSwapWith] = nums[toSwapWith] nums[firstDecreasingElement]\n\n        # Reverse elements from firstDecreasingElement to the end of the array\n        left = firstDecreasingElement + 1\n        right = lastIndex\n        while left < right:\n            nums[left] nums[right] = nums[right] nums[left]\n            left += 1\n            right -= 1\n
Nim Game,###  292\. Nim Game\n\nYou are playing the following Nim Game with your friend:\n\n  * Initially there is a heap of stones on the table.\n  * You and your friend will alternate taking turns and **you go first**.\n  * On each turn the person whose turn it is will remove 1 to 3 stones from the heap.\n  * The one who removes the last stone is the winner.\n\nGiven `n` the number of stones in the heap return `true` _if you can win the\ngame assuming both you and your friend play optimally otherwise\nreturn_`false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** false\n    **Explanation:** These are the possible outcomes:\n    1. You remove 1 stone. Your friend removes 3 stones including the last stone. Your friend wins.\n    2. You remove 2 stones. Your friend removes 2 stones including the last stone. Your friend wins.\n    3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\n    In all outcomes your friend wins.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 231 - 1`\n\n,// Runtime: 39 ms (Top 73.60%) | Memory: 13.9 MB (Top 45.89%)\nclass Solution:\n    def canWinNim(self n: int) -> bool:\n        return n%4
Non-negative Integers without Consecutive Ones,###  600\. Non-negative Integers without Consecutive Ones\n\nGiven a positive integer `n` return the number of the integers in the range\n`[0 n]` whose binary representations **do not** contain consecutive ones.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** 5\n    **Explanation:**\n    Here are the non-negative integers <= 5 with their corresponding binary representations:\n    0 : 0\n    1 : 1\n    2 : 10\n    3 : 11\n    4 : 100\n    5 : 101\n    Among them only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n\n,"class Solution:\n    def findIntegers(self n: int) -> int:\n        b=(bin(n).replace(""0b""""""))\n        dp=[[[[-1 for i in range(2)] for i in range(2)] for i in range(2)] for i in range(30)]\n        def fun(ilasttightleading_zeros):\n            if i==len(str(b)):\n                return 1\n            if dp[i][tight][leading_zeros][last]!=-1:\n                return dp[i][tight][leading_zeros][last]\n            end=1\n            if tight==1:\n                end = int(b[i])\n            res=0\n            for j in range(end+1):\n                if j==0 and leading_zeros==1:\n                    res+=fun(i+1jtight&int(j==end)1)\n                else:\n                    if j==0:\n                        res+=fun(i+1jtight&int(j==end)0)\n                    else:\n                        if last!=j:\n                            res+=fun(i+1jtight&int(j==end)0)\n            dp[i][tight][leading_zeros][last] = res\n            return res\n        return fun(0011)"
Non-overlapping Intervals,###  435\. Non-overlapping Intervals\n\nGiven an array of intervals `intervals` where `intervals[i] = [starti endi]`\nreturn _the minimum number of intervals you need to remove to make the rest of\nthe intervals non-overlapping_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** intervals = [[12][23][34][13]]\n    **Output:** 1\n    **Explanation:** [13] can be removed and the rest of the intervals are non-overlapping.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** intervals = [[12][12][12]]\n    **Output:** 2\n    **Explanation:** You need to remove two [12] to make the rest of the intervals non-overlapping.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** intervals = [[12][23]]\n    **Output:** 0\n    **Explanation:** You don't need to remove any of the intervals since they're already non-overlapping.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= intervals.length <= 105`\n  * `intervals[i].length == 2`\n  * `-5 * 104 <= starti < endi <= 5 * 104`\n\n,# Runtime: 3035 ms (Top 7.53%) | Memory: 52.8 MB (Top 61.18%)\n\nclass Solution:\n    def eraseOverlapIntervals(self intervals: List[List[int]]) -> int: # Time: O(nlogn) and Space: O(1)\n        intervals.sort()\n        res = 0\n        prevEnd = intervals[0][1]\n\n        for start end in intervals[1:]: # we will start from 1 as we already had taken 0 as a base value\n            if start >= prevEnd: # Non overlapping when new interval starts after or from the previous one\n                prevEnd = end # prev = [2 prevEnd=3] & new = [start=3 end=4] we have a new end now after checking the new non overlapping interval\n            else: # Overlapping when new interval starts in between or from the previous one\n                res += 1 # prev = [1 prevEnd=2] & new = [start=1 end=3] --> we will delete new=[1 3] & set prev = [1 prevEnd=2]\n                prevEnd = min(end prevEnd) # we will delete on the interval on the basis of whose interval ends last\n\n        return res
Nth Magical Number,###  878\. Nth Magical Number\n\nA positive integer is _magical_ if it is divisible by either `a` or `b`.\n\nGiven the three integers `n` `a` and `b` return the `nth` magical number.\nSince the answer may be very large **return it modulo**`109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1 a = 2 b = 3\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4 a = 2 b = 3\n    **Output:** 6\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n  * `2 <= a b <= 4 * 104`\n\n,# Runtime: 24 ms (Top 100.0%) | Memory: 16.28 MB (Top 81.4%)\n\nclass Solution:\n    def nthMagicalNumber(self N: int A: int B: int) -> int:\n        import math\n        lcm= A*B // math.gcd(AB)\n        lr=210**14\n        while l<=r:\n            mid=(l+r)//2\n            n = mid//A+mid//B-mid//lcm\n            if n>=N:\n                r=mid-1\n           \n            else:\n                l=mid+1\n        return l%(10**9+7)
Number of 1 Bits,###  191\. Number of 1 Bits\n\nWrite a function that takes an unsigned integer and returns the number of '1'\nbits it has (also known as the [Hamming\nweight](http://en.wikipedia.org/wiki/Hamming_weight)).\n\n**Note:**\n\n  * Note that in some languages such as Java there is no unsigned integer type. In this case the input will be given as a signed integer type. It should not affect your implementation as the integer's internal binary representation is the same whether it is signed or unsigned.\n  * In Java the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore in **Example 3**  the input represents the signed integer. `-3`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 00000000000000000000000000001011\n    **Output:** 3\n    **Explanation:** The input binary string **00000000000000000000000000001011** has a total of three '1' bits.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 00000000000000000000000010000000\n    **Output:** 1\n    **Explanation:** The input binary string **00000000000000000000000010000000** has a total of one '1' bit.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 11111111111111111111111111111101\n    **Output:** 31\n    **Explanation:** The input binary string **11111111111111111111111111111101** has a total of thirty one '1' bits.\n    \n\n\n\n**Constraints:**\n\n  * The input must be a **binary string** of length `32`.\n\n\n\n**Follow up:** If this function is called many times how would you optimize\nit?\n\n,# Runtime: 27 ms (Top 98.51%) | Memory: 13.8 MB (Top 50.40%)\nclass Solution:\n    def hammingWeight(self n: int) -> int:\n      i = 0\n      while n > 0:\n        if n % 2 != 0: i += 1\n        n = n >> 1\n      return i
Number of Atoms,"###  726\. Number of Atoms\n\nGiven a string `formula` representing a chemical formula return _the count of\neach atom_.\n\nThe atomic element always starts with an uppercase character then zero or\nmore lowercase letters representing the name.\n\nOne or more digits representing that element's count may follow if the count\nis greater than `1`. If the count is `1` no digits will follow.\n\n  * For example `""H2O""` and `""H2O2""` are possible but `""H1O2""` is impossible.\n\nTwo formulas are concatenated together to produce another formula.\n\n  * For example `""H2O2He3Mg4""` is also a formula.\n\nA formula placed in parentheses and a count (optionally added) is also a\nformula.\n\n  * For example `""(H2O2)""` and `""(H2O2)3""` are formulas.\n\nReturn the count of all elements as a string in the following form: the first\nname (in sorted order) followed by its count (if that count is more than\n`1`) followed by the second name (in sorted order) followed by its count (if\nthat count is more than `1`) and so on.\n\nThe test cases are generated so that all the values in the output fit in a\n**32-bit** integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** formula = ""H2O""\n    **Output:** ""H2O""\n    **Explanation:** The count of elements are {'H': 2 'O': 1}.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** formula = ""Mg(OH)2""\n    **Output:** ""H2MgO2""\n    **Explanation:** The count of elements are {'H': 2 'Mg': 1 'O': 2}.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** formula = ""K4(ON(SO3)2)2""\n    **Output:** ""K4N2O14S4""\n    **Explanation:** The count of elements are {'K': 4 'N': 2 'O': 14 'S': 4}.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= formula.length <= 1000`\n  * `formula` consists of English letters digits `'('` and `')'`.\n  * `formula` is always valid.\n\n","// Runtime: 35 ms (Top 78.84%) | Memory: 16.70 MB (Top 50.21%)\n\nclass Solution:\n    def countOfAtoms(self formula: str) -> str:\n        stack elem i = [{}] """" 0\n        \n        while i < len(formula):\n            # Extract the full element name\n            if formula[i].isupper():\n                j = i + 1\n                while j < len(formula) and formula[j].islower():\n                    j += 1\n                elem = formula[i:j]\n                i = j\n                # If no digits follow the element assign a count of 1\n                if i == len(formula) or not formula[i].isdigit() and not formula[i].islower():\n                    stack[-1][elem] = stack[-1].get(elem 0) + 1\n            # Extract the count\n            elif formula[i].isdigit():\n                j = i\n                while j < len(formula) and formula[j].isdigit():\n                    j += 1\n                count = int(formula[i:j])\n                stack[-1][elem] = stack[-1].get(elem 0) + count\n                i = j\n            # Handle open parentheses by pushing a new dict\n            elif formula[i] == '(':\n                stack.append({})\n                i += 1\n            # Handle close parentheses by merging with the previous dict\n            elif formula[i] == ')':\n                i += 1\n                j = i\n                while j < len(formula) and formula[j].isdigit():\n                    j += 1\n                multiplier = int(formula[i:j] or 1)\n                top = stack.pop()\n                for elem count in top.items():\n                    stack[-1][elem] = stack[-1].get(elem 0) + count * multiplier\n                i = j\n        \n        # Convert the result to the desired format\n        atoms = sorted(stack[0].items())\n        return ''.join([atom + (str(count) if count > 1 else '') for atom count in atoms])\n\n"
Number of Burgers with No Waste of Ingredients,###  1276\. Number of Burgers with No Waste of Ingredients\n\nGiven two integers `tomatoSlices` and `cheeseSlices`. The ingredients of\ndifferent burgers are as follows:\n\n  * **Jumbo Burger:** `4` tomato slices and `1` cheese slice.\n  * **Small Burger:** `2` Tomato slices and `1` cheese slice.\n\nReturn `[total_jumbo total_small]` so that the number of remaining\n`tomatoSlices` equal to `0` and the number of remaining `cheeseSlices` equal\nto `0`. If it is not possible to make the remaining `tomatoSlices` and\n`cheeseSlices` equal to `0` return `[]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** tomatoSlices = 16 cheeseSlices = 7\n    **Output:** [16]\n    **Explantion:** To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese.\n    There will be no remaining ingredients.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** tomatoSlices = 17 cheeseSlices = 4\n    **Output:** []\n    **Explantion:** There will be no way to use all ingredients to make small and jumbo burgers.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** tomatoSlices = 4 cheeseSlices = 17\n    **Output:** []\n    **Explantion:** Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= tomatoSlices cheeseSlices <= 107`\n\n,class Solution(object):\n    def numOfBurgers(self t c):\n        \n        if t==c==0:\n            return [00]\n        four=(t-2*c)//2  # no of jumbo burgers by solving 4x+2y=t and x+y=c\n        two=c-four #number of small burgers\n        if c>=t or (t-2*c)%2==1 or four<0 or two<0: #if cheese is less than tomatoes or if number of jumbo burgers is a decimal or number of burgers are negtive we return empty list\n            return []\n        \n        return [fourtwo]\n        \n
Number of Dice Rolls With Target Sum,###  1155\. Number of Dice Rolls With Target Sum\n\nYou have `n` dice and each die has `k` faces numbered from `1` to `k`.\n\nGiven three integers `n` `k` and `target` return _the number of possible\nways (out of the_`kn` _total ways)__to roll the dice so the sum of the face-up\nnumbers equals_`target`. Since the answer may be too large return it\n**modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1 k = 6 target = 3\n    **Output:** 1\n    **Explanation:** You throw one die with 6 faces.\n    There is only one way to get a sum of 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 k = 6 target = 7\n    **Output:** 6\n    **Explanation:** You throw two dice each with 6 faces.\n    There are 6 ways to get a sum of 7: 1+6 2+5 3+4 4+3 5+2 6+1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 30 k = 30 target = 500\n    **Output:** 222616187\n    **Explanation:** The answer must be returned modulo 109 + 7.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n k <= 30`\n  * `1 <= target <= 1000`\n\n,"# Runtime: 782 ms (Top 50.50%) | Memory: 18.9 MB (Top 42.22%)\n\nclass Solution(object):\n    def numRollsToTarget(self n k target):\n        """"""\n        :type n: int\n        :type k: int\n        :type target: int\n        :rtype: int\n        """"""\n\n        mem = {}\n\n        def dfs(icurrSum):\n\n            if currSum > target:\n                return 0\n\n            if i == n:\n                if currSum == target:\n                    return 1\n                return 0\n\n            if (icurrSum) in mem:\n                return mem[(icurrSum)]\n\n            ans = 0\n            for dicenumber in range(1k+1):\n                ans += dfs(i+1currSum+dicenumber)\n\n            mem[(icurrSum)] = ans\n\n            return mem[(icurrSum)]\n\n        return dfs(00) % (10**9 + 7)\n"
Number of Different Integers in a String,"###  1805\. Number of Different Integers in a String\n\nYou are given a string `word` that consists of digits and lowercase English\nletters.\n\nYou will replace every non-digit character with a space. For example\n`""a123bc34d8ef34""` will become `"" 123  34 8  34""`. Notice that you are left\nwith some integers that are separated by at least one space: `""123""` `""34""`\n`""8""` and `""34""`.\n\nReturn _the number of**different** integers after performing the replacement\noperations on _`word`.\n\nTwo integers are considered different if their decimal representations\n**without any leading zeros** are different.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word = ""a _123_ bc _34_ d _8_ ef _34_ ""\n    **Output:** 3\n    **Explanation:** The three different integers are ""123"" ""34"" and ""8"". Notice that ""34"" is only counted once.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word = ""leet _1234_ code _234_ ""\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** word = ""a _1_ b _01_ c _001_ ""\n    **Output:** 1\n    **Explanation:** The three integers ""1"" ""01"" and ""001"" all represent the same integer because\n    the leading zeros are ignored when comparing their decimal values.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word.length <= 1000`\n  * `word` consists of digits and lowercase English letters.\n\n",// Runtime: 34 ms (Top 85.83%) | Memory: 16.50 MB (Top 46.61%)\n\nclass Solution:\n    def numDifferentIntegers(self word: str) -> int:\n        word = re.findall('(\d+)' word)\n        nums = [int(i) for i in word]\n        \n        return len(set(nums))\n
Number of Different Subsequences GCDs,###  1819\. Number of Different Subsequences GCDs\n\nYou are given an array `nums` that consists of positive integers.\n\nThe **GCD** of a sequence of numbers is defined as the greatest integer that\ndivides **all** the numbers in the sequence evenly.\n\n  * For example the GCD of the sequence `[4616]` is `2`.\n\nA **subsequence** of an array is a sequence that can be formed by removing\nsome elements (possibly none) of the array.\n\n  * For example `[2510]` is a subsequence of `[121**_2_** 41_**5**_ _**10**_]`.\n\nReturn _the**number** of **different** GCDs among all **non-empty**\nsubsequences of_ `nums`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/17/image-1.png)\n\n    \n    \n    **Input:** nums = [6103]\n    **Output:** 5\n    **Explanation:** The figure shows all the non-empty subsequences and their GCDs.\n    The different GCDs are 6 10 3 2 and 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [5154056]\n    **Output:** 7\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 2 * 105`\n\n,// Runtime: 5748 ms (Top 75.00%) | Memory: 34.4 MB (Top 21.43%)\nimport math\n\nclass Solution:\n    def countDifferentSubsequenceGCDs(self nums: List[int]) -> int:\n        max_n = max(nums) + 1\n        seen = set(nums)\n\n        ans = 0\n        for k in range(1 max_n): # iterate candidate k\n            gcd = 0\n            for multiple in range(k max_n k): # compute gcd of all array multiples of k\n                if multiple in seen:\n                    gcd = math.gcd(gcd multiple)\n            if gcd == k: # check the candidate\n                ans += 1\n        return ans
Number of Digit One,###  233\. Number of Digit One\n\nGiven an integer `n` count _the total number of digit_`1` _appearing in all\nnon-negative integers less than or equal to_ `n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 13\n    **Output:** 6\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 0\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 109`\n\n,# Runtime: 65 ms (Top 7.05%) | Memory: 13.8 MB (Top 68.36%)\nclass Solution:\n    def countDigitOne(self n: int) -> int:\n        num = str(n)[::-1]\n        count = 0\n        for i in range(len(num)-1 -1 -1):\n            pv = 10**i # placevalue\n            # mulitplicity of current digit (how many times it will be repeated)\n            mul = n//(pv*10)\n            rem = n % pv # remainder of current place value\n            count += mul * pv # count for number of times 1 occurs in this place when the current digit is considered to be less than 1\n            # if the current digit is greater than 1 then additional number of 1's are added to the count (equivalent to the place value)\n            if num[i] > '1':\n                count += pv\n            # if the current digit is equal to 1 then additional number of 1's are added to the count (equivalent to the number modded by the current place value)\n            if num[i] == '1':\n                count += rem + 1\n        return count\n
Number of Distinct Roll Sequences,###  2318\. Number of Distinct Roll Sequences\n\nYou are given an integer `n`. You roll a fair 6-sided dice `n` times.\nDetermine the total number of **distinct** sequences of rolls possible such\nthat the following conditions are satisfied:\n\n  1. The **greatest common divisor** of any **adjacent** values in the sequence is equal to `1`.\n  2. There is **at least** a gap of `2` rolls between **equal** valued rolls. More formally if the value of the `ith` roll is **equal** to the value of the `jth` roll then `abs(i - j) > 2`.\n\nReturn _the**total number** of distinct sequences possible_. Since the answer\nmay be very large return it **modulo** `109 + 7`.\n\nTwo sequences are considered distinct if at least one element is different.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** 184\n    **Explanation:** Some of the possible sequences are (1 2 3 4) (6 1 2 3) (1 2 3 1) etc.\n    Some invalid sequences are (1 2 1 3) (1 2 3 6).\n    (1 2 1 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).\n    (1 2 3 6) is invalid since the greatest common divisor of 3 and 6 = 3.\n    There are a total of 184 distinct sequences possible so we return 184.\n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 22\n    **Explanation:** Some of the possible sequences are (1 2) (2 1) (3 2).\n    Some invalid sequences are (3 6) (2 4) since the greatest common divisor is not equal to 1.\n    There are a total of 22 distinct sequences possible so we return 22.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n\n,mod=1000000007\n@cache\ndef func(nprevpp):\n    if n==0:\n        return 1\n    ans=0\n    for i in range(17):\n        if prev==-1:\n            ans+=func(n-1iprev)\n            ans=ans%mod\n        elif pp==-1:\n            if(math.gcd(iprev)==1 and i!=prev):\n                ans+=func(n-1iprev)\n                ans=ans%mod\n        else:\n            if(math.gcd(iprev)==1 and i!=prev and i!=pp):\n                ans+=func(n-1iprev)\n                ans=ans%mod\n    return ans;\nclass Solution:\n    \n            \n    def distinctSequences(self n: int) -> int:\n        return func(n-1-1)\n
Number of Equivalent Domino Pairs,###  1128\. Number of Equivalent Domino Pairs\n\nGiven a list of `dominoes` `dominoes[i] = [a b]` is **equivalent to**\n`dominoes[j] = [c d]` if and only if either (`a == c` and `b == d`) or (`a\n== d` and `b == c`) - that is one domino can be rotated to be equal to\nanother domino.\n\nReturn _the number of pairs_`(i j)`_for which_`0 <= i < j < dominoes.length`\n_ and_`dominoes[i]`_is**equivalent to** _`dominoes[j]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** dominoes = [[12][21][34][56]]\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** dominoes = [[12][12][11][12][22]]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= dominoes.length <= 4 * 104`\n  * `dominoes[i].length == 2`\n  * `1 <= dominoes[i][j] <= 9`\n\n,"import math\nclass Solution:\n    def numEquivDominoPairs(self dominoes: List[List[int]]) -> int:\n        d=dict()\n        for i in dominoes:\n            i.sort()            #Just to make everything equal and comparable\n            if(tuple(i) in d.keys()):   #In python lists are unhashable so converted the list into tuples\n                d[tuple(i)]+=1\n            else:\n                d[tuple(i)]=1\n        count=0\n        for xy in d.items():\n            if(y>1):\n				count+=y*(y-1)//2        #To check the number of pairs if 2 elements pairs is 1if 3 pair is 3 and so                                                                     on.....formula is n*n-1/2\n        return count\n                \n\n\n"
Number of Flowers in Full Bloom,###  2251\. Number of Flowers in Full Bloom\n\nYou are given a **0-indexed** 2D integer array `flowers` where `flowers[i] =\n[starti endi]` means the `ith` flower will be in **full bloom** from `starti`\nto `endi` (**inclusive**). You are also given a **0-indexed** integer array\n`persons` of size `n` where `persons[i]` is the time that the `ith` person\nwill arrive to see the flowers.\n\nReturn _an integer array_`answer` _of size_`n` _ where_`answer[i]`_is\nthe**number** of flowers that are in full bloom when the _`ith` _person\narrives._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg)\n\n    \n    \n    **Input:** flowers = [[16][37][912][413]] persons = [23711]\n    **Output:** [1222]\n    **Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\n    For each person we return the number of flowers in full bloom during their arrival.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg)\n\n    \n    \n    **Input:** flowers = [[110][33]] persons = [332]\n    **Output:** [221]\n    **Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\n    For each person we return the number of flowers in full bloom during their arrival.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= flowers.length <= 5 * 104`\n  * `flowers[i].length == 2`\n  * `1 <= starti <= endi <= 109`\n  * `1 <= persons.length <= 5 * 104`\n  * `1 <= persons[i] <= 109`\n\n,# Runtime: 931 ms (Top 66.6%) | Memory: 45.16 MB (Top 22.2%)\n\nclass Solution:\n    def fullBloomFlowers(self flowers: List[List[int]] people: List[int]) -> List[int]:\n        #we ADD flowers in the order in which they start but we remove them in the order they \n        #end.  For this reason we sort the flowers by starting time but put them in a heap \n        #in which we remove them by ending time\n        starts = sorted(flowers) #keep flowers untouched in case array should be constant\n        blooming = [] #heap of active flowers\n        answer = [-1] * len(people) #output array\n        hours = [(people[i] i) for i in range(len(people))] #the people ordered and indexed by their time\n        hours.sort()\n\n        i = 0 #going through starts\n        for hour person in hours:\n            #add all flowers that have started\n            while i < len(starts) and starts[i][0] <= hour:\n                heappush(blooming (starts[i][1] starts[i][0]))\n                i += 1\n            #now remove all flowers that have ended.  Note that we only care about the absolute smallest \n            #and in python minheaps that is always the first element - even if no other element's order \n            #is guaranteed\n            while blooming and blooming[0][0] < hour: #as long as the soonest to end blooming flower hasn't already stopped\n                heappop(blooming)\n            answer[person] = len(blooming)\n        \n        return answer
Number of Good Leaf Nodes Pairs,###  1530\. Number of Good Leaf Nodes Pairs\n\nYou are given the `root` of a binary tree and an integer `distance`. A pair of\ntwo different **leaf** nodes of a binary tree is said to be good if the length\nof **the shortest path** between them is less than or equal to `distance`.\n\nReturn _the number of good leaf node pairs_ in the tree.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/07/09/e1.jpg)\n\n    \n    \n    **Input:** root = [123null4] distance = 3\n    **Output:** 1\n    **Explanation:** The leaf nodes of the tree are 3 and 4 and the length of the shortest path between them is 3. This is the only good pair.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/07/09/e2.jpg)\n\n    \n    \n    **Input:** root = [1234567] distance = 3\n    **Output:** 2\n    **Explanation:** The good pairs are [45] and [67] with shortest path = 2. The pair [46] is not good because the length of ther shortest path between them is 4.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [7146null53nullnullnullnullnull2] distance = 3\n    **Output:** 1\n    **Explanation:** The only good pair is [25].\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the `tree` is in the range `[1 210].`\n  * `1 <= Node.val <= 100`\n  * `1 <= distance <= 10`\n\n,class Solution:\n    def countPairs(self root: TreeNode distance: int) -> int:\n        adjList=defaultdict(list)\n        leaves=[]\n        ct=0\n        \n        [#undirected graph two way using parent and node in postorder style]\n        def dfs(node parent):\n            if node:\n                if not node.left and not node.right:\n                    leaves.append(node)\n                adjList[node].append(parent)\n                adjList[parent].append(node)\n                dfs(node.leftnode)\n                dfs(node.rightnode)\n        \n        [#construct graph and get all the leaves]\n        dfs(root None)\n        \n        #bfs from each leaf till we find another leaf\n        for leaf in leaves:\n            q=deque([(leaf0)] )\n            seen=set()\n            while q:\n                currdist = q.popleft()\n                seen.add(curr)\n                if dist>distance:\n                    break                \n                for nbr in adjList[curr]:\n                    if nbr and nbr not in seen:\n                        if nbr in leaves and dist+1<=distance:\n                            ct+=1\n                        q.append((nbrdist+1))\n        \n        return ct//2
Number of Good Pairs,###  1512\. Number of Good Pairs\n\nGiven an array of integers `nums` return _the number of**good pairs**_.\n\nA pair `(i j)` is called _good_ if `nums[i] == nums[j]` and `i` < `j`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123113]\n    **Output:** 4\n    **Explanation:** There are 4 good pairs (03) (04) (34) (25) 0-indexed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1111]\n    **Output:** 6\n    **Explanation:** Each pair in the array are _good_.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `1 <= nums[i] <= 100`\n\n,"from itertools import combinations\nclass Solution:\n    def numIdenticalPairs(self nums) -> int:\n        res = 0\n		nums_set = set(nums)\n        nums_coppy = nums\n        for number in nums_set:\n            number_found = []\n            deleted = 0\n            while True:\n                try:\n                    found = nums_coppy.index(number)\n                    nums_coppy.remove(number)\n                    if deleted > 0:\n                        number_found.append(found + deleted)\n                    else:\n                        number_found.append(found + deleted)\n                    deleted += 1\n                except:\n                    comb = list(combinations(number_found 2))\n                    res += len(comb)\n                    break\n        return res\n"
Number of Islands,"###  200\. Number of Islands\n\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land)\nand `'0'`s (water) return _the number of islands_.\n\nAn **island** is surrounded by water and is formed by connecting adjacent\nlands horizontally or vertically. You may assume all four edges of the grid\nare all surrounded by water.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** grid = [\n      [""1""""1""""1""""1""""0""]\n      [""1""""1""""0""""1""""0""]\n      [""1""""1""""0""""0""""0""]\n      [""0""""0""""0""""0""""0""]\n    ]\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [\n      [""1""""1""""0""""0""""0""]\n      [""1""""1""""0""""0""""0""]\n      [""0""""0""""1""""0""""0""]\n      [""0""""0""""0""""1""""1""]\n    ]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 300`\n  * `grid[i][j]` is `'0'` or `'1'`.\n\n","# Runtime: 353 ms (Top 84.15%) | Memory: 28.7 MB (Top 5.01%)\n\nseen=set()\ndef dfs(ijmngrid):\n    global seen\n    if (i<0 or i>=m or j<0 or j>=n):return\n    if (ij) in seen:return\n    seen.add((ij))\n    if grid[i][j]==""1"":\n        dfs(ij+1mngrid)\n        dfs(ij-1mngrid)\n        dfs(i+1jmngrid)\n        dfs(i-1jmngrid)\n\nclass Solution:\n    def numIslands(self grid: List[List[str]]) -> int:\n        global seen\n        m=len(grid) #no of rows\n        n=len(grid[0]) #no of columns\n        count=0\n        for i in range(m):\n            for j in range(n):\n                if (ij) not in seen and grid[i][j]==""1"":\n                    dfs(ijmngrid)\n                    count+=1\n        seen.clear()\n        return count"
Number of Laser Beams in a Bank,"###  2125\. Number of Laser Beams in a Bank\n\nAnti-theft security devices are activated inside a bank. You are given a\n**0-indexed** binary string array `bank` representing the floor plan of the\nbank which is an `m x n` 2D matrix. `bank[i]` represents the `ith` row\nconsisting of `'0'`s and `'1'`s. `'0'` means the cell is empty while`'1'`\nmeans the cell has a security device.\n\nThere is **one** laser beam between any **two** security devices **if both**\nconditions are met:\n\n  * The two devices are located on two **different rows** : `r1` and `r2` where `r1 < r2`.\n  * For **each** row `i` where `r1 < i < r2` there are **no security devices** in the `ith` row.\n\nLaser beams are independent i.e. one beam does not interfere nor join with\nanother.\n\nReturn _the total number of laser beams in the bank_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/24/laser1.jpg)\n\n    \n    \n    **Input:** bank = [""011001""""000000""""010100""""001000""]\n    **Output:** 8\n    **Explanation:** Between each of the following device pairs there is one beam. In total there are 8 beams:\n     * bank[0][1] -- bank[2][1]\n     * bank[0][1] -- bank[2][3]\n     * bank[0][2] -- bank[2][1]\n     * bank[0][2] -- bank[2][3]\n     * bank[0][5] -- bank[2][1]\n     * bank[0][5] -- bank[2][3]\n     * bank[2][1] -- bank[3][2]\n     * bank[2][3] -- bank[3][2]\n    Note that there is no beam between any device on the 0th row with any on the 3rd row.\n    This is because the 2nd row contains security devices which breaks the second condition.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/24/laser2.jpg)\n\n    \n    \n    **Input:** bank = [""000""""111""""000""]\n    **Output:** 0\n    **Explanation:** There does not exist two devices located on two different rows.\n    \n\n\n\n**Constraints:**\n\n  * `m == bank.length`\n  * `n == bank[i].length`\n  * `1 <= m n <= 500`\n  * `bank[i][j]` is either `'0'` or `'1'`.\n\n",class Solution(object):\n    def numberOfBeams(self bank):\n        ans pre = 0 0\n        for s in bank:\n            n = s.count('1')\n            if n == 0: continue\n            ans += pre * n\n            pre = n\n        return ans\n
Number of Lines To Write String,"###  806\. Number of Lines To Write String\n\nYou are given a string `s` of lowercase English letters and an array `widths`\ndenoting **how many pixels wide** each lowercase English letter is.\nSpecifically `widths[0]` is the width of `'a'` `widths[1]` is the width of\n`'b'` and so on.\n\nYou are trying to write `s` across several lines where **each line is no\nlonger than**`100`**pixels**. Starting at the beginning of `s` write as many\nletters on the first line such that the total width does not exceed `100`\npixels. Then from where you stopped in `s` continue writing as many letters\nas you can on the second line. Continue this process until you have written\nall of `s`.\n\nReturn _an array_`result` _of length 2 where:_\n\n  * `result[0]`_is the total number of lines._\n  * `result[1]`_is the width of the last line in pixels._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** widths = [1010101010101010101010101010101010101010101010101010] s = ""abcdefghijklmnopqrstuvwxyz""\n    **Output:** [360]\n    **Explanation:** You can write s as follows:\n    abcdefghij  // 100 pixels wide\n    klmnopqrst  // 100 pixels wide\n    uvwxyz      // 60 pixels wide\n    There are a total of 3 lines and the last line is 60 pixels wide.\n\n**Example 2:**\n\n    \n    \n    **Input:** widths = [410101010101010101010101010101010101010101010101010] s = ""bbbcccdddaaa""\n    **Output:** [24]\n    **Explanation:** You can write s as follows:\n    bbbcccdddaa  // 98 pixels wide\n    a            // 4 pixels wide\n    There are a total of 2 lines and the last line is 4 pixels wide.\n\n\n\n**Constraints:**\n\n  * `widths.length == 26`\n  * `2 <= widths[i] <= 10`\n  * `1 <= s.length <= 1000`\n  * `s` contains only lowercase English letters.\n\n",class Solution:\n    def numberOfLines(self w: List[int] s: str) -> List[int]:\n        r=[0]*2\n        px=0\n        l=1\n        for i in range(len(s)):\n            px+=w[ord(s[i])-97]\n            if px>100:\n                l+=1\n                px=w[ord(s[i])-97]\n                \n            print(ord(s[i]))\n        r[0]=l\n        r[1]=px\n        return r\n        
Number of Longest Increasing Subsequence,###  673\. Number of Longest Increasing Subsequence\n\nGiven an integer array `nums` return _the number of longest increasing\nsubsequences._\n\n**Notice** that the sequence has to be **strictly** increasing.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13547]\n    **Output:** 2\n    **Explanation:** The two longest increasing subsequences are [1 3 4 7] and [1 3 5 7].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [22222]\n    **Output:** 5\n    **Explanation:** The length of the longest increasing subsequence is 1 and there are 5 increasing subsequences of length 1 so output 5.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2000`\n  * `-106 <= nums[i] <= 106`\n\n,class Solution:\n    def findNumberOfLIS(self nums: List[int]) -> int:\n        \n        if not nums or len(nums) == 0:\n            return 0\n        \n        def find_pos(sub val):\n            left right = 0 len(sub) - 1\n            while left < right:\n                mid = (left + right) >> 1\n                if sub[mid] >= val: \n                    right = mid\n                else:\n                    left = mid + 1\n            return left \n        \n    \n        sub_list = []\n        \n        for val in nums:\n            if len(sub_list) == 0 or val > sub_list[-1][-1][0]:\n                # should append a new element at the end\n                cur_count = sum([x[1] for x in sub_list[-1] if val > x[0]]) if len(sub_list) != 0 else 1\n                sub_list.append([(val cur_count)])\n            else:\n                # get the last number to turn it back to a LIS problem\n                cur_sub = [array[-1][0] for array in sub_list]\n                pos = find_pos(cur_sub val)\n                # if pos == 0 means it is smallest no need to look the previous level and set it to be 1\n                cur_count = sum([x[1] for x in sub_list[pos - 1] if val > x[0]]) if pos > 0 else 1\n                sub_list[pos].append((val cur_count))\n      \n        return sum([x[1] for x in sub_list[-1]])
Number of Matching Subsequences,"###  792\. Number of Matching Subsequences\n\nGiven a string `s` and an array of strings `words` return _the number of_\n`words[i]` _that is a subsequence of_ `s`.\n\nA **subsequence** of a string is a new string generated from the original\nstring with some characters (can be none) deleted without changing the\nrelative order of the remaining characters.\n\n  * For example `""ace""` is a subsequence of `""abcde""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcde"" words = [""a""""bb""""acd""""ace""]\n    **Output:** 3\n    **Explanation:** There are three strings in words that are a subsequence of s: ""a"" ""acd"" ""ace"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""dsahjpjauf"" words = [""ahjpjau""""ja""""ahbwzgqnuk""""tnmlanowax""]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 5 * 104`\n  * `1 <= words.length <= 5000`\n  * `1 <= words[i].length <= 50`\n  * `s` and `words[i]` consist of only lowercase English letters.\n\n",# Runtime: 851 ms (Top 55.45%) | Memory: 16.4 MB (Top 32.26%)\nclass Solution:\n    def numMatchingSubseq(self s: str words: List[str]) -> int:\n        word_dict = defaultdict(list)\n        numMatch = 0\n        # add words into bucket with key as order of the first letter\n        for w in words:\n            word_dict[ord(w[0])-ord('a')].append(w)\n        # loop through the characters in s\n        for c in s:\n            qualified = word_dict[ord(c)-ord('a')]\n            word_dict[ord(c)-ord('a')] = []\n            for q in qualified:\n                # if the word starts with the specified letter. i.e this is the last letter of the word\n                if len(q) == 1:\n                    numMatch += 1\n                else:\n                    word_dict[ord(q[1])-ord('a')].append(q[1:])\n        return numMatch\n
Number of Music Playlists,###  920\. Number of Music Playlists\n\nYour music player contains `n` different songs. You want to listen to `goal`\nsongs (not necessarily different) during your trip. To avoid boredom you will\ncreate a playlist so that:\n\n  * Every song is played **at least once**.\n  * A song can only be played again only if `k` other songs have been played.\n\nGiven `n` `goal` and `k` return _the number of possible playlists that you\ncan create_. Since the answer can be very large return it **modulo** `109 +\n7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 goal = 3 k = 1\n    **Output:** 6\n    **Explanation:** There are 6 possible playlists: [1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] and [3 2 1].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 goal = 3 k = 0\n    **Output:** 6\n    **Explanation:** There are 6 possible playlists: [1 1 2] [1 2 1] [2 1 1] [2 2 1] [2 1 2] and [1 2 2].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 2 goal = 3 k = 1\n    **Output:** 2\n    **Explanation:** There are 2 possible playlists: [1 2 1] and [2 1 2].\n    \n\n\n\n**Constraints:**\n\n  * `0 <= k < n <= goal <= 100`\n\n,# Runtime: 87 ms (Top 77.87%) | Memory: 13.9 MB (Top 86.89%)\nclass Solution:\n    def numMusicPlaylists(self n: int goal: int k: int) -> int:\n        prev_p cur_p = [0] * (n+1) [0] * (n+1)\n\n        for i in range(k+1 goal+1):\n            if i == k+1:\n                prev_p[i] = math.factorial(n) // math.factorial(n-i)\n            else:\n                for j in range(k+1 min(i n)+1):\n                    cur_p[j] = prev_p[j-1] * (n - j + 1) + prev_p[j] * (j-k)\n                prev_p cur_p = cur_p [0] * (n+1)\n        return prev_p[n] % (10**9 + 7)
Number of Nodes in the Sub-Tree With the Same Label,"###  1519\. Number of Nodes in the Sub-Tree With the Same Label\n\nYou are given a tree (i.e. a connected undirected graph that has no cycles)\nconsisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1`\n`edges`. The **root** of the tree is the node `0` and each node of the tree\nhas **a label** which is a lower-case character given in the string `labels`\n(i.e. The node with the number `i` has the label `labels[i]`).\n\nThe `edges` array is given on the form `edges[i] = [ai bi]` which means\nthere is an edge between nodes `ai` and `bi` in the tree.\n\nReturn _an array of size`n`_ where `ans[i]` is the number of nodes in the\nsubtree of the `ith` node which have the same label as node `i`.\n\nA subtree of a tree `T` is the tree consisting of a node in `T` and all of its\ndescendant nodes.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/07/01/q3e1.jpg)\n\n    \n    \n    **Input:** n = 7 edges = [[01][02][14][15][23][26]] labels = ""abaedcd""\n    **Output:** [2111111]\n    **Explanation:** Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well thus the answer is 2. Notice that any node is part of its sub-tree.\n    Node 1 has a label 'b'. The sub-tree of node 1 contains nodes 14 and 5 as nodes 4 and 5 have different labels than node 1 the answer is just 1 (the node itself).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/07/01/q3e2.jpg)\n\n    \n    \n    **Input:** n = 4 edges = [[01][12][03]] labels = ""bbbb""\n    **Output:** [4211]\n    **Explanation:** The sub-tree of node 2 contains only node 2 so the answer is 1.\n    The sub-tree of node 3 contains only node 3 so the answer is 1.\n    The sub-tree of node 1 contains nodes 1 and 2 both have label 'b' thus the answer is 2.\n    The sub-tree of node 0 contains nodes 0 1 2 and 3 all with label 'b' thus the answer is 4.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/07/01/q3e3.jpg)\n\n    \n    \n    **Input:** n = 5 edges = [[01][02][13][04]] labels = ""aabab""\n    **Output:** [32111]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `edges.length == n - 1`\n  * `edges[i].length == 2`\n  * `0 <= ai bi < n`\n  * `ai != bi`\n  * `labels.length == n`\n  * `labels` is consisting of only of lowercase English letters.\n\n","class Solution:\n    """"""\n    we can solve this using dfs based approach\n    identify the root of the tree and start a dfs from there \n    """"""\n    def countSubTrees(self n: int edges: List[List[int]] labels: str) -> List[int]:\n        graph_map = {i: set() for i in range(n)}\n        for edge in edges:\n            graph_map[edge[0]].add(edge[1])\n            graph_map[edge[1]].add(edge[0])\n            \n        result = [None for _ in range(n)]\n        \n        visited = set()\n        def dfs(index):\n            visited.add(index)\n            temp = [0 for _ in range(26)]\n            temp[ord(labels[index])-97]+=1\n            for idx in graph_map[index]:\n                if idx not in visited:\n                    x = dfs(idx)\n                    temp = [a + b for a b in zip(temp x)]\n            result[index] = temp[ord(labels[index])-97]\n            return temp\n        \n        dfs(0)\n        return result\n"
Number of Orders in the Backlog,###  1801\. Number of Orders in the Backlog\n\nYou are given a 2D integer array `orders` where each `orders[i] = [pricei\namounti orderTypei]` denotes that `amounti` orders have been placed of type\n`orderTypei` at the price `pricei`. The `orderTypei` is:\n\n  * `0` if it is a batch of `buy` orders or\n  * `1` if it is a batch of `sell` orders.\n\nNote that `orders[i]` represents a batch of `amounti` independent orders with\nthe same price and order type. All orders represented by `orders[i]` will be\nplaced before all orders represented by `orders[i+1]` for all valid `i`.\n\nThere is a **backlog** that consists of orders that have not been executed.\nThe backlog is initially empty. When an order is placed the following\nhappens:\n\n  * If the order is a `buy` order you look at the `sell` order with the **smallest** price in the backlog. If that `sell` order's price is **smaller than or equal to** the current `buy` order's price they will match and be executed and that `sell` order will be removed from the backlog. Else the `buy` order is added to the backlog.\n  * Vice versa if the order is a `sell` order you look at the `buy` order with the **largest** price in the backlog. If that `buy` order's price is **larger than or equal to** the current `sell` order's price they will match and be executed and that `buy` order will be removed from the backlog. Else the `sell` order is added to the backlog.\n\nReturn _the total**amount** of orders in the backlog after placing all the\norders from the input_. Since this number can be large return it **modulo**\n`109 + 7`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/11/ex1.png)\n\n    \n    \n    **Input:** orders = [[1050][1521][2511][3040]]\n    **Output:** 6\n    **Explanation:** Here is what happens with the orders:\n    - 5 orders of type buy with price 10 are placed. There are no sell orders so the 5 orders are added to the backlog.\n    - 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15 so the 2 orders are added to the backlog.\n    - 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog so this order is added to the backlog.\n    - 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price which is 25 and this sell order is removed from the backlog. Then there are no more sell orders in the backlog so the 4th order is added to the backlog.\n    Finally the backlog has 5 buy orders with price 10 and 1 buy order with price 30. So the total number of orders in the backlog is 6.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/11/ex2.png)\n\n    \n    \n    **Input:** orders = [[710000000001][1530][59999999950][511]]\n    **Output:** 999999984\n    **Explanation:** Here is what happens with the orders:\n    - 109 orders of type sell with price 7 are placed. There are no buy orders so the 109 orders are added to the backlog.\n    - 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7 and those 3 sell orders are removed from the backlog.\n    - 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7 so the 999999995 orders are added to the backlog.\n    - 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price which is 5 and that buy order is removed from the backlog.\n    Finally the backlog has (1000000000-3) sell orders with price 7 and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991 which is equal to 999999984 % (109 + 7).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= orders.length <= 105`\n  * `orders[i].length == 3`\n  * `1 <= pricei amounti <= 109`\n  * `orderTypei` is either `0` or `1`.\n\n,"# Runtime: 689 ms (Top 70.7%) | Memory: 55.89 MB (Top 32.0%)\n\nclass Solution:\n    def getNumberOfBacklogOrders(self orders):\n        b s = [] []\n        heapq.heapify(b)\n        heapq.heapify(s)\n        \n        for pao in orders:\n            if o == 0:\n                heapq.heappush(b [-p a])\n                \n            elif o == 1:\n                heapq.heappush(s [p a])\n            \n            # Check ""good"" condition\n            while s and b and s[0][0] <= -b[0][0]:\n                a1 a2 = b[0][1] s[0][1]\n                \n                if a1 > a2:\n                    b[0][1] -= a2\n                    heapq.heappop(s)\n                elif a1 < a2:\n                    s[0][1] -= a1\n                    heapq.heappop(b)\n                else:\n                    heapq.heappop(b)\n                    heapq.heappop(s)\n                    \n        count = sum([a for pa in b]) + sum([a for pa in s])\n        return count % (10**9 + 7)"
Number of Pairs of Interchangeable Rectangles,###  2001\. Number of Pairs of Interchangeable Rectangles\n\nYou are given `n` rectangles represented by a **0-indexed** 2D integer array\n`rectangles` where `rectangles[i] = [widthi heighti]` denotes the width and\nheight of the `ith` rectangle.\n\nTwo rectangles `i` and `j` (`i < j`) are considered **interchangeable** if\nthey have the **same** width-to-height ratio. More formally two rectangles\nare **interchangeable** if `widthi/heighti == widthj/heightj` (using decimal\ndivision not integer division).\n\nReturn _the**number** of pairs of **interchangeable** rectangles in\n_`rectangles`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rectangles = [[48][36][1020][1530]]\n    **Output:** 6\n    **Explanation:** The following are the interchangeable pairs of rectangles by index (0-indexed):\n    - Rectangle 0 with rectangle 1: 4/8 == 3/6.\n    - Rectangle 0 with rectangle 2: 4/8 == 10/20.\n    - Rectangle 0 with rectangle 3: 4/8 == 15/30.\n    - Rectangle 1 with rectangle 2: 3/6 == 10/20.\n    - Rectangle 1 with rectangle 3: 3/6 == 15/30.\n    - Rectangle 2 with rectangle 3: 10/20 == 15/30.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rectangles = [[45][78]]\n    **Output:** 0\n    **Explanation:** There are no interchangeable pairs of rectangles.\n    \n\n\n\n**Constraints:**\n\n  * `n == rectangles.length`\n  * `1 <= n <= 105`\n  * `rectangles[i].length == 2`\n  * `1 <= widthi heighti <= 105`\n\n,class Solution:\n    def interchangeableRectangles(self rectangles: List[List[int]]) -> int:\n        ratios = defaultdict(int)\n        for x y in rectangles:\n            ratios[x/y] += 1\n        res = 0\n        for val in ratios.values():\n            res += (val*(val-1)//2)\n        return res\n
Number of Pairs of Strings With Concatenation Equal to Target,"###  2023\. Number of Pairs of Strings With Concatenation Equal to Target\n\nGiven an array of **digit** strings `nums` and a **digit** string `target`\nreturn _the number of pairs of indices_`(i j)`_(where_`i != j` _) such that\nthe**concatenation** of _`nums[i] + nums[j]`_equals_`target`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [""777""""7""""77""""77""] target = ""7777""\n    **Output:** 4\n    **Explanation:** Valid pairs are:\n    - (0 1): ""777"" + ""7""\n    - (1 0): ""7"" + ""777""\n    - (2 3): ""77"" + ""77""\n    - (3 2): ""77"" + ""77""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [""123""""4""""12""""34""] target = ""1234""\n    **Output:** 2\n    **Explanation:** Valid pairs are:\n    - (0 1): ""123"" + ""4""\n    - (2 3): ""12"" + ""34""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [""1""""1""""1""] target = ""11""\n    **Output:** 6\n    **Explanation:** Valid pairs are:\n    - (0 1): ""1"" + ""1""\n    - (1 0): ""1"" + ""1""\n    - (0 2): ""1"" + ""1""\n    - (2 0): ""1"" + ""1""\n    - (1 2): ""1"" + ""1""\n    - (2 1): ""1"" + ""1""\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 100`\n  * `1 <= nums[i].length <= 100`\n  * `2 <= target.length <= 100`\n  * `nums[i]` and `target` consist of digits.\n  * `nums[i]` and `target` do not have leading zeros.\n\n",class Solution:\n    def numOfPairs(self nums target):\n        return sum(i + j == target for i j in permutations(nums 2))\n
Number of People Aware of a Secret,###  2327\. Number of People Aware of a Secret\n\nOn day `1` one person discovers a secret.\n\nYou are given an integer `delay` which means that each person will **share**\nthe secret with a new person **every day**  starting from `delay` days after\ndiscovering the secret. You are also given an integer `forget` which means\nthat each person will **forget** the secret `forget` days after discovering\nit. A person **cannot** share the secret on the same day they forgot it or on\nany day afterwards.\n\nGiven an integer `n` return _the number of people who know the secret at the\nend of day_`n`. Since the answer may be very large return it **modulo** `109\n+ 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 6 delay = 2 forget = 4\n    **Output:** 5\n    **Explanation:**\n    Day 1: Suppose the first person is named A. (1 person)\n    Day 2: A is the only person who knows the secret. (1 person)\n    Day 3: A shares the secret with a new person B. (2 people)\n    Day 4: A shares the secret with a new person C. (3 people)\n    Day 5: A forgets the secret and B shares the secret with a new person D. (3 people)\n    Day 6: B shares the secret with E and C shares the secret with F. (5 people)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4 delay = 1 forget = 3\n    **Output:** 6\n    **Explanation:**\n    Day 1: The first person is named A. (1 person)\n    Day 2: A shares the secret with B. (2 people)\n    Day 3: A and B share the secret with 2 new people C and D. (4 people)\n    Day 4: A forgets the secret. B C and D share the secret with 3 new people. (6 people)\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 1000`\n  * `1 <= delay < forget <= n`\n\n,"\n```class Solution:\n    def peopleAwareOfSecret(self n: int delay: int forget: int) -> int:\n        table = [0]*(forget+1)\n        table[1] = 1\n        days = 1\n        while days<=n-1:\n            count = 0\n            for k in range(forget-1-1-1):\n                if k+1>delay:\n                    table[k+1] = table[k]\n                    count+=table[k]\n                elif k+1<=delay:\n                    table[k+1] = table[k]\n            table[1] = count\n            days+=1\n        count = 0\n        for k in range(1forget+1):\n            count+=table[k]\n        return count%(pow(109)+7)\n		\nTC---O(forget*n)\nsc---O(forget)\n            \n"
Number of Provinces,###  547\. Number of Provinces\n\nThere are `n` cities. Some of them are connected while some are not. If city\n`a` is connected directly with city `b` and city `b` is connected directly\nwith city `c` then city `a` is connected indirectly with city `c`.\n\nA **province** is a group of directly or indirectly connected cities and no\nother cities outside of the group.\n\nYou are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if\nthe `ith` city and the `jth` city are directly connected and\n`isConnected[i][j] = 0` otherwise.\n\nReturn _the total number of**provinces**_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)\n\n    \n    \n    **Input:** isConnected = [[110][110][001]]\n    **Output:** 2\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)\n\n    \n    \n    **Input:** isConnected = [[100][010][001]]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 200`\n  * `n == isConnected.length`\n  * `n == isConnected[i].length`\n  * `isConnected[i][j]` is `1` or `0`.\n  * `isConnected[i][i] == 1`\n  * `isConnected[i][j] == isConnected[j][i]`\n\n,class Solution:\n    def findCircleNum(self isConnected: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for ix in enumerate(isConnected):\n            for jn in enumerate(x):\n                if j!=i and n == 1:\n                    graph[i].append(j)\n            \n        visit = set()\n        \n        def dfs(node):\n            if node not in graph:\n                return \n            for neighbor in graph[node]:\n                if neighbor not in visit:\n                    visit.add(neighbor)\n                    dfs(neighbor)\n        count = 0\n        for i in range(len(isConnected)):\n            if i in visit:\n                continue\n            count+=1\n            dfs(i)\n        return count\n
Number of Recent Calls,"###  933\. Number of Recent Calls\n\nYou have a `RecentCounter` class which counts the number of recent requests\nwithin a certain time frame.\n\nImplement the `RecentCounter` class:\n\n  * `RecentCounter()` Initializes the counter with zero recent requests.\n  * `int ping(int t)` Adds a new request at time `t` where `t` represents some time in milliseconds and returns the number of requests that has happened in the past `3000` milliseconds (including the new request). Specifically return the number of requests that have happened in the inclusive range `[t - 3000 t]`.\n\nIt is **guaranteed** that every call to `ping` uses a strictly larger value of\n`t` than the previous call.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""RecentCounter"" ""ping"" ""ping"" ""ping"" ""ping""]\n    [[] [1] [100] [3001] [3002]]\n    **Output**\n    [null 1 2 3 3]\n    \n    **Explanation**\n    RecentCounter recentCounter = new RecentCounter();\n    recentCounter.ping(1);     // requests = [_1_] range is [-29991] return 1\n    recentCounter.ping(100);   // requests = [_1_  _100_] range is [-2900100] return 2\n    recentCounter.ping(3001);  // requests = [_1_  _100_  _3001_] range is [13001] return 3\n    recentCounter.ping(3002);  // requests = [1 _100_  _3001_  _3002_] range is [23002] return 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= t <= 109`\n  * Each test case will call `ping` with **strictly increasing** values of `t`.\n  * At most `104` calls will be made to `ping`.\n\n",# Runtime: 676 ms (Top 17.97%) | Memory: 19.4 MB (Top 70.89%)\nclass RecentCounter:\n    # Here we use list to store ping details.\n    def __init__(self):\n        self.store = []\n\n    def ping(self t: int) -> int:\n        # Basically what we need to return is how many pings fall in the range(t-3000 t).\n        # So here we append every t. Now in loop how many t from left side < t-3000 we just pop them\n        # and return the length of the list which'd contain elements in range(t-3000 t).\n        # And since every t is going to greater than previous we don't need to think about duplicates.\n\n        self.store.append(t)\n\n        while self.store[0] < t-3000:\n            self.store.pop(0)\n\n        return len(self.store)
Number Of Rectangles That Can Form The Largest Square,###  1725\. Number Of Rectangles That Can Form The Largest Square\n\nYou are given an array `rectangles` where `rectangles[i] = [li wi]`\nrepresents the `ith` rectangle of length `li` and width `wi`.\n\nYou can cut the `ith` rectangle to form a square with a side length of `k` if\nboth `k <= li` and `k <= wi`. For example if you have a rectangle `[46]`\nyou can cut it to get a square with a side length of at most `4`.\n\nLet `maxLen` be the side length of the **largest** square you can obtain from\nany of the given rectangles.\n\nReturn _the**number** of rectangles that can make a square with a side length\nof _`maxLen`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rectangles = [[58][39][512][165]]\n    **Output:** 3\n    **Explanation:** The largest squares you can get from each rectangle are of lengths [5355].\n    The largest possible square is of length 5 and you can get it out of 3 rectangles.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rectangles = [[23][37][43][37]]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rectangles.length <= 1000`\n  * `rectangles[i].length == 2`\n  * `1 <= li wi <= 109`\n  * `li != wi`\n\n,# Runtime: 239 ms (Top 76.52%) | Memory: 14.6 MB (Top 25.99%)\n\nclass Solution:\n    def countGoodRectangles(self rectangles: List[List[int]]) -> int:\n\n        #Runtime: 184 ms faster than 65.71% of Python3 online submissions\n        #Memory Usage: 14.9 MB less than 39.90% of Python3 online submissions\n\n        res = []\n\n        minSide = 0\n        maxLen = 0\n\n        for l w in rectangles:\n\n            minSide = min(l w) #Gets minSide of each rectangle\n\n            if minSide > maxLen: #Checks if rectangle holds new maxLen\n                maxLen = minSide #Tracks the current maxLen\n\n            res.append(minSide) #Holds each rectangles minSIde\n\n        return res.count(maxLen)#Returns the count of rectangles whos minSide is equal to maxLen\n
Number of Restricted Paths From First to Last Node,###  1786\. Number of Restricted Paths From First to Last Node\n\nThere is an undirected weighted connected graph. You are given a positive\ninteger `n` which denotes that the graph has `n` nodes labeled from `1` to\n`n` and an array `edges` where each `edges[i] = [ui vi weighti]` denotes\nthat there is an edge between nodes `ui` and `vi` with weight equal to\n`weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0 z1 z2\n... zk]` such that `z0 = start` and `zk = end` and there is an edge between\n`zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let\n`distanceToLastNode(x)` denote the shortest distance of a path between node\n`n` and node `x`. A **restricted path** is a path that also satisfies that\n`distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn _the number of restricted paths from node_ `1` _to node_ `n`. Since\nthat number may be too large return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex1.png)\n\n    \n    \n    **Input:** n = 5 edges = [[123][133][231][142][522][351][5410]]\n    **Output:** 3\n    **Explanation:** Each circle contains the node number in black and its distanceToLastNode value in blue. The three restricted paths are:\n    1) 1 --> 2 --> 5\n    2) 1 --> 2 --> 3 --> 5\n    3) 1 --> 3 --> 5\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/17/restricted_paths_ex22.png)\n\n    \n    \n    **Input:** n = 7 edges = [[131][412][734][253][561][672][753][264]]\n    **Output:** 1\n    **Explanation:** Each circle contains the node number in black and its distanceToLastNode value in blue. The only restricted path is 1 --> 3 --> 7.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 2 * 104`\n  * `n - 1 <= edges.length <= 4 * 104`\n  * `edges[i].length == 3`\n  * `1 <= ui vi <= n`\n  * `ui != vi`\n  * `1 <= weighti <= 105`\n  * There is at most one edge between any two nodes.\n  * There is at least one path between any two nodes.\n\n,class Solution:\n    def countRestrictedPaths(self n: int edges: List[List[int]]) -> int:\n        \n        dct_nd    = {}\n        dist_to_n = {}\n        queue     = deque() # from n-node to 1-node\n        visited   = set()\n        \n        # 1 step: create dictionary with nodes and nodes' distances to n\n\n        # create dictionary with format (weight node_to)\n        # heap will automatically sort weight and node_to in ascending order\n        for l r w in edges:\n            dct_nd[l] = dct_nd.get(l []) + [(w r)]\n            dct_nd[r] = dct_nd.get(r []) + [(w l)]\n        \n        dist_to_n[n] = 0\n        queue.append(n)\n        visited.add(n)\n        \n        hpf = dct_nd[n].copy()   # without '.copy()' hpf will be only pointer and dct_nd[n] could change\n        heapify(hpf)\n        while hpf:\n            el_w el_nd = heappop(hpf)\n            if el_nd in visited:   continue\n            \n            dist_to_n[el_nd] = el_w\n            visited.add(el_nd)\n            queue.append(el_nd)\n\n            if el_nd == 1:         break  # you don't need to traverse more if you've reached 1-node\n                                          # other distances will be more than distance of 1-node\n            for (i_w i_nd) in dct_nd[el_nd]:\n                if i_nd not in visited:\n                    heappush(hpf (el_w + i_w i_nd))\n        # step 1: end\n\n        # add to dictionary one more field: number of routes to n\n        dist_to_n = {k: [v 0]   for k v in dist_to_n.items()}\n        dist_to_n[n] = [dist_to_n[n][0] 1]  # for n-node number of routes = 1\n        \n        # step 2: Dynamic Programming\n        visited.clear()\n        while queue:\n            # start from n and traverse futher and futher\n            nd_prv = queue.popleft()\n            visited.add(nd_prv)\n            for (w_cur nd_cur) in dct_nd[nd_prv]:\n                if nd_cur not in visited           and   \\n                   nd_cur     in dist_to_n.keys()  and dist_to_n[nd_cur][0] > dist_to_n[nd_prv][0]:\n                    # to current node add number of routes from previous node\n                    dist_to_n[nd_cur][1] += dist_to_n[nd_prv][1]\n                    # !!! careful !!! you need to add modulo operation (as said in the task)\n                    dist_to_n[nd_cur][1]  = int(dist_to_n[nd_cur][1] % (1e9+7))\n        # step 2: End\n        \n        return dist_to_n[1][1] # return number of routes for 1-node\n
Number of Segments in a String,"###  434\. Number of Segments in a String\n\nGiven a string `s` return _the number of segments in the string_.\n\nA **segment** is defined to be a contiguous sequence of **non-space\ncharacters**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""Hello my name is John""\n    **Output:** 5\n    **Explanation:** The five segments are [""Hello"" ""my"" ""name"" ""is"" ""John""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""Hello""\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `0 <= s.length <= 300`\n  * `s` consists of lowercase and uppercase English letters digits or one of the following characters `""!@#$%^&*()_+-='.:""`.\n  * The only space character in `s` is `' '`.\n\n",class Solution:\n    def countSegments(self s: str) -> int:\n        return len(s.split())\n
Number of Squareful Arrays,###  996\. Number of Squareful Arrays\n\nAn array is **squareful** if the sum of every pair of adjacent elements is a\n**perfect square**.\n\nGiven an integer array nums return _the number of permutations of_`nums`\n_that are**squareful**_.\n\nTwo permutations `perm1` and `perm2` are different if there is some index `i`\nsuch that `perm1[i] != perm2[i]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1178]\n    **Output:** 2\n    **Explanation:** [1817] and [1781] are the valid permutations.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [222]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 12`\n  * `0 <= nums[i] <= 109`\n\n,# Runtime: 56 ms (Top 51.37%) | Memory: 13.9 MB (Top 48.63%)\nclass Solution:\n    def isSquare(selfnum):\n        return int(num**0.5)**2 == num\n    def makePermutation(selfusedvisprevn):\n        if used == n:\n            #we reached the end\n            self.ans += 1\n            return\n        tmp = {}\n        for i in range(n):\n            if vis[i] == False and self.nums[i] not in tmp:\n                tmp[self.nums[i]] = True\n                if self.nums[i] in self.d[prev]:\n                    vis[i] = True\n                    self.makePermutation(used+1visself.nums[i]n)\n                    vis[i] = False\n\n    def numSquarefulPerms(self nums: List[int]) -> int:\n        d = { x:{} for x in nums}\n        n = len(nums)\n        for i in range(n):\n            for j in range(i+1n):\n                if self.isSquare(nums[i] + nums[j]):\n                    d[nums[i]][nums[j]] = True\n                    d[nums[j]][nums[i]] = True\n        self.nums = nums\n        self.ans = 0\n        self.d = d\n        vis = [False]*n\n        tmp = {}\n        for i in range(n):\n            if nums[i] in tmp: continue\n            tmp[nums[i]] = True\n            vis[i] = True\n            self.makePermutation(1visself.nums[i]n)\n            vis[i] = False\n        return self.ans
Number of Steps to Reduce a Number in Binary Representation to One,"###  1404\. Number of Steps to Reduce a Number in Binary Representation to One\n\nGiven the binary representation of an integer as a string `s` return _the\nnumber of steps to reduce it to_`1` _under the following rules_ :\n\n  * If the current number is even you have to divide it by `2`.\n\n  * If the current number is odd you have to add `1` to it.\n\nIt is guaranteed that you can always reach one for all test cases.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""1101""\n    **Output:** 6\n    **Explanation:** ""1101"" corressponds to number 13 in their decimal representation.\n    Step 1) 13 is odd add 1 and obtain 14. \n    Step 2) 14 is even divide by 2 and obtain 7.\n    Step 3) 7 is odd add 1 and obtain 8.\n    Step 4) 8 is even divide by 2 and obtain 4.  \n    Step 5) 4 is even divide by 2 and obtain 2. \n    Step 6) 2 is even divide by 2 and obtain 1.  \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""10""\n    **Output:** 1\n    **Explanation:** ""10"" corressponds to number 2 in their decimal representation.\n    Step 1) 2 is even divide by 2 and obtain 1.  \n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""1""\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 500`\n  * `s` consists of characters '0' or '1'\n  * `s[0] == '1'`\n\n",\nclass Solution:\n    def numSteps(self s: str) -> int:\n        size = len(s)\n        if size == 1:\n            return 0\n        one_group = s.split('0')\n        zero_group = s.split('1')\n\n        \n        if size - len(zero_group[-1]) == 1:\n            return size - 1\n        else:\n            return size + len(one_group) - len(zero_group[-1])\n
Number of Steps to Reduce a Number to Zero,###  1342\. Number of Steps to Reduce a Number to Zero\n\nGiven an integer `num` return _the number of steps to reduce it to zero_.\n\nIn one step if the current number is even you have to divide it by `2`\notherwise you have to subtract `1` from it.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 14\n    **Output:** 6\n    **Explanation:**  \n    Step 1) 14 is even; divide by 2 and obtain 7. \n    Step 2) 7 is odd; subtract 1 and obtain 6.\n    Step 3) 6 is even; divide by 2 and obtain 3. \n    Step 4) 3 is odd; subtract 1 and obtain 2. \n    Step 5) 2 is even; divide by 2 and obtain 1. \n    Step 6) 1 is odd; subtract 1 and obtain 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 8\n    **Output:** 4\n    **Explanation:**  \n    Step 1) 8 is even; divide by 2 and obtain 4. \n    Step 2) 4 is even; divide by 2 and obtain 2. \n    Step 3) 2 is even; divide by 2 and obtain 1. \n    Step 4) 1 is odd; subtract 1 and obtain 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = 123\n    **Output:** 12\n    \n\n\n\n**Constraints:**\n\n  * `0 <= num <= 106`\n\n,# Runtime: 70 ms (Top 5.12%) | Memory: 13.9 MB (Top 52.31%)\nclass Solution:\n    def numberOfSteps(self num: int) -> int:\n        count=0\n        while num:\n            if num%2:\n                num=num-1\n            else:\n                num=num//2\n            count+=1\n        return count
Number of Strings That Appear as Substrings in Word,"###  1967\. Number of Strings That Appear as Substrings in Word\n\nGiven an array of strings `patterns` and a string `word` return\n_the**number** of strings in _`patterns` _that exist as a**substring** in\n_`word`.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** patterns = [""a""""abc""""bc""""d""] word = ""abc""\n    **Output:** 3\n    **Explanation:**\n    - ""a"" appears as a substring in ""_a_ bc"".\n    - ""abc"" appears as a substring in ""_abc_ "".\n    - ""bc"" appears as a substring in ""a _bc_ "".\n    - ""d"" does not appear as a substring in ""abc"".\n    3 of the strings in patterns appear as a substring in word.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** patterns = [""a""""b""""c""] word = ""aaaaabbbbb""\n    **Output:** 2\n    **Explanation:**\n    - ""a"" appears as a substring in ""a _a_ aaabbbbb"".\n    - ""b"" appears as a substring in ""aaaaabbbb _b_ "".\n    - ""c"" does not appear as a substring in ""aaaaabbbbb"".\n    2 of the strings in patterns appear as a substring in word.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** patterns = [""a""""a""""a""] word = ""ab""\n    **Output:** 3\n    **Explanation:** Each of the patterns appears as a substring in word ""_a_ b"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= patterns.length <= 100`\n  * `1 <= patterns[i].length <= 100`\n  * `1 <= word.length <= 100`\n  * `patterns[i]` and `word` consist of lowercase English letters.\n\n",class Solution:\n    def numOfStrings(self patterns: List[str] word: str) -> int:\n        return sum([pattern in word for pattern in patterns])\n\n        
Number of Students Doing Homework at a Given Time,###  1450\. Number of Students Doing Homework at a Given Time\n\nGiven two integer arrays `startTime` and `endTime` and given an integer\n`queryTime`.\n\nThe `ith` student started doing their homework at the time `startTime[i]` and\nfinished it at time `endTime[i]`.\n\nReturn _the number of students_ doing their homework at time `queryTime`. More\nformally return the number of students where `queryTime` lays in the interval\n`[startTime[i] endTime[i]]` inclusive.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** startTime = [123] endTime = [327] queryTime = 4\n    **Output:** 1\n    **Explanation:** We have 3 students where:\n    The first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\n    The second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\n    The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** startTime = [4] endTime = [4] queryTime = 4\n    **Output:** 1\n    **Explanation:** The only student was doing their homework at the queryTime.\n    \n\n\n\n**Constraints:**\n\n  * `startTime.length == endTime.length`\n  * `1 <= startTime.length <= 100`\n  * `1 <= startTime[i] <= endTime[i] <= 1000`\n  * `1 <= queryTime <= 1000`\n\n,# Runtime: 67 ms (Top 36.82%) | Memory: 13.9 MB (Top 71.93%)\nclass Solution(object):\n    def busyStudent(self startTime endTime queryTime):\n        res = 0\n        for i in range(len(startTime)):\n            if startTime[i] <= queryTime <= endTime[i]:\n                res += 1\n            else:\n                pass\n        return res
Number of Students Unable to Eat Lunch,###  1700\. Number of Students Unable to Eat Lunch\n\nThe school cafeteria offers circular and square sandwiches at lunch break\nreferred to by numbers `0` and `1` respectively. All students stand in a\nqueue. Each student either prefers square or circular sandwiches.\n\nThe number of sandwiches in the cafeteria is equal to the number of students.\nThe sandwiches are placed in a **stack**. At each step:\n\n  * If the student at the front of the queue **prefers** the sandwich on the top of the stack they will **take it** and leave the queue.\n  * Otherwise they will **leave it** and go to the queue's end.\n\nThis continues until none of the queue students want to take the top sandwich\nand are thus unable to eat.\n\nYou are given two integer arrays `students` and `sandwiches` where\n`sandwiches[i]` is the type of the `i​​​​​​th` sandwich in the\nstack (`i = 0` is the top of the stack) and `students[j]` is the preference of\nthe `j​​​​​​th` student in the initial queue (`j = 0` is the front\nof the queue). Return _the number of students that are unable to eat._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** students = [1100] sandwiches = [0101]\n    **Output:** 0**Explanation:**\n    - Front student leaves the top sandwich and returns to the end of the line making students = [1001].\n    - Front student leaves the top sandwich and returns to the end of the line making students = [0011].\n    - Front student takes the top sandwich and leaves the line making students = [011] and sandwiches = [101].\n    - Front student leaves the top sandwich and returns to the end of the line making students = [110].\n    - Front student takes the top sandwich and leaves the line making students = [10] and sandwiches = [01].\n    - Front student leaves the top sandwich and returns to the end of the line making students = [01].\n    - Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].\n    - Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].\n    Hence all students are able to eat.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** students = [111001] sandwiches = [100011]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= students.length sandwiches.length <= 100`\n  * `students.length == sandwiches.length`\n  * `sandwiches[i]` is `0` or `1`.\n  * `students[i]` is `0` or `1`.\n\n,"// Runtime: 76 ms (Top 5.69%) | Memory: 17.30 MB (Top 7.83%)\n\nclass Solution:\n    def countStudents(self students: List[int] sandwiches: List[int]) -> int:\n        count = 0\n        while len(students) > count:\n            if students[0] == sandwiches[0]:\n                sandwiches.pop(0)\n                count = 0\n            else:\n                students.append(students[0])\n                count+=1\n\n            students.pop(0)\n        return len(students)\n		\n#Upvote will be encouraging.\n"
Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold,###  1343\. Number of Sub-arrays of Size K and Average Greater than or Equal\nto Threshold\n\nGiven an array of integers `arr` and two integers `k` and `threshold` return\n_the number of sub-arrays of size_`k` _and average greater than or equal\nto_`threshold`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [22225558] k = 3 threshold = 4\n    **Output:** 3\n    **Explanation:** Sub-arrays [255][555] and [558] have averages 4 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [1113172329317523] k = 3 threshold = 5\n    **Output:** 6\n    **Explanation:** The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 105`\n  * `1 <= arr[i] <= 104`\n  * `1 <= k <= arr.length`\n  * `0 <= threshold <= 104`\n\n,class Solution:\n    def numOfSubarrays(self nums: List[int] k: int threshold: int) -> int:\n        currSum = 0\n        start = 0\n        end = 0\n        count = 0\n        \n        # run right pointer till end element\n        for end in range(len(nums)):\n            # update value to window\n            currSum += nums[end]\n            \n            # check if window size achieved\n            if (end - start + 1) == k:\n                # is average > target val\n                if (currSum // k) >= threshold:\n                    count += 1\n                # slide the window\n                currSum -= nums[start]\n                start += 1\n            \n            \n        return count\n
Number of Sub-arrays With Odd Sum,###  1524\. Number of Sub-arrays With Odd Sum\n\nGiven an array of integers `arr` return _the number of subarrays with\nan**odd** sum_.\n\nSince the answer can be very large return it modulo `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [135]\n    **Output:** 4\n    **Explanation:** All subarrays are [[1][13][135][3][35][5]]\n    All sub-arrays sum are [149385].\n    Odd sums are [1935] so the answer is 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [246]\n    **Output:** 0\n    **Explanation:** All subarrays are [[2][24][246][4][46][6]]\n    All sub-arrays sum are [26124106].\n    All sub-arrays have even sum and the answer is 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [1234567]\n    **Output:** 16\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 105`\n  * `1 <= arr[i] <= 100`\n\n,class Solution:\n    def numOfSubarrays(self arr: List[int]) -> int:\n        ce co = 0 0\n        s = 0\n        for x in arr:\n            if x % 2 == 0:\n                ce += 1\n            else:\n                old_co = co\n                co = ce + 1\n                ce = old_co\n            \n            s += co\n            \n        return s % (10**9+7)\n
Number of Subsequences That Satisfy the Given Sum Condition,###  1498\. Number of Subsequences That Satisfy the Given Sum Condition\n\nYou are given an array of integers `nums` and an integer `target`.\n\nReturn _the number of**non-empty** subsequences of _`nums` _such that the sum\nof the minimum and maximum element on it is less or equal to_`target`. Since\nthe answer may be too large return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3567] target = 9\n    **Output:** 4\n    **Explanation:** There are 4 subsequences that satisfy the condition.\n    [3] -> Min value + max value <= target (3 + 3 <= 9)\n    [35] -> (3 + 5 <= 9)\n    [356] -> (3 + 6 <= 9)\n    [36] -> (3 + 6 <= 9)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [3368] target = 10\n    **Output:** 6\n    **Explanation:** There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).\n    [3]  [3]  [33] [36]  [36]  [336]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [233467] target = 12\n    **Output:** 61\n    **Explanation:** There are 63 non-empty subsequences two of them do not satisfy the condition ([67] [7]).\n    Number of valid subsequences (63 - 2 = 61).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 106`\n  * `1 <= target <= 106`\n\n,# Runtime: 637 ms (Top 91.1%) | Memory: 29.39 MB (Top 30.6%)\n\nclass Solution:\n    def numSubseq(self nums: List[int] target: int) -> int:\n        nums.sort()\n        left right = 0 len(nums) - 1\n        count = 0\n        mod = 10 ** 9 + 7\n        \n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                count += pow(2 right - left mod)\n                left += 1\n        \n        return count % mod\n
Number of Substrings Containing All Three Characters,"###  1358\. Number of Substrings Containing All Three Characters\n\nGiven a string `s` consisting only of characters _a_  _b_ and _c_.\n\nReturn the number of substrings containing **at least**  one occurrence of all\nthese characters _a_  _b_ and _c_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcabc""\n    **Output:** 10\n    **Explanation:** The substrings containing at least one occurrence of the characters _a_  _b_  and _c are ""_ abc _"" ""_ abca _"" ""_ abcab _"" ""_ abcabc _"" ""_ bca _"" ""_ bcab _"" ""_ bcabc _"" ""_ cab _"" ""_ cabc _""_ and _""_ abc _""_(**again**)_._\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aaacb""\n    **Output:** 3\n    **Explanation:** The substrings containing at least one occurrence of the characters _a_  _b_  and _c are ""_ aaacb _"" ""_ aacb _""_ and _""_ acb _"".___\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""abc""\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `3 <= s.length <= 5 x 10^4`\n  * `s` only consists of _a_  _b_ or _c  _characters.\n\n",# Runtime: 466 ms (Top 30.17%) | Memory: 14.4 MB (Top 31.83%)\nclass Solution:\n    def numberOfSubstrings(self s: str) -> int:\n        start = 0\n        end = 0\n        counter = 0\n        store = {'a' : 0 'b' : 0 'c' : 0}\n\n        for end in range(len(s)):\n            store[s[end]] += 1\n\n            while store['a'] > 0 and store['b'] > 0 and store['c'] > 0:\n                counter += (len(s) - end)\n                store[s[start]] -= 1\n                start += 1\n\n        return counter
Number of Substrings With Only 1s,"###  1513\. Number of Substrings With Only 1s\n\nGiven a binary string `s` return _the number of substrings with all\ncharacters_ `1` _'s_. Since the answer may be too large return it modulo `109\n+ 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""0110111""\n    **Output:** 9\n    **Explanation:** There are 9 substring in total with only 1's characters.\n    ""1"" -> 5 times.\n    ""11"" -> 3 times.\n    ""111"" -> 1 time.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""101""\n    **Output:** 2\n    **Explanation:** Substring ""1"" is shown 2 times in s.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""111111""\n    **Output:** 21\n    **Explanation:** Each substring contains only 1's characters.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is either `'0'` or `'1'`.\n\n",# Runtime: 46 ms (Top 40.6%) | Memory: 14.50 MB (Top 56.2%)\n\nclass Solution(object):\n    def numSub(self s):\n        res currsum = 00\n        for digit in s:\n            if digit == '0':\n                currsum = 0\n            else:\n                currsum += 1 \n                res+=currsum \n        return res % (10**9+7)
Number of Times Binary String Is Prefix-Aligned,"###  1375\. Number of Times Binary String Is Prefix-Aligned\n\nYou have a **1-indexed** binary string of length `n` where all the bits are\n`0` initially. We will flip all the bits of this binary string (i.e. change\nthem from `0` to `1`) one by one. You are given a **1-indexed** integer array\n`flips` where `flips[i]` indicates that the bit at index `i` will be flipped\nin the `ith` step.\n\nA binary string is **prefix-aligned** if after the `ith` step all the bits\nin the **inclusive** range `[1 i]` are ones and all the other bits are zeros.\n\nReturn _the number of times the binary string is**prefix-aligned** during the\nflipping process_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** flips = [32415]\n    **Output:** 2\n    **Explanation:** The binary string is initially ""00000"".\n    After applying step 1: The string becomes ""00100"" which is not prefix-aligned.\n    After applying step 2: The string becomes ""01100"" which is not prefix-aligned.\n    After applying step 3: The string becomes ""01110"" which is not prefix-aligned.\n    After applying step 4: The string becomes ""11110"" which is prefix-aligned.\n    After applying step 5: The string becomes ""11111"" which is prefix-aligned.\n    We can see that the string was prefix-aligned 2 times so we return 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** flips = [4123]\n    **Output:** 1\n    **Explanation:** The binary string is initially ""0000"".\n    After applying step 1: The string becomes ""0001"" which is not prefix-aligned.\n    After applying step 2: The string becomes ""1001"" which is not prefix-aligned.\n    After applying step 3: The string becomes ""1101"" which is not prefix-aligned.\n    After applying step 4: The string becomes ""1111"" which is prefix-aligned.\n    We can see that the string was prefix-aligned 1 time so we return 1.\n    \n\n\n\n**Constraints:**\n\n  * `n == flips.length`\n  * `1 <= n <= 5 * 104`\n  * `flips` is a permutation of the integers in the range `[1 n]`.\n\n",class Solution:\n    def numTimesAllBlue(self flips: List[int]) -> int:\n        \n        \n        l = len(flips)\n        s = 0\n        c = 0\n        \n        for i in range(len(flips)):\n            f = flips[i]\n            s = 1 << (f - 1) | s\n            if s ==  (1 << (i+1))-1:\n                c += 1\n        \n        return c\n
Number of Valid Words for Each Puzzle,"###  1178\. Number of Valid Words for Each Puzzle\n\nWith respect to a given `puzzle` string a `word` is _valid_ if both the\nfollowing conditions are satisfied:\n\n  * `word` contains the first letter of `puzzle`.\n  * For each letter in `word` that letter is in `puzzle`. \n    * For example if the puzzle is `""abcdefg""` then valid words are `""faced""` `""cabbage""` and `""baggage""` while\n    * invalid words are `""beefed""` (does not include `'a'`) and `""based""` (includes `'s'` which is not in the puzzle).\n\nReturn _an array_`answer` _ where_`answer[i]`_is the number of words in the\ngiven word list_`words` _that is valid with respect to the\npuzzle_`puzzles[i]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""aaaa""""asas""""able""""ability""""actt""""actor""""access""] puzzles = [""aboveyz""""abrodyz""""abslute""""absoryz""""actresz""""gaswxyz""]\n    **Output:** [113240]\n    **Explanation:** \n    1 valid word for ""aboveyz"" : ""aaaa"" \n    1 valid word for ""abrodyz"" : ""aaaa""\n    3 valid words for ""abslute"" : ""aaaa"" ""asas"" ""able""\n    2 valid words for ""absoryz"" : ""aaaa"" ""asas""\n    4 valid words for ""actresz"" : ""aaaa"" ""asas"" ""actt"" ""access""\n    There are no valid words for ""gaswxyz"" cause none of the words in the list contains letter 'g'.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""apple""""pleas""""please""] puzzles = [""aelwxyz""""aelpxyz""""aelpsxy""""saelpxy""""xaelpsy""]\n    **Output:** [01320]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 105`\n  * `4 <= words[i].length <= 50`\n  * `1 <= puzzles.length <= 104`\n  * `puzzles[i].length == 7`\n  * `words[i]` and `puzzles[i]` consist of lowercase English letters.\n  * Each `puzzles[i] `does not contain repeated characters.\n\n",class Solution:\n    def findNumOfValidWords(self words: List[str] puzzles: List[str]) -> List[int]:\n        look_up=collections.defaultdict(int)\n        def get_mask(word):\n            mask=0\n            for c in word:\n                mask |= 1<<(ord(c)-ord('a'))\n            return mask\n        for word in words:\n            mask=get_mask(word)\n            look_up[mask]+=1\n        ans=[]\n        def solve(puzzle_idxmaskc_idx):\n            if c_idx==len(puzzles[puzzle_idx]):\n                ans[-1]+=look_up[mask]\n                return\n            #take this c_idx\n            solve(puzzle_idxmask | 1<<(ord(puzzles[puzzle_idx][c_idx])-ord('a'))c_idx+1)\n            #dont take this c_idx\n            solve(puzzle_idxmaskc_idx+1)\n        for ipuzzle in enumerate(puzzles):\n            ans.append(0)\n            solve(i1<<(ord(puzzle[0])-ord('a'))1)\n        return ans\n
Number of Valid Words in a Sentence,"###  2047\. Number of Valid Words in a Sentence\n\nA sentence consists of lowercase letters (`'a'` to `'z'`) digits (`'0'` to\n`'9'`) hyphens (`'-'`) punctuation marks (`'!'` `'.'` and `''`) and\nspaces (`' '`) only. Each sentence can be broken down into **one or more\ntokens** separated by one or more spaces `' '`.\n\nA token is a valid word if **all three** of the following are true:\n\n  * It only contains lowercase letters hyphens and/or punctuation (**no** digits).\n  * There is **at most one** hyphen `'-'`. If present it **must** be surrounded by lowercase characters (`""a-b""` is valid but `""-ab""` and `""ab-""` are not valid).\n  * There is **at most one** punctuation mark. If present it **must** be at the **end** of the token (`""ab""` `""cd!""` and `"".""` are valid but `""a!b""` and `""c.""` are not valid).\n\nExamples of valid words include `""a-b.""` `""afad""` `""ba-c""` `""a!""` and\n`""!""`.\n\nGiven a string `sentence` return _the**number** of valid words in\n_`sentence`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** sentence = ""_cat_ _and_  _dog_ ""\n    **Output:** 3\n    **Explanation:** The valid words in the sentence are ""cat"" ""and"" and ""dog"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** sentence = ""!this  1-s b8d!""\n    **Output:** 0\n    **Explanation:** There are no valid words in the sentence.\n    ""!this"" is invalid because it starts with a punctuation mark.\n    ""1-s"" and ""b8d"" are invalid because they contain digits.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** sentence = ""_alice_ _and_  _bob_ _are_ _playing_ stone-game10""\n    **Output:** 5\n    **Explanation:** The valid words in the sentence are ""alice"" ""and"" ""bob"" ""are"" and ""playing"".\n    ""stone-game10"" is invalid because it contains digits.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= sentence.length <= 1000`\n  * `sentence` only contains lowercase English letters digits `' '` `'-'` `'!'` `'.'` and `''`.\n  * There will be at least `1` token.\n\n",import re\nclass Solution:\n    def countValidWords(self sentence: str) -> int:\n        \n        # parse and get each word from sentence\n        words = sentence.split()\n        \n        # regular expression pattern for valid words\n        pattern = re.compile( r'^([a-z]+\-?[a-z]+[!\.]?)$|^([a-z]*[!\.]?)$' )\n        \n        # valid word count\n        count = 0\n        \n        # scan each word from word pool\n        for word in words:\n            \n            # judge whether current word is valid or not\n            match = re.match(pattern word)\n            \n            if match:\n                count+=1\n                \n        return count\n
Number of Visible People in a Queue,###  1944\. Number of Visible People in a Queue\n\nThere are `n` people standing in a queue and they numbered from `0` to `n -\n1` in **left to right** order. You are given an array `heights` of\n**distinct** integers where `heights[i]` represents the height of the `ith`\nperson.\n\nA person can **see** another person to their right in the queue if everybody\nin between is **shorter** than both of them. More formally the `ith` person\ncan see the `jth` person if `i < j` and `min(heights[i] heights[j]) >\nmax(heights[i+1] heights[i+2] ... heights[j-1])`.\n\nReturn _an array_`answer` _of length_`n` _where_`answer[i]`_is the**number of\npeople** the _`ith` _person can**see** to their right in the queue_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/29/queue-plane.jpg)\n\n    \n    \n    **Input:** heights = [10685119]\n    **Output:** [312110]\n    **Explanation:**\n    Person 0 can see person 1 2 and 4.\n    Person 1 can see person 2.\n    Person 2 can see person 3 and 4.\n    Person 3 can see person 4.\n    Person 4 can see person 5.\n    Person 5 can see no one since nobody is to the right of them.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** heights = [512310]\n    **Output:** [41110]\n    \n\n\n\n**Constraints:**\n\n  * `n == heights.length`\n  * `1 <= n <= 105`\n  * `1 <= heights[i] <= 105`\n  * All the values of `heights` are **unique**.\n\n,# Runtime: 2162 ms (Top 20.79%) | Memory: 30.1 MB (Top 6.96%)\n\nclass Solution:\n    def canSeePersonsCount(self heights: List[int]) -> List[int]:\n        ans=[]\n        stack=[]\n        n=len(heights)\n        for i in range(n-1-1-1):\n            if len(stack)==0:\n                ans.append(0)\n                stack.append(heights[i])\n            else:\n                if heights[i]<stack[-1]:\n                    ans.append(1)\n                    stack.append(heights[i])\n                else:\n                    ctr=0\n                    while(len(stack)>0 and stack[-1]<heights[i]):\n                        ctr+=1\n                        stack.pop()\n                    if len(stack)==0:\n                        ans.append(ctr)\n                    else:\n                        ans.append(ctr+1)\n                    stack.append(heights[i])\n        return ans[::-1]
Number of Ways of Cutting a Pizza,"###  1444\. Number of Ways of Cutting a Pizza\n\nGiven a rectangular pizza represented as a `rows x cols` matrix containing the\nfollowing characters: `'A'` (an apple) and `'.'` (empty cell) and given the\ninteger `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n\nFor each cut you choose the direction: vertical or horizontal then you choose\na cut position at the cell boundary and cut the pizza into two pieces. If you\ncut the pizza vertically give the left part of the pizza to a person. If you\ncut the pizza horizontally give the upper part of the pizza to a person. Give\nthe last piece of pizza to the last person.\n\n_Return the number of ways of cutting the pizza such that each piece\ncontains**at least** one apple. _Since the answer can be a huge number return\nthis modulo 10^9 + 7.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/04/23/ways_to_cut_apple_1.png)**\n\n    \n    \n    **Input:** pizza = [""A..""""AAA""""...""] k = 3\n    **Output:** 3 \n    **Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** pizza = [""A..""""AA.""""...""] k = 3\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** pizza = [""A..""""A..""""...""] k = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rows cols <= 50`\n  * `rows == pizza.length`\n  * `cols == pizza[i].length`\n  * `1 <= k <= 10`\n  * `pizza` consists of characters `'A'` and `'.'` only.\n\n",class Solution:\n    def ways(self p: List[str] k: int) -> int:\n        m n = len(p) len(p[0])\n        apples = [[0 for _ in range(n+1)] for _ in range(m+1)] \n        # number of apples in (00) to (ij)\n        apples[1][1] = 0 if p[0][0] == '.' else 1\n        for j in range(1n):\n            apples[1][j+1] = apples[1][j] if p[0][j] == '.' else apples[1][j] + 1\n        for i in range(1m):\n            cur_apple = 0 if p[i][0] == '.' else 1\n            apples[i+1][1] = apples[i][1] + cur_apple\n            for j in range(1n):\n                if p[i][j] == 'A': cur_apple += 1\n                apples[i+1][j+1] = apples[i][j+1] + cur_apple\n\n        def getApples(xyzw):\n        # get the number of apples within range\n        # xy: top-left coordinates of current pizza\n        # zw: bottom-right\n            return apples[z+1][w+1] + apples[x][y] - apples[z+1][y] - apples[x][w+1]\n\n        @lru_cache(None)\n        def cut(cxyzw):\n        # c: number of cuts already cut\n        # xy: top-left coordinates of current pizza\n        # zw: bottom-right\n            if c == k - 1:\n                return 1 if getApples(xyzw) > 0 else 0\n\n            r = 0\n            # horizontal cuts\n            i = x\n            while i < z:\n                if getApples(xyiw) > 0: break\n                i += 1\n            while i < z:\n                r += cut(c+1i+1yzw)\n                i += 1\n            # vertical cuts\n            j = y\n            while j < w:\n                if getApples(xyzj) > 0: break\n                j += 1\n            while j < w:\n                r += cut(c+1xj+1zw)\n                j += 1\n\n            return r\n\n        return cut(000m-1n-1)%(10**9+7)
Number of Ways to Divide a Long Corridor,"###  2147\. Number of Ways to Divide a Long Corridor\n\nAlong a long library corridor there is a line of seats and decorative plants.\nYou are given a **0-indexed** string `corridor` of length `n` consisting of\nletters `'S'` and `'P'` where each `'S'` represents a seat and each `'P'`\nrepresents a plant.\n\nOne room divider has **already** been installed to the left of index `0` and\n**another** to the right of index `n - 1`. Additional room dividers can be\ninstalled. For each position between indices `i - 1` and `i` (`1 <= i <= n -\n1`) at most one divider can be installed.\n\nDivide the corridor into non-overlapping sections where each section has\n**exactly two seats** with any number of plants. There may be multiple ways to\nperform the division. Two ways are **different** if there is a position with a\nroom divider installed in the first way but not in the second way.\n\nReturn _the number of ways to divide the corridor_. Since the answer may be\nvery large return it **modulo** `109 + 7`. If there is no way return `0`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/04/1.png)\n\n    \n    \n    **Input:** corridor = ""SSPPSPS""\n    **Output:** 3\n    **Explanation:** There are 3 different ways to divide the corridor.\n    The black bars in the above image indicate the two room dividers already installed.\n    Note that in each of the ways **each** section has exactly **two** seats.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/04/2.png)\n\n    \n    \n    **Input:** corridor = ""PPSPSP""\n    **Output:** 1\n    **Explanation:** There is only 1 way to divide the corridor by not installing any additional dividers.\n    Installing any would create some section that does not have exactly two seats.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/12/12/3.png)\n\n    \n    \n    **Input:** corridor = ""S""\n    **Output:** 0\n    **Explanation:** There is no way to divide the corridor because there will always be a section that does not have exactly two seats.\n    \n\n\n\n**Constraints:**\n\n  * `n == corridor.length`\n  * `1 <= n <= 105`\n  * `corridor[i]` is either `'S'` or `'P'`.\n\n",// Runtime: 253 ms (Top 99.08%) | Memory: 17.50 MB (Top 42.72%)\n\nclass Solution:\n    def numberOfWays(self corridor):\n        seat res plant = 0 1 0\n        for i in corridor:\n            if i=='S':\n                seat += 1\n            else:\n                if seat == 2:\n                    plant += 1\n            if seat == 3:\n                res = res*(plant+1) % (10**9 + 7)\n                seat  plant = 1  0\n        if seat != 2:\n            return 0\n        return res\n
Number Of Ways To Reconstruct A Tree,###  1719\. Number Of Ways To Reconstruct A Tree\n\nYou are given an array `pairs` where `pairs[i] = [xi yi]` and:\n\n  * There are no duplicates.\n  * `xi < yi`\n\nLet `ways` be the number of rooted trees that satisfy the following\nconditions:\n\n  * The tree consists of nodes whose values appeared in `pairs`.\n  * A pair `[xi yi]` exists in `pairs` **if and only if** `xi` is an ancestor of `yi` or `yi` is an ancestor of `xi`.\n  * **Note:** the tree does not have to be a binary tree.\n\nTwo ways are considered to be different if there is at least one node that has\ndifferent parents in both ways.\n\nReturn:\n\n  * `0` if `ways == 0`\n  * `1` if `ways == 1`\n  * `2` if `ways > 1`\n\nA **rooted tree** is a tree that has a single root node and all edges are\noriented to be outgoing from the root.\n\nAn **ancestor** of a node is any node on the path from the root to that node\n(excluding the node itself). The root has no ancestors.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/03/trees2.png)\n\n    \n    \n    **Input:** pairs = [[12][23]]\n    **Output:** 1\n    **Explanation:** There is exactly one valid rooted tree which is shown in the above figure.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/03/tree.png)\n\n    \n    \n    **Input:** pairs = [[12][23][13]]\n    **Output:** 2\n    **Explanation:** There are multiple valid rooted trees. Three of them are shown in the above figures.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** pairs = [[12][23][24][15]]\n    **Output:** 0\n    **Explanation:** There are no valid rooted trees.\n\n\n\n**Constraints:**\n\n  * `1 <= pairs.length <= 105`\n  * `1 <= xi < yi <= 500`\n  * The elements in `pairs` are unique.\n\n,class Solution:\n    def checkWays(self P):\n        g = defaultdict(set)\n        for u v in P:\n            g[u].add(v)\n            g[v].add(u)\n\n        def helper(nodes):\n            d m = defaultdict(list) len(nodes) - 1\n            for node in nodes:\n                d[len(g[node])].append(node)\n\n            if len(d[m]) == 0: return 0\n            root = d[m][0]\n            \n            for node in g[root]: g[node].remove(root)\n            \n            comps seen i = defaultdict(set) set() 0\n            def dfs(node i):\n                comps[i].add(node)\n                seen.add(node)\n                for neib in g[node]:\n                    if neib not in seen: dfs(neib i)\n                        \n            for node in nodes:\n                if node != root and node not in seen:\n                    dfs(node i)\n                    i += 1\n                    \n            cands = [helper(comps[i]) for i in comps]\n            if 0 in cands: return 0\n            if 2 in cands: return 2\n            if len(d[m]) >= 2: return 2\n            return 1\n            \n        return helper(set(g.keys()))\n
Number of Ways to Reorder Array to Get Same BST,###  1569\. Number of Ways to Reorder Array to Get Same BST\n\nGiven an array `nums` that represents a permutation of integers from `1` to\n`n`. We are going to construct a binary search tree (BST) by inserting the\nelements of `nums` in order into an initially empty BST. Find the number of\ndifferent ways to reorder `nums` so that the constructed BST is identical to\nthat formed from the original array `nums`.\n\n  * For example given `nums = [213]` we will have 2 as the root 1 as a left child and 3 as a right child. The array `[231]` also yields the same BST but `[321]` yields a different BST.\n\nReturn _the number of ways to reorder_ `nums` _such that the BST formed is\nidentical to the original BST formed from_ `nums`.\n\nSince the answer may be very large **return it modulo**`109 + 7`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/12/bb.png)\n\n    \n    \n    **Input:** nums = [213]\n    **Output:** 1\n    **Explanation:** We can reorder nums to be [231] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/08/12/ex1.png)\n\n    \n    \n    **Input:** nums = [34512]\n    **Output:** 5\n    **Explanation:** The following 5 arrays will yield the same BST: \n    [31245]\n    [31425]\n    [31452]\n    [34125]\n    [34152]\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/08/12/ex4.png)\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** 0\n    **Explanation:** There are no other orderings of nums that will yield the same BST.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `1 <= nums[i] <= nums.length`\n  * All integers in `nums` are **distinct**.\n\n,# Runtime: 556 ms (Top 18.24%) | Memory: 15.4 MB (Top 89.19%)\nclass node:\n    def __init__(self val):\n        self.val = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def BST(self root cur):\n        if cur.val < root.val:\n            if root.left == None:\n                root.left = cur\n                return\n            else:\n                self.BST(root.left cur)\n        elif cur.val > root.val:\n            if root.right == None:\n                root.right = cur\n                return\n            else:\n                self.BST(root.right cur)\n\n    def solve(self root):\n        if root.left == None and root.right == None:\n            return 1\n        left = 0 ; right = 0\n        if root.left is not None:\n            left = self.solve(root.left)\n        if root.right is not None:\n            right = self.solve(root.right)\n        self.total *= math.comb(left + right left)\n        return left + right + 1\n\n    def numOfWays(self nums: List[int]) -> int:\n        import math\n        self.total = 1\n        root = node(nums[0])\n        for i in range(1 len(nums)):\n            self.BST(root node(nums[i]))\n        self.solve(root)\n        return (self.total - 1) % (int(1e9) + 7)
Number of Ways to Select Buildings,"###  2222\. Number of Ways to Select Buildings\n\nYou are given a **0-indexed** binary string `s` which represents the types of\nbuildings along a street where:\n\n  * `s[i] = '0'` denotes that the `ith` building is an office and\n  * `s[i] = '1'` denotes that the `ith` building is a restaurant.\n\nAs a city official you would like to **select** 3 buildings for random\ninspection. However to ensure variety **no two consecutive** buildings out\nof the **selected** buildings can be of the same type.\n\n  * For example given `s = ""0 _**0**_ 1 _**1**_ 0 _**1**_ ""` we cannot select the `1st` `3rd` and `5th` buildings as that would form `""0** _11_** ""` which is **not** allowed due to having two consecutive buildings of the same type.\n\nReturn _the**number of valid ways** to select 3 buildings._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""001101""\n    **Output:** 6\n    **Explanation:** \n    The following sets of indices selected are valid:\n    - [024] from ""_**0**_ 0** _1_** 1** _0_** 1"" forms ""010""\n    - [034] from ""_**0**_ 01 _**10**_ 1"" forms ""010""\n    - [124] from ""0 _**01**_ 1 _**0**_ 1"" forms ""010""\n    - [134] from ""0 _**0**_ 1 _**10**_ 1"" forms ""010""\n    - [245] from ""00 _**1**_ 1 _**01**_ "" forms ""101""\n    - [345] from ""001 _**101**_ "" forms ""101""\n    No other selection is valid. Thus there are 6 total ways.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""11100""\n    **Output:** 0\n    **Explanation:** It can be shown that there are no valid selections.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= s.length <= 105`\n  * `s[i]` is either `'0'` or `'1'`.\n\n","class Solution:\n    def numberOfWays(self s: str) -> int:\n        \n        temp = []\n        c0 = 0\n        c1 = 0\n        for char in s :\n            if char == ""0"" :\n                c0+=1\n            else:\n                c1+=1\n            temp.append([c0c1])\n            \n        total0 = c0\n        total1 = c1\n        \n        \n        count = 0\n        for i in range(1 len(s)-1) :\n            \n            if s[i] == ""0"" :\n                m1 = temp[i-1][1]\n                m2 = total1 - temp[i][1]\n                count += m1*m2\n                \n            else:\n                m1 = temp[i-1][0]\n                m2 = total0 - temp[i][0]\n                count += m1*m2\n        return count\n                \n        \n"
Number of Ways to Separate Numbers,"###  1977\. Number of Ways to Separate Numbers\n\nYou wrote down many **positive** integers in a string called `num`. However\nyou realized that you forgot to add commas to seperate the different numbers.\nYou remember that the list of integers was **non-decreasing** and that **no**\ninteger had leading zeros.\n\nReturn _the**number of possible lists of integers** that you could have\nwritten down to get the string _`num`. Since the answer may be large return\nit **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = ""327""\n    **Output:** 2\n    **Explanation:** You could have written down the numbers:\n    3 27\n    327\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = ""094""\n    **Output:** 0\n    **Explanation:** No numbers can have leading zeros and all numbers must be positive.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = ""0""\n    **Output:** 0\n    **Explanation:** No numbers can have leading zeros and all numbers must be positive.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num.length <= 3500`\n  * `num` consists of digits `'0'` through `'9'`.\n\n",# Runtime: 11887 ms (Top 6.00%) | Memory: 14.2 MB (Top 88.00%)\nclass Solution:\n    def numberOfCombinations(self num: str) -> int:\n        if num[0]=='0': return 0\n        N=len(num)\n        MOD=int(10**9+7)\n        ways = (N+1)*[0]\n        acc = list(ways)\n        for n in range(1N+1):\n            ways[n] = int(n==N or num[n]!='0')\n            for i in range(n+1N+1):\n                if i<N and num[i]=='0':\n                    ways[i] = 0\n                    continue\n                ways[i] = (acc[i-n] + ((w := ways[i-n]) and i>=2*n and num[i-2*n:i-n] <= num[i-n:i] and w)) %MOD\n            for i in range(nN+1):\n                a = (acc[i] + ways[i]) %MOD\n                acc[i] = a\n        return acc[N]
Number of Ways to Split a String,"###  1573\. Number of Ways to Split a String\n\nGiven a binary string `s` you can split `s` into 3 **non-empty** strings\n`s1` `s2` and `s3` where `s1 + s2 + s3 = s`.\n\nReturn the number of ways `s` can be split such that the number of ones is the\nsame in `s1` `s2` and `s3`. Since the answer may be too large return it\n**modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""10101""\n    **Output:** 4\n    **Explanation:** There are four ways to split s in 3 parts where each part contain the same number of letters '1'.\n    ""1|010|1""\n    ""1|01|01""\n    ""10|10|1""\n    ""10|1|01""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""1001""\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""0000""\n    **Output:** 3\n    **Explanation:** There are three ways to split s in 3 parts.\n    ""0|0|00""\n    ""0|00|0""\n    ""00|0|0""\n    \n\n\n\n**Constraints:**\n\n  * `3 <= s.length <= 105`\n  * `s[i]` is either `'0'` or `'1'`.\n\n","class Solution:\n    def numWays(self s: str) -> int:\n        ones = 0\n\n        # Count number of Ones\n        for char in s:\n            if char == ""1"":\n                ones += 1\n\n        # Can't be grouped equally if the ones are not divisible by 3\n        if ones > 0 and ones % 3 != 0:\n            return 0\n\n        # Ways of selecting two dividers from n - 1 dividers \n        if ones == 0:\n            n = len(s)\n			# n = {3: 1 4: 3 5: 6 6: 10 7: 15 ... }\n            return (((n - 1) * (n - 2)) // 2) % ((10 ** 9) + 7)\n\n        # Number of ones in each group\n        ones_interval = ones // 3\n\n        # Number of zeroes which lie on the borders\n        left right = 0 0\n\n        # Iterator\n        i = 0\n        temp = 0\n\n        # Finding the zeroes on the left and right border\n        while i < len(s):\n            temp += int(s[i]) & 1\n            if temp == ones_interval:\n                if s[i] == '0':\n                    left += 1\n            if temp == 2 * ones_interval:\n                if s[i] == '0':\n                    right += 1\n            i += 1\n        \n        # The result is the product of number of (left + 1) and (right + 1)\n        # Because let's assume it as we only want to fill up the middle group\n        # The solution would be if we have zero then there might be a zero in the middle\n        # Or there might not be the zero so this might case is added and then\n		# the events are independent so product of both the events\n        return ((left + 1) * (right + 1)) % ((10 ** 9) + 7)\n\n"
Number of Ways to Split Array,###  2270\. Number of Ways to Split Array\n\nYou are given a **0-indexed** integer array `nums` of length `n`.\n\n`nums` contains a **valid split** at index `i` if the following are true:\n\n  * The sum of the first `i + 1` elements is **greater than or equal to** the sum of the last `n - i - 1` elements.\n  * There is **at least one** element to the right of `i`. That is `0 <= i < n - 1`.\n\nReturn _the number of**valid splits** in_ `nums`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [104-87]\n    **Output:** 2\n    **Explanation:** \n    There are three ways of splitting nums into two non-empty parts:\n    - Split nums at index 0. Then the first part is [10] and its sum is 10. The second part is [4-87] and its sum is 3. Since 10 >= 3 i = 0 is a valid split.\n    - Split nums at index 1. Then the first part is [104] and its sum is 14. The second part is [-87] and its sum is -1. Since 14 >= -1 i = 1 is a valid split.\n    - Split nums at index 2. Then the first part is [104-8] and its sum is 6. The second part is [7] and its sum is 7. Since 6 < 7 i = 2 is not a valid split.\n    Thus the number of valid splits in nums is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2310]\n    **Output:** 2\n    **Explanation:** \n    There are two valid splits in nums:\n    - Split nums at index 1. Then the first part is [23] and its sum is 5. The second part is [10] and its sum is 1. Since 5 >= 1 i = 1 is a valid split. \n    - Split nums at index 2. Then the first part is [231] and its sum is 6. The second part is [0] and its sum is 0. Since 6 >= 0 i = 2 is a valid split.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 105`\n  * `-105 <= nums[i] <= 105`\n\n,class Solution:\n    def waysToSplitArray(self nums: List[int]) -> int:\n        prefix_sum = [nums[0]]\n        n = len(nums)\n        for i in range(1 n):\n            prefix_sum.append(nums[i] + prefix_sum[-1]) \n        \n        count = 0\n        for i in range(n-1):\n            if prefix_sum[i] >= prefix_sum[n-1] - prefix_sum[i]:\n                count += 1\n        return count\n
Number of Ways to Stay in the Same Place After Some Steps,###  1269\. Number of Ways to Stay in the Same Place After Some Steps\n\nYou have a pointer at index `0` in an array of size `arrLen`. At each step\nyou can move 1 position to the left 1 position to the right in the array or\nstay in the same place (The pointer should not be placed outside the array at\nany time).\n\nGiven two integers `steps` and `arrLen` return the number of ways such that\nyour pointer still at index `0` after **exactly** `steps` steps. Since the\nanswer may be too large return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** steps = 3 arrLen = 2\n    **Output:** 4\n    **Explanation:** There are 4 differents ways to stay at index 0 after 3 steps.\n    Right Left Stay\n    Stay Right Left\n    Right Stay Left\n    Stay Stay Stay\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** steps = 2 arrLen = 4\n    **Output:** 2\n    **Explanation:** There are 2 differents ways to stay at index 0 after 2 steps\n    Right Left\n    Stay Stay\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** steps = 4 arrLen = 2\n    **Output:** 8\n    \n\n\n\n**Constraints:**\n\n  * `1 <= steps <= 500`\n  * `1 <= arrLen <= 106`\n\n,class Solution:\n    def numWays(self steps: int arrLen: int) -> int:\n        \n        # obtain maximum index we can reach\n        maxLen = min(steps+1 arrLen)\n        dp = [0]*maxLen\n        dp[0] = 1\n        \n        for step in range(1 steps+1):\n            dp2 = [0]*maxLen\n            for pos in range(maxLen):\n                # dp[step][pos] = dp[step-1][pos] + dp[step-1][pos-1] + dp[step-1][pos+1] \n                temp1 = 0 if pos == 0 else dp[pos-1]\n                temp2 = 0 if pos == maxLen-1 else dp[pos+1]\n                dp2[pos] = (dp[pos] + temp1 + temp2)%(10**9+7)\n                \n            dp = dp2\n        return dp[0]\n
Number of Ways to Wear Different Hats to Each Other,###  1434\. Number of Ways to Wear Different Hats to Each Other\n\nThere are `n` people and `40` types of hats labeled from `1` to `40`.\n\nGiven a 2D integer array `hats` where `hats[i]` is a list of all hats\npreferred by the `ith` person.\n\nReturn _the number of ways that the`n` people wear different hats to each\nother_.\n\nSince the answer may be too large return it modulo `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** hats = [[34][45][5]]\n    **Output:** 1\n    **Explanation:** There is only one way to choose hats given the conditions. \n    First person choose hat 3 Second person choose hat 4 and last one hat 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** hats = [[351][35]]\n    **Output:** 4\n    **Explanation:** There are 4 ways to choose hats:\n    (35) (53) (13) and (15)\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** hats = [[1234][1234][1234][1234]]\n    **Output:** 24\n    **Explanation:** Each person can choose hats labeled from 1 to 4.\n    Number of Permutations of (1234) = 24.\n    \n\n\n\n**Constraints:**\n\n  * `n == hats.length`\n  * `1 <= n <= 10`\n  * `1 <= hats[i].length <= 40`\n  * `1 <= hats[i][j] <= 40`\n  * `hats[i]` contains a list of **unique** integers.\n\n,from functools import cache\n\n\nclass Solution:\n    def numberWays(self hats: List[List[int]]) -> int:\n        # transpose hats\n        n_persons = len(hats)\n        temp = [[] for _ in range(40)]\n        for i person in enumerate(hats):\n            for hat in person:\n                temp[hat-1].append(i)\n        hats = temp\n        \n        # drop empty hats and sort\n        hats = [h for h in hats if h]\n        hats.sort(key=lambda h: len(h))\n        n_hats = len(hats)\n        \n        # helpers\n        full = 2 ** n_persons - 1\n        bits = [1 << i for i in range(n_persons)]\n        cut = 10 ** 9 + 7\n        \n        \n        @cache\n        def get_count(i has_hat):\n            if has_hat == full:\n                # all persons have a hat\n                return 1\n            elif i == n_hats:\n                # no more hats left\n                return 0\n            else:\n                result = 0\n                for person in hats[i]:\n                    # does the person \n                    # still not have a hat?\n                    if has_hat & bits[person] == 0:\n                        # the person wears i-th hat\n                        result += get_count(i + 1 has_hat | bits[person])\n                # no one wears i-th hat\n                result += get_count(i + 1 has_hat)\n                \n                # return modulo (10 ** 9 - 7)\n                return result % cut\n        \n        \n        # start form 0-th hat and \n        # no person wearing a hat\n        return get_count(0 0)\n
Number of Ways Where Square of Number Is Equal to Product of Two Numbers,###  1577\. Number of Ways Where Square of Number Is Equal to Product of Two\nNumbers\n\nGiven two arrays of integers `nums1` and `nums2` return the number of\ntriplets formed (type 1 and type 2) under the following rules:\n\n  * Type 1: Triplet (i j k) if `nums1[i]2 == nums2[j] * nums2[k]` where `0 <= i < nums1.length` and `0 <= j < k < nums2.length`.\n  * Type 2: Triplet (i j k) if `nums2[i]2 == nums1[j] * nums1[k]` where `0 <= i < nums2.length` and `0 <= j < k < nums1.length`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [74] nums2 = [5289]\n    **Output:** 1\n    **Explanation:** Type 1: (1 1 2) nums1[1]2 = nums2[1] * nums2[2]. (42 = 2 * 8). \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [11] nums2 = [111]\n    **Output:** 9\n    **Explanation:** All Triplets are valid because 12 = 1 * 1.\n    Type 1: (001) (002) (012) (101) (102) (112).  nums1[i]2 = nums2[j] * nums2[k].\n    Type 2: (001) (101) (201). nums2[i]2 = nums1[j] * nums1[k].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [7783] nums2 = [1297]\n    **Output:** 2\n    **Explanation:** There are 2 valid triplets.\n    Type 1: (302).  nums1[3]2 = nums2[0] * nums2[2].\n    Type 2: (301).  nums2[3]2 = nums1[0] * nums1[1].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 1000`\n  * `1 <= nums1[i] nums2[i] <= 105`\n\n,# Runtime: 753 ms (Top 50.00%) | Memory: 14 MB (Top 47.37%)\nclass Solution:\n    def numTriplets(self nums1: List[int] nums2: List[int]) -> int:\n        sqr1 sqr2 = defaultdict(int) defaultdict(int)\n        m n = len(nums1) len(nums2)\n        for i in range(m):\n            sqr1[nums1[i]**2] += 1\n        for j in range(n):\n            sqr2[nums2[j]**2] += 1\n\n        res = 0\n        for i in range(m-1):\n            for j in range(i+1 m):\n                if nums1[i]*nums1[j] in sqr2:\n                    res += sqr2[nums1[i]*nums1[j]]\n\n        for i in range(n-1):\n            for j in range(i+1 n):\n                if nums2[i]*nums2[j] in sqr1:\n                    res += sqr1[nums2[i]*nums2[j]]\n        return res
Number of Wonderful Substrings,"###  1915\. Number of Wonderful Substrings\n\nA **wonderful** string is a string where **at most one** letter appears an\n**odd** number of times.\n\n  * For example `""ccjjc""` and `""abab""` are wonderful but `""ab""` is not.\n\nGiven a string `word` that consists of the first ten lowercase English letters\n(`'a'` through `'j'`) return _the**number of wonderful non-empty substrings**\nin _`word` _. If the same substring appears multiple times in_`word` _ then\ncount**each occurrence** separately._\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word = ""aba""\n    **Output:** 4\n    **Explanation:** The four wonderful substrings are underlined below:\n    - ""_**a**_ ba"" -> ""a""\n    - ""a _**b**_ a"" -> ""b""\n    - ""ab _**a**_ "" -> ""a""\n    - ""_**aba**_ "" -> ""aba""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word = ""aabb""\n    **Output:** 9\n    **Explanation:** The nine wonderful substrings are underlined below:\n    - ""**_a_** abb"" -> ""a""\n    - ""_**aa**_ bb"" -> ""aa""\n    - ""_**aab**_ b"" -> ""aab""\n    - ""_**aabb**_ "" -> ""aabb""\n    - ""a _**a**_ bb"" -> ""a""\n    - ""a _**abb**_ "" -> ""abb""\n    - ""aa _**b**_ b"" -> ""b""\n    - ""aa _**bb**_ "" -> ""bb""\n    - ""aab _**b**_ "" -> ""b""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** word = ""he""\n    **Output:** 2\n    **Explanation:** The two wonderful substrings are underlined below:\n    - ""**_h_** e"" -> ""h""\n    - ""h** _e_** "" -> ""e""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word.length <= 105`\n  * `word` consists of lowercase English letters from `'a'` to `'j'`.\n\n",class Solution:\n    def wonderfulSubstrings(self word: str) -> int:\n        cnt res mask = [1] + [0] * 1023 0 0\n        for ch in word:\n            mask ^= 1 << (ord(ch) - ord('a'))\n            res += cnt[mask]\n            for n in range(10):\n                res += cnt[mask ^ 1 << n];\n            cnt[mask] += 1\n        return res\n
Number of Zero-Filled Subarrays,###  2348\. Number of Zero-Filled Subarrays\n\nGiven an integer array `nums` return _the number of**subarrays** filled with\n_`0`.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13002004]\n    **Output:** 6\n    **Explanation:** \n    There are 4 occurrences of [0] as a subarray.\n    There are 2 occurrences of [00] as a subarray.\n    There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore we return 6.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [000200]\n    **Output:** 9\n    **Explanation:** There are 5 occurrences of [0] as a subarray.\n    There are 3 occurrences of [00] as a subarray.\n    There is 1 occurrence of [000] as a subarray.\n    There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore we return 9.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [2102019]\n    **Output:** 0\n    **Explanation:** There is no subarray filled with 0. Therefore we return 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-109 <= nums[i] <= 109`\n\n,#Baraa\nclass Solution:\n    def zeroFilledSubarray(self nums: List[int]) -> int:\n        i = 0\n        res = 0\n        for j in range(len(nums)):\n            if nums[j] != 0:\n                i = j + 1\n            else:\n                res += (j - i + 1)\n        return res\n
Numbers With Repeated Digits,###  1012\. Numbers With Repeated Digits\n\nGiven an integer `n` return _the number of positive integers in the\nrange_`[1 n]`_that have**at least one** repeated digit_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 20\n    **Output:** 1\n    **Explanation:** The only positive number (<= 20) with at least 1 repeated digit is 11.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 100\n    **Output:** 10\n    **Explanation:** The positive numbers (<= 100) with atleast 1 repeated digit are 11 22 33 44 55 66 77 88 99 and 100.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 1000\n    **Output:** 262\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n\n,"class Solution:\n    def numDupDigitsAtMostN(self n: int) -> int:\n        \n        nums = [int(i) for i in str(n+1)] # digits in n+1\n        d = len(nums) # number of digits in n+1\n        res = 0 # number of no duplicates\n        \n        # count no duplicates for numbers with <d digits\n        for i in range(1d):\n            res += 9 * math.perm(9i-1)\n        \n		# count no duplicates for numbers with d digits and smaller than n\n        for i x in enumerate(nums):\n            if i == 0:\n                digit_range = range(1x) # first digit can not be 0\n            else:\n                digit_range = range(x)\n                \n            for y in digit_range:\n                if y not in nums[:i]:\n                    res += math.perm(9-id-1-i)\n            if x in nums[:i]: break\n                \n        return n - res\n"
Numbers With Same Consecutive Differences,###  967\. Numbers With Same Consecutive Differences\n\nReturn all **non-negative** integers of length `n` such that the absolute\ndifference between every two consecutive digits is `k`.\n\nNote that **every** number in the answer **must not** have leading zeros. For\nexample `01` has one leading zero and is invalid.\n\nYou may return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 k = 7\n    **Output:** [181292707818929]\n    **Explanation:** Note that 070 is not a valid number because it has leading zeroes.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2 k = 1\n    **Output:** [1012212332344345545665677678878998]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 9`\n  * `0 <= k <= 9`\n\n,class Solution:\n    def numsSameConsecDiff(self n: int k: int) -> List[int]:\n        # initialize the cache with all the valid numbers of length 1\n        # cache is a list of tuple (number digit at units place)\n        cache = [(0 0) (1 1) (2 2) (3 3) (4 4) (5 5) (6 6) (7 7) (8 8) (9 9)]\n        cacheTemp = []\n        \n        # each iteration will store all the valid numbers of length 2 to n in cache\n        for i in range(2 n + 1):\n            # loop through the cache from the previous iteration\n            for j in cache:\n                if k == 0:\n                    if j[0] != 0:\n                        cacheTemp.append((j[0] * 10 + j[1] j[1]))\n                elif j[1] == 0 and i == 2:\n                    continue\n                elif j[1] <= k - 1:\n                    if j[1] < 10 - k:\n                        cacheTemp.append((j[0] * 10 + j[1] + k j[1] + k))\n                elif j[1] >= 10 - k:\n                    if j[1] > k - 1:\n                        cacheTemp.append((j[0] * 10 + j[1] - k j[1] - k))\n                else:\n                    cacheTemp.append((j[0] * 10 + j[1] - k j[1] - k))\n                    cacheTemp.append((j[0] * 10 + j[1] + k j[1] + k))\n            cache = cacheTemp   # store the list of valid integers of length i in cache\n            cacheTemp = []  # empty the temporary list\n        \n        res = []\n        for i in cache:\n            res.append(i[0])\n        \n        return res\n        \n
Occurrences After Bigram,"###  1078\. Occurrences After Bigram\n\nGiven two strings `first` and `second` consider occurrences in some text of\nthe form `""first second third""` where `second` comes immediately after\n`first` and `third` comes immediately after `second`.\n\nReturn _an array of all the words_ `third` _for each occurrence of_ `""first\nsecond third""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text = ""alice is a good girl she is a good student"" first = ""a"" second = ""good""\n    **Output:** [""girl""""student""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text = ""we will we will rock you"" first = ""we"" second = ""will""\n    **Output:** [""we""""rock""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length <= 1000`\n  * `text` consists of lowercase English letters and spaces.\n  * All the words in `text` a separated by **a single space**.\n  * `1 <= first.length second.length <= 10`\n  * `first` and `second` consist of lowercase English letters.\n\n","class Solution:\n    def findOcurrences(self text: str first: str second: str) -> List[str]:\n        pattern = r""(?<=\b"" + first +"" "" + second + r"" )[a-z]*""\n        txt = re.findall(patterntext)\n        return txt"
Odd Even Jump,###  975\. Odd Even Jump\n\nYou are given an integer array `arr`. From some starting index you can make a\nseries of jumps. The (1st 3rd 5th ...) jumps in the series are called\n**odd-numbered jumps**  and the (2nd 4th 6th ...) jumps in the series are\ncalled **even-numbered jumps**. Note that the **jumps** are numbered not the\nindices.\n\nYou may jump forward from index `i` to index `j` (with `i < j`) in the\nfollowing way:\n\n  * During **odd-numbered jumps** (i.e. jumps 1 3 5 ...) you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j` you can only jump to the **smallest** such index `j`.\n  * During **even-numbered jumps** (i.e. jumps 2 4 6 ...) you jump to the index `j` such that `arr[i] >= arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j` you can only jump to the **smallest** such index `j`.\n  * It may be the case that for some index `i` there are no legal jumps.\n\nA starting index is **good** if starting from that index you can reach the\nend of the array (index `arr.length - 1`) by jumping some number of times\n(possibly 0 or more than once).\n\nReturn _the number of**good** starting indices_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [1013121415]\n    **Output:** 2\n    **Explanation:** \n    From starting index i = 0 we can make our 1st jump to i = 2 (since arr[2] is the smallest among arr[1] arr[2] arr[3] arr[4] that is greater or equal to arr[0]) then we cannot jump any more.\n    From starting index i = 1 and i = 2 we can make our 1st jump to i = 3 then we cannot jump any more.\n    From starting index i = 3 we can make our 1st jump to i = 4 so we have reached the end.\n    From starting index i = 4 we have reached the end already.\n    In total there are 2 different starting indices i = 3 and i = 4 where we can reach the end with some number of\n    jumps.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [23114]\n    **Output:** 3\n    **Explanation:** \n    From starting index i = 0 we make jumps to i = 1 i = 2 i = 3:\n    During our 1st jump (odd-numbered) we first jump to i = 1 because arr[1] is the smallest value in [arr[1] arr[2] arr[3] arr[4]] that is greater than or equal to arr[0].\n    During our 2nd jump (even-numbered) we jump from i = 1 to i = 2 because arr[2] is the largest value in [arr[2] arr[3] arr[4]] that is less than or equal to arr[1]. arr[3] is also the largest value but 2 is a smaller index so we can only jump to i = 2 and not i = 3\n    During our 3rd jump (odd-numbered) we jump from i = 2 to i = 3 because arr[3] is the smallest value in [arr[3] arr[4]] that is greater than or equal to arr[2].\n    We can't jump from i = 3 to i = 4 so the starting index i = 0 is not good.\n    In a similar manner we can deduce that:\n    From starting index i = 1 we jump to i = 4 so we reach the end.\n    From starting index i = 2 we jump to i = 3 and then we can't jump anymore.\n    From starting index i = 3 we jump to i = 4 so we reach the end.\n    From starting index i = 4 we are already at the end.\n    In total there are 3 different starting indices i = 1 i = 3 and i = 4 where we can reach the end with some\n    number of jumps.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [51342]\n    **Output:** 3\n    **Explanation:** We can reach the end from starting indices 1 2 and 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 2 * 104`\n  * `0 <= arr[i] < 105`\n\n,class Solution:\n    def oddEvenJumps(self arr: List[int]) -> int:\n        \n        l = len(arr)\n        res = [False]*l\n        res[-1] = True\n        \n        # for odd jump: for i get next larger one \n        odd_next = [i for i in range(l)]\n        stack = [] # mono inc for ind\n        for n i in sorted([(arr[i] i) for i in range(l)]):\n            while stack and stack[-1]<i:\n                odd_next[stack.pop()] = i\n            stack.append(i)\n                \n        # for even jump: for i get next smaller one \n        even_next = [i for i in range(l)]\n        stack = [] # mono inc for ind\n        for n i in sorted([(-arr[i] i) for i in range(l)]):\n            while stack and stack[-1]<i:\n                even_next[stack.pop()] = i\n            stack.append(i)\n            \n        # dp \n        @lru_cache(None)\n        def dp(i odd):\n            if i == l-1:\n                return True\n            ind = odd_next[i] if odd else even_next[i]\n            \n            if ind == i:\n                return False\n            \n            return dp(ind not odd)\n        \n        for i in range(l-1):\n            res[i] = dp(i True)\n        return sum(res)\n
Odd Even Linked List,###  328\. Odd Even Linked List\n\nGiven the `head` of a singly linked list group all the nodes with odd indices\ntogether followed by the nodes with even indices and return _the reordered\nlist_.\n\nThe **first** node is considered **odd**  and the **second** node is **even**\n and so on.\n\nNote that the relative order inside both the even and odd groups should remain\nas it was in the input.\n\nYou must solve the problem in `O(1)` extra space complexity and `O(n)` time\ncomplexity.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg)\n\n    \n    \n    **Input:** head = [12345]\n    **Output:** [13524]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg)\n\n    \n    \n    **Input:** head = [2135647]\n    **Output:** [2367154]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the linked list is in the range `[0 104]`.\n  * `-106 <= Node.val <= 106`\n\n,class Solution:\n    def oddEvenList(self head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return \n        odd even_start even = head head.next head.next\n        while odd is not None and even is not None:\n            odd.next = even.next\n            if odd.next is not None:\n                odd = odd.next\n                even.next = odd.next\n                even = even.next\n            else:\n                break\n        odd.next = even_start\n        return head\n
Online Election,"###  911\. Online Election\n\nYou are given two integer arrays `persons` and `times`. In an election the\n`ith` vote was cast for `persons[i]` at time `times[i]`.\n\nFor each query at a time `t` find the person that was leading the election at\ntime `t`. Votes cast at time `t` will count towards our query. In the case of\na tie the most recent vote (among tied candidates) wins.\n\nImplement the `TopVotedCandidate` class:\n\n  * `TopVotedCandidate(int[] persons int[] times)` Initializes the object with the `persons` and `times` arrays.\n  * `int q(int t)` Returns the number of the person that was leading the election at time `t` according to the mentioned rules.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""TopVotedCandidate"" ""q"" ""q"" ""q"" ""q"" ""q"" ""q""]\n    [[[0 1 1 0 0 1 0] [0 5 10 15 20 25 30]] [3] [12] [25] [15] [24] [8]]\n    **Output**\n    [null 0 1 1 0 0 1]\n    \n    **Explanation**\n    TopVotedCandidate topVotedCandidate = new TopVotedCandidate([0 1 1 0 0 1 0] [0 5 10 15 20 25 30]);\n    topVotedCandidate.q(3); // return 0 At time 3 the votes are [0] and 0 is leading.\n    topVotedCandidate.q(12); // return 1 At time 12 the votes are [011] and 1 is leading.\n    topVotedCandidate.q(25); // return 1 At time 25 the votes are [011001] and 1 is leading (as ties go to the most recent vote.)\n    topVotedCandidate.q(15); // return 0\n    topVotedCandidate.q(24); // return 0\n    topVotedCandidate.q(8); // return 1\n    \n    \n\n\n\n**Constraints:**\n\n  * `1 <= persons.length <= 5000`\n  * `times.length == persons.length`\n  * `0 <= persons[i] < persons.length`\n  * `0 <= times[i] <= 109`\n  * `times` is sorted in a strictly increasing order.\n  * `times[0] <= t <= 109`\n  * At most `104` calls will be made to `q`.\n\n",class TopVotedCandidate:\n\n    def __init__(self persons: List[int] times: List[int]):\n        counter = defaultdict(int)\n\n        mostVotePersons = [0] * len(persons) # mostVotePersons[i] is the most vote person at times[i]\n        largestVote = -1 # keep largest vote person index\n        for i in range(len(persons)):\n            counter[persons[i]] += 1\n            if largestVote == -1 or counter[persons[i]] >= counter[largestVote]:\n                largestVote = persons[i]\n            mostVotePersons[i] = largestVote\n        \n        self.times = times\n        self.mostVotePersons = mostVotePersons\n\n    def q(self t: int) -> int:\n        idx = bisect_right(self.times t) - 1 # binary search on times to find the most recent time before t\n        return self.mostVotePersons[idx]\n
Online Majority Element In Subarray,"###  1157\. Online Majority Element In Subarray\n\nDesign a data structure that efficiently finds the **majority element** of a\ngiven subarray.\n\nThe **majority element** of a subarray is an element that occurs `threshold`\ntimes or more in the subarray.\n\nImplementing the `MajorityChecker` class:\n\n  * `MajorityChecker(int[] arr)` Initializes the instance of the class with the given array `arr`.\n  * `int query(int left int right int threshold)` returns the element in the subarray `arr[left...right]` that occurs at least `threshold` times or `-1` if no such element exists.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""MajorityChecker"" ""query"" ""query"" ""query""]\n    [[[1 1 2 2 1 1]] [0 5 4] [0 3 3] [2 3 2]]\n    **Output**\n    [null 1 -1 2]\n    \n    **Explanation**\n    MajorityChecker majorityChecker = new MajorityChecker([1 1 2 2 1 1]);\n    majorityChecker.query(0 5 4); // return 1\n    majorityChecker.query(0 3 3); // return -1\n    majorityChecker.query(2 3 2); // return 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 2 * 104`\n  * `1 <= arr[i] <= 2 * 104`\n  * `0 <= left <= right < arr.length`\n  * `threshold <= right - left + 1`\n  * `2 * threshold > right - left + 1`\n  * At most `104` calls will be made to `query`.\n\n",# Runtime: 1961 ms (Top 83.96%) | Memory: 47.2 MB (Top 5.66%)\nMAX_N = 2*10**4\nMAX_BIT = MAX_N.bit_length()\nclass MajorityChecker:\n\n    def __init__(self nums: List[int]):\n        n = len(nums)\n        self.bit_sum = [[0] * MAX_BIT for _ in range(n+1)]\n        for i in range(1 n+1):\n            for b in range(MAX_BIT):\n                self.bit_sum[i][b] = self.bit_sum[i-1][b] + ((nums[i-1] >> b) & 1)\n        self.num_idx = defaultdict(list)\n        for i in range(n):\n            self.num_idx[nums[i]].append(i)\n\n    def query(self left: int right: int threshold: int) -> int:\n        num = 0\n        for b in range(MAX_BIT):\n            if self.bit_sum[right+1][b] - self.bit_sum[left][b] >= threshold:\n                num |= 1 << b\n        l = bisect.bisect_left(self.num_idx[num] left)\n        r = bisect.bisect_right(self.num_idx[num] right)\n        if r-l >= threshold:\n            return num\n        return -1
Online Stock Span,"###  901\. Online Stock Span\n\nDesign an algorithm that collects daily price quotes for some stock and\nreturns **the span** of that stock's price for the current day.\n\nThe **span** of the stock's price today is defined as the maximum number of\nconsecutive days (starting from today and going backward) for which the stock\nprice was less than or equal to today's price.\n\n  * For example if the price of a stock over the next `7` days were `[100806070607585]` then the stock spans would be `[1112146]`.\n\nImplement the `StockSpanner` class:\n\n  * `StockSpanner()` Initializes the object of the class.\n  * `int next(int price)` Returns the **span** of the stock's price given that today's price is `price`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""StockSpanner"" ""next"" ""next"" ""next"" ""next"" ""next"" ""next"" ""next""]\n    [[] [100] [80] [60] [70] [60] [75] [85]]\n    **Output**\n    [null 1 1 1 2 1 4 6]\n    \n    **Explanation**\n    StockSpanner stockSpanner = new StockSpanner();\n    stockSpanner.next(100); // return 1\n    stockSpanner.next(80);  // return 1\n    stockSpanner.next(60);  // return 1\n    stockSpanner.next(70);  // return 2\n    stockSpanner.next(60);  // return 1\n    stockSpanner.next(75);  // return 4 because the last 4 prices (including today's price of 75) were less than or equal to today's price.\n    stockSpanner.next(85);  // return 6\n    \n\n\n\n**Constraints:**\n\n  * `1 <= price <= 105`\n  * At most `104` calls will be made to `next`.\n\n",class StockSpanner:\n\n    def __init__(self):\n        self.stack = []\n        \n    def next(self price: int) -> int:\n        \n        ans = 1\n        while self.stack and self.stack[-1][0] <= price:\n            ans += self.stack.pop()[1]\n        \n        self.stack.append((price ans))\n        \n        return ans\n        \n\n# Your StockSpanner object will be instantiated and called as such:\n# obj = StockSpanner()\n# param_1 = obj.next(price)\n
Open the Lock,"###  752\. Open the Lock\n\nYou have a lock in front of you with 4 circular wheels. Each wheel has 10\nslots: `'0' '1' '2' '3' '4' '5' '6' '7' '8' '9'`. The wheels can\nrotate freely and wrap around: for example we can turn `'9'` to be `'0'` or\n`'0'` to be `'9'`. Each move consists of turning one wheel one slot.\n\nThe lock initially starts at `'0000'` a string representing the state of the\n4 wheels.\n\nYou are given a list of `deadends` dead ends meaning if the lock displays any\nof these codes the wheels of the lock will stop turning and you will be\nunable to open it.\n\nGiven a `target` representing the value of the wheels that will unlock the\nlock return the minimum total number of turns required to open the lock or\n-1 if it is impossible.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** deadends = [""0201""""0101""""0102""""1212""""2002""] target = ""0202""\n    **Output:** 6\n    **Explanation:** \n    A sequence of valid moves would be ""0000"" -> ""1000"" -> ""1100"" -> ""1200"" -> ""1201"" -> ""1202"" -> ""0202"".\n    Note that a sequence like ""0000"" -> ""0001"" -> ""0002"" -> ""0102"" -> ""0202"" would be invalid\n    because the wheels of the lock become stuck after the display becomes the dead end ""0102"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** deadends = [""8888""] target = ""0009""\n    **Output:** 1\n    **Explanation:** We can turn the last wheel in reverse to move from ""0000"" -> ""0009"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** deadends = [""8887""""8889""""8878""""8898""""8788""""8988""""7888""""9888""] target = ""8888""\n    **Output:** -1\n    **Explanation:** We cannot reach the target without getting stuck.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= deadends.length <= 500`\n  * `deadends[i].length == 4`\n  * `target.length == 4`\n  * target **will not be** in the list `deadends`.\n  * `target` and `deadends[i]` consist of digits only.\n\n","class Solution:\n    def openLock(self deadends: List[str] target: str) -> int:\n        def neighbor(s):\n            res = []\n            for i c in enumerate(s):\n                res.append(s[:i] + chr((ord(c) - ord('0') + 9) % 10 + ord('0')) + s[i + 1:])\n                res.append(s[:i] + chr((ord(c) - ord('0') + 1) % 10 + ord('0')) + s[i + 1:])\n            return res\n        \n        deadends = set(deadends)\n        if ""0000"" in deadends:\n            return -1\n        ans = 0\n        queue = deque([""0000""])\n        vis = set()\n        while queue:\n            l = len(queue)\n            for _ in range(l):\n                cur = queue.popleft()\n                if cur == target:\n                    return ans\n                for nxt in neighbor(cur):\n                    if nxt not in vis and nxt not in deadends:\n                        queue.append(nxt)\n                        vis.add(nxt)\n            ans += 1\n        return -1\n"
Operations on Tree,"###  1993\. Operations on Tree\n\nYou are given a tree with `n` nodes numbered from `0` to `n - 1` in the form\nof a parent array `parent` where `parent[i]` is the parent of the `ith` node.\nThe root of the tree is node `0` so `parent[0] = -1` since it has no parent.\nYou want to design a data structure that allows users to lock unlock and\nupgrade nodes in the tree.\n\nThe data structure should support the following functions:\n\n  * **Lock:** **Locks** the given node for the given user and prevents other users from locking the same node. You may only lock a node using this function if the node is unlocked.\n  * **Unlock: Unlocks** the given node for the given user. You may only unlock a node using this function if it is currently locked by the same user.\n  * **Upgrade****: Locks** the given node for the given user and **unlocks** all of its descendants **regardless** of who locked it. You may only upgrade a node if **all** 3 conditions are true: \n    * The node is unlocked\n    * It has at least one locked descendant (by **any** user) and\n    * It does not have any locked ancestors.\n\nImplement the `LockingTree` class:\n\n  * `LockingTree(int[] parent)` initializes the data structure with the parent array.\n  * `lock(int num int user)` returns `true` if it is possible for the user with id `user` to lock the node `num` or `false` otherwise. If it is possible the node `num` will become**locked** by the user with id `user`.\n  * `unlock(int num int user)` returns `true` if it is possible for the user with id `user` to unlock the node `num` or `false` otherwise. If it is possible the node `num` will become **unlocked**.\n  * `upgrade(int num int user)` returns `true` if it is possible for the user with id `user` to upgrade the node `num` or `false` otherwise. If it is possible the node `num` will be **upgraded**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/29/untitled.png)\n\n    \n    \n    **Input**\n    [""LockingTree"" ""lock"" ""unlock"" ""unlock"" ""lock"" ""upgrade"" ""lock""]\n    [[[-1 0 0 1 1 2 2]] [2 2] [2 3] [2 2] [4 5] [0 1] [0 1]]\n    **Output**\n    [null true false true true true false]\n    \n    **Explanation**\n    LockingTree lockingTree = new LockingTree([-1 0 0 1 1 2 2]);\n    lockingTree.lock(2 2);    // return true because node 2 is unlocked.\n                               // Node 2 will now be locked by user 2.\n    lockingTree.unlock(2 3);  // return false because user 3 cannot unlock a node locked by user 2.\n    lockingTree.unlock(2 2);  // return true because node 2 was previously locked by user 2.\n                               // Node 2 will now be unlocked.\n    lockingTree.lock(4 5);    // return true because node 4 is unlocked.\n                               // Node 4 will now be locked by user 5.\n    lockingTree.upgrade(0 1); // return true because node 0 is unlocked and has at least one locked descendant (node 4).\n                               // Node 0 will now be locked by user 1 and node 4 will now be unlocked.\n    lockingTree.lock(0 1);    // return false because node 0 is already locked.\n    \n\n\n\n**Constraints:**\n\n  * `n == parent.length`\n  * `2 <= n <= 2000`\n  * `0 <= parent[i] <= n - 1` for `i != 0`\n  * `parent[0] == -1`\n  * `0 <= num <= n - 1`\n  * `1 <= user <= 104`\n  * `parent` represents a valid tree.\n  * At most `2000` calls **in total** will be made to `lock` `unlock` and `upgrade`.\n\n",class LockingTree:\n\n    def __init__(self parent: List[int]):\n        self.p = collections.defaultdict(lambda: -2)\n        self.c = collections.defaultdict(list)\n        for i p in enumerate(parent):\n            self.c[p].append(i)\n            self.p[i] = p\n        self.user = collections.defaultdict(set)\n        self.node = collections.defaultdict(lambda: -2)\n\n    def lock(self num: int user: int) -> bool:\n        if self.node[num] == -2:\n            self.user[user].add(num)\n            self.node[num] = user\n            return True\n        return False \n\n    def unlock(self num: int user: int) -> bool:\n        if self.node[num] == user: \n            del self.node[num]\n            self.user[user].remove(num)\n            return True\n        return False        \n\n    def upgrade(self num: int user: int) -> bool:\n        if self.node[num] != -2: return False\n        if not self.has_locked_descendant(num): return False\n        if self.has_locked_ancester(num): return False\n        self.lock(num user)\n        self.unlock_descendant(num)\n        return True\n    \n    def has_locked_descendant(self num):  #function to check if alteast one desendent is lock or not \n        has = False\n        for child in self.c[num]:\n            if self.node[child] != -2:\n                return True\n            has |= self.has_locked_descendant(child)\n        return has               \n        \n    def has_locked_ancester(self num):   # function to check if no parent is locked \n        if num == -1: return False\n        if self.node[self.p[num]] != -2:\n            return True\n        return self.has_locked_ancester(self.p[num])\n\n    def unlock_descendant(self num):   # function fro unlocking all desendents \n        for child in self.c[num]:\n            if child in self.node:\n                user = self.node[child]\n                del self.node[child]\n                if user in self.user:\n                    self.user[user].remove(child)\n            self.unlock_descendant(child)\n
Optimal Division,"###  553\. Optimal Division\n\nYou are given an integer array `nums`. The adjacent integers in `nums` will\nperform the float division.\n\n  * For example for `nums = [234]` we will evaluate the expression `""2/3/4""`.\n\nHowever you can add any number of parenthesis at any position to change the\npriority of operations. You want to add these parentheses such the value of\nthe expression after the evaluation is maximum.\n\nReturn _the corresponding expression that has the maximum value in string\nformat_.\n\n**Note:** your expression should not contain redundant parenthesis.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1000100102]\n    **Output:** ""1000/(100/10/2)""\n    **Explanation:**\n    1000/(100/10/2) = 1000/((100/10)/2) = 200\n    However the bold parenthesis in ""1000/((100/10)/2)"" are redundant since they don't influence the operation priority. So you should return ""1000/(100/10/2)"".\n    Other cases:\n    1000/(100/10)/2 = 50\n    1000/(100/(10/2)) = 50\n    1000/100/10/2 = 0.5\n    1000/100/(10/2) = 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [234]\n    **Output:** ""2/(3/4)""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [2]\n    **Output:** ""2""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 10`\n  * `2 <= nums[i] <= 1000`\n  * There is only one optimal division for the given iput.\n\n",class Solution(object):\n    def optimalDivision(self nums):\n\n        A = list(map(str nums))\n        \n        \n        if len(A) <= 2:\n            \n            return '/'.join(A)\n        \n        \n        return A[0] + '/(' + '/'.join(A[1:]) + ')'\n
Out of Boundary Paths,###  576\. Out of Boundary Paths\n\nThere is an `m x n` grid with a ball. The ball is initially at the position\n`[startRow startColumn]`. You are allowed to move the ball to one of the four\nadjacent cells in the grid (possibly out of the grid crossing the grid\nboundary). You can apply **at most** `maxMove` moves to the ball.\n\nGiven the five integers `m` `n` `maxMove` `startRow` `startColumn` return\nthe number of paths to move the ball out of the grid boundary. Since the\nanswer can be very large return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_1.png)\n\n    \n    \n    **Input:** m = 2 n = 2 maxMove = 2 startRow = 0 startColumn = 0\n    **Output:** 6\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/28/out_of_boundary_paths_2.png)\n\n    \n    \n    **Input:** m = 1 n = 3 maxMove = 3 startRow = 0 startColumn = 1\n    **Output:** 12\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m n <= 50`\n  * `0 <= maxMove <= 50`\n  * `0 <= startRow < m`\n  * `0 <= startColumn < n`\n\n,class Solution:\n    def helper(self m n maxMove startRow startColumn matdp) -> int:\n        if startRow < 0 or startRow >=m or startColumn < 0 or startColumn >=n:\n            return 1\n        \n        if dp[maxMove][startRow][startColumn]!=-1:\n            return dp[maxMove][startRow][startColumn]\n        \n        if mat[startRow][startColumn]==1:\n            return 0\n        \n        if maxMove <= 0:\n            return 0\n        \n        # mat[startRow][startColumn] = 1\n        a = self.helper(m n maxMove-1 startRow+1 startColumnmatdp)\n        b = self.helper(m n maxMove-1 startRow-1 startColumnmatdp)\n        c = self.helper(m n maxMove-1 startRow startColumn+1matdp)\n        d = self.helper(m n maxMove-1 startRow startColumn-1matdp)\n        dp[maxMove][startRow][startColumn] = a+b+c+d\n        return dp[maxMove][startRow][startColumn]\n        \n        \n    def findPaths(self m: int n: int maxMove: int startRow: int startColumn: int) -> int:\n        mat = [[0 for i in range(n)] for j in range(m)]\n        dp = [[[-1 for i in range(n+1)] for j in range(m+1)] for k in range(maxMove+1)]\n        return self.helper(m n maxMove startRow startColumn matdp)%(10**9  + 7) \n    \n\n            \n
Pacific Atlantic Water Flow,###  417\. Pacific Atlantic Water Flow\n\nThere is an `m x n` rectangular island that borders both the **Pacific Ocean**\nand **Atlantic Ocean**. The **Pacific Ocean** touches the island's left and\ntop edges and the **Atlantic Ocean** touches the island's right and bottom\nedges.\n\nThe island is partitioned into a grid of square cells. You are given an `m x\nn` integer matrix `heights` where `heights[r][c]` represents the **height\nabove sea level** of the cell at coordinate `(r c)`.\n\nThe island receives a lot of rain and the rain water can flow to neighboring\ncells directly north south east and west if the neighboring cell's height\nis **less than or equal to** the current cell's height. Water can flow from\nany cell adjacent to an ocean into the ocean.\n\nReturn _a**2D list** of grid coordinates _`result` _where_`result[i] = [ri\nci]`_denotes that rain water can flow from cell_`(ri ci)`_to**both** the\nPacific and Atlantic oceans_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)\n\n    \n    \n    **Input:** heights = [[12235][32344][24531][67145][51124]]\n    **Output:** [[04][13][14][22][30][31][40]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** heights = [[21][12]]\n    **Output:** [[00][01][10][11]]\n    \n\n\n\n**Constraints:**\n\n  * `m == heights.length`\n  * `n == heights[r].length`\n  * `1 <= m n <= 200`\n  * `0 <= heights[r][c] <= 105`\n\n,class Solution:\n    def pacificAtlantic(self heights: List[List[int]]) -> List[List[int]]:\n        # Purpose: find the cells that allow rain flow into the ocean\n        # Method: DFS\n        # Intuition: start from each border check cell and neb if OK append to res\n            \n        # init: res vis (pac atl) ROW COL\n        res = []\n        pac = set()\n        atl = set()\n        ROW = len(heights)\n        COL = len(heights[0])\n\n        # top and bottom row\n        for col in range(COL):\n            self.dfs(0 col pac heights[0][col] heights)\n            self.dfs(ROW-1 col atl heights[ROW-1][col] heights)\n\n        # left and right col\n        for row in range(ROW):\n            self.dfs(row 0 pac heights[row][0] heights)\n            self.dfs(row COL-1 atl heights[row][COL-1] heights)\n\n        # append to res\n        for row in range(ROW):\n            for col in range(COL):\n                if (row col) in pac and (row col) in atl:\n                    res.append([row col])\n\n        # return\n        return res\n\n    \n    def dfs(self row col vis prev heights):\n        # hard-code definition\n        try:\n            cur = heights[row][col]\n        except:\n            pass\n\n        # inbound unvisited increase from ocean\n        if (0<=row<len(heights) and 0<=col<len(heights[0])) \\n            and (cur >= prev) \\n                and ((row col) not in vis):\n\n            # add to visited \n            vis.add((row col))\n\n            # check nebs\n            self.dfs(row+1 col vis cur heights)\n            self.dfs(row-1 col vis cur heights)\n            self.dfs(row col+1 vis cur heights)\n            self.dfs(row col-1 vis cur heights)\n\n
Paint House III,###  1473\. Paint House III\n\nThere is a row of `m` houses in a small city each house must be painted with\none of the `n` colors (labeled from `1` to `n`) some houses that have been\npainted last summer should not be painted again.\n\nA neighborhood is a maximal group of continuous houses that are painted with\nthe same color.\n\n  * For example: `houses = [12233211]` contains `5` neighborhoods `[{1} {22} {33} {2} {11}]`.\n\nGiven an array `houses` an `m x n` matrix `cost` and an integer `target`\nwhere:\n\n  * `houses[i]`: is the color of the house `i` and `0` if the house is not painted yet.\n  * `cost[i][j]`: is the cost of paint the house `i` with the color `j + 1`.\n\nReturn _the minimum cost of painting all the remaining houses in such a way\nthat there are exactly_ `target` _neighborhoods_. If it is not possible\nreturn `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** houses = [00000] cost = [[110][101][101][110][51]] m = 5 n = 2 target = 3\n    **Output:** 9\n    **Explanation:** Paint houses of this way [12211]\n    This array contains target = 3 neighborhoods [{1} {22} {11}].\n    Cost of paint all houses (1 + 1 + 1 + 1 + 5) = 9.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** houses = [02120] cost = [[110][101][101][110][51]] m = 5 n = 2 target = 3\n    **Output:** 11\n    **Explanation:** Some houses are already painted Paint the houses of this way [22122]\n    This array contains target = 3 neighborhoods [{22} {1} {22}]. \n    Cost of paint the first and last house (10 + 1) = 11.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** houses = [3123] cost = [[111][111][111][111]] m = 4 n = 3 target = 3\n    **Output:** -1\n    **Explanation:** Houses are already painted with a total of 4 neighborhoods [{3}{1}{2}{3}] different of target = 3.\n    \n\n\n\n**Constraints:**\n\n  * `m == houses.length == cost.length`\n  * `n == cost[i].length`\n  * `1 <= m <= 100`\n  * `1 <= n <= 20`\n  * `1 <= target <= m`\n  * `0 <= houses[i] <= n`\n  * `1 <= cost[i][j] <= 104`\n\n,\n\nclass Solution:\n    def minCost(self houses: List[int] cost: List[List[int]] m: int n: int target: int) -> int:\n        @cache\n        def dp(i p h):\n            if (h > target) or (i == m and h != target):\n                return inf\n            if i == m:\n                return 0\n            if houses[i] != 0:\n                return dp(i + 1 houses[i] h + int(p != houses[i]))\n\n            best = inf\n            for j c in enumerate(cost[i] 1):\n                best = min(best dp(i + 1 j h + int(p != j)) + c)\n            return best\n\n        res = dp(0 0 0)\n        return res if res != inf else -1\n
Painting a Grid With Three Different Colors,###  1931\. Painting a Grid With Three Different Colors\n\nYou are given two integers `m` and `n`. Consider an `m x n` grid where each\ncell is initially white. You can paint each cell **red**  **green**  or\n**blue**. All cells **must** be painted.\n\nReturn _the number of ways to color the grid with**no two adjacent cells\nhaving the same color**_. Since the answer can be very large return it\n**modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/22/colorthegrid.png)\n\n    \n    \n    **Input:** m = 1 n = 1\n    **Output:** 3\n    **Explanation:** The three possible colorings are shown in the image above.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/22/copy-of-colorthegrid.png)\n\n    \n    \n    **Input:** m = 1 n = 2\n    **Output:** 6\n    **Explanation:** The six possible colorings are shown in the image above.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** m = 5 n = 5\n    **Output:** 580986\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m <= 5`\n  * `1 <= n <= 1000`\n\n,class Solution:\n    def colorTheGrid(self m: int n: int) -> int:\n        from functools import reduce\n        MOD = 10**9 + 7\n        sum_mod = lambda xy: (x+y)%MOD\n        \n        def normalize(pat_var):\n            mapping = { e:i+1 for i e in enumerate(pat_var[0:2]) }\n            mapping[list({123}.difference(mapping.keys()))[0]] = 3\n            return tuple([ mapping[e] for e in pat_var])\n        \n        def get_pats(m i pat pats):\n            if i == m-1:\n                pats.append(tuple(pat))\n                return\n            i_nx = i+1\n            for p_it_nx in (123):\n                if (i_nx <= 1 and p_it_nx == i_nx+1 ) or (i_nx >= 2 and p_it_nx != pat[-1]):\n                    pat.append(p_it_nx)\n                    get_pats(m i_nx pat pats)\n                    pat.pop()\n            return pats\n        \n        def get_trans(pat i pat_pre trans):\n            if i == len(pat)-1:\n                pat_nl = normalize(pat_pre)\n                trans[pat_nl] = trans.get(pat_nl 0) + 1\n                return\n            for p_it_pre in (123):\n                i_nx = i+1\n                if (p_it_pre != pat[i_nx]\n                    and (not pat_pre or p_it_pre != pat_pre[-1])):\n                    pat_pre.append(p_it_pre)\n                    get_trans(pat i_nx pat_pre trans)\n                    pat_pre.pop()\n            return trans\n\n        pats = get_pats(m -1 [] [])\n        # {pattern_i: {pattern_pre:count}}\n        pat_trans = { pat: get_trans(pat -1 [] {}) for pat in pats }  \n        \n        p_counts = { pat:1 for pat in pat_trans.keys() }\n        for i in range(n-1):\n            p_counts_new = {}\n            for pat trans in pat_trans.items():\n                p_counts_new[pat] = reduce(sum_mod (p_counts[pat_pre] * cnt for pat_pre cnt in trans.items()))\n            p_counts = p_counts_new\n        \n        res = reduce(sum_mod (cnt for cnt in p_counts.values()))\n        perms = reduce(lambda xy: x*y (3-i for i in range(min(3m))))\n        return (res * perms) % MOD\n
Palindrome Number,###  9\. Palindrome Number\n\nGiven an integer `x` return `true` if `x` is palindrome integer.\n\nAn integer is a **palindrome** when it reads the same backward as forward.\n\n  * For example `121` is a palindrome while `123` is not.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** x = 121\n    **Output:** true\n    **Explanation:** 121 reads as 121 from left to right and from right to left.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** x = -121\n    **Output:** false\n    **Explanation:** From left to right it reads -121. From right to left it becomes 121-. Therefore it is not a palindrome.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** x = 10\n    **Output:** false\n    **Explanation:** Reads 01 from right to left. Therefore it is not a palindrome.\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= x <= 231 - 1`\n\n\n\n**Follow up:** Could you solve it without converting the integer to a string?\n\n,# Runtime: 61 ms (Top 94.40%) | Memory: 13.8 MB (Top 59.53%)\nclass Solution(object):\n   def isPalindrome(selfx):\n       return str(x) == str(x)[::-1]
Palindrome Pairs,"###  336\. Palindrome Pairs\n\nGiven a list of **unique** words return all the pairs of the **_distinct_**\nindices `(i j)` in the given list so that the concatenation of the two words\n`words[i] + words[j]` is a palindrome.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""abcd""""dcba""""lls""""s""""sssll""]\n    **Output:** [[01][10][32][24]]\n    **Explanation:** The palindromes are [""dcbaabcd""""abcddcba""""slls""""llssssll""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""bat""""tab""""cat""]\n    **Output:** [[01][10]]\n    **Explanation:** The palindromes are [""battab""""tabbat""]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""a""""""]\n    **Output:** [[01][10]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 5000`\n  * `0 <= words[i].length <= 300`\n  * `words[i]` consists of lower-case English letters.\n\n",class Solution:\n    def palindromePairs(self words: List[str]) -> List[List[int]]:\n        m = {}\n        for i word in enumerate(words):\n            m[word] = i\n        \n        result = set()\n        for i word in enumerate(words):\n            n rev_word = len(word) word[::-1]\n            prefix suffix = word rev_word\n            \n            for j in range(n+1):\n                if prefix == suffix:\n                    key = rev_word[:j]\n                    if key in m and m[key] != i:\n                        result.add((m[key] i))\n                \n                if j == n:\n                    break\n                \n                prefix = prefix[:-1]\n                suffix = suffix[1:]\n            \n            # print('pre' i result)\n            \n            prefix suffix = '' ''\n            for j in range(n+1):\n                if prefix == suffix:\n                    if prefix == suffix:\n                        key = rev_word[j:]\n                        if key in m and m[key] != i:\n                            result.add((i m[key]))\n                \n                if j == n:\n                    break\n                \n                prefix = word[n-j-1] + prefix\n                suffix = suffix + rev_word[j]\n            \n            # print('post' i result)\n        \n        return list(result)\n
Palindrome Partitioning,"###  131\. Palindrome Partitioning\n\nGiven a string `s` partition `s` such that every substring of the partition\nis a **palindrome**. Return all possible palindrome partitioning of `s`.\n\nA **palindrome** string is a string that reads the same backward as forward.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aab""\n    **Output:** [[""a""""a""""b""][""aa""""b""]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""a""\n    **Output:** [[""a""]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 16`\n  * `s` contains only lowercase English letters.\n\n","# Runtime: 1302 ms (Top 13.95%) | Memory: 35.7 MB (Top 6.05%)\n""""""\nwe can approach this problem using manacher's algorithm with backtracking and recursion\n""""""\nclass Solution:\n    def partition(self s: str) -> List[List[str]]:\n        lookup = {"""": [[]]}\n        def lps(s):\n            if s in lookup:\n                return lookup[s]\n\n            final_res = []\n            result_set = set()\n            for k in range(len(s)):\n                i j = k k\n\n                # check for odd length palindromes\n                while i>= 0 and j < len(s) and s[i] == s[j]:\n                    # palindrome found\n                    res = []\n                    for partition in lps(s[:i]):\n                        res.append(partition + [s[i:j+1]])\n                    for partition in res:\n                        for part in lps(s[j+1:]):\n                            temp = partition + part\n                            if tuple(temp) not in result_set:\n                                result_set.add(tuple(temp))\n                                final_res.append(temp)\n                    i-=1\n                    j+=1\n\n                # check for even length palindromes\n                i j = k k+1\n                while i >= 0 and j < len(s) and s[i] == s[j]:\n                    # palindrome found\n                    res = []\n                    for partition in lps(s[:i]):\n                        res.append(partition + [s[i:j+1]])\n                    for partition in res:\n                        for part in lps(s[j+1:]):\n                            temp = partition + part\n                            if tuple(temp) not in result_set:\n                                result_set.add(tuple(temp))\n                                final_res.append(temp)\n                    i-=1\n                    j+=1\n            lookup[s] = final_res\n            return final_res\n        return lps(s)"
Palindrome Partitioning II,"###  132\. Palindrome Partitioning II\n\nGiven a string `s` partition `s` such that every substring of the partition\nis a palindrome.\n\nReturn _the minimum cuts needed_ for a palindrome partitioning of `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aab""\n    **Output:** 1\n    **Explanation:** The palindrome partitioning [""aa""""b""] could be produced using 1 cut.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""a""\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""ab""\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 2000`\n  * `s` consists of lowercase English letters only.\n\n",class Solution:\n    def isPallindrom(self s: str l r) -> bool:\n        st = s[l: r+1]\n        rev = st[::-1]\n        return st == rev\n    \n    def minCut(self s: str) -> int:\n        N = len(s)\n        if not s: return 0\n        if self.isPallindrom(s 0 N-1): return 0\n        dp = [sys.maxsize] * (N+1)\n        dp[-1] = 0\n        \n        for i in range(N-1 -1 -1):\n            for j in range(i N):\n                if self.isPallindrom(s i j):\n                    dp[i] = min(dp[i] 1 + dp[j+1])\n                    \n        return dp[0]-1\n
Palindrome Partitioning III,"###  1278\. Palindrome Partitioning III\n\nYou are given a string `s` containing lowercase letters and an integer `k`.\nYou need to :\n\n  * First change some characters of `s` to other lowercase English letters.\n  * Then divide `s` into `k` non-empty disjoint substrings such that each substring is a palindrome.\n\nReturn _the minimal number of characters that you need to change to divide the\nstring_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abc"" k = 2\n    **Output:** 1\n    **Explanation:**  You can split the string into ""ab"" and ""c"" and change 1 character in ""ab"" to make it palindrome.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aabbc"" k = 3\n    **Output:** 0\n    **Explanation:**  You can split the string into ""aa"" ""bb"" and ""c"" all of them are palindrome.\n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""leetcode"" k = 8\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= s.length <= 100`.\n  * `s` only contains lowercase English letters.\n\n",class Solution:\n    def palindromePartition(self s: str t: int) -> int:\n        n=len(s)\n        @lru_cache(None)\n        def is_palin(s):                #This function returns min no of chars to change to make s as a palindrome\n            cnt=0\n            for c1c2 in zip(ss[::-1]):\n                if c1!=c2: cnt+=1\n            if len(s)%2==0:\n                return cnt//2\n            return (cnt+1)//2\n        @lru_cache(None)\n        def dp(ijk):            #We analyse string s[i:j+1] with k divisions left\n            if j==n:\n                return 0 if k==0 else sys.maxsize\n            if k==0: \n                return sys.maxsize\n            ans=sys.maxsize\n            cnt=is_palin(s[i:j+1])\n            #terminate here\n            ans=min(ansdp(j+1j+1k-1)+cnt)\n            #dont terminate\n            ans=min(ansdp(ij+1k))\n            return ans\n        return dp(00t)\n                        \n                \n            \n
Palindrome Partitioning IV,"###  1745\. Palindrome Partitioning IV\n\nGiven a string `s` return `true` _if it is possible to split the string_ `s`\n_into three**non-empty** palindromic substrings. Otherwise return\n_`false`.​​​​​\n\nA string is said to be palindrome if it the same string when reversed.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcbdd""\n    **Output:** true\n    **Explanation:** ""abcbdd"" = ""a"" + ""bcb"" + ""dd"" and all three substrings are palindromes.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""bcbddxy""\n    **Output:** false\n    **Explanation:** s cannot be split into 3 palindromes.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= s.length <= 2000`\n  * `s`​​​​​​ consists only of lowercase English letters.\n\n",# Runtime: 4163 ms (Top 80.92%) | Memory: 673.9 MB (Top 5.26%)\nclass Solution:\n    def checkPartitioning(self s: str) -> bool:\n        n = len(s)\n\n        @lru_cache(None)\n        def pal(ij):\n            if i == j:\n                return True\n            if s[i] != s[j]:\n                return False\n            if i+1 == j:\n                return True\n            else:\n                return pal(i+1j-1)\n\n        for i in range(n-2):\n            if pal(0i):\n                for j in range(i+1n-1):\n                    if pal(i+1j) and pal(j+1n-1):\n                        return True\n        return False
Palindromic Substrings,"###  647\. Palindromic Substrings\n\nGiven a string `s` return _the number of**palindromic substrings** in it_.\n\nA string is a **palindrome** when it reads the same backward as forward.\n\nA **substring** is a contiguous sequence of characters within the string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abc""\n    **Output:** 3\n    **Explanation:** Three palindromic strings: ""a"" ""b"" ""c"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aaa""\n    **Output:** 6\n    **Explanation:** Six palindromic strings: ""a"" ""a"" ""a"" ""aa"" ""aa"" ""aaa"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s` consists of lowercase English letters.\n\n",int n = s.length();\n        int count = 0;\n        for(int i = 0;i<n;i++){\n            int l = i;\n            int r = l;\n            while(l>=0 && r<n && s[l]==s[r]){\n                count++;\n                l--;\n                r++;\n            }\n        }\n        for(int i = 0;i<n-1;i++){\n            int l =  i;\n            int r = l+1;\n            while(l>=0 && r<n && s[l]==s[r]){\n                count++;\n                l--;\n                r++;\n            }\n        }\n        return count;
Pancake Sorting,###  969\. Pancake Sorting\n\nGiven an array of integers `arr` sort the array by performing a series of\n**pancake flips**.\n\nIn one pancake flip we do the following steps:\n\n  * Choose an integer `k` where `1 <= k <= arr.length`.\n  * Reverse the sub-array `arr[0...k-1]` (**0-indexed**).\n\nFor example if `arr = [3214]` and we performed a pancake flip choosing `k\n= 3` we reverse the sub-array `[321]` so `arr = [_1_ _2_ _3_ 4]` after\nthe pancake flip at `k = 3`.\n\nReturn _an array of the_`k` _-values corresponding to a sequence of pancake\nflips that sort_`arr`. Any valid answer that sorts the array within `10 *\narr.length` flips will be judged as correct.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [3241]\n    **Output:** [4243]\n    **Explanation:**\n    We perform 4 pancake flips with k values 4 2 4 and 3.\n    Starting state: arr = [3 2 4 1]\n    After 1st flip (k = 4): arr = [_1_  _4_  _2_  _3_]\n    After 2nd flip (k = 2): arr = [_4_  _1_  2 3]\n    After 3rd flip (k = 4): arr = [_3_  _2_  _1_  _4_]\n    After 4th flip (k = 3): arr = [_1_  _2_  _3_  4] which is sorted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [123]\n    **Output:** []\n    **Explanation:** The input is already sorted so there is no need to flip anything.\n    Note that other answers such as [3 3] would also be accepted.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 100`\n  * `1 <= arr[i] <= arr.length`\n  * All integers in `arr` are unique (i.e. `arr` is a permutation of the integers from `1` to `arr.length`).\n\n,"class Solution:\n    def pancakeSort(self arr: List[int]) -> List[int]:\n        #helper function to flip the numbers in the array\n		def flip(i j):\n            while i < j:\n                arr[i] arr[j] = arr[j] arr[i]\n                j -= 1\n                i += 1\n        \n        #sort from 0 to i\n        def sort(i):\n			#base case where all the numbers are sorted thus no more recursive calls\n            if i < 0:\n                return []\n            ret = []\n			#find the biggest number which always will be the len(arr) or i + 1\n            idx = arr.index(i + 1)\n			# if the biggest number is in the right place as in idx == i then we don't change anything but just move to sort the next biggest number\n            if idx == i:\n                return sort(i - 1)\n            \n			#we flip it with the first element (even if the biggest number is the first element it will flip itself (k = 1) and does not affect the result\n            ret.append(idx + 1)\n            flip(0 idx)\n			#we know the biggest number is the first element of the array. Flip the whole array in the boundary so that the biggest number would be in the last of the subarray (notice not len(arr) - 1 because that will flip the already-sorted elements as well)\n            ret.append(i + 1)\n            flip(0 i)\n			#sort the next biggest number by setting a new boundary i - 1\n            return ret + sort(i - 1)\n            \n            \n        return sort(len(arr) - 1)\n            \n"
Parallel Courses II,###  1494\. Parallel Courses II\n\nYou are given an integer `n` which indicates that there are `n` courses\nlabeled from `1` to `n`. You are also given an array `relations` where\n`relations[i] = [prevCoursei nextCoursei]` representing a prerequisite\nrelationship between course `prevCoursei` and course `nextCoursei`: course\n`prevCoursei` has to be taken before course `nextCoursei`. Also you are given\nthe integer `k`.\n\nIn one semester you can take **at most** `k` courses as long as you have\ntaken all the prerequisites in the **previous** semesters for the courses you\nare taking.\n\nReturn _the**minimum** number of semesters needed to take all courses_. The\ntestcases will be generated such that it is possible to take every course.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_1.png)**\n\n    \n    \n    **Input:** n = 4 dependencies = [[21][31][14]] k = 2\n    **Output:** 3 \n    **Explanation:** The figure above represents the given graph.\n    In the first semester you can take courses 2 and 3.\n    In the second semester you can take course 1.\n    In the third semester you can take course 4.\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2020/05/22/leetcode_parallel_courses_2.png)**\n\n    \n    \n    **Input:** n = 5 dependencies = [[21][31][41][15]] k = 2\n    **Output:** 4 \n    **Explanation:** The figure above represents the given graph.\n    In the first semester you can take courses 2 and 3 only since you cannot take more than two per semester.\n    In the second semester you can take course 4.\n    In the third semester you can take course 1.\n    In the fourth semester you can take course 5.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 11 dependencies = [] k = 2\n    **Output:** 6\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 15`\n  * `1 <= k <= n`\n  * `0 <= relations.length <= n * (n-1) / 2`\n  * `relations[i].length == 2`\n  * `1 <= prevCoursei nextCoursei <= n`\n  * `prevCoursei != nextCoursei`\n  * All the pairs `[prevCoursei nextCoursei]` are **unique**.\n  * The given graph is a directed acyclic graph.\n\n,class Solution:\n    def minNumberOfSemesters(self n: int relations: List[List[int]] k: int) -> int:\n        graph = [0] * n\n        out_degree = [0] * n\n        # -1 to fix 1-based indexing offset from prompt.\n        for pre_req course in relations:\n            graph[course-1] += 1 << (pre_req-1)\n            out_degree[pre_req-1] += 1\n        # Just converts course to its shifted value\n        c2shift = [1<<course for course in range(n)]\n        start = 0\n        goal = 2**n-1  # will eq course_total once all have been taken.\n        queue = collections.deque([(start0)])\n        seen = [0] * (2 ** n)\n\n        # Similar to Bellman-Ford\n        while queue:\n            # course_total is state. Each bit representing a taken course.\n            course_total steps = queue.popleft()\n            available = []\n            for course_num in range(n):\n                if (course_total & graph[course_num] == graph[course_num]) \\n                            and (course_total & c2shift[course_num] == 0):\n                    available.append(course_num)\n\n            # pre_req courses can unlock others.\n            pre_reqs = [c2shift[course_num] for course_num in available if out_degree[course_num]]\n            leaves = [c2shift[course_num] for course_num in available if out_degree[course_num] == 0] \n            \n            # We only include leaf courses when we have extra space\n            if len(pre_reqs) <= k:\n                course_total += sum(pre_reqs) + sum(leaves[:k-len(pre_reqs)])\n                if course_total == goal:\n                    return steps + 1\n                if not seen[course_total]:\n                    queue.append((course_totalsteps+1))\n                    seen[course_total] = 1\n            else:\n                # Trying every combination of the pre_reqs.\n                # comb is required here because we can't simply take them all (len(pre_reqs) > k)\n                for batch in itertools.combinations(pre_reqs k):\n                    diff = sum(batch)\n                    t = course_total + diff\n                    if t == goal:\n                        return steps + 1\n                    if not seen[t]:\n                        queue.append((t steps+1))\n                        seen[t] = 1![Uploading file...]()\n\n
Parallel Courses III,###  2050\. Parallel Courses III\n\nYou are given an integer `n` which indicates that there are `n` courses\nlabeled from `1` to `n`. You are also given a 2D integer array `relations`\nwhere `relations[j] = [prevCoursej nextCoursej]` denotes that course\n`prevCoursej` has to be completed **before** course `nextCoursej`\n(prerequisite relationship). Furthermore you are given a **0-indexed**\ninteger array `time` where `time[i]` denotes how many **months** it takes to\ncomplete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the\ncourses following these rules:\n\n  * You may start taking a course at **any time** if the prerequisites are met.\n  * **Any number of courses** can be taken at the **same time**.\n\nReturn _the**minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete\nevery course (i.e. the graph is a directed acyclic graph).\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2021/10/07/ex1.png)**\n\n    \n    \n    **Input:** n = 3 relations = [[13][23]] time = [325]\n    **Output:** 8\n    **Explanation:** The figure above represents the given graph and the time required to complete each course. \n    We start course 1 and course 2 simultaneously at month 0.\n    Course 1 takes 3 months and course 2 takes 2 months to complete respectively.\n    Thus the earliest time we can start course 3 is at month 3 and the total time required is 3 + 5 = 8 months.\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2021/10/07/ex2.png)**\n\n    \n    \n    **Input:** n = 5 relations = [[15][25][35][34][45]] time = [12345]\n    **Output:** 12\n    **Explanation:** The figure above represents the given graph and the time required to complete each course.\n    You can start courses 1 2 and 3 at month 0.\n    You can complete them after 1 2 and 3 months respectively.\n    Course 4 can be taken only after course 3 is completed i.e. after 3 months. It is completed after 3 + 4 = 7 months.\n    Course 5 can be taken only after courses 1 2 3 and 4 have been completed i.e. after max(1237) = 7 months.\n    Thus the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 5 * 104`\n  * `0 <= relations.length <= min(n * (n - 1) / 2 5 * 104)`\n  * `relations[j].length == 2`\n  * `1 <= prevCoursej nextCoursej <= n`\n  * `prevCoursej != nextCoursej`\n  * All the pairs `[prevCoursej nextCoursej]` are **unique**.\n  * `time.length == n`\n  * `1 <= time[i] <= 104`\n  * The given graph is a directed acyclic graph.\n\n,# Runtime: 1787 ms (Top 90.42%) | Memory: 42.7 MB (Top 96.74%)\nclass Solution:\n    def minimumTime(self n: int relations: List[List[int]] time: List[int]) -> int:\n        in_degree=defaultdict(int)\n        graph=defaultdict(list)\n        latest=[0]*(n+1)\n        for uv in relations:\n            graph[u].append(v)\n            in_degree[v]+=1\n        q=[]\n        for i in range(1n+1):\n            if in_degree[i]==0:\n                latest[i]=time[i-1]\n                q.append(i)\n        while q:\n            node=q.pop()\n            t0=latest[node]\n            for nei in graph[node]:\n                t=time[nei-1]\n                latest[nei]=max(latest[nei]t0+t)\n                in_degree[nei]-=1\n                if in_degree[nei]==0:\n                    q.append(nei)\n        return max(latest)\n
Parse Lisp Expression,"###  736\. Parse Lisp Expression\n\nYou are given a string expression representing a Lisp-like expression to\nreturn the integer value of.\n\nThe syntax for these expressions is given as follows.\n\n  * An expression is either an integer let expression add expression mult expression or an assigned variable. Expressions always evaluate to a single integer.\n  * (An integer could be positive or negative.)\n  * A let expression takes the form `""(let v1 e1 v2 e2 ... vn en expr)""` where let is always the string `""let""` then there are one or more pairs of alternating variables and expressions meaning that the first variable `v1` is assigned the value of the expression `e1` the second variable `v2` is assigned the value of the expression `e2` and so on sequentially; and then the value of this let expression is the value of the expression `expr`.\n  * An add expression takes the form `""(add e1 e2)""` where add is always the string `""add""` there are always two expressions `e1` `e2` and the result is the addition of the evaluation of `e1` and the evaluation of `e2`.\n  * A mult expression takes the form `""(mult e1 e2)""` where mult is always the string `""mult""` there are always two expressions `e1` `e2` and the result is the multiplication of the evaluation of e1 and the evaluation of e2.\n  * For this question we will use a smaller subset of variable names. A variable starts with a lowercase letter then zero or more lowercase letters or digits. Additionally for your convenience the names `""add""` `""let""` and `""mult""` are protected and will never be used as variable names.\n  * Finally there is the concept of scope. When an expression of a variable name is evaluated within the context of that evaluation the innermost scope (in terms of parentheses) is checked first for the value of that variable and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** expression = ""(let x 2 (mult x (let x 3 y 4 (add x y))))""\n    **Output:** 14\n    **Explanation:** In the expression (add x y) when checking for the value of the variable x\n    we check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\n    Since x = 3 is found first the value of x is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** expression = ""(let x 3 x 2 x)""\n    **Output:** 2\n    **Explanation:** Assignment in let statements is processed sequentially.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** expression = ""(let x 1 y 2 x (add x y) (add x y))""\n    **Output:** 5\n    **Explanation:** The first (add x y) evaluates as 3 and is assigned to x.\n    The second (add x y) evaluates as 3+2 = 5.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= expression.length <= 2000`\n  * There are no leading or trailing spaces in `expression`.\n  * All tokens are separated by a single space in `expression`.\n  * The answer and all intermediate calculations of that answer are guaranteed to fit in a **32-bit** integer.\n  * The expression is guaranteed to be legal and evaluate to an integer.\n\n","class Solution:\n    def evaluate(self expression: str) -> int:\n        loc = {}\n        stack = []\n        for i x in enumerate(expression): \n            if x == ""("": stack.append(i)\n            elif x == "")"": loc[stack.pop()] = i\n        \n        def fn(lo hi mp): \n            """"""Return value of given expression.""""""\n            if expression[lo] == ""("": return fn(lo+1 hi-1 mp)\n            i = lo\n            vals = []\n            while i < hi: \n                if expression[i:i+3] in (""let"" ""add""): \n                    op = expression[i:i+3]\n                    i += 3\n                elif expression[i:i+4] == ""mult"": \n                    op = ""mult""\n                    i += 4\n                elif expression[i].isalpha(): \n                    x = """"\n                    while i < hi and expression[i].isalnum(): \n                        x += expression[i]\n                        i += 1\n                    if op in (""add"" ""mult""): vals.append(mp[x])\n                elif expression[i].isdigit() or expression[i] == ""-"": \n                    v = """"\n                    while i < hi and (expression[i].isdigit() or expression[i] == ""-""): \n                        v += expression[i]\n                        i += 1\n                    if op == ""let"": mp[x] = int(v)\n                    else: vals.append(int(v))\n                elif expression[i] == ""("": \n                    v = fn(i+1 loc[i] mp.copy())\n                    i = loc[i] + 1\n                    if op == ""let"": mp[x] = v\n                    else: vals.append(v)\n                else: i += 1\n            if op == ""let"": return int(v)\n            elif op == ""add"": return sum(vals)\n            else: return reduce(mul vals)\n            \n        return fn(0 len(expression) {})"
Parsing A Boolean Expression,"###  1106\. Parsing A Boolean Expression\n\nReturn the result of evaluating a given boolean `expression` represented as a\nstring.\n\nAn expression can either be:\n\n  * `""t""` evaluating to `True`;\n  * `""f""` evaluating to `False`;\n  * `""!(expr)""` evaluating to the logical NOT of the inner expression `expr`;\n  * `""&(expr1expr2...)""` evaluating to the logical AND of 2 or more inner expressions `expr1 expr2 ...`;\n  * `""|(expr1expr2...)""` evaluating to the logical OR of 2 or more inner expressions `expr1 expr2 ...`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** expression = ""!(f)""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** expression = ""|(ft)""\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** expression = ""&(tf)""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= expression.length <= 2 * 104`\n  * `expression[i]` consists of characters in `{'(' ')' '&' '|' '!' 't' 'f' ''}`.\n  * `expression` is a valid expression representing a boolean as given in the description.\n\n","class Solution:\n    def parseBoolExpr(self expression: str) -> bool:\n        \n        # expresssion map\n        opMap = {""!"" : ""!"" ""|"" : ""|""  ""&"" : ""&""}\n        expMap = {""t"" : True ""f"" : False}\n        expStack = []\n        opStack = []\n        ans = 0\n        i = 0\n        \n        while i < len(expression):\n            \n            if expression[i] in opMap:\n                opStack.append(opMap[expression[i]])\n            \n            elif expression[i] in expMap:\n                expStack.append(expMap[expression[i]])\n                \n            elif expression[i] == ""("":\n                expStack.append(""("")\n            \n            # strat performing operations\n            elif expression[i] == "")"":\n                op = opStack.pop()\n                ans = [] # evaluator arr\n                \n                # To Check\n                # print(""EXPSTACK :- "" expStack ""OPSTACK :- "" opStack ""outer WHILE"")\n                \n                # Performing serries of operation on exp inside a ()\n                while expStack[-1] != ""("":\n                    \n                    # To check \n                    # print(""EXPSTACK :- "" expStack ""OPSTACK :- "" opStack ""OPerator :- ""op ""INNER WHILE"")\n    \n                    # Not single operation only\n                    if op == ""!"":\n                        ans.append(not expStack.pop())\n                    else:\n                        ans.append(expStack.pop())\n                \n                # Operation evaluation for more then 1 exp inside () for & or\n                while len(ans) > 1:\n                    # or\n                    if op == ""|"":\n                        exp1 exp2 = ans.pop() ans.pop()\n                        res = exp1 or exp2\n                        ans.append(res)\n                    # and\n                    elif op == ""&"":\n                        exp1 exp2 = ans.pop() ans.pop()\n                        res = exp1 and exp2\n                        ans.append(res)\n                    \n                # poping "")"" and adding the res of operation done above\n                expStack.pop() # poping "")""\n                expStack.append(ans[-1])\n                        \n            # increment i   \n            i += 1\n                \n        return expStack[-1]\n    \n    \n""""""\nTC : O(n * m) | n = len(expression) m = no of expression inside a prenthesis\nSc : O(n)\n""""""\n"
Partition Array According to Given Pivot,###  2161\. Partition Array According to Given Pivot\n\nYou are given a **0-indexed** integer array `nums` and an integer `pivot`.\nRearrange `nums` such that the following conditions are satisfied:\n\n  * Every element less than `pivot` appears **before** every element greater than `pivot`.\n  * Every element equal to `pivot` appears **in between** the elements less than and greater than `pivot`.\n  * The **relative order** of the elements less than `pivot` and the elements greater than `pivot` is maintained. \n    * More formally consider every `pi` `pj` where `pi` is the new position of the `ith` element and `pj` is the new position of the `jth` element. For elements less than `pivot` if `i < j` and `nums[i] < pivot` and `nums[j] < pivot` then `pi < pj`. Similarly for elements greater than `pivot` if `i < j` and `nums[i] > pivot` and `nums[j] > pivot` then `pi < pj`.\n\nReturn `nums` _after the rearrangement._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [91251014310] pivot = 10\n    **Output:** [95310101214]\n    **Explanation:** \n    The elements 9 5 and 3 are less than the pivot so they are on the left side of the array.\n    The elements 12 and 14 are greater than the pivot so they are on the right side of the array.\n    The relative ordering of the elements less than and greater than pivot is also maintained. [9 5 3] and [12 14] are the respective orderings.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-3432] pivot = 2\n    **Output:** [-3243]\n    **Explanation:** \n    The element -3 is less than the pivot so it is on the left side of the array.\n    The elements 4 and 3 are greater than the pivot so they are on the right side of the array.\n    The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4 3] are the respective orderings.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-106 <= nums[i] <= 106`\n  * `pivot` equals to an element of `nums`.\n\n,class Solution:\n    def pivotArray(self nums: List[int] pivot: int) -> List[int]:\n        left=[]\n        mid=[]\n        right=[]\n        for i in nums:\n            if(i<pivot):\n                left.append(i)\n            elif(i==pivot):\n                mid.append(i)\n            else:\n                right.append(i)\n        return left+mid+right\n\n
Partition Array for Maximum Sum,###  1043\. Partition Array for Maximum Sum\n\nGiven an integer array `arr` partition the array into (contiguous) subarrays\nof length **at most** `k`. After partitioning each subarray has their values\nchanged to become the maximum value of that subarray.\n\nReturn _the largest sum of the given array after partitioning. Test cases are\ngenerated so that the answer fits in a**32-bit** integer._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [115792510] k = 3\n    **Output:** 84\n    **Explanation:** arr becomes [1515159101010]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [14157361993] k = 4\n    **Output:** 83\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [1] k = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 500`\n  * `0 <= arr[i] <= 109`\n  * `1 <= k <= arr.length`\n\n,"class Solution:\n    def maxSumAfterPartitioning(self nums: List[int] k: int) -> int:\n        def get_max(start end):\n            return max(nums[start:end + 1]) * (end - start + 1)\n\n        def dfs(start):\n            if start == N: # base case so in tabulation we go [N - 1]...[0] as [N] = 0\n                return 0\n            \n            maxi = float(-inf)\n			# you partition at every position up to start + k and repeat the same process for the next partition\n			# e.g. 1 9 3 k = 2\n			# 1|9|3 => with max in each partition: 1|9|3 = 13\n			# 1|9 3 => with max in each partition: 1|9 9 = 19\n			# 1 9|3 => with max in each partition: 9 9|3 = 21\n			# get max_in_partition(startend) + give_me_max_for_array(previous_partition_end + 1 N)\n			# rec.relation = max(max_sum_in_partition[start end] + dfs(end + 1)))\n            for end in range(start min(N start + k)):\n                maxi = max(maxi get_max(start end) + dfs(end + 1))\n            return maxi\n        \n        N = len(nums)\n        return dfs(0)\n"
Partition Array into Disjoint Intervals,###  915\. Partition Array into Disjoint Intervals\n\nGiven an integer array `nums` partition it into two (contiguous) subarrays\n`left` and `right` so that:\n\n  * Every element in `left` is less than or equal to every element in `right`.\n  * `left` and `right` are non-empty.\n  * `left` has the smallest possible size.\n\nReturn _the length of_`left` _after such a partitioning_.\n\nTest cases are generated such that partitioning exists.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [50386]\n    **Output:** 3\n    **Explanation:** left = [503] right = [86]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1110612]\n    **Output:** 4\n    **Explanation:** left = [1110] right = [612]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 105`\n  * `0 <= nums[i] <= 106`\n  * There is at least one valid answer for the given input.\n\n,class Solution:\n    def partitionDisjoint(self nums: List[int]) -> int:\n        prefix = [nums[0] for _ in range(len(nums))]\n        suffix = [nums[-1] for _ in range(len(nums))]\n        for i in range(1 len(nums)):\n            prefix[i] = max(prefix[i-1] nums[i-1])\n        for i in range(len(nums)-2 -1 -1):\n            suffix[i] = min(suffix[i+1] nums[i+1])\n        for i in range(0 len(nums)-1):\n            if prefix[i] <= suffix[i]:\n                return i+1\n
Partition Array Into Three Parts With Equal Sum,###  1013\. Partition Array Into Three Parts With Equal Sum\n\nGiven an array of integers `arr` return `true` if we can partition the array\ninto three **non-empty** parts with equal sums.\n\nFormally we can partition the array if we can find indexes `i + 1 < j` with\n`(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1]\n== arr[j] + arr[j + 1] + ... + arr[arr.length - 1])`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [021-66-791201]\n    **Output:** true\n    **Explanation:** 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [021-6679-1201]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [3365-2251-94]\n    **Output:** true\n    **Explanation:** 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4\n    \n\n\n\n**Constraints:**\n\n  * `3 <= arr.length <= 5 * 104`\n  * `-104 <= arr[i] <= 104`\n\n,# Runtime: 668 ms (Top 23.61%) | Memory: 21 MB (Top 37.82%)\nclass Solution:\n    def canThreePartsEqualSum(self arr: List[int]) -> bool:\n        total = sum(arr)\n        if total % 3 != 0:\n            return False\n        ave = total // 3\n        stage = 0\n        add = 0\n        for i in arr[:-1]:\n            add += i\n            if add == ave:\n                stage +=1\n                add = 0\n            if stage == 2:\n                return True\n        return False
Partition Array Into Two Arrays to Minimize Sum Difference,###  2035\. Partition Array Into Two Arrays to Minimize Sum Difference\n\nYou are given an integer array `nums` of `2 * n` integers. You need to\npartition `nums` into **two** arrays of length `n` to **minimize the absolute\ndifference** of the **sums** of the arrays. To partition `nums` put each\nelement of `nums` into **one** of the two arrays.\n\nReturn _the**minimum** possible absolute difference_.\n\n\n\n**Example 1:**\n\n![example-1](https://assets.leetcode.com/uploads/2021/10/02/ex1.png)\n\n    \n    \n    **Input:** nums = [3973]\n    **Output:** 2\n    **Explanation:** One optimal partition is: [39] and [73].\n    The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-3636]\n    **Output:** 72\n    **Explanation:** One optimal partition is: [-36] and [36].\n    The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.\n    \n\n**Example 3:**\n\n![example-3](https://assets.leetcode.com/uploads/2021/10/02/ex3.png)\n\n    \n    \n    **Input:** nums = [2-104-2-9]\n    **Output:** 0\n    **Explanation:** One optimal partition is: [24-9] and [-10-2].\n    The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 15`\n  * `nums.length == 2 * n`\n  * `-107 <= nums[i] <= 107`\n\n,class Solution:\n    def minimumDifference(self nums: List[int]) -> int:\n        n = len(nums)//2\n        left right = nums[:n] nums[n:]\n        lsum rsum = sum(left) sum(right)\n        \n        ans = inf\n        for i in range(n+1): \n            vals = sorted(2*sum(combo)-lsum for combo in combinations(left i))\n            for combo in combinations(right n-i): \n                diff = 2*sum(combo) - rsum\n                k = bisect_left(vals -diff)\n                if k: ans = min(ans abs(vals[k-1] + diff))\n                if k < len(vals): ans = min(ans abs(vals[k] + diff))\n        return ans \n
Partition Array Such That Maximum Difference Is K,###  2294\. Partition Array Such That Maximum Difference Is K\n\nYou are given an integer array `nums` and an integer `k`. You may partition\n`nums` into one or more **subsequences** such that each element in `nums`\nappears in **exactly** one of the subsequences.\n\nReturn _the**minimum** number of subsequences needed such that the difference\nbetween the maximum and minimum values in each subsequence is **at most** _`k`\n_._\n\nA **subsequence** is a sequence that can be derived from another sequence by\ndeleting some or no elements without changing the order of the remaining\nelements.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [36125] k = 2\n    **Output:** 2\n    **Explanation:**\n    We can partition nums into the two subsequences [312] and [65].\n    The difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.\n    The difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.\n    Since two subsequences were created we return 2. It can be shown that 2 is the minimum number of subsequences needed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [123] k = 1\n    **Output:** 2\n    **Explanation:**\n    We can partition nums into the two subsequences [12] and [3].\n    The difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.\n    The difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.\n    Since two subsequences were created we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [23].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [2245] k = 0\n    **Output:** 3\n    **Explanation:**\n    We can partition nums into the three subsequences [22] [4] and [5].\n    The difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.\n    The difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.\n    The difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.\n    Since three subsequences were created we return 3. It can be shown that 3 is the minimum number of subsequences needed.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 105`\n  * `0 <= k <= 105`\n\n,"class Solution:\n    def partitionArray(self nums: List[int] k: int) -> int:\n        nums.sort()\n        ans = 1\n		# To keep track of starting element of each subsequence\n        start = nums[0]\n        \n        for i in range(1 len(nums)):\n            diff = nums[i] - start\n            if diff > k:\n				# If difference of starting and current element of subsequence is greater\n				# than K then only start new subsequence\n                ans += 1\n                start = nums[i]\n        \n        return ans"
Partition Equal Subset Sum,###  416\. Partition Equal Subset Sum\n\nGiven a **non-empty** array `nums` containing **only positive integers** \nfind if the array can be partitioned into two subsets such that the sum of\nelements in both subsets is equal.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [15115]\n    **Output:** true\n    **Explanation:** The array can be partitioned as [1 5 5] and [11].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1235]\n    **Output:** false\n    **Explanation:** The array cannot be partitioned into equal sum subsets.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 200`\n  * `1 <= nums[i] <= 100`\n\n,// Runtime: 437 ms (Top 80.03%) | Memory: 18.00 MB (Top 70.21%)\n\nclass Solution:\n    def canPartition(self nums: List[int]) -> bool:\n        dp s = set([0]) sum(nums)\n        if s&1:\n            return False\n        for num in nums:\n            for curr in range(s>>1 num-1 -1):\n                if curr not in dp and curr-num in dp:\n                    if curr == s>>1:\n                        return True\n                    dp.add(curr)\n        return False\n
Partition Labels,"###  763\. Partition Labels\n\nYou are given a string `s`. We want to partition the string into as many parts\nas possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in\norder the resultant string should be `s`.\n\nReturn _a list of integers representing the size of these parts_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ababcbacadefegdehijhklij""\n    **Output:** [978]\n    **Explanation:**\n    The partition is ""ababcbaca"" ""defegde"" ""hijhklij"".\n    This is a partition so that each letter appears in at most one part.\n    A partition like ""ababcbacadefegde"" ""hijhklij"" is incorrect because it splits s into less parts.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""eccbbbbdec""\n    **Output:** [10]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 500`\n  * `s` consists of lowercase English letters.\n\n",class Solution:\n    def partitionLabels(self s: str) -> List[int]:\n        d = defaultdict(list)\n        for i char in enumerate(s):\n            d[char].append(i)\n        nums = []\n        \n        for v in d.values():\n            nums.append([v[0] v[-1]])\n\n        start = nums[0][0]\n        maxIndex = nums[0][1]\n        ans = []\n        for i in range(1 len(nums)):\n            if nums[i][0] <= maxIndex:\n                maxIndex = max(maxIndex nums[i][1])\n            else:\n                ans.append(maxIndex - start + 1)\n                start = nums[i][0]\n                maxIndex = nums[i][1]\n        ans.append(maxIndex - start + 1)\n        # print(ans)\n        return ans\n
Partition List,###  86\. Partition List\n\nGiven the `head` of a linked list and a value `x` partition it such that all\nnodes **less than** `x` come before nodes **greater than or equal** to `x`.\n\nYou should **preserve** the original relative order of the nodes in each of\nthe two partitions.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)\n\n    \n    \n    **Input:** head = [143252] x = 3\n    **Output:** [122435]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** head = [21] x = 2\n    **Output:** [12]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[0 200]`.\n  * `-100 <= Node.val <= 100`\n  * `-200 <= x <= 200`\n\n,"# Runtime: 53 ms (Top 53.47%) | Memory: 13.8 MB (Top 76.51%)\n# Definition for singly-linked list.\n# class ListNode(object):\n# def __init__(self val=0 next=None):\n# self.val = val\n# self.next = next\nclass Solution(object):\n    def partition(self head x):\n        """"""\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        """"""\n        lessthan = []\n        greateql = []\n\n        while head:\n            if head.val < x:\n                lessthan.append(head.val)\n            else:\n                greateql.append(head.val)\n            head = head.next\n\n        h = res = ListNode()\n\n        for i in range(len(lessthan)):\n            res.next = ListNode(lessthan[i])\n            res = res.next\n        for i in range(len(greateql)):\n            res.next = ListNode(greateql[i])\n            res = res.next\n\n        return h.next"
Partitioning Into Minimum Number Of Deci-Binary Numbers,"###  1689\. Partitioning Into Minimum Number Of Deci-Binary Numbers\n\nA decimal number is called **deci-binary** if each of its digits is either `0`\nor `1` without any leading zeros. For example `101` and `1100` are **deci-\nbinary**  while `112` and `3001` are not.\n\nGiven a string `n` that represents a positive decimal integer return\n_the**minimum** number of positive **deci-binary** numbers needed so that they\nsum up to _`n` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = ""32""\n    **Output:** 3\n    **Explanation:** 10 + 11 + 11 = 32\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = ""82734""\n    **Output:** 8\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = ""27346209830709182346""\n    **Output:** 9\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n.length <= 105`\n  * `n` consists of only digits.\n  * `n` does not contain any leading zeros and represents a positive integer.\n\n",# Runtime: 109 ms (Top 63.86%) | Memory: 14.9 MB (Top 22.11%)\nclass Solution:\n    def minPartitions(self n: str) -> int:\n        return int(max(n))
Pascal's Triangle II,###  119\. Pascal's Triangle II\n\nGiven an integer `rowIndex` return the `rowIndexth` (**0-indexed**) row of\nthe **Pascal's triangle**.\n\nIn **Pascal's triangle**  each number is the sum of the two numbers directly\nabove it as shown:\n\n![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rowIndex = 3\n    **Output:** [1331]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rowIndex = 0\n    **Output:** [1]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** rowIndex = 1\n    **Output:** [11]\n    \n\n\n\n**Constraints:**\n\n  * `0 <= rowIndex <= 33`\n\n\n\n**Follow up:** Could you optimize your algorithm to use only `O(rowIndex)`\nextra space?\n\n,class Solution:\n    def getRow(self rowIndex: int) -> List[int]:\n        # base case\n        # we know that there exist two base case one which is for zero input\n        # One when we have to exit our recursive loop \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [11]\n        #recurance relation or prev call\n        prev_prob = self.getRow(rowIndex-1)\n        # post processing on data \n        # if someone has given us prev_Row what operation we can perform to get current_Row\n        return [1]+[prev_prob[i]+prev_prob[i-1] for i in range(1len(prev_prob))]+[1]\n
Path Crossing,"###  1496\. Path Crossing\n\nGiven a string `path` where `path[i] = 'N'` `'S'` `'E'` or `'W'` each\nrepresenting moving one unit north south east or west respectively. You\nstart at the origin `(0 0)` on a 2D plane and walk on the path specified by\n`path`.\n\nReturn `true` _if the path crosses itself at any point that is if at any\ntime you are on a location you have previously visited_. Return `false`\notherwise.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/06/10/screen-\nshot-2020-06-10-at-123929-pm.png)\n\n    \n    \n    **Input:** path = ""NES""\n    **Output:** false \n    **Explanation:** Notice that the path doesn't cross any point more than once.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/06/10/screen-\nshot-2020-06-10-at-123843-pm.png)\n\n    \n    \n    **Input:** path = ""NESWW""\n    **Output:** true\n    **Explanation:** Notice that the path visits the origin twice.\n\n\n\n**Constraints:**\n\n  * `1 <= path.length <= 104`\n  * `path[i]` is either `'N'` `'S'` `'E'` or `'W'`.\n\n",# Runtime: 55 ms (Top 32.81%) | Memory: 14.1 MB (Top 28.49%)\nclass Solution:\n    def isPathCrossing(self path: str) -> bool:\n        c = set()\n        xy = 00\n        c.add((xy))\n        for i in path:\n            if i == 'N':\n                y+=1\n            elif i == 'E':\n                x+=1\n            elif i == 'W':\n                x-=1\n            else:\n                y-=1\n            if (xy) in c:\n                return True\n            else:\n                c.add((xy))\n        return False
Path In Zigzag Labelled Binary Tree,###  1104\. Path In Zigzag Labelled Binary Tree\n\nIn an infinite binary tree where every node has two children the nodes are\nlabelled in row order.\n\nIn the odd numbered rows (ie. the first third fifth...) the labelling is\nleft to right while in the even numbered rows (second fourth sixth...)\nthe labelling is right to left.\n\n![](https://assets.leetcode.com/uploads/2019/06/24/tree.png)\n\nGiven the `label` of a node in this tree return the labels in the path from\nthe root of the tree to the node with that `label`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** label = 14\n    **Output:** [13414]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** label = 26\n    **Output:** [1261026]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= label <= 10^6`\n\n,// Runtime: 31 ms (Top 88.8%) | Memory: 16.50 MB (Top 52.0%)\n\nclass Solution:\n    def pathInZigZagTree(self label: int) -> List[int]:\n        \n        x = label\n        mask = 0 \n        while x > 1:\n            x >>= 1\n            mask <<= 1\n            mask |= 1\n            \n        x = label\n        res = deque()\n        while x:\n            res.appendleft(x)\n            x >>= 1\n            mask >>= 1\n            x ^= mask\n        return res\n
Path Sum,###  112\. Path Sum\n\nGiven the `root` of a binary tree and an integer `targetSum` return `true` if\nthe tree has a **root-to-leaf** path such that adding up all the values along\nthe path equals `targetSum`.\n\nA **leaf** is a node with no children.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)\n\n    \n    \n    **Input:** root = [54811null13472nullnullnull1] targetSum = 22\n    **Output:** true\n    **Explanation:** The root-to-leaf path with the target sum is shown.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)\n\n    \n    \n    **Input:** root = [123] targetSum = 5\n    **Output:** false\n    **Explanation:** There two root-to-leaf paths in the tree:\n    (1 --> 2): The sum is 3.\n    (1 --> 3): The sum is 4.\n    There is no root-to-leaf path with sum = 5.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [] targetSum = 0\n    **Output:** false\n    **Explanation:** Since the tree is empty there are no root-to-leaf paths.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 5000]`.\n  * `-1000 <= Node.val <= 1000`\n  * `-1000 <= targetSum <= 1000`\n\n,"class Solution(object):\n    def hasPathSum(self root targetSum):\n        """"""\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        """"""\n        if not root: return False\n        targetSum -= root.val\n        if not root.left and not root.right:\n            return not targetSum\n        return self.hasPathSum(root.left targetSum) or self.hasPathSum(root.right targetSum)\n"
Path Sum II,###  113\. Path Sum II\n\nGiven the `root` of a binary tree and an integer `targetSum` return\n_all**root-to-leaf** paths where the sum of the node values in the path equals\n_`targetSum` _. Each path should be returned as a list of the node**values** \nnot node references_.\n\nA **root-to-leaf** path is a path starting from the root and ending at any\nleaf node. A **leaf** is a node with no children.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)\n\n    \n    \n    **Input:** root = [54811null13472nullnull51] targetSum = 22\n    **Output:** [[54112][5845]]\n    **Explanation:** There are two paths whose sum equals targetSum:\n    5 + 4 + 11 + 2 = 22\n    5 + 8 + 4 + 5 = 22\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)\n\n    \n    \n    **Input:** root = [123] targetSum = 5\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [12] targetSum = 0\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 5000]`.\n  * `-1000 <= Node.val <= 1000`\n  * `-1000 <= targetSum <= 1000`\n\n,class Solution:\n    def pathSum(self root: Optional[TreeNode] targetSum: int) -> List[List[int]]:\n        res = []\n        def dfs(v path pathsum):\n            if not v:\n                return\n            path.append(v.val)\n            pathsum += v.val\n            if not v.left and not v.right and pathsum == targetSum:\n                res.append(path[:])\n            dfs(v.left path pathsum)\n            dfs(v.right path pathsum)\n            path.pop()\n        dfs(root [] 0)\n        return res
Path Sum III,###  437\. Path Sum III\n\nGiven the `root` of a binary tree and an integer `targetSum` return _the\nnumber of paths where the sum of the values  along the path equals_\n`targetSum`.\n\nThe path does not need to start or end at the root or a leaf but it must go\ndownwards (i.e. traveling only from parent nodes to child nodes).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)\n\n    \n    \n    **Input:** root = [105-332null113-2null1] targetSum = 8\n    **Output:** 3\n    **Explanation:** The paths that sum to 8 are shown.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [54811null13472nullnull51] targetSum = 22\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 1000]`.\n  * `-109 <= Node.val <= 109`\n  * `-1000 <= targetSum <= 1000`\n\n,class Solution:\n    def pathSum(self root: Optional[TreeNode] targetSum: int) -> int:\n        def util(node: TreeNode sum_array) -> int:\n            t = [e - node.val for e in sum_array]\n            zeroes = t.count(0)\n            if node.left is None and node.right is None:\n                return zeroes\n            ansl ansr = 0 0\n            if node.left:\n                ansl = util(node.left t + [targetSum])\n            if node.right:\n                ansr = util(node.right t + [targetSum])\n            return ansl + ansr + zeroes\n\n        return util(root [targetSum]) if root is not None else 0\n
Path with Maximum Gold,###  1219\. Path with Maximum Gold\n\nIn a gold mine `grid` of size `m x n` each cell in this mine has an integer\nrepresenting the amount of gold in that cell `0` if it is empty.\n\nReturn the maximum amount of gold you can collect under the conditions:\n\n  * Every time you are located in a cell you will collect all the gold in that cell.\n  * From your position you can walk one step to the left right up or down.\n  * You can't visit the same cell more than once.\n  * Never visit a cell with `0` gold.\n  * You can start and stop collecting gold from **any** position in the grid that has some gold.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** grid = [[060][587][090]]\n    **Output:** 24\n    **Explanation:**\n    [[060]\n     [587]\n     [090]]\n    Path to get the maximum gold 9 -> 8 -> 7.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[107][206][345][030][9020]]\n    **Output:** 28\n    **Explanation:**\n    [[107]\n     [206]\n     [345]\n     [030]\n     [9020]]\n    Path to get the maximum gold 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 15`\n  * `0 <= grid[i][j] <= 100`\n  * There are at most **25** cells containing gold.\n\n,# Runtime: 1480 ms (Top 97.21%) | Memory: 14.1 MB (Top 13.08%)\nclass Solution:\n    def getMaximumGold(self grid):\n        answer = [0]\n\n        def visit(visited i j gold_sum):\n            val = grid[i][j]\n            if val == 0 or (ij) in visited:\n                answer[0] = max(answer[0] gold_sum)\n                return\n\n            gold_sum_new = gold_sum + val\n            visited_new = visited.union({(ij)})\n\n            if i > 0:\n                visit(visited_new i-1 j gold_sum_new)\n\n            if j < len(grid[i]) - 1:\n                visit(visited_new i j+1 gold_sum_new)\n\n            if i < len(grid) - 1:\n                visit(visited_new i+1 j gold_sum_new)\n            if j > 0:\n                visit(visited_new i j-1 gold_sum_new)\n        #choosing the starting points\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] != 0:\n                    count = 0\n\n                    try:\n                        if grid[i-1][j] != 0:\n                            count += 1\n                    except:\n                        pass\n                    try:\n                        if grid[i][j+1] != 0:\n                            count += 1\n                    except:\n                        pass\n                    try:\n                        if grid[i+1][j] != 0:\n                            count += 1\n                    except:\n                        pass\n                    try:\n                        if grid[i][j-1] != 0:\n                            count += 1\n                    except:\n                        pass\n\n                    if count < 3:\n                        visit(set()ij0)\n\n        return answer[0]\n
Path with Maximum Probability,###  1514\. Path with Maximum Probability\n\nYou are given an undirected weighted graph of `n` nodes (0-indexed)\nrepresented by an edge list where `edges[i] = [a b]` is an undirected edge\nconnecting the nodes `a` and `b` with a probability of success of traversing\nthat edge `succProb[i]`.\n\nGiven two nodes `start` and `end` find the path with the maximum probability\nof success to go from `start` to `end` and return its success probability.\n\nIf there is no path from `start` to `end` **return  0**. Your answer will be\naccepted if it differs from the correct answer by at most **1e-5**.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png)**\n\n    \n    \n    **Input:** n = 3 edges = [[01][12][02]] succProb = [0.50.50.2] start = 0 end = 2\n    **Output:** 0.25000\n    **Explanation:**  There are two paths from start to end one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png)**\n\n    \n    \n    **Input:** n = 3 edges = [[01][12][02]] succProb = [0.50.50.3] start = 0 end = 2\n    **Output:** 0.30000\n    \n\n**Example 3:**\n\n**![](https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png)**\n\n    \n    \n    **Input:** n = 3 edges = [[01]] succProb = [0.5] start = 0 end = 2\n    **Output:** 0.00000\n    **Explanation:**  There is no path between 0 and 2.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 10^4`\n  * `0 <= start end < n`\n  * `start != end`\n  * `0 <= a b < n`\n  * `a != b`\n  * `0 <= succProb.length == edges.length <= 2*10^4`\n  * `0 <= succProb[i] <= 1`\n  * There is at most one edge between every two nodes.\n\n,# Runtime: 755 ms (Top 91.19%) | Memory: 25.4 MB (Top 98.78%)\nclass Solution(object):\n    def maxProbability(self n edges succProb start end):\n        adj=[[] for i in range(n)]\n        dist=[sys.maxsize for i in range(n)]\n        heap=[]\n        c=0\n        for ij in edges:\n            adj[i].append([jsuccProb[c]])\n            adj[j].append([isuccProb[c]])\n            c+=1\n        heapq.heappush(heap[-1.0start])\n        dist[start]=1\n        while(heap):\n            probu=heapq.heappop(heap)\n            for vw in adj[u]:\n                if(dist[v]>-abs(w*prob)):\n                    dist[v]=-abs(w*prob)\n                    heapq.heappush(heap[dist[v]v])\n        if(sys.maxsize==dist[end]):\n            return 0.00000\n        else:\n            return -dist[end]
Path With Minimum Effort,###  1631\. Path With Minimum Effort\n\nYou are a hiker preparing for an upcoming hike. You are given `heights` a 2D\narray of size `rows x columns` where `heights[row][col]` represents the\nheight of cell `(row col)`. You are situated in the top-left cell `(0 0)`\nand you hope to travel to the bottom-right cell `(rows-1 columns-1)` (i.e.\n**0-indexed**). You can move **up**  **down**  **left**  or **right**  and\nyou wish to find a route that requires the minimum **effort**.\n\nA route's **effort** is the **maximum absolute difference****** in heights\nbetween two consecutive cells of the route.\n\nReturn _the minimum**effort** required to travel from the top-left cell to the\nbottom-right cell._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/04/ex1.png)\n\n    \n    \n    **Input:** heights = [[122][382][535]]\n    **Output:** 2\n    **Explanation:** The route of [13535] has a maximum absolute difference of 2 in consecutive cells.\n    This is better than the route of [12225] where the maximum absolute difference is 3.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/04/ex2.png)\n\n    \n    \n    **Input:** heights = [[123][384][535]]\n    **Output:** 1\n    **Explanation:** The route of [12345] has a maximum absolute difference of 1 in consecutive cells which is better than route [13535].\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/10/04/ex3.png)\n\n    \n    \n    **Input:** heights = [[12111][12121][12121][12121][11121]]\n    **Output:** 0\n    **Explanation:** This route does not require any effort.\n    \n\n\n\n**Constraints:**\n\n  * `rows == heights.length`\n  * `columns == heights[i].length`\n  * `1 <= rows columns <= 100`\n  * `1 <= heights[i][j] <= 106`\n\n,# Runtime: 1804 ms (Top 36.30%) | Memory: 15.4 MB (Top 76.73%)\nclass Solution:\n    def minimumEffortPath(self heights: List[List[int]]) -> int:\n        di = (0 1 0 -1)\n        dj = (1 0 -1 0)\n        m n = len(heights) len(heights[0])\n        visited = [[False] * n for _ in range(m)]\n        h = [(0 0 0)]\n        while h:\n            effort i j = heappop(h)\n            if visited[i][j]:\n                continue\n            visited[i][j] = True\n            if i + 1 == m and j + 1 == n:\n                return effort ## have reached the (m-1 n-1) cell\n            for k in range(4):\n                ii jj = i + di[k] j + dj[k]\n                if 0 <= ii < m and 0 <= jj < n and not visited[ii][jj]:\n                    neffort = max(effort abs(heights[i][j] - heights[ii][jj]))\n                    heappush(h (neffort ii jj))\n        return ## cell (m-1 n-1) not reachable should never happen
Peeking Iterator,"###  284\. Peeking Iterator\n\nDesign an iterator that supports the `peek` operation on an existing iterator\nin addition to the `hasNext` and the `next` operations.\n\nImplement the `PeekingIterator` class:\n\n  * `PeekingIterator(Iterator<int> nums)` Initializes the object with the given integer iterator `iterator`.\n  * `int next()` Returns the next element in the array and moves the pointer to the next element.\n  * `boolean hasNext()` Returns `true` if there are still elements in the array.\n  * `int peek()` Returns the next element in the array **without** moving the pointer.\n\n**Note:** Each language may have a different implementation of the constructor\nand `Iterator` but they all support the `int next()` and `boolean hasNext()`\nfunctions.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""PeekingIterator"" ""next"" ""peek"" ""next"" ""next"" ""hasNext""]\n    [[[1 2 3]] [] [] [] [] []]\n    **Output**\n    [null 1 2 2 3 false]\n    \n    **Explanation**\n    PeekingIterator peekingIterator = new PeekingIterator([1 2 3]); // [_**1**_ 23]\n    peekingIterator.next();    // return 1 the pointer moves to the next element [1_**2**_ 3].\n    peekingIterator.peek();    // return 2 the pointer does not move [1_**2**_ 3].\n    peekingIterator.next();    // return 2 the pointer moves to the next element [12_**3**_]\n    peekingIterator.next();    // return 3 the pointer moves to the next element [123]\n    peekingIterator.hasNext(); // return False\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 1000`\n  * All the calls to `next` and `peek` are valid.\n  * At most `1000` calls will be made to `next` `hasNext` and `peek`.\n\n\n\n**Follow up:** How would you extend your design to be generic and work with\nall types not just integer?\n\n",// Runtime: 44 ms (Top 25.31%) | Memory: 17.60 MB (Top 8.9%)\n\nclass PeekingIterator:\n    def __init__(self iterator):\n        self.iterator = iterator\n        self.buffer = self.iterator.next() if self.iterator.hasNext() else None\n        \n    def peek(self):\n        return self.buffer\n        \n    def next(self):\n        tmp = self.buffer\n        self.buffer = self.iterator.next() if self.iterator.hasNext() else None\n        return tmp\n        \n    def hasNext(self):\n        return self.buffer != None\n
People Whose List of Favorite Companies Is Not a Subset of Another List,"###  1452\. People Whose List of Favorite Companies Is Not a Subset of Another\nList\n\nGiven the array `favoriteCompanies` where `favoriteCompanies[i]` is the list\nof favorites companies for the `ith` person (**indexed from 0**).\n\n_Return the indices of people whose list of favorite companies is not\na**subset** of any other list of favorites companies_. You must return the\nindices in increasing order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** favoriteCompanies = [[""leetcode""""google""""facebook""][""google""""microsoft""][""google""""facebook""][""google""][""amazon""]]\n    **Output:** [014] \n    **Explanation:** \n    Person with index=2 has favoriteCompanies[2]=[""google""""facebook""] which is a subset of favoriteCompanies[0]=[""leetcode""""google""""facebook""] corresponding to the person with index 0. \n    Person with index=3 has favoriteCompanies[3]=[""google""] which is a subset of favoriteCompanies[0]=[""leetcode""""google""""facebook""] and favoriteCompanies[1]=[""google""""microsoft""]. \n    Other lists of favorite companies are not a subset of another list therefore the answer is [014].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** favoriteCompanies = [[""leetcode""""google""""facebook""][""leetcode""""amazon""][""facebook""""google""]]\n    **Output:** [01] \n    **Explanation:** In this case favoriteCompanies[2]=[""facebook""""google""] is a subset of favoriteCompanies[0]=[""leetcode""""google""""facebook""] therefore the answer is [01].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** favoriteCompanies = [[""leetcode""][""google""][""facebook""][""amazon""]]\n    **Output:** [0123]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= favoriteCompanies.length <= 100`\n  * `1 <= favoriteCompanies[i].length <= 500`\n  * `1 <= favoriteCompanies[i][j].length <= 20`\n  * All strings in `favoriteCompanies[i]` are **distinct**.\n  * All lists of favorite companies are **distinct**  that is If we sort alphabetically each list then `favoriteCompanies[i] != favoriteCompanies[j].`\n  * All strings consist of lowercase English letters only.\n\n",class Solution:\n    def peopleIndexes(self favoriteCompanies: List[List[str]]) -> List[int]:\n        \n        F = favoriteCompanies\n        ans = [] \n        \n        seen = set() \n        \n        for i in range(len(F)):\n            for j in range(i+1len(F)):\n                st1 = set(F[i])\n                st2 = set(F[j])\n                if st1.intersection(st2) == st1: seen.add(i)\n                if st2.intersection(st1) == st2: seen.add(j) \n\n        ans = []\n        for i in range(len(F)):\n            if i in seen: continue \n            ans.append(i) \n            \n        return ans
Percentage of Letter in String,"###  2278\. Percentage of Letter in String\n\nGiven a string `s` and a character `letter` return _the**percentage** of\ncharacters in _`s` _that equal_`letter` _**rounded down** to the nearest whole\npercent._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""foobar"" letter = ""o""\n    **Output:** 33\n    **Explanation:**\n    The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down so we return 33.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""jjjj"" letter = ""k""\n    **Output:** 0\n    **Explanation:**\n    The percentage of characters in s that equal the letter 'k' is 0% so we return 0.\n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s` consists of lowercase English letters.\n  * `letter` is a lowercase English letter.\n\n",class Solution:\n    def percentageLetter(self s: str letter: str) -> int:\n        return (s.count(letter)*100)//len(s)\n
Perfect Number,###  507\. Perfect Number\n\nA [**perfect number**](https://en.wikipedia.org/wiki/Perfect_number) is a\n**positive integer** that is equal to the sum of its **positive divisors** \nexcluding the number itself. A **divisor** of an integer `x` is an integer\nthat can divide `x` evenly.\n\nGiven an integer `n` return `true` _if_`n` _is a perfect number otherwise\nreturn_`false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 28\n    **Output:** true\n    **Explanation:** 28 = 1 + 2 + 4 + 7 + 14\n    1 2 4 7 and 14 are all divisors of 28.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 7\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num <= 108`\n\n,class Solution:\n    def checkPerfectNumber(self num: int) -> bool:\n        sum = 0\n        root = num**0.5  \n        if num ==1:\n            return False\n        for i in range(2int(root)+1):\n            if num%i== 0:\n                sum +=(num//i)+i\n        return sum+1 == num\n
Perfect Rectangle,###  391\. Perfect Rectangle\n\nGiven an array `rectangles` where `rectangles[i] = [xi yi ai bi]`\nrepresents an axis-aligned rectangle. The bottom-left point of the rectangle\nis `(xi yi)` and the top-right point of it is `(ai bi)`.\n\nReturn `true` _if all the rectangles together form an exact cover of a\nrectangular region_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/27/perectrec1-plane.jpg)\n\n    \n    \n    **Input:** rectangles = [[1133][3142][3244][1324][2334]]\n    **Output:** true\n    **Explanation:** All 5 rectangles together form an exact cover of a rectangular region.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/27/perfectrec2-plane.jpg)\n\n    \n    \n    **Input:** rectangles = [[1123][1324][3142][3244]]\n    **Output:** false\n    **Explanation:** Because there is a gap between the two rectangular regions.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/03/27/perfecrrec4-plane.jpg)\n\n    \n    \n    **Input:** rectangles = [[1133][3142][1324][2244]]\n    **Output:** false\n    **Explanation:** Because two of the rectangles overlap with each other.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rectangles.length <= 2 * 104`\n  * `rectangles[i].length == 4`\n  * `-105 <= xi yi ai bi <= 105`\n\n,class Solution:\n    def isRectangleCover(self rectangles: List[List[int]]) -> bool:\n        X1 Y1 = float('inf') float('inf')\n        X2 Y2 = -float('inf') -float('inf')\n\n        points = set()\n        actual_area = 0\n        for x1 y1 x2 y2 in rectangles:\n            # calculate the coords of the potential perfect rectangle\n            X1 Y1 = min(X1 x1) min(Y1 y1)\n            X2 Y2 = max(X2 x2) max(Y2 y2)\n            # add up to the actual_area so we can check against to see if thers is any part overwritten.\n            actual_area += (x2 - x1) * (y2 - y1)\n            \n            # proving steps in https://labuladong.github.io/algo/4/32/131/\n            for p in [(x1 y1) (x1 y2) (x2 y1) (x2 y2)]:\n                if p in points: \n                    points.remove(p)\n                else:           \n                    points.add(p)\n\n        # check the area \n        expected_area = (X2 - X1) * (Y2 - Y1)\n        if actual_area != expected_area:\n            return False\n        \n        if len(points) != 4:       \n            return False\n\n        if (X1 Y1) not in points: \n            return False\n        if (X1 Y2) not in points: \n            return False\n        if (X2 Y1) not in points: \n            return False\n        if (X2 Y2) not in points: \n            return False\n\n        return True
Perfect Squares,###  279\. Perfect Squares\n\nGiven an integer `n` return _the least number of perfect square numbers that\nsum to_ `n`.\n\nA **perfect square** is an integer that is the square of an integer; in other\nwords it is the product of some integer with itself. For example `1` `4`\n`9` and `16` are perfect squares while `3` and `11` are not.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 12\n    **Output:** 3\n    **Explanation:** 12 = 4 + 4 + 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 13\n    **Output:** 2\n    **Explanation:** 13 = 4 + 9.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n\n,// Runtime: 28 ms (Top 99.85%) | Memory: 17.30 MB (Top 57.47%)\n\nclass Solution:\n    def isSquare(self n: int) -> bool:\n        sq = int(math.sqrt(n))\n        return sq*sq == n\n        \n    def numSquares(self n: int) -> int:\n        # Lagrange's four-square theorem\n        if self.isSquare(n):\n            return 1\n        while (n & 3) == 0:\n            n >>= 2\n        if (n & 7) == 7:\n            return 4\n        sq = int(math.sqrt(n)) + 1\n        for i in range(1sq):\n            if self.isSquare(n - i*i):\n                return 2\n        return 3\n
Permutation in String,"###  567\. Permutation in String\n\nGiven two strings `s1` and `s2` return `true` _if_`s2` _contains a\npermutation of_`s1` _ or_`false` _otherwise_.\n\nIn other words return `true` if one of `s1`'s permutations is the substring\nof `s2`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s1 = ""ab"" s2 = ""eidbaooo""\n    **Output:** true\n    **Explanation:** s2 contains one permutation of s1 (""ba"").\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""ab"" s2 = ""eidboaoo""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s1.length s2.length <= 104`\n  * `s1` and `s2` consist of lowercase English letters.\n\n",class Solution:\n    def checkInclusion(self s1: str s2: str) -> bool:\n        if len(s1) > len(s2):\n            return False\n        s1_map = {}\n        s2_map = {}\n        for i in range(ord('a')  ord('z') + 1):\n            s1_map[chr(i)] = 0\n            s2_map[chr(i)] = 0\n        \n        for i in s1:\n            s1_map[i] += 1\n            \n        l = 0\n        r = 0\n        \n        while r < len(s2):\n            print(s2_map  l r)\n            if r == 0:\n                while r < len(s1):\n                    s2_map[s2[r]] += 1\n                    r += 1\n                if s2_map == s1_map:\n                    return True\n\n            else:\n                s2_map[s2[l]] -= 1\n                s2_map[s2[r]] += 1\n                \n                if s2_map == s1_map:\n                    return True\n                else:\n                    l += 1\n                    r += 1\n            \n        return False      \n
Permutation Sequence,"###  60\. Permutation Sequence\n\nThe set `[1 2 3 ... n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order we get the following\nsequence for `n = 3`:\n\n  1. `""123""`\n  2. `""132""`\n  3. `""213""`\n  4. `""231""`\n  5. `""312""`\n  6. `""321""`\n\nGiven `n` and `k` return the `kth` permutation sequence.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 k = 3\n    **Output:** ""213""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4 k = 9\n    **Output:** ""2314""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3 k = 1\n    **Output:** ""123""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 9`\n  * `1 <= k <= n!`\n\n",// Runtime: 38 ms (Top 71.08%) | Memory: 17.30 MB (Top 15.2%)\n\nclass Solution:\n    def getPermutation(self n: int k: int) -> str:\n        nums = [i for i in range(1 n+1)] # list of numbers from 1 to n\n        factorial = [1] * n\n        for i in range(1 n):\n            factorial[i] = factorial[i-1] * i\n        \n        k -= 1\n        result = []\n        for i in range(n-1 -1 -1):\n            index = k // factorial[i]\n            result.append(str(nums[index]))\n            nums.pop(index)\n            k = k % factorial[i]\n        \n        return ''.join(result)\n
Permutations,###  46\. Permutations\n\nGiven an array `nums` of distinct integers return _all the possible\npermutations_. You can return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** [[123][132][213][231][312][321]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [01]\n    **Output:** [[01][10]]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1]\n    **Output:** [[1]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 6`\n  * `-10 <= nums[i] <= 10`\n  * All the integers of `nums` are **unique**.\n\n,class Solution:\n    def permute(self nums: List[int]) -> List[List[int]]:\n        return list(permutations(nums))\n
Permutations II,###  47\. Permutations II\n\nGiven a collection of numbers `nums` that might contain duplicates return\n_all possible unique permutations**in any order**._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [112]\n    **Output:**\n    [[112]\n     [121]\n     [211]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** [[123][132][213][231][312][321]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 8`\n  * `-10 <= nums[i] <= 10`\n\n,"# Runtime: 136 ms (Top 31.20%) | Memory: 14.2 MB (Top 62.53%)\nclass Solution(object):\n    def permuteUnique(self nums):\n        """"""\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        """"""\n        if len(nums) == 1:\n            return [[nums[0]]]\n\n        res = self.permuteUnique(nums[1:])\n\n        for i in range(len(res)-1 -1  -1):\n            j = 0\n            while j < len(res[i]):\n                if res[i][j] == nums[0]: #to account for repeated nums\n                    break\n                lst = res[i][:]\n                lst.insert(j nums[0])\n                res.append(lst)\n                j += 1\n\n            res[i].insert(jnums[0])\n\n        return res"
Pizza With 3n Slices,###  1388\. Pizza With 3n Slices\n\nThere is a pizza with `3n` slices of varying size you and your friends will\ntake slices of pizza as follows:\n\n  * You will pick **any** pizza slice.\n  * Your friend Alice will pick the next slice in the anti-clockwise direction of your pick.\n  * Your friend Bob will pick the next slice in the clockwise direction of your pick.\n  * Repeat until there are no more slices of pizzas.\n\nGiven an integer array `slices` that represent the sizes of the pizza slices\nin a clockwise direction return _the maximum possible sum of slice sizes that\nyou can pick_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/02/18/sample_3_1723.png)\n\n    \n    \n    **Input:** slices = [123456]\n    **Output:** 10\n    **Explanation:** Pick pizza slice of size 4 Alice and Bob will pick slices with size 3 and 5 respectively. Then Pick slices with size 6 finally Alice and Bob will pick slice of size 2 and 1 respectively. Total = 4 + 6.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/02/18/sample_4_1723.png)\n\n    \n    \n    **Input:** slices = [898611]\n    **Output:** 16\n    **Explanation:** Pick pizza slice of size 8 in each turn. If you pick slice with size 9 your partners will pick slices of size 8.\n    \n\n\n\n**Constraints:**\n\n  * `3 * n == slices.length`\n  * `1 <= slices.length <= 500`\n  * `1 <= slices[i] <= 1000`\n\n," class Solution:\n    def maxSizeSlices(self slices: List[int]) -> int:\n       ** #This solve function mainly on work on the idea of A Previous dp problem House Robber II \n		#If we take the first slice then we cant take the second slice and vice versa**\n		def solve(slicesstartendndp):\n            if start>end or n==0:\n                return 0\n            if dp[start][n] !=-1:\n                return dp[start][n]\n            include = slices[start] + solve(slicesstart+2endn-1dp)\n            \n            exclude = 0 + solve(slicesstart+1endndp)\n            \n            dp[start][n]= max(includeexclude)\n            return dp[start][n]\n        dp1=[[-1 for i in range(k+1)]for _ in range(k+1)]\n        dp2=[[-1 for i in range(k+1)]for _ in range(k+1)]\n        \n        option1=solve(slices0k-2k//3dp1)#Taking the the first slice  now we cant take the last slice and next slice\n        option2=solve(slices1k-1k//3dp2)#Taking the the second slice  now we cant take the second last slice and next slice\n        \n        return max(option1option2)\n"
Plates Between Candles,"###  2055\. Plates Between Candles\n\nThere is a long table with a line of plates and candles arranged on top of it.\nYou are given a **0-indexed** string `s` consisting of characters `'*'` and\n`'|'` only where a `'*'` represents a **plate** and a `'|'` represents a\n**candle**.\n\nYou are also given a **0-indexed** 2D integer array `queries` where\n`queries[i] = [lefti righti]` denotes the **substring** `s[lefti...righti]`\n(**inclusive**). For each query you need to find the **number** of plates\n**between candles** that are **in the substring**. A plate is considered\n**between candles** if there is at least one candle to its left **and** at\nleast one candle to its right **in the substring**.\n\n  * For example `s = ""||**||**|*""` and a query `[3 8]` denotes the substring `""*||**_**_** |""`. The number of plates between candles in this substring is `2` as each of the two plates has at least one candle **in the substring** to its left **and** right.\n\nReturn _an integer array_ `answer` _where_ `answer[i]` _is the answer to the_\n`ith` _query_.\n\n\n\n**Example 1:**\n\n![ex-1](https://assets.leetcode.com/uploads/2021/10/04/ex-1.png)\n\n    \n    \n    **Input:** s = ""**|**|***|"" queries = [[25][59]]\n    **Output:** [23]\n    **Explanation:**\n    - queries[0] has two plates between candles.\n    - queries[1] has three plates between candles.\n    \n\n**Example 2:**\n\n![ex-2](https://assets.leetcode.com/uploads/2021/10/04/ex-2.png)\n\n    \n    \n    **Input:** s = ""***|**|*****|**||**|*"" queries = [[117][45][1417][511][1516]]\n    **Output:** [90000]\n    **Explanation:**\n    - queries[0] has nine plates between candles.\n    - The other queries have zero plates between candles.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= s.length <= 105`\n  * `s` consists of `'*'` and `'|'` characters.\n  * `1 <= queries.length <= 105`\n  * `queries[i].length == 2`\n  * `0 <= lefti <= righti < s.length`\n\n",class Solution:\n    def platesBetweenCandles(self s: str queries: List[List[int]]) -> List[int]:\n        psum next prev = [0] * (len(s) + 1) [inf] * (len(s) + 1) [0] * (len(s) + 1)\n        res = []\n        for i ch in enumerate(s):\n            psum[i + 1] = psum[i] + (ch == '|')\n            prev[i + 1] = i if ch == '|' else prev[i]\n        for i ch in reversed(list(enumerate(s))):\n            next[i] = i if ch == '|' else next[i + 1]\n        for q in queries:\n            l r = next[q[0]] prev[q[1] + 1]\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\n        return res\n
Plus One,###  66\. Plus One\n\nYou are given a **large integer** represented as an integer array `digits`\nwhere each `digits[i]` is the `ith` digit of the integer. The digits are\nordered from most significant to least significant in left-to-right order. The\nlarge integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return _the resulting array of digits_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** digits = [123]\n    **Output:** [124]\n    **Explanation:** The array represents the integer 123.\n    Incrementing by one gives 123 + 1 = 124.\n    Thus the result should be [124].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** digits = [4321]\n    **Output:** [4322]\n    **Explanation:** The array represents the integer 4321.\n    Incrementing by one gives 4321 + 1 = 4322.\n    Thus the result should be [4322].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** digits = [9]\n    **Output:** [10]\n    **Explanation:** The array represents the integer 9.\n    Incrementing by one gives 9 + 1 = 10.\n    Thus the result should be [10].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= digits.length <= 100`\n  * `0 <= digits[i] <= 9`\n  * `digits` does not contain any leading `0`'s.\n\n,// Runtime: 33 ms (Top 85.76%) | Memory: 16.50 MB (Top 60.81%)\n\nclass Solution:\n    def plusOne(self digits: List[int]) -> List[int]:\n\n        for i in range(len(digits)-1 -1 -1):\n            if digits[i] == 9:\n                digits[i] = 0\n            else:\n                digits[i] = digits[i] + 1\n                return digits\n        return [1] + digits \n\n        \n
Poor Pigs,###  458\. Poor Pigs\n\nThere are `buckets` buckets of liquid where **exactly one** of the buckets is\npoisonous. To figure out which one is poisonous you feed some number of\n(poor) pigs the liquid to see whether they will die or not. Unfortunately you\nonly have `minutesToTest` minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\n  1. Choose some live pigs to feed.\n  2. For each pig choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets and each bucket can be fed from by any number of pigs.\n  3. Wait for `minutesToDie` minutes. You may **not** feed any other pigs during this time.\n  4. After `minutesToDie` minutes have passed any pigs that have been fed the poisonous bucket will die and all others will survive.\n  5. Repeat this process until you run out of time.\n\nGiven `buckets` `minutesToDie` and `minutesToTest` return _the**minimum**\nnumber of pigs needed to figure out which bucket is poisonous within the\nallotted time_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** buckets = 4 minutesToDie = 15 minutesToTest = 15\n    **Output:** 2\n    **Explanation:** We can determine the poisonous bucket as follows:\n    At time 0 feed the first pig buckets 1 and 2 and feed the second pig buckets 2 and 3.\n    At time 15 there are 4 possible outcomes:\n    - If only the first pig dies then bucket 1 must be poisonous.\n    - If only the second pig dies then bucket 3 must be poisonous.\n    - If both pigs die then bucket 2 must be poisonous.\n    - If neither pig dies then bucket 4 must be poisonous.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** buckets = 4 minutesToDie = 15 minutesToTest = 30\n    **Output:** 2\n    **Explanation:** We can determine the poisonous bucket as follows:\n    At time 0 feed the first pig bucket 1 and feed the second pig bucket 2.\n    At time 15 there are 2 possible outcomes:\n    - If either pig dies then the poisonous bucket is the one it was fed.\n    - If neither pig dies then feed the first pig bucket 3 and feed the second pig bucket 4.\n    At time 30 one of the two pigs must die and the poisonous bucket is the one it was fed.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= buckets <= 1000`\n  * `1 <= minutesToDie <= minutesToTest <= 100`\n\n,# Runtime: 32 ms (Top 93.2%) | Memory: 16.18 MB (Top 93.2%)\n\nclass Solution(object):\n    def poorPigs(self buckets minutesToDie minutesToTest):\n        # Calculate the max time for a pig to test buckets...\n        # Note that max time will not be (minutesToTest / minutesToDie)...\n        # Thinking about all pigs drinking all buckets at last but no one died immediately so the poison bucket is the last bucket...\n        max_time = minutesToTest / minutesToDie + 1\n        # Initialize the required minimum number of pigs...\n        req_pigs = 0\n        # To find the minimum number of pigs find the minimum req_pigs such that Math.pow(max_time req_pigs) >= buckets...\n        while (max_time) ** req_pigs < buckets:\n            # Increment until it will be greater or equals to bucket...\n            req_pigs += 1\n        # Return the required minimum number of pigs...\n        return req_pigs
Populating Next Right Pointers in Each Node,###  116\. Populating Next Right Pointers in Each Node\n\nYou are given a **perfect binary tree** where all leaves are on the same\nlevel and every parent has two children. The binary tree has the following\ndefinition:\n\n    \n    \n    struct Node {\n      int val;\n      Node *left;\n      Node *right;\n      Node *next;\n    }\n    \n\nPopulate each next pointer to point to its next right node. If there is no\nnext right node the next pointer should be set to `NULL`.\n\nInitially all next pointers are set to `NULL`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)\n\n    \n    \n    **Input:** root = [1234567]\n    **Output:** [1#23#4567#]\n    **Explanation:** Given the above perfect binary tree (Figure A) your function should populate each next pointer to point to its next right node just like in Figure B. The serialized output is in level order as connected by the next pointers with '#' signifying the end of each level.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 212 - 1]`.\n  * `-1000 <= Node.val <= 1000`\n\n\n\n**Follow-up:**\n\n  * You may only use constant extra space.\n  * The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.\n\n,"""\n# Definition for a Node.\nclass Node:\n    def __init__(self val: int = 0 left: 'Node' = None right: 'Node' = None next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n""\n\nclass Solution:\n    def connect(self root: 'Optional[Node]') -> 'Optional[Node]':\n        q=[]\n        q.append(root)\n        if not root:\n            return None\n        while q:\n            prev=None\n            for i in range(len(q)):\n                node=q.pop(0)\n                if prev:\n                    prev.next=node\n                prev=node\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            prev=None\n        return root\n        \n"
Populating Next Right Pointers in Each Node II,###  117\. Populating Next Right Pointers in Each Node II\n\nGiven a binary tree\n\n    \n    \n    struct Node {\n      int val;\n      Node *left;\n      Node *right;\n      Node *next;\n    }\n    \n\nPopulate each next pointer to point to its next right node. If there is no\nnext right node the next pointer should be set to `NULL`.\n\nInitially all next pointers are set to `NULL`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/02/15/117_sample.png)\n\n    \n    \n    **Input:** root = [12345null7]\n    **Output:** [1#23#457#]\n    **Explanation:** Given the above binary tree (Figure A) your function should populate each next pointer to point to its next right node just like in Figure B. The serialized output is in level order as connected by the next pointers with '#' signifying the end of each level.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 6000]`.\n  * `-100 <= Node.val <= 100`\n\n\n\n**Follow-up:**\n\n  * You may only use constant extra space.\n  * The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.\n\n,"# Runtime: 305 ms (Top 5.46%) | Memory: 15.4 MB (Top 49.03%)\n""""""\n# Definition for a Node.\nclass Node(object):\n    def __init__(self val=0 left=None right=None next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n""""""\n\nclass Solution(object):\n    def findRightMost(self root level requiredLevel):\n        if not root:\n            return root\n        if level == requiredLevel:\n            return root\n        right = self.findRightMost(root.right level + 1 requiredLevel)\n        if right:\n            return right\n        return self.findRightMost(root.left level + 1 requiredLevel)\n    def findLeftMost(self root level requiredLevel):\n        if not root:\n            return root\n        if level == requiredLevel:\n            return root\n        left = self.findLeftMost(root.left level + 1 requiredLevel)\n        if left:\n            return left\n        return self.findLeftMost(root.right level + 1 requiredLevel)\n    def findRightMostFromRoot(self rootLevelInfo requiredLevel currentRight):\n        if currentRight:\n            if currentRight.right:\n                return currentRight.right\n            if currentRight.left:\n                return currentRight.left\n        root rootlevel = rootLevelInfo\n        rightMost = self.findRightMost(root rootlevel requiredLevel)\n        while not rightMost and root:\n            root = root.right if root.right else root.left\n            rootlevel += 1\n            rightMost = self.findRightMost(root rootlevel requiredLevel)\n            if rightMost:\n                rootLevelInfo[-1] = rootlevel\n                rootLevelInfo[0] = root\n        return rightMost\n    def findLeftMostFromRoot(self rootLevelInfo requiredLevel currentLeft):\n        if currentLeft:\n            if currentLeft.left:\n                return currentLeft.left\n            if currentLeft.right:\n                return currentLeft.right\n        root rootlevel = rootLevelInfo\n        leftMost = self.findLeftMost(root rootlevel requiredLevel)\n        while not leftMost and root:\n            root = root.left if root.left else root.right\n            rootlevel += 1\n            leftMost = self.findLeftMost(root rootlevel requiredLevel)\n            if leftMost:\n                rootLevelInfo[-1] = rootlevel\n                rootLevelInfo[0] = root\n\n        return leftMost\n    def stitch(self root):\n        if not root:\n            return\n        leftRootStart = [root.left 1]\n        rightRootStart = [root.right 1]\n        connectLevel = 1\n        currentLeft = self.findLeftMostFromRoot(rightRootStart 1 None)\n        currentRight = self.findRightMostFromRoot(leftRootStart 1 None)\n        while currentLeft and currentRight:\n            currentRight.next = currentLeft\n            connectLevel += 1\n            currentLeft = self.findLeftMostFromRoot(rightRootStart connectLevel currentLeft)\n            currentRight = self.findRightMostFromRoot(leftRootStart connectLevel currentRight)\n\n        self.stitch(root.left)\n        self.stitch(root.right)\n    def connect(self root):\n        """"""\n        :type root: Node\n        :rtype: Node\n        """"""\n        if not root:\n            return root\n        self.stitch(root)\n        return root"
Positions of Large Groups,"###  830\. Positions of Large Groups\n\nIn a string `s` of lowercase letters these letters form consecutive groups of\nthe same character.\n\nFor example a string like `s = ""abbxxxxzyy""` has the groups `""a""` `""bb""`\n`""xxxx""` `""z""` and `""yy""`.\n\nA group is identified by an interval `[start end]` where `start` and `end`\ndenote the start and end indices (inclusive) of the group. In the above\nexample `""xxxx""` has the interval `[36]`.\n\nA group is considered **large**  if it has 3 or more characters.\n\nReturn _the intervals of every**large** group sorted in **increasing order by\nstart index**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abbxxxxzzy""\n    **Output:** [[36]]\n    **Explanation:** ""xxxx"" is the only large group with start index 3 and end index 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abc""\n    **Output:** []\n    **Explanation:** We have groups ""a"" ""b"" and ""c"" none of which are large groups.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""abcdddeeeeaabbbcd""\n    **Output:** [[35][69][1214]]\n    **Explanation:** The large groups are ""ddd"" ""eeee"" and ""bbb"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s` contains lowercase English letters only.\n\n","# Runtime: 81 ms (Top 17.97%) | Memory: 13.9 MB (Top 73.17%)\nclass Solution:\n    def largeGroupPositions(self s: str) -> List[List[int]]:\n\n        i=0\n        c=1\n        prev=""""\n        l=len(s)\n        ans=[]\n        while i<l:\n            if s[i]==prev:\n                c+=1\n                if (i==l-1) & (c>=3):\n                    ans.append([i+1-ci])\n            else:\n                if c>=3:\n                    ans.append([i-ci-1])\n                c=1\n            prev=s[i]\n            i+=1\n        return ans\n"
Possible Bipartition,###  886\. Possible Bipartition\n\nWe want to split a group of `n` people (labeled from `1` to `n`) into two\ngroups of **any size**. Each person may dislike some other people and they\nshould not go into the same group.\n\nGiven the integer `n` and the array `dislikes` where `dislikes[i] = [ai bi]`\nindicates that the person labeled `ai` does not like the person labeled `bi`\nreturn `true` _if it is possible to split everyone into two groups in this\nway_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 4 dislikes = [[12][13][24]]\n    **Output:** true\n    **Explanation:** group1 [14] and group2 [23].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3 dislikes = [[12][13][23]]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 5 dislikes = [[12][23][34][45][15]]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 2000`\n  * `0 <= dislikes.length <= 104`\n  * `dislikes[i].length == 2`\n  * `1 <= dislikes[i][j] <= n`\n  * `ai < bi`\n  * All the pairs of `dislikes` are **unique**.\n\n,# Runtime: 997 ms (Top 62.25%) | Memory: 22.2 MB (Top 22.99%)\nclass Solution:\n    def possibleBipartition(self n: int dislikes: List[List[int]]) -> bool:\n        def dfs(i c):\n            if color[i] != 0:\n                if color[i] != c:\n                    return False\n                return True\n\n            color[i] = c\n            for u in e[i]:\n                if not dfs(u 3 - c):\n                    return False\n            return True\n\n        e = [[] for _ in range(n)]\n        for u v in dislikes:\n            u -= 1\n            v -= 1\n            e[u].append(v)\n            e[v].append(u)\n        color = [0] * n\n        for i in range(n):\n            if color[i] == 0:\n                if not dfs(i 1):\n                    return False\n        return True
Pow(x n),###  50\. Pow(x n)\n\nImplement [pow(x n)](http://www.cplusplus.com/reference/valarray/pow/) which\ncalculates `x` raised to the power `n` (i.e. `xn`).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** x = 2.00000 n = 10\n    **Output:** 1024.00000\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** x = 2.10000 n = 3\n    **Output:** 9.26100\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** x = 2.00000 n = -2\n    **Output:** 0.25000\n    **Explanation:** 2-2 = 1/22 = 1/4 = 0.25\n    \n\n\n\n**Constraints:**\n\n  * `-100.0 < x < 100.0`\n  * `-231 <= n <= 231-1`\n  * `-104 <= xn <= 104`\n\n,class Solution:\n    def myPow(self x: float n: int) -> float:\n        self.x = x\n        \n        if n == 0:\n            return 1\n        \n        isInverted = False\n        if n < 0:\n            isInverted = True\n            n = -1 * n\n\n        result = self.pow(n)\n        \n        return result if not isInverted else 1 / result\n        \n    def pow(self n):\n        if n == 1:\n            return self.x\n        \n        if n % 2 == 0:\n            p = self.pow(n / 2)\n            return p * p\n        else:\n            return self.x * self.pow(n-1)\n
Power of Four,###  342\. Power of Four\n\nGiven an integer `n` return _`true` if it is a power of four. Otherwise\nreturn `false`_.\n\nAn integer `n` is a power of four if there exists an integer `x` such that `n\n== 4x`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 16\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= n <= 231 - 1`\n\n\n\n**Follow up:** Could you solve it without loops/recursion?\n\n,# Runtime: 46 ms (Top 35.3%) | Memory: 16.23 MB (Top 61.5%)\n\nimport math \nclass Solution:\n    def isPowerOfFour(self n: int) -> bool:\n\n        if n <= 0:\n            return False\n        return math.log(n 4).is_integer()
Power of Two,###  231\. Power of Two\n\nGiven an integer `n` return _`true` if it is a power of two. Otherwise\nreturn `false`_.\n\nAn integer `n` is a power of two if there exists an integer `x` such that `n\n== 2x`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** true\n    **Explanation:** 20 = 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 16\n    **Output:** true\n    **Explanation:** 24 = 16\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= n <= 231 - 1`\n\n\n\n**Follow up:** Could you solve it without loops/recursion?\n\n,"class Solution:\n    def isPowerOfTwo(self n: int) -> bool:\n        \n         if n == 0: return False\n        \n         k = n\n         while k != 1:\n             if k % 2 != 0:\n                 return False\n             k = k // 2\n            \n            \n         return True\n\n        count = 0\n        for i in range(33):\n            mask = 1 << i\n            \n            if mask & n:\n                count += 1\n                \n            if count > 1:\n                return False\n                \n        if count == 1:\n            return True\n        return False\n		\n"
Powerful Integers,###  970\. Powerful Integers\n\nGiven three integers `x` `y` and `bound` return _a list of all\nthe**powerful integers** that have a value less than or equal to_ `bound`.\n\nAn integer is **powerful** if it can be represented as `xi + yj` for some\nintegers `i >= 0` and `j >= 0`.\n\nYou may return the answer in **any order**. In your answer each value should\noccur **at most once**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** x = 2 y = 3 bound = 10\n    **Output:** [23457910]\n    **Explanation:**\n    2 = 20 + 30\n    3 = 21 + 30\n    4 = 20 + 31\n    5 = 21 + 31\n    7 = 22 + 31\n    9 = 23 + 30\n    10 = 20 + 32\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** x = 3 y = 5 bound = 15\n    **Output:** [24681014]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= x y <= 100`\n  * `0 <= bound <= 106`\n\n,from math import log\nclass Solution:\n    def powerfulIntegers(self x: int y: int bound: int) -> List[int]:\n        if bound == 0:\n            return []\n        maxi = int(log(boundmax(x2))) +1\n        maxj = int(log(boundmax(y2))) +1\n        L = set()\n        for i in range(maxi):\n            for j in range(maxj):\n                if (t:=x**i +y**j) <= bound:\n                    L.add(t)\n                else:\n                    break\n        return list(L)\n
Prefix and Suffix Search,"###  745\. Prefix and Suffix Search\n\nDesign a special dictionary that searches the words in it by a prefix and a\nsuffix.\n\nImplement the `WordFilter` class:\n\n  * `WordFilter(string[] words)` Initializes the object with the `words` in the dictionary.\n  * `f(string pref string suff)` Returns _the index of the word in the dictionary_ which has the prefix `pref` and the suffix `suff`. If there is more than one valid index return **the largest** of them. If there is no such word in the dictionary return `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""WordFilter"" ""f""]\n    [[[""apple""]] [""a"" ""e""]]\n    **Output**\n    [null 0]\n    **Explanation**\n    WordFilter wordFilter = new WordFilter([""apple""]);\n    wordFilter.f(""a"" ""e""); // return 0 because the word at index 0 has prefix = ""a"" and suffix = ""e"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 104`\n  * `1 <= words[i].length <= 7`\n  * `1 <= pref.length suff.length <= 7`\n  * `words[i]` `pref` and `suff` consist of lowercase English letters only.\n  * At most `104` calls will be made to the function `f`.\n\n",class WordFilter:\n    def __init__(self words: List[str]):\n        self.words = words\n        \n    def f(self prefix: str suffix: str) -> int:\n        idx = -1\n        for iw in enumerate(self.words):\n            if w.startswith(prefix) and w.endswith(suffix):\n                idx = i\n        \n        return idx\n\n
Preimage Size of Factorial Zeroes Function,###  793\. Preimage Size of Factorial Zeroes Function\n\nLet `f(x)` be the number of zeroes at the end of `x!`. Recall that `x! = 1 * 2\n* 3 * ... * x` and by convention `0! = 1`.\n\n  * For example `f(3) = 0` because `3! = 6` has no zeroes at the end while `f(11) = 2` because `11! = 39916800` has two zeroes at the end.\n\nGiven an integer `k` return the number of non-negative integers `x` have the\nproperty that `f(x) = k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** k = 0\n    **Output:** 5\n    **Explanation:** 0! 1! 2! 3! and 4! end with k = 0 zeroes.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** k = 5\n    **Output:** 0\n    **Explanation:** There is no x such that x! ends in k = 5 zeroes.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** k = 3\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * `0 <= k <= 109`\n\n,// Runtime: 30 ms (Top 93.33%) | Memory: 16.50 MB (Top 82.96%)\n\nclass Solution:\n    def preimageSizeFZF(self k: int) -> int:  \n\n        def atMost_k(k: int)-> int:\n\n            left right = 0 5*k + 4\n\n            while left <= right:\n                mid = (left+right)//2\n                count n = 0 mid\n\n                while n:\n                    n//= 5\n                    count+= n\n\n                if count <= k: left = mid + 1\n                else: right = mid - 1\n\n            return right\n\n        \n        return atMost_k(k) - atMost_k(k-1)\n
Previous Permutation With One Swap,###  1053\. Previous Permutation With One Swap\n\nGiven an array of positive integers `arr` (not necessarily distinct) return\n_the lexicographically largest permutation that is smaller than_ `arr` that\ncan be **made with exactly one swap** (A _swap_ exchanges the positions of two\nnumbers `arr[i]` and `arr[j]`). If it cannot be done then return the same\narray.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [321]\n    **Output:** [312]\n    **Explanation:** Swapping 2 and 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [115]\n    **Output:** [115]\n    **Explanation:** This is already the smallest permutation.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [19467]\n    **Output:** [17469]\n    **Explanation:** Swapping 9 and 7.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 104`\n  * `1 <= arr[i] <= 104`\n\n,# Runtime: 486 ms (Top 14.08%) | Memory: 15.3 MB (Top 47.61%)\nclass Solution:\n\n    def find_max(self i a n):\n        maxs = i+1\n        for j in range(n-1 i -1):\n            # if only j is greater than max and smaller than first descending element\n            if(a[maxs] <= a[j] and a[j] < a[i]):\n                maxs = j\n        # Swap\n        a[i] a[maxs] = a[maxs] a[i]\n        return a\n\n    def prevPermOpt1(self arr):\n        n = len(arr)\n        for i in range(n-1 0 -1):\n            if(arr[i] < arr[i-1]):\n                # sending the first descending element from right to max_function\n                arr = self.find_max(i-1 arr n)\n                break\n        return arr
Prime Arrangements,###  1175\. Prime Arrangements\n\nReturn the number of permutations of 1 to `n` so that prime numbers are at\nprime indices (1-indexed.)\n\n_(Recall that an integer  is prime if and only if it is greater than 1 and\ncannot be written as a product of two positive integers both smaller than\nit.)_\n\nSince the answer may be large return the answer **modulo`10^9 + 7`**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5\n    **Output:** 12\n    **Explanation:** For example [12543] is a valid permutation but [52341] is not because the prime number 5 is at index 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 100\n    **Output:** 682289015\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 100`\n\n,class Solution:\n    def numPrimeArrangements(self n: int) -> int:\n        primes = set()\n        for i in range(2n+1):\n            if all(i%p != 0 for p in primes):\n                primes.add(i)\n        M = 10**9 + 7\n        def fact(k):\n            res = 1\n            for i in range(2k+1):\n                res = (res*i)%M\n            return res\n        return fact(len(primes))*fact(n-len(primes))%M
Print Words Vertically,"###  1324\. Print Words Vertically\n\nGiven a string `s`. Return all the words vertically in the same order in which\nthey appear in `s`.  \nWords are returned as a list of strings complete with spaces when is\nnecessary. (Trailing spaces are not allowed).  \nEach word would be put on only one column and that in one column there will be\nonly one word.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""HOW ARE YOU""\n    **Output:** [""HAY""""ORO""""WEU""]\n    **Explanation:** Each word is printed vertically. \n     ""HAY""\n     ""ORO""\n     ""WEU""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""TO BE OR NOT TO BE""\n    **Output:** [""TBONTB""""OEROOE""""   T""]\n    **Explanation:** Trailing spaces is not allowed. \n    ""TBONTB""\n    ""OEROOE""\n    ""   T""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""CONTEST IS COMING""\n    **Output:** [""CIC""""OSO""""N M""""T I""""E N""""S G""""T""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 200`\n  * `s` contains only upper case English letters.\n  * It's guaranteed that there is only one space between 2 words.\n\n","\nclass Solution:\n    def getMaxLen(self words):\n        max_len = 0\n        for word in words:\n            max_len = max(max_len len(word))\n        return max_len\n    \n    def printVertically(self s: str) -> List[str]:\n        words = s.split()\n        max_len = self.getMaxLen(words)\n        \n        res = list()\n        for i in range(max_len):\n            s = """"\n            for word in words:\n                if i < len(word):\n                    s += word[i]\n                else:\n                    s += "" ""\n            s = s.rstrip()\n            res.append(s)\n        return res\n            \n            \n        \n		\n"
Prison Cells After N Days,###  957\. Prison Cells After N Days\n\nThere are `8` prison cells in a row and each cell is either occupied or\nvacant.\n\nEach day whether the cell is occupied or vacant changes according to the\nfollowing rules:\n\n  * If a cell has two adjacent neighbors that are both occupied or both vacant then the cell becomes occupied.\n  * Otherwise it becomes vacant.\n\n**Note** that because the prison is a row the first and the last cells in the\nrow can't have two adjacent neighbors.\n\nYou are given an integer array `cells` where `cells[i] == 1` if the `ith` cell\nis occupied and `cells[i] == 0` if the `ith` cell is vacant and you are given\nan integer `n`.\n\nReturn the state of the prison after `n` days (i.e. `n` such changes\ndescribed above).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** cells = [01011001] n = 7\n    **Output:** [00110000]\n    **Explanation:** The following table summarizes the state of the prison on each day:\n    Day 0: [0 1 0 1 1 0 0 1]\n    Day 1: [0 1 1 0 0 0 0 0]\n    Day 2: [0 0 0 0 1 1 1 0]\n    Day 3: [0 1 1 0 0 1 0 0]\n    Day 4: [0 0 0 0 0 1 0 0]\n    Day 5: [0 1 1 1 0 1 0 0]\n    Day 6: [0 0 1 0 1 1 0 0]\n    Day 7: [0 0 1 1 0 0 0 0]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cells = [10010010] n = 1000000000\n    **Output:** [00111110]\n    \n\n\n\n**Constraints:**\n\n  * `cells.length == 8`\n  * `cells[i]` is either `0` or `1`.\n  * `1 <= n <= 109`\n\n,# Runtime: 85 ms (Top 14.83%) | Memory: 14 MB (Top 28.83%)\nclass Solution:\n    def prisonAfterNDays(self cells: List[int] n: int) -> List[int]:\n        patternMatch=defaultdict(int) # pattern match\n        totalPrisons=8 # totalPrisons\n        cells= [ str(c) for c in (cells)] # into char type\n        for d in range(1n+1):\n            tempCell=[]\n            tempCell.append('0') # left corner case\n            for c in range(1totalPrisons-1):\n                if (cells[c-1]=='1' and cells[c+1]=='1') or (cells[c-1]=='0' and cells[c+1]=='0'):\n                    tempCell.append('1') # insert 1 if first condition met\n                else:\n                    tempCell.append('0') # otherwise 0\n            tempCell.append('0') # right corner case\n            cells=tempCell # update cells\n            pattern= ''.join(tempCell) # insert pattern in hashtable\n            if pattern in patternMatch: # if there is a match\n                day=patternMatch[pattern]\n                remainder= (n%(d-1))-1 # take modulo\n                match= list(patternMatch.keys())[remainder] # find key\n                return [ int(m) for m in match] # return\n            patternMatch[pattern]=d # assign day\n        return [ int(c) for c in (cells)] # return
Probability of a Two Boxes Having The Same Number of Distinct Balls,###  1467\. Probability of a Two Boxes Having The Same Number of Distinct\nBalls\n\nGiven `2n` balls of `k` distinct colors. You will be given an integer array\n`balls` of size `k` where `balls[i]` is the number of balls of color `i`.\n\nAll the balls will be **shuffled uniformly at random**  then we will\ndistribute the first `n` balls to the first box and the remaining `n` balls to\nthe other box (Please read the explanation of the second example carefully).\n\nPlease note that the two boxes are considered different. For example if we\nhave two balls of colors `a` and `b` and two boxes `[]` and `()` then the\ndistribution `[a] (b)` is considered different than the distribution `[b] (a)\n`(Please read the explanation of the first example carefully).\n\nReturn _the probability_ that the two boxes have the same number of distinct\nballs. Answers within `10-5` of the actual value will be accepted as correct.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** balls = [11]\n    **Output:** 1.00000\n    **Explanation:** Only 2 ways to divide the balls equally:\n    - A ball of color 1 to box 1 and a ball of color 2 to box 2\n    - A ball of color 2 to box 1 and a ball of color 1 to box 2\n    In both ways the number of distinct colors in each box is equal. The probability is 2/2 = 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** balls = [211]\n    **Output:** 0.66667\n    **Explanation:** We have the set of balls [1 1 2 3]\n    This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n    [11 / 23] [11 / 32] [12 / 13] [12 / 31] [13 / 12] [13 / 21] [21 / 13] [21 / 31] [23 / 11] [31 / 12] [31 / 21] [32 / 11]\n    After that we add the first two balls to the first box and the second two balls to the second box.\n    We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\n    Probability is 8/12 = 0.66667\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** balls = [1212]\n    **Output:** 0.60000\n    **Explanation:** The set of balls is [1 2 2 3 4 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\n    Probability = 108 / 180 = 0.6\n    \n\n\n\n**Constraints:**\n\n  * `1 <= balls.length <= 8`\n  * `1 <= balls[i] <= 6`\n  * `sum(balls)` is even.\n\n,// Runtime: 53 ms (Top 90.74%) | Memory: 14.1 MB (Top 53.70%)\nclass Solution:\n    def getProbability(self balls: List[int]) -> float:\n        m = len(balls)\n        N = sum(balls)\n        n = N // 2\n\n        prefix = [0] * m\n        for i in range(m):\n            prefix[i] = prefix[i-1] + balls[i]\n\n        # STEP 1: Compute the number of ways to pick j balls from i total i.e. C(i j)\n        choose = [[0] * (N + 1) for i in range(N + 1)]\n        choose[0][0] = 1\n        for i in range(1 N + 1):\n            for pick in range(N + 1):\n                # DECISION 1: don't pick the ith ball\n                choose[i][pick] += choose[i - 1][pick]\n                # DECISION 2: pick the ith ball\n                choose[i][pick] += choose[i - 1][pick - 1]\n\n        # STEP 2: From first i ball types compute ways to:\n        # - pick c1 balls in box1\n        # - such that the difference in unique ball count between box1 and box2 is d\n        ways = [[defaultdict(int) for k in range(n + 1)] for i in range(m + 1)]\n        ways[0][0][0] = 1\n\n        for i in range(m):\n            b = balls[i]\n            if i == 0:\n                prev_total = 0\n            else:\n                prev_total = prefix[i - 1]\n            for c1 in range(n + 1):\n                c2 = prev_total - c1\n                if c2 < 0:\n                    continue\n                for d in ways[i][c1]:\n                    for add1 in range(b + 1):\n                        add2 = b - add1\n                        if c1 + add1 > n:\n                            continue\n                        if c2 + add2 > n:\n                            continue\n                        if add1 == b:\n                            delta = 1\n                        elif add2 == b:\n                            delta = -1\n                        else:\n                            delta = 0\n                        ways_to_add = choose[b][add1] * ways[i][c1][d]\n                        ways[i + 1][c1 + add1][d + delta] += ways_to_add\n\n        # compute the actual probability\n        return ways[m][n][0] / choose[N][n]
Process Restricted Friend Requests,###  2076\. Process Restricted Friend Requests\n\nYou are given an integer `n` indicating the number of people in a network.\nEach person is labeled from `0` to `n - 1`.\n\nYou are also given a **0-indexed** 2D integer array `restrictions` where\n`restrictions[i] = [xi yi]` means that person `xi` and person `yi` **cannot**\nbecome **friends** **** either **directly** or **indirectly** through other\npeople.\n\nInitially no one is friends with each other. You are given a list of friend\nrequests as a **0-indexed** 2D integer array `requests` where `requests[j] =\n[uj vj]` is a friend request between person `uj` and person `vj`.\n\nA friend request is **successful** if `uj` and `vj` can be **friends**. Each\nfriend request is processed in the given order (i.e. `requests[j]` occurs\nbefore `requests[j + 1]`) and upon a successful request `uj` and `vj`\n**become direct friends** for all future friend requests.\n\nReturn _a**boolean array** _`result`_where each_`result[j]`_is_`true` _if\nthe_`jth` _friend request is**successful** or _`false` _if it is not_.\n\n**Note:** If `uj` and `vj` are already direct friends the request is still\n**successful**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 restrictions = [[01]] requests = [[02][21]]\n    **Output:** [truefalse]\n    **Explanation:** Request 0: Person 0 and person 2 can be friends so they become direct friends. \n    Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3 restrictions = [[01]] requests = [[12][02]]\n    **Output:** [truefalse]\n    **Explanation:** Request 0: Person 1 and person 2 can be friends so they become direct friends.\n    Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 5 restrictions = [[01][12][23]] requests = [[04][12][31][34]]\n    **Output:** [truefalsetruefalse]\n    **Explanation:** Request 0: Person 0 and person 4 can be friends so they become direct friends.\n    Request 1: Person 1 and person 2 cannot be friends since they are directly restricted.\n    Request 2: Person 3 and person 1 can be friends so they become direct friends.\n    Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1).\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 1000`\n  * `0 <= restrictions.length <= 1000`\n  * `restrictions[i].length == 2`\n  * `0 <= xi yi <= n - 1`\n  * `xi != yi`\n  * `1 <= requests.length <= 1000`\n  * `requests[j].length == 2`\n  * `0 <= uj vj <= n - 1`\n  * `uj != vj`\n\n,class UnionFindSet(object):\n    def __init__(self n):\n        self.data = range(n)\n\n    def find(self x):\n        while x <> self.data[x]:\n            x = self.data[x]\n        return x\n\n    def union(self x y):\n        self.data[self.find(x)] = self.find(y)\n\n    def speedup(self):\n        for i in range(len(self.data)):\n            self.data[i] = self.find(i)\n\n\nclass Solution(object):\n    def friendRequests(self n restrictions requests):\n        uf = UnionFindSet(n)\n        ret = [True] * len(requests)\n        for k [x y] in enumerate(requests):  # Process Requests Sequentially\n            xh = uf.find(x)  # backup the head of x for undo\n            uf.union(x y)  # link [x y] and verify if any restriction triggers\n            for [i j] in restrictions:\n                if uf.find(i) == uf.find(j):\n                    ret[k] = False\n                    break\n            if not ret[k]:  # if any restriction triggers undo\n                uf.data[xh] = xh\n            else:\n                uf.speedup()\n        return ret\n
Process Tasks Using Servers,###  1882\. Process Tasks Using Servers\n\nYou are given two **0-indexed** integer arrays `servers` and `tasks` of\nlengths `n`​​​​​​ and `m`​​​​​​ respectively.\n`servers[i]` is the **weight** of the `i​​​​​​th`​​​​\nserver and `tasks[j]` is the **time needed** to process the\n`j​​​​​​th`​​​​ task **in seconds**.\n\nTasks are assigned to the servers using a **task queue**. Initially all\nservers are free and the queue is **empty**.\n\nAt second `j` the `jth` task is **inserted** into the queue (starting with\nthe `0th` task being inserted at second `0`). As long as there are free\nservers and the queue is not empty the task in the front of the queue will be\nassigned to a free server with the **smallest weight**  and in case of a tie\nit is assigned to a free server with the **smallest index**.\n\nIf there are no free servers and the queue is not empty we wait until a\nserver becomes free and immediately assign the next task. If multiple servers\nbecome free at the same time then multiple tasks from the queue will be\nassigned **in order of insertion** following the weight and index priorities\nabove.\n\nA server that is assigned task `j` at second `t` will be free again at second\n`t + tasks[j]`.\n\nBuild an array `ans`​​​​ of length `m` where `ans[j]` is the\n**index** of the server the `j​​​​​​th` task will be assigned to.\n\nReturn _the array_`ans`​​​​.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** servers = [332] tasks = [123212]\n    **Output:** [220212]\n    **Explanation:** Events in chronological order go as follows:\n    - At second 0 task 0 is added and processed using server 2 until second 1.\n    - At second 1 server 2 becomes free. Task 1 is added and processed using server 2 until second 3.\n    - At second 2 task 2 is added and processed using server 0 until second 5.\n    - At second 3 server 2 becomes free. Task 3 is added and processed using server 2 until second 5.\n    - At second 4 task 4 is added and processed using server 1 until second 5.\n    - At second 5 all servers become free. Task 5 is added and processed using server 2 until second 7.\n\n**Example 2:**\n\n    \n    \n    **Input:** servers = [51432] tasks = [2124521]\n    **Output:** [1414132]\n    **Explanation:** Events in chronological order go as follows: \n    - At second 0 task 0 is added and processed using server 1 until second 2.\n    - At second 1 task 1 is added and processed using server 4 until second 2.\n    - At second 2 servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. \n    - At second 3 task 3 is added and processed using server 4 until second 7.\n    - At second 4 server 1 becomes free. Task 4 is added and processed using server 1 until second 9. \n    - At second 5 task 5 is added and processed using server 3 until second 7.\n    - At second 6 task 6 is added and processed using server 2 until second 7.\n    \n\n\n\n**Constraints:**\n\n  * `servers.length == n`\n  * `tasks.length == m`\n  * `1 <= n m <= 2 * 105`\n  * `1 <= servers[i] tasks[j] <= 2 * 105`\n\n,class Solution:\n    def assignTasks(self servers: List[int] tasks: List[int]) -> List[int]:\n        servers_available = [(w i) for iw in enumerate(servers)]\n        heapify(servers_available)\n        tasks_in_progress = []\n        res = []\n        time = 0\n        for jtask in enumerate(tasks):\n            time = max(time j)\n            if not servers_available:\n                time = tasks_in_progress[0][0]\n            while tasks_in_progress and tasks_in_progress[0][0] <= time:\n                heappush(servers_available heappop(tasks_in_progress)[1])\n            res.append(servers_available[0][1])\n            heappush(tasks_in_progress (time + task heappop(servers_available)))\n        return res\n
Product of Array Except Self,###  238\. Product of Array Except Self\n\nGiven an integer array `nums` return _an array_ `answer` _such that_\n`answer[i]` _is equal to the product of all the elements of_ `nums` _except_\n`nums[i]`.\n\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a\n**32-bit** integer.\n\nYou must write an algorithm that runs in `O(n)` time and without using the\ndivision operation.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** [241286]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-110-33]\n    **Output:** [00900]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 105`\n  * `-30 <= nums[i] <= 30`\n  * The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\n\n\n**Follow up:**  Can you solve the problem in `O(1) `extra space complexity?\n(The output array **does not** count as extra space for space complexity\nanalysis.)\n\n,# Runtime: 477 ms (Top 13.75%) | Memory: 22.5 MB (Top 18.46%)\nclass Solution:\n    def productExceptSelf(self nums: List[int]) -> List[int]:\n        pre = [1]* (len(nums)+1)\n        back = [1]*(len(nums)+1)\n\n        for i in range(len(nums)):\n            pre[i+1] = pre[i]*nums[i]\n\n        for i in range(len(nums)-1-1-1):\n            back[i-1] = back[i]*nums[i]\n        for i in range(len(pre)-1):\n            nums[i]=pre[i]*back[i]\n\n        return nums
Product of the Last K Numbers,"###  1352\. Product of the Last K Numbers\n\nDesign an algorithm that accepts a stream of integers and retrieves the\nproduct of the last `k` integers of the stream.\n\nImplement the `ProductOfNumbers` class:\n\n  * `ProductOfNumbers()` Initializes the object with an empty stream.\n  * `void add(int num)` Appends the integer `num` to the stream.\n  * `int getProduct(int k)` Returns the product of the last `k` numbers in the current list. You can assume that always the current list has at least `k` numbers.\n\nThe test cases are generated so that at any time the product of any\ncontiguous sequence of numbers will fit into a single 32-bit integer without\noverflowing.\n\n\n\n**Example:**\n\n    \n    \n    **Input**\n    [""ProductOfNumbers""""add""""add""""add""""add""""add""""getProduct""""getProduct""""getProduct""""add""""getProduct""]\n    [[][3][0][2][5][4][2][3][4][8][2]]\n    \n    **Output**\n    [nullnullnullnullnullnull20400null32]\n    \n    **Explanation**\n    ProductOfNumbers productOfNumbers = new ProductOfNumbers();\n    productOfNumbers.add(3);        // [3]\n    productOfNumbers.add(0);        // [30]\n    productOfNumbers.add(2);        // [302]\n    productOfNumbers.add(5);        // [3025]\n    productOfNumbers.add(4);        // [30254]\n    productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20\n    productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40\n    productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0\n    productOfNumbers.add(8);        // [302548]\n    productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 \n    \n\n\n\n**Constraints:**\n\n  * `0 <= num <= 100`\n  * `1 <= k <= 4 * 104`\n  * At most `4 * 104` calls will be made to `add` and `getProduct`.\n  * The product of the stream at any point in time will fit in a **32-bit** integer.\n\n",# Runtime: 732 ms (Top 6.90%) | Memory: 163.2 MB (Top 5.18%)\nclass ProductOfNumbers:\n    def __init__(self):\n        self.prods = [1]\n        self.max = 0\n\n    def add(self num: int) -> None:\n        if num == 0:\n            num = 1\n            self.max = len(self.prods)\n        self.prods.append(self.prods[-1] * num)\n\n    def getProduct(self k: int) -> int:\n        if k >= len(self.prods) - self.max:\n            return 0\n        return self.prods[-1] // self.prods[-k-1]
Profitable Schemes,###  879\. Profitable Schemes\n\nThere is a group of `n` members and a list of various crimes they could\ncommit. The `ith` crime generates a `profit[i]` and requires `group[i]`\nmembers to participate in it. If a member participates in one crime that\nmember can't participate in another crime.\n\nLet's call a **profitable scheme** any subset of these crimes that generates\nat least `minProfit` profit and the total number of members participating in\nthat subset of crimes is at most `n`.\n\nReturn the number of schemes that can be chosen. Since the answer may be very\nlarge **return it modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5 minProfit = 3 group = [22] profit = [23]\n    **Output:** 2\n    **Explanation:** To make a profit of at least 3 the group could either commit crimes 0 and 1 or just crime 1.\n    In total there are 2 schemes.\n\n**Example 2:**\n\n    \n    \n    **Input:** n = 10 minProfit = 5 group = [235] profit = [678]\n    **Output:** 7\n    **Explanation:** To make a profit of at least 5 the group could commit any crimes as long as they commit one.\n    There are 7 possible schemes: (0) (1) (2) (01) (02) (12) and (012).\n\n\n\n**Constraints:**\n\n  * `1 <= n <= 100`\n  * `0 <= minProfit <= 100`\n  * `1 <= group.length <= 100`\n  * `1 <= group[i] <= 100`\n  * `profit.length == group.length`\n  * `0 <= profit[i] <= 100`\n\n,class Solution:\n    def profitableSchemes(self n minProfit group profit):\n        \n        k = len(group)\n        arr = [[[0 for _ in range(k+1)] for _ in range(minProfit+1)] for _ in range(n+1)]\n        \n        for i in range(n+1):\n            arr[i][0][k] = 1\n       \n        for j in range(k-1-1-1):\n            for i in range(n-1-1):\n                for x in range(minProfit-1-1):\n\n                    arr[i][x][j] = arr[i][x][j+1]\n                    if i>=group[j]:\n                        arr[i][x][j] += arr[i-group[j]][max(x-profit[j]0)][j+1]\n        \n        return arr[n][minProfit][0] % (10**9 + 7)\n\n
Projection Area of 3D Shapes,"###  883\. Projection Area of 3D Shapes\n\nYou are given an `n x n` `grid` where we place some `1 x 1 x 1` cubes that are\naxis-aligned with the `x` `y` and `z` axes.\n\nEach value `v = grid[i][j]` represents a tower of `v` cubes placed on top of\nthe cell `(i j)`.\n\nWe view the projection of these cubes onto the `xy` `yz` and `zx` planes.\n\nA **projection** is like a shadow that maps our **3-dimensional** figure to a\n**2-dimensional** plane. We are viewing the ""shadow"" when looking at the cubes\nfrom the top the front and the side.\n\nReturn _the total area of all three projections_.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png)\n\n    \n    \n    **Input:** grid = [[12][34]]\n    **Output:** 17\n    **Explanation:** Here are the three projections (""shadows"") of the shape made with each axis-aligned plane.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[2]]\n    **Output:** 5\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[10][02]]\n    **Output:** 8\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length == grid[i].length`\n  * `1 <= n <= 50`\n  * `0 <= grid[i][j] <= 50`\n\n","class Solution:\n    def projectionArea(self grid: List[List[int]]) -> int:\n        total = 0\n		\n        # top\n        total += sum([1 for i in grid for j in i if j > 0])\n        \n		# front\n        total +=  sum([max(col) for col in zip(*grid)])\n        \n		# side\n        total +=  sum([max(row) for row in grid])\n        \n		return total\n"
Pseudo-Palindromic Paths in a Binary Tree,###  1457\. Pseudo-Palindromic Paths in a Binary Tree\n\nGiven a binary tree where node values are digits from 1 to 9. A path in the\nbinary tree is said to be **pseudo-palindromic** if at least one permutation\nof the node values in the path is a palindrome.\n\n_Return the number of**pseudo-palindromic** paths going from the root node to\nleaf nodes._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/05/06/palindromic_paths_1.png)\n\n    \n    \n    **Input:** root = [23131null1]\n    **Output:** 2 \n    **Explanation:** The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [233] the green path [211] and the path [231]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [233] can be rearranged in [323] (palindrome) and the green path [211] can be rearranged in [121] (palindrome).\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2020/05/07/palindromic_paths_2.png)**\n\n    \n    \n    **Input:** root = [21113nullnullnullnullnull1]\n    **Output:** 1 \n    **Explanation:** The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [211] the path [2131] and the path [21]. Among these paths only the green path is pseudo-palindromic since [211] can be rearranged in [121] (palindrome).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [9]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 105]`.\n  * `1 <= Node.val <= 9`\n\n,# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def dfs(self node path):\n        if not node:\n            return\n        \n        if not node.left and not node.right:\n            path += [node.val]\n            d = {}\n            for i in path.copy():\n                if i in d:\n                    del d[i]\n                else:\n                    d[i] = 1\n            #print(d.items())\n            self.ans += 1 if len(d) <= 1 else 0\n            return\n                \n        self.dfs(node.left path+[node.val])\n        self.dfs(node.right path+[node.val])\n    \n    def pseudoPalindromicPaths (self root: Optional[TreeNode]) -> int:\n        self.ans = 0\n        self.dfs(root [])\n        return self.ans
Queens That Can Attack the King,###  1222\. Queens That Can Attack the King\n\nOn an **8x8** chessboard there can be multiple Black Queens and one White\nKing.\n\nGiven an array of integer coordinates `queens` that represents the positions\nof the Black Queens and a pair of coordinates `king` that represent the\nposition of the White King return the coordinates of all the queens (in any\norder) that can attack the King.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/10/01/untitled-diagram.jpg)\n\n    \n    \n    **Input:** queens = [[01][10][40][04][33][24]] king = [00]\n    **Output:** [[01][10][33]]\n    **Explanation:**   \n    The queen at [01] can attack the king cause they're in the same row. \n    The queen at [10] can attack the king cause they're in the same column. \n    The queen at [33] can attack the king cause they're in the same diagnal. \n    The queen at [04] can't attack the king cause it's blocked by the queen at [01]. \n    The queen at [40] can't attack the king cause it's blocked by the queen at [10]. \n    The queen at [24] can't attack the king cause it's not in the same row/column/diagnal as the king.\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2019/10/01/untitled-diagram-1.jpg)**\n\n    \n    \n    **Input:** queens = [[00][11][22][34][35][44][45]] king = [33]\n    **Output:** [[22][34][44]]\n    \n\n**Example 3:**\n\n**![](https://assets.leetcode.com/uploads/2019/10/01/untitled-diagram-2.jpg)**\n\n    \n    \n    **Input:** queens = [[56][77][21][07][16][51][37][03][40][12][63][50][04][22][11][64][54][00][26][45][52][14][75][23][05][42][10][27][01][46][61][06][43][17]] king = [34]\n    **Output:** [[23][14][16][37][43][54][45]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= queens.length <= 63`\n  * `queens[i].length == 2`\n  * `0 <= queens[i][j] < 8`\n  * `king.length == 2`\n  * `0 <= king[0] king[1] < 8`\n  * At most one piece is allowed in a cell.\n\n,class Solution:\n    def queensAttacktheKing(self queens: List[List[int]] king: List[int]) -> List[List[int]]:\n        ans = []\n        d = {(i[0]i[1]) : True for i in queens}\n        def goUp(rc):\n            while r >=0:\n                if (rc) in d:\n                    ans.append([rc])\n                    break\n                r -= 1\n        def goDown(rc):\n            while r < 8:\n                if (rc) in d: \n                    ans.append([rc])\n                    break\n                r += 1\n        def goLeft(rc):\n            while c >= 0:\n                if (rc) in d:\n                    ans.append([rc])\n                    break\n                c -= 1\n        def goRight(rc):\n            while c < 8:\n                if (rc) in d: \n                    ans.append([rc])\n                    break\n                c += 1\n        def goD1(rc):\n            while r >=0 and c >= 0:\n                if (rc) in d:\n                    ans.append([rc])\n                    break\n                r -= 1\n                c -= 1\n        def goD2(rc):\n            while r < 8 and c >= 0:\n                if (rc) in d: \n                    ans.append([rc])\n                    break\n                r += 1\n                c -= 1\n        def goD3(rc):\n            while r < 8 and c < 8:\n                if (rc) in d: \n                    ans.append([rc])\n                    break\n                r += 1\n                c += 1\n        def goD4(rc):\n            while r >= 0 and c < 8:\n                if (rc) in d: \n                    ans.append([rc])\n                    break\n                r -= 1\n                c += 1\n\n        goUp(king[0]king[1])\n        goDown(king[0]king[1])\n        goLeft(king[0]king[1])\n        goRight(king[0]king[1])\n        goD1(king[0]king[1])\n        goD2(king[0]king[1])\n        goD3(king[0]king[1])\n        goD4(king[0]king[1])\n\n        return ans\n
Queries on a Permutation With Key,###  1409\. Queries on a Permutation With Key\n\nGiven the array `queries` of positive integers between `1` and `m` you have\nto process all `queries[i]` (from `i=0` to `i=queries.length-1`) according to\nthe following rules:\n\n  * In the beginning you have the permutation `P=[123...m]`.\n  * For the current `i` find the position of `queries[i]` in the permutation `P` (**indexing from 0**) and then move this at the beginning of the permutation `P.` Notice that the position of `queries[i]` in `P` is the result for `queries[i]`.\n\nReturn an array containing the result for the given `queries`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** queries = [3121] m = 5\n    **Output:** [2121] \n    **Explanation:** The queries are processed as follow: \n    For i=0: queries[i]=3 P=[12345] position of 3 in P is **2**  then we move 3 to the beginning of P resulting in P=[31245]. \n    For i=1: queries[i]=1 P=[31245] position of 1 in P is **1**  then we move 1 to the beginning of P resulting in P=[13245]. \n    For i=2: queries[i]=2 P=[13245] position of 2 in P is **2**  then we move 2 to the beginning of P resulting in P=[21345]. \n    For i=3: queries[i]=1 P=[21345] position of 1 in P is **1**  then we move 1 to the beginning of P resulting in P=[12345]. \n    Therefore the array containing the result is [2121].  \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** queries = [4122] m = 4\n    **Output:** [3120]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** queries = [75583] m = 8\n    **Output:** [65075]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m <= 10^3`\n  * `1 <= queries.length <= m`\n  * `1 <= queries[i] <= m`\n\n,class Solution:\n    def processQueries(self queries: List[int] m: int) -> List[int]:\n        perm=[i for i in range(1m+1)]\n        res=[]\n        for i in queries:\n            ind=perm.index(i)\n            res.append(ind)\n            perm=[perm.pop(ind)]+perm\n        return res\n
Queries on Number of Points Inside a Circle,###  1828\. Queries on Number of Points Inside a Circle\n\nYou are given an array `points` where `points[i] = [xi yi]` is the\ncoordinates of the `ith` point on a 2D plane. Multiple points can have the\n**same** coordinates.\n\nYou are also given an array `queries` where `queries[j] = [xj yj rj]`\ndescribes a circle centered at `(xj yj)` with a radius of `rj`.\n\nFor each query `queries[j]` compute the number of points **inside** the `jth`\ncircle. Points **on the border** of the circle are considered **inside**.\n\nReturn _an array_`answer` _ where_`answer[j]`_is the answer to the_`jth`\n_query_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-34-16.png)\n\n    \n    \n    **Input:** points = [[13][33][53][22]] queries = [[231][431][112]]\n    **Output:** [322]\n    **Explanation:** The points and circles are shown above.\n    queries[0] is the green circle queries[1] is the red circle and queries[2] is the blue circle.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/25/chrome_2021-03-25_22-42-07.png)\n\n    \n    \n    **Input:** points = [[11][22][33][44][55]] queries = [[122][222][432][433]]\n    **Output:** [2324]\n    **Explanation:** The points and circles are shown above.\n    queries[0] is green queries[1] is red queries[2] is blue and queries[3] is purple.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= points.length <= 500`\n  * `points[i].length == 2`\n  * `0 <= x​​​​​​i y​​​​​​i <= 500`\n  * `1 <= queries.length <= 500`\n  * `queries[j].length == 3`\n  * `0 <= xj yj <= 500`\n  * `1 <= rj <= 500`\n  * All coordinates are integers.\n\n\n\n**Follow up:** Could you find the answer for each query in better complexity\nthan `O(n)`?\n\n,"class Solution:\n	def countPoints(self points: List[List[int]] queries: List[List[int]]) -> List[int]:\n		circle = []\n		for x2 y2 radius in queries:\n			count = 0\n			for x1 y1 in points:\n				dis = ((x2-x1)**2+(y2-y1)**2)**0.5 # Use the Distance Formula...\n				if dis <= radius:\n					count += 1\n			circle.append(count)\n		return circle"
Query Kth Smallest Trimmed Number,"###  2343\. Query Kth Smallest Trimmed Number\n\nYou are given a **0-indexed** array of strings `nums` where each string is of\n**equal length** and consists of only digits.\n\nYou are also given a **0-indexed** 2D integer array `queries` where\n`queries[i] = [ki trimi]`. For each `queries[i]` you need to:\n\n  * **Trim** each number in `nums` to its **rightmost** `trimi` digits.\n  * Determine the **index** of the `kith` smallest trimmed number in `nums`. If two trimmed numbers are equal the number with the **lower** index is considered to be smaller.\n  * Reset each number in `nums` to its original length.\n\nReturn _an array_`answer` _of the same length\nas_`queries`_where_`answer[i]`_is the answer to the_`ith` _query._\n\n**Note** :\n\n  * To trim to the rightmost `x` digits means to keep removing the leftmost digit until only `x` digits remain.\n  * Strings in `nums` may contain leading zeros.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [""102""""473""""251""""814""] queries = [[11][23][42][12]]\n    **Output:** [2210]\n    **Explanation:**\n    1. After trimming to the last digit nums = [""2""""3""""1""""4""]. The smallest number is 1 at index 2.\n    2. Trimmed to the last 3 digits nums is unchanged. The 2nd smallest number is 251 at index 2.\n    3. Trimmed to the last 2 digits nums = [""02""""73""""51""""14""]. The 4th smallest number is 73.\n    4. Trimmed to the last 2 digits the smallest number is 2 at index 0.\n       Note that the trimmed number ""02"" is evaluated as 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [""24""""37""""96""""04""] queries = [[21][22]]\n    **Output:** [30]\n    **Explanation:**\n    1. Trimmed to the last digit nums = [""4""""7""""6""""4""]. The 2nd smallest number is 4 at index 3.\n       There are two occurrences of 4 but the one at index 0 is considered smaller than the one at index 3.\n    2. Trimmed to the last 2 digits nums is unchanged. The 2nd smallest number is 24.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `1 <= nums[i].length <= 100`\n  * `nums[i]` consists of only digits.\n  * All `nums[i].length` are **equal**.\n  * `1 <= queries.length <= 100`\n  * `queries[i].length == 2`\n  * `1 <= ki <= nums.length`\n  * `1 <= trimi <= nums[i].length`\n\n\n\n**Follow up:** Could you use the **Radix Sort Algorithm** to solve this\nproblem? What will be the complexity of that solution?\n\n",# Runtime: 1276 ms (Top 58.39%) | Memory: 15.2 MB (Top 22.81%)\nfrom collections import defaultdict\n\nclass Solution:\n    def smallestTrimmedNumbers(self nums: List[str] queries: List[List[int]]) -> List[int]:\n        sl = len(nums[0])\n        len_to_sorted = defaultdict(list)\n        ans = [0] * len(queries)\n\n        for i (k_smallest trim_len) in enumerate(queries):\n            if trim_len not in len_to_sorted:\n                # have to trim\n                for ni num in enumerate(nums):\n                    len_to_sorted[trim_len].append( (int(num[sl - trim_len:]) ni) )\n\n                len_to_sorted[trim_len] = sorted(len_to_sorted[trim_len])\n            ans[i] = len_to_sorted[trim_len][k_smallest -1][1]\n\n        return ans
Queue Reconstruction by Height,###  406\. Queue Reconstruction by Height\n\nYou are given an array of people `people` which are the attributes of some\npeople in a queue (not necessarily in order). Each `people[i] = [hi ki]`\nrepresents the `ith` person of height `hi` with **exactly** `ki` other people\nin front who have a height greater than or equal to `hi`.\n\nReconstruct and return _the queue that is represented by the input\narray_`people`. The returned queue should be formatted as an array `queue`\nwhere `queue[j] = [hj kj]` is the attributes of the `jth` person in the queue\n(`queue[0]` is the person at the front of the queue).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** people = [[70][44][71][50][61][52]]\n    **Output:** [[50][70][52][61][44][71]]\n    **Explanation:**\n    Person 0 has height 5 with no other people taller or the same height in front.\n    Person 1 has height 7 with no other people taller or the same height in front.\n    Person 2 has height 5 with two persons taller or the same height in front which is person 0 and 1.\n    Person 3 has height 6 with one person taller or the same height in front which is person 1.\n    Person 4 has height 4 with four people taller or the same height in front which are people 0 1 2 and 3.\n    Person 5 has height 7 with one person taller or the same height in front which is person 1.\n    Hence [[50][70][52][61][44][71]] is the reconstructed queue.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** people = [[60][50][40][32][22][14]]\n    **Output:** [[40][50][22][32][14][60]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= people.length <= 2000`\n  * `0 <= hi <= 106`\n  * `0 <= ki < people.length`\n  * It is guaranteed that the queue can be reconstructed.\n\n,"class Solution:\n	def reconstructQueue(self people: List[List[int]]) -> List[List[int]]:\n		n = len(people)\n		people.sort()\n		ans = [[]]*n\n		i = 0\n		while people:\n			hp = people.pop(0)\n			count= p\n			for i in range(n):\n				if count== 0 and ans[i] == []:\n					ans[i] = [hp]\n					break\n\n				elif not ans[i] or (ans[i] and ans[i][0] >= h ):\n					count -= 1\n		return ans"
Rabbits in Forest,"###  781\. Rabbits in Forest\n\nThere is a forest with an unknown number of rabbits. We asked n rabbits **""How\nmany rabbits have the same color as you?""** and collected the answers in an\ninteger array `answers` where `answers[i]` is the answer of the `ith` rabbit.\n\nGiven the array `answers` return _the minimum number of rabbits that could be\nin the forest_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** answers = [112]\n    **Output:** 5\n    **Explanation:**\n    The two rabbits that answered ""1"" could both be the same color say red.\n    The rabbit that answered ""2"" can't be red or the answers would be inconsistent.\n    Say the rabbit that answered ""2"" was blue.\n    Then there should be 2 other blue rabbits in the forest that didn't answer into the array.\n    The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** answers = [101010]\n    **Output:** 11\n    \n\n\n\n**Constraints:**\n\n  * `1 <= answers.length <= 1000`\n  * `0 <= answers[i] < 1000`\n\n",# Runtime: 54 ms (Top 35.1%) | Memory: 16.38 MB (Top 76.8%)\n\nclass Solution:\n    def numRabbits(self answers: List[int]) -> int:\n        counts = {}\n        count = 0\n\n        for answer in answers:\n            if answer == 0:\n                # This must be the only rabbit of its color.\n                count += 1\n            elif answer not in counts or counts[answer] == 0:\n                # This is the first time the color appears.\n                counts[answer] = 1\n                # Add all rabbits having this new color.\n                count += answer + 1\n            else:\n                # Add one to how many times answer occurred.\n                counts[answer] += 1\n                if counts[answer] > answer:\n                    # If n+1 rabbits have said n\n                    # this color group is complete.\n                    counts[answer] = 0\n        \n        return count
Race Car,"###  818\. Race Car\n\nYour car starts at position `0` and speed `+1` on an infinite number line.\nYour car can go into negative positions. Your car drives automatically\naccording to a sequence of instructions `'A'` (accelerate) and `'R'`\n(reverse):\n\n  * When you get an instruction `'A'` your car does the following: \n    * `position += speed`\n    * `speed *= 2`\n  * When you get an instruction `'R'` your car does the following: \n    * If your speed is positive then `speed = -1`\n    * otherwise `speed = 1`\nYour position stays the same.\n\nFor example after commands `""AAR""` your car goes to positions `0 --> 1 --> 3\n--> 3` and your speed goes to `1 --> 2 --> 4 --> -1`.\n\nGiven a target position `target` return _the length of the shortest sequence\nof instructions to get there_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = 3\n    **Output:** 2\n    **Explanation:** \n    The shortest instruction sequence is ""AA"".\n    Your position goes from 0 --> 1 --> 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = 6\n    **Output:** 5\n    **Explanation:** \n    The shortest instruction sequence is ""AAARA"".\n    Your position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= target <= 104`\n\n",# Runtime: 95 ms (Top 46.38%) | Memory: 14.3 MB (Top 75.93%)\nclass Solution:\n    def racecar(self target: int) -> int:\n        q = [(0 1)]\n        steps = 0\n\n        while q:\n            num = len(q)\n            for i in range(num):\n                pos speed = q.pop(0)\n                if pos == target:\n                    return steps\n                q.append((pos+speed speed*2))\n                rev_speed = -1 if speed > 0 else 1\n                if (pos+speed) < target and speed < 0 or (pos+speed) > target and speed > 0:\n                    q.append((pos rev_speed))\n            steps += 1
Random Flip Matrix,"###  519\. Random Flip Matrix\n\nThere is an `m x n` binary grid `matrix` with all the values set `0`\ninitially. Design an algorithm to randomly pick an index `(i j)` where\n`matrix[i][j] == 0` and flips it to `1`. All the indices `(i j)` where\n`matrix[i][j] == 0` should be equally likely to be returned.\n\nOptimize your algorithm to minimize the number of calls made to the **built-\nin** random function of your language and optimize the time and space\ncomplexity.\n\nImplement the `Solution` class:\n\n  * `Solution(int m int n)` Initializes the object with the size of the binary matrix `m` and `n`.\n  * `int[] flip()` Returns a random index `[i j]` of the matrix where `matrix[i][j] == 0` and flips it to `1`.\n  * `void reset()` Resets all the values of the matrix to be `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Solution"" ""flip"" ""flip"" ""flip"" ""reset"" ""flip""]\n    [[3 1] [] [] [] [] []]\n    **Output**\n    [null [1 0] [2 0] [0 0] null [2 0]]\n    \n    **Explanation**\n    Solution solution = new Solution(3 1);\n    solution.flip();  // return [1 0] [00] [10] and [20] should be equally likely to be returned.\n    solution.flip();  // return [2 0] Since [10] was returned [20] and [00]\n    solution.flip();  // return [0 0] Based on the previously returned indices only [00] can be returned.\n    solution.reset(); // All the values are reset to 0 and can be returned.\n    solution.flip();  // return [2 0] [00] [10] and [20] should be equally likely to be returned.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m n <= 104`\n  * There will be at least one free cell for each call to `flip`.\n  * At most `1000` calls will be made to `flip` and `reset`.\n\n",from random import randint\n\nclass Solution:\n\n    def __init__(self m: int n: int):\n        self.m = m\n        self.n = n\n        self.ones = set()\n\n    def flip(self) -> List[int]:\n        i j = randint(0 self.m - 1) randint(0 self.n - 1)\n        while (i j) in self.ones:\n            i j = randint(0 self.m - 1) randint(0 self.n - 1)\n        self.ones.add((i j))\n        return [i j]\n\n    def reset(self) -> None:\n        self.ones.clear()\n
Random Pick Index,"###  398\. Random Pick Index\n\nGiven an integer array `nums` with possible **duplicates**  randomly output\nthe index of a given `target` number. You can assume that the given target\nnumber must exist in the array.\n\nImplement the `Solution` class:\n\n  * `Solution(int[] nums)` Initializes the object with the array `nums`.\n  * `int pick(int target)` Picks a random index `i` from `nums` where `nums[i] == target`. If there are multiple valid i's then each index should have an equal probability of returning.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Solution"" ""pick"" ""pick"" ""pick""]\n    [[[1 2 3 3 3]] [3] [1] [3]]\n    **Output**\n    [null 4 0 2]\n    \n    **Explanation**\n    Solution solution = new Solution([1 2 3 3 3]);\n    solution.pick(3); // It should return either index 2 3 or 4 randomly. Each index should have equal probability of returning.\n    solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.\n    solution.pick(3); // It should return either index 2 3 or 4 randomly. Each index should have equal probability of returning.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 104`\n  * `-231 <= nums[i] <= 231 - 1`\n  * `target` is an integer from `nums`.\n  * At most `104` calls will be made to `pick`.\n\n",class Solution:\n\n    def __init__(self nums: List[int]):\n        #self.nums = nums\n        #create a hash of values with their list of indices\n        self.map = defaultdict(list)\n        for iv in enumerate(nums):\n            self.map[v].append(i)\n        \n\n    def pick(self target: int) -> int:\n        return random.sample(self.map[target]1)[0]\n        '''\n        reservoir = 0\n        count = 0\n        for i in range(len(self.nums)):\n            if self.nums[i] == target:\n                count+=1\n                if random.random() < 1/count:\n                    reservoir = i\n        return reservoir\n\n        \n        samp = []\n        for i in range(len(self.nums)):\n            if self.nums[i] == target:\n                samp.append(i)\n        return (random.sample(samp1))[0]\n        '''\n        \n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(nums)\n# param_1 = obj.pick(target)
Random Pick with Blacklist,"###  710\. Random Pick with Blacklist\n\nYou are given an integer `n` and an array of **unique** integers `blacklist`.\nDesign an algorithm to pick a random integer in the range `[0 n - 1]` that is\n**not** in `blacklist`. Any integer that is in the mentioned range and not in\n`blacklist` should be **equally likely** to be returned.\n\nOptimize your algorithm such that it minimizes the number of calls to the\n**built-in** random function of your language.\n\nImplement the `Solution` class:\n\n  * `Solution(int n int[] blacklist)` Initializes the object with the integer `n` and the blacklisted integers `blacklist`.\n  * `int pick()` Returns a random integer in the range `[0 n - 1]` and not in `blacklist`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Solution"" ""pick"" ""pick"" ""pick"" ""pick"" ""pick"" ""pick"" ""pick""]\n    [[7 [2 3 5]] [] [] [] [] [] [] []]\n    **Output**\n    [null 0 4 1 6 1 0 4]\n    \n    **Explanation**\n    Solution solution = new Solution(7 [2 3 5]);\n    solution.pick(); // return 0 any integer from [0146] should be ok. Note that for every call of pick\n                     // 0 1 4 and 6 must be equally likely to be returned (i.e. with probability 1/4).\n    solution.pick(); // return 4\n    solution.pick(); // return 1\n    solution.pick(); // return 6\n    solution.pick(); // return 1\n    solution.pick(); // return 0\n    solution.pick(); // return 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 109`\n  * `0 <= blacklist.length <= min(105 n - 1)`\n  * `0 <= blacklist[i] < n`\n  * All the values of `blacklist` are **unique**.\n  * At most `2 * 104` calls will be made to `pick`.\n\n",# Runtime: 841 ms (Top 10.38%) | Memory: 24.8 MB (Top 56.73%)\nclass Solution:\n\n    def __init__(self n: int blacklist: List[int]):\n        self.hashmap={}\n        for b in blacklist:\n            self.hashmap[b]=-1\n        self.length=n-len(blacklist)\n        flag=n-1\n        for b in blacklist:\n            if b<self.length:\n                while flag in self.hashmap:\n                    flag-=1\n                self.hashmap[b]=flag\n                flag-=1\n\n    def pick(self) -> int:\n        seed=random.randrange(self.length)\n        return self.hashmap.get(seedseed)\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(n blacklist)\n# param_1 = obj.pick()
Random Pick with Weight,"###  528\. Random Pick with Weight\n\nYou are given a **0-indexed** array of positive integers `w` where `w[i]`\ndescribes the **weight** of the `ith` index.\n\nYou need to implement the function `pickIndex()` which **randomly** picks an\nindex in the range `[0 w.length - 1]` (**inclusive**) and returns it. The\n**probability** of picking an index `i` is `w[i] / sum(w)`.\n\n  * For example if `w = [1 3]` the probability of picking index `0` is `1 / (1 + 3) = 0.25` (i.e. `25%`) and the probability of picking index `1` is `3 / (1 + 3) = 0.75` (i.e. `75%`).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Solution""""pickIndex""]\n    [[[1]][]]\n    **Output**\n    [null0]\n    \n    **Explanation**\n    Solution solution = new Solution([1]);\n    solution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n    \n\n**Example 2:**\n\n    \n    \n    **Input**\n    [""Solution""""pickIndex""""pickIndex""""pickIndex""""pickIndex""""pickIndex""]\n    [[[13]][][][][][]]\n    **Output**\n    [null11110]\n    \n    **Explanation**\n    Solution solution = new Solution([1 3]);\n    solution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\n    solution.pickIndex(); // return 1\n    solution.pickIndex(); // return 1\n    solution.pickIndex(); // return 1\n    solution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\n    \n    Since this is a randomization problem multiple answers are allowed.\n    All of the following outputs can be considered correct:\n    [null11110]\n    [null11111]\n    [null11100]\n    [null11101]\n    [null10100]\n    ......\n    and so on.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= w.length <= 104`\n  * `1 <= w[i] <= 105`\n  * `pickIndex` will be called at most `104` times.\n\n","class Solution(object):\n	def __init__(self w):\n		""""""\n		:type w: List[int]\n		""""""\n		#Cumulative sum\n		self.list = [0] * len(w)\n\n		s = 0\n		for i n in enumerate(w):\n			s += n\n			self.list[i] = s\n\n\n	def pickIndex(self):\n		""""""\n		:rtype: int\n		""""""\n		return bisect_left(self.list random.randint(1 self.list[-1]))\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(w)\n# param_1 = obj.pickIndex()\n"
Random Point in Non-overlapping Rectangles,"###  497\. Random Point in Non-overlapping Rectangles\n\nYou are given an array of non-overlapping axis-aligned rectangles `rects`\nwhere `rects[i] = [ai bi xi yi]` indicates that `(ai bi)` is the bottom-\nleft corner point of the `ith` rectangle and `(xi yi)` is the top-right\ncorner point of the `ith` rectangle. Design an algorithm to pick a random\ninteger point inside the space covered by one of the given rectangles. A point\non the perimeter of a rectangle is included in the space covered by the\nrectangle.\n\nAny integer point inside the space covered by one of the given rectangles\nshould be equally likely to be returned.\n\n**Note** that an integer point is a point that has integer coordinates.\n\nImplement the `Solution` class:\n\n  * `Solution(int[][] rects)` Initializes the object with the given rectangles `rects`.\n  * `int[] pick()` Returns a random integer point `[u v]` inside the space covered by one of the given rectangles.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/24/lc-pickrandomrec.jpg)\n\n    \n    \n    **Input**\n    [""Solution"" ""pick"" ""pick"" ""pick"" ""pick"" ""pick""]\n    [[[[-2 -2 1 1] [2 2 4 6]]] [] [] [] [] []]\n    **Output**\n    [null [1 -2] [1 -1] [-1 -2] [-2 -2] [0 0]]\n    \n    **Explanation**\n    Solution solution = new Solution([[-2 -2 1 1] [2 2 4 6]]);\n    solution.pick(); // return [1 -2]\n    solution.pick(); // return [1 -1]\n    solution.pick(); // return [-1 -2]\n    solution.pick(); // return [-2 -2]\n    solution.pick(); // return [0 0]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rects.length <= 100`\n  * `rects[i].length == 4`\n  * `-109 <= ai < xi <= 109`\n  * `-109 <= bi < yi <= 109`\n  * `xi - ai <= 2000`\n  * `yi - bi <= 2000`\n  * All the rectangles do not overlap.\n  * At most `104` calls will be made to `pick`.\n\n","class Solution:\n    """"""\n    1 <= rects.length <= 100\n    rects[i].length == 4\n    -10^9 <= ai < xi <= 10^9\n    -10^9 <= bi < yi <= 10^9\n    xi - ai <= 2000\n    yi - bi <= 2000\n    All the rectangles do not overlap.\n    At most 10^4 calls will be made to pick.\n    """"""\n\n    def __init__(self rects: List[List[int]]):\n        self.rects = rects\n        self.n_range = list(range(len(self.rects)))\n        self.weights = [(x[2] - x[0] + 1) * (x[3] - x[1] + 1) for x in rects]\n\n    def pick(self) -> List[int]:\n        rect = self.rects[choices(self.n_range self.weights k=1)[0]]\n        return [randint(rect[0] rect[2]) randint(rect[1] rect[3])]\n\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(rects)\n# param_1 = obj.pick()\n"
Range Frequency Queries,"###  2080\. Range Frequency Queries\n\nDesign a data structure to find the **frequency** of a given value in a given\nsubarray.\n\nThe **frequency** of a value in a subarray is the number of occurrences of\nthat value in the subarray.\n\nImplement the `RangeFreqQuery` class:\n\n  * `RangeFreqQuery(int[] arr)` Constructs an instance of the class with the given **0-indexed** integer array `arr`.\n  * `int query(int left int right int value)` Returns the **frequency** of `value` in the subarray `arr[left...right]`.\n\nA **subarray** is a contiguous sequence of elements within an array.\n`arr[left...right]` denotes the subarray that contains the elements of `nums`\nbetween indices `left` and `right` (**inclusive**).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""RangeFreqQuery"" ""query"" ""query""]\n    [[[12 33 4 56 22 2 34 33 22 12 34 56]] [1 2 4] [0 11 33]]\n    **Output**\n    [null 1 2]\n    \n    **Explanation**\n    RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12 33 4 56 22 2 34 33 22 12 34 56]);\n    rangeFreqQuery.query(1 2 4); // return 1. The value 4 occurs 1 time in the subarray [33 4]\n    rangeFreqQuery.query(0 11 33); // return 2. The value 33 occurs 2 times in the whole array.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 105`\n  * `1 <= arr[i] value <= 104`\n  * `0 <= left <= right < arr.length`\n  * At most `105` calls will be made to `query`\n\n",# Runtime: 3295 ms (Top 30.98%) | Memory: 53.7 MB (Top 24.88%)\nclass RangeFreqQuery:\n    def __init__(self arr: List[int]):\n        self.l = [[] for _ in range(10001)]\n        for i v in enumerate(arr):\n            self.l[v].append(i)\n    def query(self left: int right: int v: int) -> int:\n        return bisect_right(self.l[v] right) - bisect_left(self.l[v] left)
Range Module,"###  715\. Range Module\n\nA Range Module is a module that tracks ranges of numbers. Design a data\nstructure to track the ranges represented as **half-open intervals** and query\nabout them.\n\nA **half-open interval** `[left right)` denotes all the real numbers `x`\nwhere `left <= x < right`.\n\nImplement the `RangeModule` class:\n\n  * `RangeModule()` Initializes the object of the data structure.\n  * `void addRange(int left int right)` Adds the **half-open interval** `[left right)` tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval `[left right)` that are not already tracked.\n  * `boolean queryRange(int left int right)` Returns `true` if every real number in the interval `[left right)` is currently being tracked and `false` otherwise.\n  * `void removeRange(int left int right)` Stops tracking every real number currently being tracked in the **half-open interval** `[left right)`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""RangeModule"" ""addRange"" ""removeRange"" ""queryRange"" ""queryRange"" ""queryRange""]\n    [[] [10 20] [14 16] [10 14] [13 15] [16 17]]\n    **Output**\n    [null null null true false true]\n    \n    **Explanation**\n    RangeModule rangeModule = new RangeModule();\n    rangeModule.addRange(10 20);\n    rangeModule.removeRange(14 16);\n    rangeModule.queryRange(10 14); // return True(Every number in [10 14) is being tracked)\n    rangeModule.queryRange(13 15); // return False(Numbers like 14 14.03 14.17 in [13 15) are not being tracked)\n    rangeModule.queryRange(16 17); // return True (The number 16 in [16 17) is still being tracked despite the remove operation)\n    \n\n\n\n**Constraints:**\n\n  * `1 <= left < right <= 109`\n  * At most `104` calls will be made to `addRange` `queryRange` and `removeRange`.\n\n",from bisect import bisect_left as bl bisect_right as br\nclass RangeModule:\n\n    def __init__(self):\n        self._X = []\n\n    def addRange(self left: int right: int) -> None:\n        # Main Logic \n        #   If idx(left) or idx(right) is odd it's in a interval. So don't add it. \n        #   If idx(left) or idx(right) is even it's not in any interval. So add it as new interval \n        #   Slice array[idx(left) : idx(right)]\n        #       1) both odd: Nothing is added. Merge all middle intervals. \n        #       2) both even: Add new intervals. Merge all middle intervals\n        #       3) idx(left) is even: update start point of next interval with left\n        #       4) idx(right) is even: update end point of previous interval with right\n        # Bisect_left vs. Bisect_right\n        #   left need to proceed all interval closing at left so use Bisect_left\n        #   right need to go after all interval openning at right so use Bisect_right\n        i j = bl(self._X left) br(self._X right)\n        self._X[i : j] = [left] * (i % 2 == 0) + [right] * (j % 2 == 0)\n        \n\n    def queryRange(self left: int right: int) -> bool:\n        # Main logic \n        #   If idx of left/right is odd it's in a interval. Else it's not. \n        #   If idx of left&right is the same they're in the same interval\n        # Bisect_left vs. Bisect_right\n        #   [start end). Start is included. End is not. \n        #   so use bisect_right for left \n        #   so use bisect_left for right \n        i j = br(self._X left) bl(self._X right)\n        return i == j and i % 2 == 1\n        \n\n    def removeRange(self left: int right: int) -> None:\n        # Main Logic \n        #   If idx(left) is odd the interval that contains left need to change end point to left \n        #   If idx(right) is odd the interval that contains right need to change start point to right\n        #   Else everything from idx(left) to idx(right) is removed. Nothing is changed. \n        # Bisect_left vs. Bisect_right\n        #   Same as addRange\n        i j = bl(self._X left) br(self._X right)\n        self._X[i : j] = [left] * (i % 2 == 1) + [right] * (j % 2 == 1)\n\n
Range Sum of Sorted Subarray Sums,###  1508\. Range Sum of Sorted Subarray Sums\n\nYou are given the array `nums` consisting of `n` positive integers. You\ncomputed the sum of all non-empty continuous subarrays from the array and then\nsorted them in non-decreasing order creating a new array of `n * (n + 1) / 2`\nnumbers.\n\n_Return the sum of the numbers from index_`left` _to index_`right` (**indexed\nfrom 1**)_ inclusive in the new array._ Since the answer can be a huge\nnumber return it modulo `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234] n = 4 left = 1 right = 5\n    **Output:** 13 \n    **Explanation:** All subarray sums are 1 3 6 10 2 5 9 3 7 4. After sorting them in non-decreasing order we have the new array [1 2 3 3 4 5 6 7 9 10]. The sum of the numbers from index le = 1 to ri = 5 is 1 + 2 + 3 + 3 + 4 = 13. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234] n = 4 left = 3 right = 4\n    **Output:** 6\n    **Explanation:** The given array is the same as example 1. We have the new array [1 2 3 3 4 5 6 7 9 10]. The sum of the numbers from index le = 3 to ri = 4 is 3 + 3 = 6.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1234] n = 4 left = 1 right = 10\n    **Output:** 50\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 100`\n  * `1 <= left <= right <= n * (n + 1) / 2`\n\n,# Runtime: 276 ms (Top 95.45%) | Memory: 37.2 MB (Top 59.09%)\nfrom itertools import accumulate\n\nclass Solution:\n    def rangeSum(self nums n left right):\n        acc = []\n\n        for i in range(n):\n            acc.extend(accumulate(nums[i:]))\n\n        acc.sort()\n\n        return sum(acc[left - 1:right]) % (10**9 + 7)
Range Sum Query - Mutable,"###  307\. Range Sum Query - Mutable\n\nGiven an integer array `nums` handle multiple queries of the following types:\n\n  1. **Update** the value of an element in `nums`.\n  2. Calculate the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** where `left <= right`.\n\nImplement the `NumArray` class:\n\n  * `NumArray(int[] nums)` Initializes the object with the integer array `nums`.\n  * `void update(int index int val)` **Updates** the value of `nums[index]` to be `val`.\n  * `int sumRange(int left int right)` Returns the **sum** of the elements of `nums` between indices `left` and `right` **inclusive** (i.e. `nums[left] + nums[left + 1] + ... + nums[right]`).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""NumArray"" ""sumRange"" ""update"" ""sumRange""]\n    [[[1 3 5]] [0 2] [1 2] [0 2]]\n    **Output**\n    [null 9 null 8]\n    \n    **Explanation**\n    NumArray numArray = new NumArray([1 3 5]);\n    numArray.sumRange(0 2); // return 1 + 3 + 5 = 9\n    numArray.update(1 2);   // nums = [1 2 5]\n    numArray.sumRange(0 2); // return 1 + 2 + 5 = 8\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 3 * 104`\n  * `-100 <= nums[i] <= 100`\n  * `0 <= index < nums.length`\n  * `-100 <= val <= 100`\n  * `0 <= left <= right < nums.length`\n  * At most `3 * 104` calls will be made to `update` and `sumRange`.\n\n",class NumArray:\n    nums = []\n    s = 0\n    l = 0\n    \n    def __init__(self nums: List[int]):\n        self.nums = nums\n        self.s = sum(nums)\n        self.l = len(nums)\n\n    def update(self index: int val: int) -> None:\n        self.s -= self.nums[index]\n        self.nums[index] = val\n        self.s += self.nums[index]\n\n    def sumRange(self left: int right: int) -> int:\n        if right - left > self.l // 2:\n            ans = sum(self.nums[:left]) + sum(self.nums[right + 1:])\n            return self.s - ans\n        else:\n            return sum(self.nums[left: right + 1])\n
Rank Teams by Votes,"###  1366\. Rank Teams by Votes\n\nIn a special ranking system each voter gives a rank from highest to lowest to\nall teams participated in the competition.\n\nThe ordering of teams is decided by who received the most position-one votes.\nIf two or more teams tie in the first position we consider the second\nposition to resolve the conflict if they tie again we continue this process\nuntil the ties are resolved. If two or more teams are still tied after\nconsidering all positions we rank them alphabetically based on their team\nletter.\n\nGiven an array of strings `votes` which is the votes of all voters in the\nranking systems. Sort all teams according to the ranking system described\nabove.\n\nReturn _a string of all teams_ **sorted** by the ranking system.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** votes = [""ABC""""ACB""""ABC""""ACB""""ACB""]\n    **Output:** ""ACB""\n    **Explanation:** Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team.\n    Team B was ranked second by 2 voters and was ranked third by 3 voters.\n    Team C was ranked second by 3 voters and was ranked third by 2 voters.\n    As most of the voters ranked C second team C is the second team and team B is the third.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** votes = [""WXYZ""""XYZW""]\n    **Output:** ""XWYZ""\n    **Explanation:** X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn't have any votes as second position. \n    \n\n**Example 3:**\n\n    \n    \n    **Input:** votes = [""ZMNAGUEDSJYLBOPHRQICWFXTVK""]\n    **Output:** ""ZMNAGUEDSJYLBOPHRQICWFXTVK""\n    **Explanation:** Only one voter so his votes are used for the ranking.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= votes.length <= 1000`\n  * `1 <= votes[i].length <= 26`\n  * `votes[i].length == votes[j].length` for `0 <= i j < votes.length`.\n  * `votes[i][j]` is an English **uppercase** letter.\n  * All characters of `votes[i]` are unique.\n  * All the characters that occur in `votes[0]` **also occur** in `votes[j]` where `1 <= j < votes.length`.\n\n","#[""ABC""""ACB""""ABC""""ACB""""ACB""]\n#d = {\n#    ""A"": [5 0 0]\n#    ""B"": [0 2 3]\n#    ""C"": [0 3 2]\n#}\n#keys represent the candidates\n#index of array in dict represent the rank\n#value of array item represent number of votes casted\n#ref: https://www.programiz.com/python-programming/methods/built-in/sorted\nclass Solution:\n    #T=O(mn + mlgm) S=O(mn)\n	#n=number of votes\n	#m=number of candidates and m(number of ranks) is constant(26)\n    def rankTeams(self votes: List[str]) -> str:\n        d = {}\n        #build the dict\n        #T=O(mn) S=O(mn)\n		#n=number of votes m=number of candidates(26)\n        for vote in votes:\n            for i c in enumerate(vote):\n                #if key not in dict\n                if c not in d:\n                    #d[char] = [0 0 0]\n                    d[c] = [0]*len(vote)\n                #increment the count of votes for each rank\n                #d[""A""][0] = 1\n                d[c][i] += 1\n        #sort the dict keys in ascending order because if there is a tie we return in ascending order\n		#sorted uses a stable sorting algorithm\n        #T=O(mlgm) S=O(m)\n        vote_names = sorted(d.keys()) #d.keys()=[""A"" ""B"" ""C""]\n        #sort the dict keys based on votes for each rank in descending order\n        #T=O(mlgm) S=O(m)\n        #sorted() always returns a list\n        vote_rank = sorted(vote_names reverse=True key= lambda x: d[x])\n        #join the list\n        return """".join(vote_rank)\n"
Rank Transform of a Matrix,###  1632\. Rank Transform of a Matrix\n\nGiven an `m x n` `matrix` return _a new matrix_`answer`\n_where_`answer[row][col]`_is the_ _**rank** of _`matrix[row][col]`.\n\nThe **rank** is an **integer** that represents how large an element is\ncompared to other elements. It is calculated using the following rules:\n\n  * The rank is an integer starting from `1`.\n  * If two elements `p` and `q` are in the **same row or column**  then: \n    * If `p < q` then `rank(p) < rank(q)`\n    * If `p == q` then `rank(p) == rank(q)`\n    * If `p > q` then `rank(p) > rank(q)`\n  * The **rank** should be as **small** as possible.\n\nThe test cases are generated so that `answer` is unique under the given rules.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/18/rank1.jpg)\n\n    \n    \n    **Input:** matrix = [[12][34]]\n    **Output:** [[12][23]]\n    **Explanation:**\n    The rank of matrix[0][0] is 1 because it is the smallest integer in its row and column.\n    The rank of matrix[0][1] is 2 because matrix[0][1] > matrix[0][0] and matrix[0][0] is rank 1.\n    The rank of matrix[1][0] is 2 because matrix[1][0] > matrix[0][0] and matrix[0][0] is rank 1.\n    The rank of matrix[1][1] is 3 because matrix[1][1] > matrix[0][1] matrix[1][1] > matrix[1][0] and both matrix[0][1] and matrix[1][0] are rank 2.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/18/rank2.jpg)\n\n    \n    \n    **Input:** matrix = [[77][77]]\n    **Output:** [[11][11]]\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/10/18/rank3.jpg)\n\n    \n    \n    **Input:** matrix = [[20-2114][-19419][22-4724][-19419]]\n    **Output:** [[423][134][516][134]]\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m n <= 500`\n  * `-109 <= matrix[row][col] <= 109`\n\n,# Runtime: 3042 ms (Top 71.65%) | Memory: 50.4 MB (Top 92.27%)\nclass Solution:\n    def matrixRankTransform(self matrix: List[List[int]]) -> List[List[int]]:\n        m n = len(matrix) len(matrix[0])\n        rank = [0]*(m + n)\n        d = defaultdict(list)\n        for i in range(m):\n            for j in range(n):\n                d[matrix[i][j]].append((ij))\n        def find(i):\n            if p[i] != i:\n                p[i] = find(p[i])\n            return p[i]\n        def union(ij):\n            pi pj = find(i) find(j)\n            p[pi] = pj\n            newrank[pj] = max(newrank[pi] newrank[pj])\n        for e in sorted(d):\n            p = list(range(m+n))\n            newrank = rank[:]\n            for i j in d[e]:\n                union(im+j)\n            for i j in d[e]:\n                rank[i] = rank[m+j] = matrix[i][j] = newrank[find(i)] + 1\n        return matrix
Rank Transform of an Array,###  1331\. Rank Transform of an Array\n\nGiven an array of integers `arr` replace each element with its rank.\n\nThe rank represents how large the element is. The rank has the following\nrules:\n\n  * Rank is an integer starting from 1.\n  * The larger the element the larger the rank. If two elements are equal their rank must be the same.\n  * Rank should be as small as possible.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [40102030]\n    **Output:** [4123]\n    **Explanation** : 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.\n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [100100100]\n    **Output:** [111]\n    **Explanation** : Same elements share the same rank.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [37122891005680512]\n    **Output:** [534286713]\n    \n\n\n\n**Constraints:**\n\n  * `0 <= arr.length <= 105`\n  * `-109 <= arr[i] <= 109`\n\n,# Runtime: 325 ms (Top 99.70%) | Memory: 33.7 MB (Top 29.42%)\nclass Solution:\n    def arrayRankTransform(self arr: List[int]) -> List[int]:\n        arr_set = list(sorted(set(arr)))\n        rank = {}\n        for i e in enumerate(arr_set):\n            rank[e] = i+1\n        return [ rank[e] for e in arr]
Ransom Note,"###  383\. Ransom Note\n\nGiven two strings `ransomNote` and `magazine` return `true` _if_`ransomNote`\n_can be constructed by using the letters from_`magazine` _and_`false`\n_otherwise_.\n\nEach letter in `magazine` can only be used once in `ransomNote`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** ransomNote = ""a"" magazine = ""b""\n    **Output:** false\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** ransomNote = ""aa"" magazine = ""ab""\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** ransomNote = ""aa"" magazine = ""aab""\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= ransomNote.length magazine.length <= 105`\n  * `ransomNote` and `magazine` consist of lowercase English letters.\n\n",from collections import Counter\nclass Solution:\n    def canConstruct(self ransomNote: str magazine: str) -> bool:\n         \n        ransomNote_count = dict(Counter(ransomNote))\n        magazine_count = dict(Counter(magazine))\n        \n        for key  value in ransomNote_count.items():\n            \n            if key in magazine_count:\n                if value <= magazine_count[key]:\n                    continue\n            else:\n                return False\n            \n            return False\n        \n        return True\n
Reach a Number,###  754\. Reach a Number\n\nYou are standing at position `0` on an infinite number line. There is a\ndestination at position `target`.\n\nYou can make some number of moves `numMoves` so that:\n\n  * On each move you can either go left or right.\n  * During the `ith` move (starting from `i == 1` to `i == numMoves`) you take `i` steps in the chosen direction.\n\nGiven the integer `target` return _the**minimum** number of moves required\n(i.e. the minimum _`numMoves` _) to reach the destination_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** target = 2\n    **Output:** 3\n    **Explanation:**\n    On the 1st move we step from 0 to 1 (1 step).\n    On the 2nd move we step from 1 to -1 (2 steps).\n    On the 3rd move we step from -1 to 2 (3 steps).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** target = 3\n    **Output:** 2\n    **Explanation:**\n    On the 1st move we step from 0 to 1 (1 step).\n    On the 2nd move we step from 1 to 3 (2 steps).\n    \n\n\n\n**Constraints:**\n\n  * `-109 <= target <= 109`\n  * `target != 0`\n\n,class Solution: \n  def  reachNumber(selftarget):\n    jumpCount = 1 \n    sum = 0 \n    while sum<abs(target):\n      sum+=jump \n      jumpCount+=1 \n    \n    if (sum-target)%2==0: return jumpCount-1 \n    else:\n      \n      if ((sum+jumpCount)-target)%2==0: \n        return jumpCount\n      else:\n        return jumpCount+1 \n
Reachable Nodes In Subdivided Graph,"###  882\. Reachable Nodes In Subdivided Graph\n\nYou are given an undirected graph (the **""original graph""**) with `n` nodes\nlabeled from `0` to `n - 1`. You decide to **subdivide** each edge in the\ngraph into a chain of nodes with the number of new nodes varying between each\nedge.\n\nThe graph is given as a 2D array of `edges` where `edges[i] = [ui vi cnti]`\nindicates that there is an edge between nodes `ui` and `vi` in the original\ngraph and `cnti` is the total number of new nodes that you will **subdivide**\nthe edge into. Note that `cnti == 0` means you will not subdivide the edge.\n\nTo **subdivide** the edge `[ui vi]` replace it with `(cnti + 1)` new edges\nand `cnti` new nodes. The new nodes are `x1` `x2` ... `xcnti` and the new\nedges are `[ui x1]` `[x1 x2]` `[x2 x3]` ... `[xcnti-1 xcnti]`\n`[xcnti vi]`.\n\nIn this **new graph**  you want to know how many nodes are **reachable** from\nthe node `0` where a node is **reachable** if the distance is `maxMoves` or\nless.\n\nGiven the original graph and `maxMoves` return _the number of nodes that\nare**reachable** from node _`0` _in the new graph_.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png)\n\n    \n    \n    **Input:** edges = [[0110][021][122]] maxMoves = 6 n = 3\n    **Output:** 13\n    **Explanation:** The edge subdivisions are shown in the image above.\n    The nodes that are reachable are highlighted in yellow.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** edges = [[014][126][028][131]] maxMoves = 10 n = 4\n    **Output:** 23\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** edges = [[124][145][131][234][345]] maxMoves = 17 n = 5\n    **Output:** 1\n    **Explanation:** Node 0 is disconnected from the rest of the graph so only node 0 is reachable.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= edges.length <= min(n * (n - 1) / 2 104)`\n  * `edges[i].length == 3`\n  * `0 <= ui < vi < n`\n  * There are **no multiple edges** in the graph.\n  * `0 <= cnti <= 104`\n  * `0 <= maxMoves <= 109`\n  * `1 <= n <= 3000`\n\n",# Runtime: 1218 ms (Top 16.46%) | Memory: 23.7 MB (Top 8.86%)\nclass Solution:\n    def reachableNodes(self edges: List[List[int]] maxMoves: int n: int) -> int:\n        m = defaultdict(list)\n        for a b p in edges:\n            m[a].append((p b))\n            m[b].append((p a))\n\n        vis = set()\n        queue = []\n        heappush(queue (0 0))\n        edgevis = set()\n        edgeofl = defaultdict(lambda: 0)\n        ans = 0\n        while queue:\n            # print(queue)\n            cost cur = heappop(queue)\n            vis.add(cur)\n            for p nxt in m[cur]:\n                if p < maxMoves - cost:\n                    if (cur nxt) not in edgevis and (nxt cur) not in edgevis:\n                        ans += p\n                        # if nxt in vis:\n                        # ans -= 1\n                        edgevis.add((cur nxt))\n                        edgevis.add((nxt cur))\n                        if nxt not in vis:\n                            heappush(queue (cost + p + 1 nxt))\n                else:\n                    bal = maxMoves - cost\n                    if (cur nxt) in edgevis:\n                        continue\n                    if bal <= edgeofl[(cur nxt)]:\n                        continue\n                    if bal + edgeofl[(nxt cur)] < p:\n                        ans += bal - edgeofl[(cur nxt)]\n                        edgeofl[(cur nxt)] = bal\n                    else:\n                        ans += p - edgeofl[(nxt cur)] - edgeofl[(cur nxt)]\n                        edgevis.add((cur nxt))\n                        edgevis.add((nxt cur))\n        return ans + len(vis)
Reachable Nodes With Restrictions,###  2368\. Reachable Nodes With Restrictions\n\nThere is an undirected tree with `n` nodes labeled from `0` to `n - 1` and `n\n- 1` edges.\n\nYou are given a 2D integer array `edges` of length `n - 1` where `edges[i] =\n[ai bi]` indicates that there is an edge between nodes `ai` and `bi` in the\ntree. You are also given an integer array `restricted` which represents\n**restricted** nodes.\n\nReturn _the**maximum** number of nodes you can reach from node _`0` _without\nvisiting a restricted node._\n\nNote that node `0` will **not** be a restricted node.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/06/15/ex1drawio.png)\n\n    \n    \n    **Input:** n = 7 edges = [[01][12][31][40][05][56]] restricted = [45]\n    **Output:** 4\n    **Explanation:** The diagram above shows the tree.\n    We have that [0123] are the only nodes that can be reached from node 0 without visiting a restricted node.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/06/15/ex2drawio.png)\n\n    \n    \n    **Input:** n = 7 edges = [[01][02][05][04][32][65]] restricted = [421]\n    **Output:** 3\n    **Explanation:** The diagram above shows the tree.\n    We have that [056] are the only nodes that can be reached from node 0 without visiting a restricted node.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 105`\n  * `edges.length == n - 1`\n  * `edges[i].length == 2`\n  * `0 <= ai bi < n`\n  * `ai != bi`\n  * `edges` represents a valid tree.\n  * `1 <= restricted.length < n`\n  * `1 <= restricted[i] < n`\n  * All the values of `restricted` are **unique**.\n\n,class Solution:\n    def reachableNodes(self n: int edges: List[List[int]] restricted: List[int]) -> int:\n        # ignore restricted node\n        # bfs from 0\n        \n        # O(E) EDITED: the time complexity here is wrong plz see my comment\n        adj_dict = collections.defaultdict(list)\n        for u v in edges:\n            if u in restricted or v in restricted:  # EDITED: not O(1)\n                continue\n            adj_dict[u].append(v)\n            adj_dict[v].append(u)\n        \n        # O(V + E)\n        queue = collections.deque([0])\n        visited = {0}\n        while queue:\n            cur = queue.popleft()\n            for neighbor in adj_dict[cur]:\n                if neighbor in visited:\n                    continue\n                visited.add(neighbor)\n                queue.append(neighbor)\n\n        return len(visited)\n
Reaching Points,###  780\. Reaching Points\n\nGiven four integers `sx` `sy` `tx` and `ty` return `true` _if it is\npossible to convert the point_`(sx sy)`_to the point_`(tx ty)` _through some\noperations_ _ or_`false` _otherwise_.\n\nThe allowed operation on some point `(x y)` is to convert it to either `(x x\n+ y)` or `(x + y y)`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** sx = 1 sy = 1 tx = 3 ty = 5\n    **Output:** true\n    **Explanation:**\n    One series of moves that transforms the starting point to the target is:\n    (1 1) -> (1 2)\n    (1 2) -> (3 2)\n    (3 2) -> (3 5)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** sx = 1 sy = 1 tx = 2 ty = 2\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** sx = 1 sy = 1 tx = 1 ty = 1\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= sx sy tx ty <= 109`\n\n,from collections import defaultdict\n\nclass Solution:\n    def reachingPoints(self sx: int sy: int tx: int ty: int) -> bool:\n        def nextNum(tatbs):\n            if ta % tb == s % tb:\n                return min(ta s)\n            return ta % tb\n        visited = defaultdict(bool)\n        while tx >= sx and ty >= sy and (sx != tx or sy != ty):\n            if tx > ty:\n                tx ty = nextNum(tx ty sx) ty\n            else:\n                tx ty = tx nextNum(ty tx sy)\n            if visited[(txty)]:\n                break\n            visited[(txty)] = True\n        return (sx == tx) and (sy == ty)\n
Rearrange Array Elements by Sign,###  2149\. Rearrange Array Elements by Sign\n\nYou are given a **0-indexed** integer array `nums` of **even** length\nconsisting of an **equal** number of positive and negative integers.\n\nYou should **rearrange** the elements of `nums` such that the modified array\nfollows the given conditions:\n\n  1. Every **consecutive pair** of integers have **opposite signs**.\n  2. For all integers with the same sign the **order** in which they were present in `nums` is **preserved**.\n  3. The rearranged array begins with a positive integer.\n\nReturn _the modified array after rearranging the elements to satisfy the\naforementioned conditions_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [31-2-52-4]\n    **Output:** [3-21-52-4]\n    **Explanation:**\n    The positive integers in nums are [312]. The negative integers are [-2-5-4].\n    The only possible way to rearrange them such that they satisfy all conditions is [3-21-52-4].\n    Other ways such as [1-22-53-4] [312-2-5-4] [-23-51-42] are incorrect because they do not satisfy one or more conditions.  \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-11]\n    **Output:** [1-1]\n    **Explanation:**\n    1 is the only positive integer and -1 the only negative integer in nums.\n    So nums is rearranged to [1-1].\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 2 * 105`\n  * `nums.length` is **even**\n  * `1 <= |nums[i]| <= 105`\n  * `nums` consists of **equal** number of positive and negative integers.\n\n,class Solution:\n    def rearrangeArray(self nums: List[int]) -> List[int]:\n        return [i for t in zip([p for p in nums if p > 0] [n for n in nums if n < 0]) for i in t]\n
Rearrange Characters to Make Target String,"###  2287\. Rearrange Characters to Make Target String\n\nYou are given two **0-indexed** strings `s` and `target`. You can take some\nletters from `s` and rearrange them to form new strings.\n\nReturn _the**maximum** number of copies of _`target` _that can be formed by\ntaking letters from_`s` _and rearranging them._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ilovecodingonleetcode"" target = ""code""\n    **Output:** 2\n    **Explanation:**\n    For the first copy of ""code"" take the letters at indices 4 5 6 and 7.\n    For the second copy of ""code"" take the letters at indices 17 18 19 and 20.\n    The strings that are formed are ""ecod"" and ""code"" which can both be rearranged into ""code"".\n    We can make at most two copies of ""code"" so we return 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcba"" target = ""abc""\n    **Output:** 1\n    **Explanation:**\n    We can make one copy of ""abc"" by taking the letters at indices 0 1 and 2.\n    We can make at most one copy of ""abc"" so we return 1.\n    Note that while there is an extra 'a' and 'b' at indices 3 and 4 we cannot reuse the letter 'c' at index 2 so we cannot make a second copy of ""abc"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""abbaccaddaeea"" target = ""aaaaa""\n    **Output:** 1\n    **Explanation:**\n    We can make one copy of ""aaaaa"" by taking the letters at indices 0 3 6 9 and 12.\n    We can make at most one copy of ""aaaaa"" so we return 1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `1 <= target.length <= 10`\n  * `s` and `target` consist of lowercase English letters.\n\n",# Runtime: 55 ms (Top 32.02%) | Memory: 13.9 MB (Top 67.72%)\nclass Solution:\n    def rearrangeCharacters(self s: str target: str) -> int:\n        counter_s = Counter(s)\n        return min(counter_s[c] // count for ccount in Counter(target).items())
Rearrange Spaces Between Words,"###  1592\. Rearrange Spaces Between Words\n\nYou are given a string `text` of words that are placed among some number of\nspaces. Each word consists of one or more lowercase English letters and are\nseparated by at least one space. It's guaranteed that `text` **contains at\nleast one word**.\n\nRearrange the spaces so that there is an **equal** number of spaces between\nevery pair of adjacent words and that number is **maximized**. If you cannot\nredistribute all the spaces equally place the **extra spaces at the end** \nmeaning the returned string should be the same length as `text`.\n\nReturn _the string after rearranging the spaces_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text = ""  this   is  a sentence ""\n    **Output:** ""this   is   a   sentence""\n    **Explanation:** There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text = "" practice   makes   perfect""\n    **Output:** ""practice   makes   perfect ""\n    **Explanation:** There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length <= 100`\n  * `text` consists of lowercase English letters and `' '`.\n  * `text` contains at least one word.\n\n","class Solution(object):\n    def reorderSpaces(self text):\n        word_list = text.split()\n        words spaces = len(word_list) text.count("" "")\n        \n        if words > 1:\n            q r = spaces//(words-1) spaces%(words-1)\n            return ("" "" * q).join(word_list) + "" "" * r\n        else:\n            return """".join(word_list) + "" "" * spaces\n"
Rearrange Words in a Sentence,"###  1451\. Rearrange Words in a Sentence\n\nGiven a sentence `text` (A _sentence_  is a string of space-separated words)\nin the following format:\n\n  * First letter is in upper case.\n  * Each word in `text` are separated by a single space.\n\nYour task is to rearrange the words in text such that all words are rearranged\nin an increasing order of their lengths. If two words have the same length\narrange them in their original order.\n\nReturn the new text following the format shown above.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text = ""Leetcode is cool""\n    **Output:** ""Is cool leetcode""\n    **Explanation:** There are 3 words ""Leetcode"" of length 8 ""is"" of length 2 and ""cool"" of length 4.\n    Output is ordered by length and the new first word starts with capital letter.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text = ""Keep calm and code on""\n    **Output:** ""On and keep calm code""\n    **Explanation:** Output is ordered as follows:\n    ""On"" 2 letters.\n    ""and"" 3 letters.\n    ""keep"" 4 letters in case of tie order by position in original text.\n    ""calm"" 4 letters.\n    ""code"" 4 letters.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** text = ""To be or not to be""\n    **Output:** ""To be or to be not""\n    \n\n\n\n**Constraints:**\n\n  * `text` begins with a capital letter and then contains lowercase letters and single space between words.\n  * `1 <= text.length <= 10^5`\n\n","// Runtime: 40 ms (Top 89.61%) | Memory: 19.60 MB (Top 55.06%)\n\nclass Solution:\n    def arrangeWords(self text: str) -> str:\n        a = []\n        for x in text.split("" ""):\n            a.append(x.lower())\n        return "" "".join(sorted(a key=len)).capitalize()\n"
Reconstruct Original Digits from English,"###  423\. Reconstruct Original Digits from English\n\nGiven a string `s` containing an out-of-order English representation of digits\n`0-9` return _the digits in**ascending** order_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""owoztneoer""\n    **Output:** ""012""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""fviefuro""\n    **Output:** ""45""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is one of the characters `[""e""""g""""f""""i""""h""""o""""n""""s""""r""""u""""t""""w""""v""""x""""z""]`.\n  * `s` is **guaranteed** to be valid.\n\n","class Solution:\n    def originalDigits(self s: str) -> str:\n        c = dict()\n        \n        c[0] = s.count(""z"")\n        c[2] = s.count(""w"")\n        c[4] = s.count(""u"")\n        c[6] = s.count(""x"")\n        c[8] = s.count(""g"")\n        \n        c[3] = s.count(""h"") - c[8]\n        c[5] = s.count(""f"") - c[4]\n        c[7] = s.count(""s"") - c[6]\n        \n        c[9] = s.count(""i"") - (c[8] + c[5] + c[6])\n        c[1] = s.count(""o"") - (c[0] + c[2] + c[4])\n        \n        c = sorted(c.items() key = lambda x: x[0])\n        ans = """"\n        for k v in c:\n            ans += (str(k) * v)\n        return ans"
Recover a Tree From Preorder Traversal,"###  1028\. Recover a Tree From Preorder Traversal\n\nWe run a preorder depth-first search (DFS) on the `root` of a binary tree.\n\nAt each node in this traversal we output `D` dashes (where `D` is the depth\nof this node) then we output the value of this node.  If the depth of a node\nis `D` the depth of its immediate child is `D + 1`.  The depth of the `root`\nnode is `0`.\n\nIf a node has only one child that child is guaranteed to be **the left\nchild**.\n\nGiven the output `traversal` of this traversal recover the tree and return\n_its_ `root`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/04/08/recover-a-tree-from-\npreorder-traversal.png)\n\n    \n    \n    **Input:** traversal = ""1-2--3--4-5--6--7""\n    **Output:** [1253467]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/04/11/screen-\nshot-2019-04-10-at-114101-pm.png)\n\n    \n    \n    **Input:** traversal = ""1-2--3---4-5--6---7""\n    **Output:** [1253null6null4null7]\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/04/11/screen-\nshot-2019-04-10-at-114955-pm.png)\n\n    \n    \n    **Input:** traversal = ""1-401--349---90--88""\n    **Output:** [1401null3498890]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the original tree is in the range `[1 1000]`.\n  * `1 <= Node.val <= 109`\n\n","// Runtime: 138 ms (Top 42.81%) | Memory: 14.7 MB (Top 52.51%)\nclass Solution:\n    def recoverFromPreorder(self traversal: str) -> Optional[TreeNode]:\n        i = 0\n        dummy_head = TreeNode()\n        depth = 0\n        while i < len(traversal):\n            if traversal[i].isdigit():\n                value i = get_value(traversal i)\n                insert_node(dummy_head depth value)\n\n            else:\n                depth i = get_depth(traversal i)\n\n        return dummy_head.left\n\n# Returns the next value from the string traversal and returns the position following the last digit of the current value.\ndef get_value(traversal i):\n    value = 0\n    while i < len(traversal) and traversal[i].isdigit():\n        value *= 10\n        value += int(traversal[i])\n        i += 1\n\n    return value i\n\n# Insertes a node of the given `value` at the given `depth` of the subtree whose root is the given `root`.\ndef insert_node(root depth value):\n    for _ in range(depth):\n        if root.right:\n            root = root.right\n        else:\n            root = root.left\n\n    new_node = TreeNode(value)\n    if root.left:\n        root.right = new_node\n    else:\n        root.left = new_node\n\n# Gets the next depth from the string traversal and returns the position following the last dash of the current depth.\ndef get_depth(traversal i):\n    depth = 0\n    while i < len(traversal) and traversal[i] == ""-"":\n        depth += 1\n        i += 1\n\n    return depth i"
Recover Binary Search Tree,###  99\. Recover Binary Search Tree\n\nYou are given the `root` of a binary search tree (BST) where the values of\n**exactly** two nodes of the tree were swapped by mistake. _Recover the tree\nwithout changing its structure_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/28/recover1.jpg)\n\n    \n    \n    **Input:** root = [13nullnull2]\n    **Output:** [31nullnull2]\n    **Explanation:** 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/28/recover2.jpg)\n\n    \n    \n    **Input:** root = [314nullnull2]\n    **Output:** [214nullnull3]\n    **Explanation:** 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[2 1000]`.\n  * `-231 <= Node.val <= 231 - 1`\n\n\n\n**Follow up:** A solution using `O(n)` space is pretty straight-forward. Could\nyou devise a constant `O(1)` space solution?\n\n,"# Runtime: 61 ms (Top 95.6%) | Memory: 16.68 MB (Top 75.1%)\n\nclass Solution:\n    \n    """"""\n        Brute force kind of thing\n        -> Inorder Traversal returns sorted array\n        -> find a swap btwn numbers to make sorted\n        Make single swap to make array sorted\n        [1 2 3 4 10 6 9 5 10 12]\n         x x x x x No\n            prev number is mismatch -> 10 is cause\n        now go frm right to left\n        [1 2 3 4 10 6 9 5 11 12]\n                            No x   x   x\n                        mismatch with next number -> 5 is the cause\n        swap 10 5\n        \n        Eg: 2\n        [3 2 1]\n         x  No -> 3 is the cause\n        [3 2 1]\n         x  No -> 1 is the cause\n        swap values -> 1 3\n    """"""\n    \n    def inorder(self root li):\n        if root is None:\n            return li\n        li = self.inorder(root.left li)\n        li.append(root)\n        li = self.inorder(root.right li)\n        return li\n    \n    def recoverTree(self root: TreeNode) -> None:\n        """"""\n        Do not return anything modify root in-place instead.\n        """"""\n        li = self.inorder(root [])\n        n = len(li)\n        i j = 1 n-2\n        a = li[0]\n        for i in range(1 n):\n            if li[i].val < li[i-1].val:\n                a = li[i-1]\n                break\n        b = li[-1]\n        for i in range(n-2 -1 -1):\n            if li[i].val > li[i+1].val:\n                b = li[i+1]\n                break\n\n        a.valb.val = b.val a.val\n"
Recover the Original Array,###  2122\. Recover the Original Array\n\nAlice had a **0-indexed** array `arr` consisting of `n` **positive** integers.\nShe chose an arbitrary **positive integer** `k` and created two new\n**0-indexed** integer arrays `lower` and `higher` in the following manner:\n\n  1. `lower[i] = arr[i] - k` for every index `i` where `0 <= i < n`\n  2. `higher[i] = arr[i] + k` for every index `i` where `0 <= i < n`\n\nUnfortunately Alice lost all three arrays. However she remembers the\nintegers that were present in the arrays `lower` and `higher` but not the\narray each integer belonged to. Help Alice and recover the original array.\n\nGiven an array `nums` consisting of `2n` integers where **exactly** `n` of\nthe integers were present in `lower` and the remaining in `higher` return\n_the**original** array_ `arr`. In case the answer is not unique return\n_**any** valid array_.\n\n**Note:** The test cases are generated such that there exists **at least one**\nvalid array `arr`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [21064812]\n    **Output:** [3711]\n    **Explanation:**\n    If arr = [3711] and k = 1 we get lower = [2610] and higher = [4812].\n    Combining lower and higher gives us [26104812] which is a permutation of nums.\n    Another valid possibility is that arr = [579] and k = 3. In that case lower = [246] and higher = [81012]. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1133]\n    **Output:** [22]\n    **Explanation:**\n    If arr = [22] and k = 1 we get lower = [11] and higher = [33].\n    Combining lower and higher gives us [1133] which is equal to nums.\n    Note that arr cannot be [13] because in that case the only possible way to obtain [1133] is with k = 0.\n    This is invalid since k must be positive.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [5435]\n    **Output:** [220]\n    **Explanation:**\n    The only possible combination is arr = [220] and k = 215. Using them we get lower = [5] and higher = [435].\n    \n\n\n\n**Constraints:**\n\n  * `2 * n == nums.length`\n  * `1 <= n <= 1000`\n  * `1 <= nums[i] <= 109`\n  * The test cases are generated such that there exists **at least one** valid array `arr`.\n\n,"class Solution(object):\n    def recoverArray(self nums):\n        nums.sort()\n        mid = len(nums) // 2\n        # All possible k are (nums[j] - nums[0]) // 2 otherwise there is no num that satisfies nums[0] + k = num - k.\n        # For nums is sorted so that any 2 elements (x y) in nums[1:j] cannot satisfy x + k = y - k.\n        # In other words for any x in nums[1:j] it needs to find y from nums[j + 1:] to satisfy x + k = y - k but\n        # unfortunately if j > mid then len(nums[j + 1:]) < mid <= len(nums[1:j]) nums[j + 1:] are not enough.\n        # The conclusion is j <= mid.\n		# If you think it’s not easy to understand why mid is enough len(nums) can also work well\n		# for j in range(1 len(nums)):  \n        for j in range(1 mid + 1):  # O(N)\n            if nums[j] - nums[0] > 0 and (nums[j] - nums[0]) % 2 == 0:  # Note the problem described k is positive.\n                k counter ans = (nums[j] - nums[0]) // 2 collections.Counter(nums) []\n                # For each number in lower we try to find the corresponding number from higher list.\n                # Because nums is sorted current n is always the current lowest num which can only come from lower\n                # list so we search the corresponding number of n which equals to n + 2 * k in the left\n                # if it can not be found change another k and continue to try.\n                for n in nums:  # check if n + 2 * k available as corresponding number in higher list of n\n                    if counter[n] == 0:  # removed by previous num as its corresponding number in higher list\n                        continue\n                    if counter[n + 2 * k] == 0:  # not found corresponding number in higher list\n                        break\n                    ans.append(n + k)\n                    counter[n] -= 1  # remove n\n                    counter[n + 2 * k] -= 1  # remove the corresponding number in higher list\n                if len(ans) == mid:\n                    return ans\n"
Rectangle Area,###  223\. Rectangle Area\n\nGiven the coordinates of two **rectilinear** rectangles in a 2D plane return\n_the total area covered by the two rectangles_.\n\nThe first rectangle is defined by its **bottom-left** corner `(ax1 ay1)` and\nits **top-right** corner `(ax2 ay2)`.\n\nThe second rectangle is defined by its **bottom-left** corner `(bx1 by1)` and\nits **top-right** corner `(bx2 by2)`.\n\n\n\n**Example 1:**\n\n![Rectangle Area](https://assets.leetcode.com/uploads/2021/05/08/rectangle-\nplane.png)\n\n    \n    \n    **Input:** ax1 = -3 ay1 = 0 ax2 = 3 ay2 = 4 bx1 = 0 by1 = -1 bx2 = 9 by2 = 2\n    **Output:** 45\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** ax1 = -2 ay1 = -2 ax2 = 2 ay2 = 2 bx1 = -2 by1 = -2 bx2 = 2 by2 = 2\n    **Output:** 16\n    \n\n\n\n**Constraints:**\n\n  * `-104 <= ax1 <= ax2 <= 104`\n  * `-104 <= ay1 <= ay2 <= 104`\n  * `-104 <= bx1 <= bx2 <= 104`\n  * `-104 <= by1 <= by2 <= 104`\n\n,# Runtime: 86 ms (Top 48.63%) | Memory: 14 MB (Top 27.24%)\nclass Solution:\n    def computeArea(self ax1: int ay1: int ax2: int ay2: int bx1: int by1: int bx2: int by2: int) -> int:\n        def segment(ax1ax2bx1bx2):\n            return min(ax2bx2) - max(ax1 bx1) if max(ax1 bx1) < min(ax2 bx2) else 0\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - segment(ax1ax2bx1bx2)*segment(ay1ay2by1by2)
Rectangle Area II,###  850\. Rectangle Area II\n\nYou are given a 2D array of axis-aligned `rectangles`. Each `rectangle[i] =\n[xi1 yi1 xi2 yi2]` denotes the `ith` rectangle where `(xi1 yi1)` are the\ncoordinates of the **bottom-left corner**  and `(xi2 yi2)` are the\ncoordinates of the **top-right corner**.\n\nCalculate the **total area** covered by all `rectangles` in the plane. Any\narea covered by two or more rectangles should only be counted **once**.\n\nReturn _the**total area**_. Since the answer may be too large return it\n**modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-\nupload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png)\n\n    \n    \n    **Input:** rectangles = [[0022][1023][1031]]\n    **Output:** 6\n    **Explanation:** A total area of 6 is covered by all three rectangles as illustrated in the picture.\n    From (11) to (22) the green and red rectangles overlap.\n    From (10) to (23) all three rectangles overlap.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rectangles = [[0010000000001000000000]]\n    **Output:** 49\n    **Explanation:** The answer is 1018 modulo (109 + 7) which is 49.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rectangles.length <= 200`\n  * `rectanges[i].length == 4`\n  * `0 <= xi1 yi1 xi2 yi2 <= 109`\n\n,# Runtime: 133 ms (Top 41.78%) | Memory: 13.9 MB (Top 70.89%)\nclass SegmentTree:\n    def __init__(self xs):\n        #cnts[v] means that the node's interval is active\n        self.cnts = defaultdict(int)\n        #total[v] length of active intervals that are contained the node's interval\n        self.total = defaultdict(int)\n        self.xs = xs\n\n    def update(self v tl tr l r h):\n        #node interval [tltr] does not overlap with query interval [lr]\n        if r < tl or tr < l: return\n        #node interval is included in the query interval\n        if l <= tl and tr <= r:\n            self.cnts[v] += h\n        else:\n            tm = (tl + tr)//2\n            self.update(v*2 tl tm l r h)\n            self.update(v*2+1 tm+1 tr l r h)\n        #node interval is included in the active interval\n        if self.cnts[v] > 0:\n            self.total[v] = self.xs[tr + 1] - self.xs[tl]\n        else:\n            self.total[v] = self.total[v*2] + self.total[v*2+1]\n        return self.total[v]\n\nclass Solution:\n    def rectangleArea(self rectangles):\n        #index i means the interval from xs[i] to xs[i+1]\n        xs = sorted(set([x for x1 y1 x2 y2 in rectangles for x in [x1 x2]]))\n        xs_i = {x:i for i x in enumerate(xs)}\n        st = SegmentTree(xs)\n        L = []\n        for x1 y1 x2 y2 in rectangles:\n            L.append([y1 1 x1 x2])\n            L.append([y2 -1 x1 x2])\n        L.sort()\n        cur_y = cur_x_sum = area = 0\n        for y open_close x1 x2 in L:\n            area += (y - cur_y) * cur_x_sum\n            cur_y = y\n            #one index corresponds to one interval that's why we use xs_i[x2]-1 instead of xs_i[x2]\n            st.update(1 0 len(xs) - 1 xs_i[x1] xs_i[x2]-1 open_close)\n            cur_x_sum = st.total[1]\n\n        return area % (10 ** 9 + 7)
Rectangle Overlap,###  836\. Rectangle Overlap\n\nAn axis-aligned rectangle is represented as a list `[x1 y1 x2 y2]` where\n`(x1 y1)` is the coordinate of its bottom-left corner and `(x2 y2)` is the\ncoordinate of its top-right corner. Its top and bottom edges are parallel to\nthe X-axis and its left and right edges are parallel to the Y-axis.\n\nTwo rectangles overlap if the area of their intersection is **positive**. To\nbe clear two rectangles that only touch at the corner or edges do not\noverlap.\n\nGiven two axis-aligned rectangles `rec1` and `rec2` return `true` _if they\noverlap otherwise return_`false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** rec1 = [0022] rec2 = [1133]\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** rec1 = [0011] rec2 = [1021]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** rec1 = [0011] rec2 = [2233]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `rec1.length == 4`\n  * `rec2.length == 4`\n  * `-109 <= rec1[i] rec2[i] <= 109`\n  * `rec1` and `rec2` represent a valid rectangle with a non-zero area.\n\n,class Solution:\n    def isRectangleOverlap(self rec1: List[int] rec2: List[int]) -> bool:\n        if (rec2[1]>=rec1[3] or rec2[0]>=rec1[2] or rec2[3]<=rec1[1] or rec1[0]>=rec2[2])  :\n            \n            return False\n        else:\n            return True\n
Redistribute Characters to Make All Strings Equal,"###  1897\. Redistribute Characters to Make All Strings Equal\n\nYou are given an array of strings `words` (**0-indexed**).\n\nIn one operation pick two **distinct** indices `i` and `j` where `words[i]`\nis a non-empty string and move **any** character from `words[i]` to **any**\nposition in `words[j]`.\n\nReturn `true` _if you can make**every** string in _`words` _**equal** using\n**any** number of operations__and_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""abc""""aabc""""bc""]\n    **Output:** true\n    **Explanation:** Move the first 'a' in words[1] to the front of words[2]\n    to make words[1] = ""abc"" and words[2] = ""abc"".\n    All the strings are now equal to ""abc"" so return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""ab""""a""]\n    **Output:** false\n    **Explanation:** It is impossible to make all the strings equal using the operation.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 100`\n  * `1 <= words[i].length <= 100`\n  * `words[i]` consists of lowercase English letters.\n\n",class Solution:\n    def makeEqual(self words: List[str]) -> bool:\n        map_ = {}\n        for word in words:\n            for i in word:\n                if i not in map_:\n                    map_[i] = 1\n                else:\n                    map_[i] += 1\n        n = len(words)\n        for kv in map_.items():\n            if (v%n) != 0:\n                return False\n        return True\n
Reduce Array Size to The Half,###  1338\. Reduce Array Size to The Half\n\nYou are given an integer array `arr`. You can choose a set of integers and\nremove all the occurrences of these integers in the array.\n\nReturn _the minimum size of the set so that**at least** half of the integers\nof the array are removed_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [3333555227]\n    **Output:** 2\n    **Explanation:** Choosing {37} will make the new array [55522] which has size 5 (i.e equal to half of the size of the old array).\n    Possible sets of size 2 are {35}{32}{52}.\n    Choosing set {27} is not possible as it will make the new array [3333555] which has a size greater than half of the size of the old array.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [777777]\n    **Output:** 1\n    **Explanation:** The only possible set you can choose is {7}. This will make the new array empty.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= arr.length <= 105`\n  * `arr.length` is even.\n  * `1 <= arr[i] <= 105`\n\n,class Solution:\n    def minSetSize(self arr: List[int]) -> int:\n        n = len(arr)\n        half = n // 2\n        \n        c = Counter(arr)\n        s = 0\n        ans = 0\n        \n        for num occurances in c.most_common():\n            s += occurances\n            ans += 1\n            if s >= half:\n                return ans\n        return ans\n
Reducing Dishes,###  1402\. Reducing Dishes\n\nA chef has collected data on the `satisfaction` level of his `n` dishes. Chef\ncan cook any dish in 1 unit of time.\n\n**Like-time coefficient** of a dish is defined as the time taken to cook that\ndish including previous dishes multiplied by its satisfaction level i.e.\n`time[i] * satisfaction[i]`.\n\nReturn _the maximum sum of**like-time coefficient** that the chef can obtain\nafter dishes preparation_.\n\nDishes can be prepared in **any** order and the chef can discard some dishes\nto get this maximum value.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** satisfaction = [-1-805-9]\n    **Output:** 14\n    **Explanation:** After Removing the second and last dish the maximum total **like-time coefficient** will be equal to (-1*1 + 0*2 + 5*3 = 14).\n    Each dish is prepared in one unit of time.\n\n**Example 2:**\n\n    \n    \n    **Input:** satisfaction = [432]\n    **Output:** 20\n    **Explanation:** Dishes can be prepared in any order (2*1 + 3*2 + 4*3 = 20)\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** satisfaction = [-1-4-5]\n    **Output:** 0\n    **Explanation:** People do not like the dishes. No dish is prepared.\n    \n\n\n\n**Constraints:**\n\n  * `n == satisfaction.length`\n  * `1 <= n <= 500`\n  * `-1000 <= satisfaction[i] <= 1000`\n\n,class Solution:\n    def maxSatisfaction(self satisfaction: List[int]) -> int:\n        satisfaction.sort(reverse=True)\n        maxSatisfaction = dishSum = 0\n\n        for dish in satisfaction:\n            dishSum += dish\n            if dishSum <= 0:\n                break\n            maxSatisfaction += dishSum\n        \n        return maxSatisfaction
Reduction Operations to Make the Array Elements Equal,###  1887\. Reduction Operations to Make the Array Elements Equal\n\nGiven an integer array `nums` your goal is to make all elements in `nums`\nequal. To complete one operation follow these steps:\n\n  1. Find the **largest** value in `nums`. Let its index be `i` (**0-indexed**) and its value be `largest`. If there are multiple elements with the largest value pick the smallest `i`.\n  2. Find the **next largest** value in `nums` **strictly smaller** than `largest`. Let its value be `nextLargest`.\n  3. Reduce `nums[i]` to `nextLargest`.\n\nReturn _the number of operations to make all elements in_`nums` _equal_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [513]\n    **Output:** 3\n    **Explanation:**  It takes 3 operations to make all elements in nums equal:\n    1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [_3_ 13].\n    2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [_1_ 13].\n    3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [11_1_].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [111]\n    **Output:** 0\n    **Explanation:**  All elements in nums are already equal.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [11223]\n    **Output:** 4\n    **Explanation:**  It takes 4 operations to make all elements in nums equal:\n    1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1122_2_].\n    2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [11_1_ 22].\n    3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [111_1_ 2].\n    4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1111_1_].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5 * 104`\n  * `1 <= nums[i] <= 5 * 104`\n\n,// Runtime: 717 ms (Top 99.99%) | Memory: 24.60 MB (Top 36.15%)\n\nclass Solution:\n    def reductionOperations(self nums: List[int]) -> int:\n        ans = val = 0\n        nums.sort()\n        for i in range(1 len(nums)): \n            if nums[i-1] < nums[i]: val += 1\n            ans += val\n        return ans \n
Redundant Connection,###  684\. Redundant Connection\n\nIn this problem a tree is an **undirected graph** that is connected and has\nno cycles.\n\nYou are given a graph that started as a tree with `n` nodes labeled from `1`\nto `n` with one additional edge added. The added edge has two **different**\nvertices chosen from `1` to `n` and was not an edge that already existed. The\ngraph is represented as an array `edges` of length `n` where `edges[i] = [ai\nbi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.\n\nReturn _an edge that can be removed so that the resulting graph is a tree\nof_`n` _nodes_. If there are multiple answers return the answer that occurs\nlast in the input.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg)\n\n    \n    \n    **Input:** edges = [[12][13][23]]\n    **Output:** [23]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg)\n\n    \n    \n    **Input:** edges = [[12][23][34][14][15]]\n    **Output:** [14]\n    \n\n\n\n**Constraints:**\n\n  * `n == edges.length`\n  * `3 <= n <= 1000`\n  * `edges[i].length == 2`\n  * `1 <= ai < bi <= edges.length`\n  * `ai != bi`\n  * There are no repeated edges.\n  * The given graph is connected.\n\n,class UnionFind:\n    \n    def __init__(self size):\n        \n        self.parent = [-1 for _ in range(size)]\n        self.rank = [-1 for _ in range(size)]\n        \n    def find(self i):\n        \n        if self.parent[i] == -1:\n            return i\n        \n        k = self.find(self.parent[i])\n        self.parent[i] = k\n        return k\n    \n    def union(self x y):\n        \n        x = self.find(x)\n        y = self.find(y)\n        \n        if x == y:\n            return -1\n        else:\n            \n            if self.rank[x] > self.rank[y]:\n                self.parent[y] = x\n            \n            elif self.rank[x] < self.rank[y]:\n                self.parent[x] = y\n                \n            else:\n                self.rank[x] += 1\n                self.parent[y] = x\n\nclass Solution:\n    def findRedundantConnection(self edges: List[List[int]]) -> List[int]:\n   \n        vertex_set = set()\n    \n        for edge in edges:\n            vertex_set.add(edge[0])\n            vertex_set.add(edge[1])\n        \n        \n        union_find = UnionFind(len(vertex_set))\n        \n        for edge in edges:\n            \n            new_edge = [edge[0]-1 edge[1]-1]\n            \n            if union_find.union(new_edge[0] new_edge[1]) == -1:\n                return edge\n        \n        return []\n\n
Redundant Connection II,###  685\. Redundant Connection II\n\nIn this problem a rooted tree is a **directed** graph such that there is\nexactly one node (the root) for which all other nodes are descendants of this\nnode plus every node has exactly one parent except for the root node which\nhas no parents.\n\nThe given input is a directed graph that started as a rooted tree with `n`\nnodes (with distinct values from `1` to `n`) with one additional directed\nedge added. The added edge has two different vertices chosen from `1` to `n`\nand was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of `edges`. Each element of `edges`\nis a pair `[ui vi]` that represents a **directed** edge connecting nodes `ui`\nand `vi` where `ui` is a parent of child `vi`.\n\nReturn _an edge that can be removed so that the resulting graph is a rooted\ntree of_ `n` _nodes_. If there are multiple answers return the answer that\noccurs last in the given 2D-array.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg)\n\n    \n    \n    **Input:** edges = [[12][13][23]]\n    **Output:** [23]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/20/graph2.jpg)\n\n    \n    \n    **Input:** edges = [[12][23][34][41][15]]\n    **Output:** [41]\n    \n\n\n\n**Constraints:**\n\n  * `n == edges.length`\n  * `3 <= n <= 1000`\n  * `edges[i].length == 2`\n  * `1 <= ui vi <= n`\n  * `ui != vi`\n\n,# Runtime: 118 ms (Top 30.98%) | Memory: 14.6 MB (Top 46.10%)\nclass Solution:\n    def findRedundantDirectedConnection(self edges: List[List[int]]) -> List[int]:\n        # THREE DIFFERENT TYPES OF REDUNDANT TREES CAN EXISIT IDENTIFY THOSE (CYCLENOCYCLEINDEGREE2)\n        # CAN BE SOLVED USING DSU OR DFS\n        class DSU:\n            def __init__(selfn):\n                self.parent = [i for i in range(1005)]\n            def find(selfnode):\n                if self.parent[node] == node:\n                    return node\n                self.parent[node] = self.find(self.parent[node])\n                return self.parent[node]\n            def union(selfnode1node2):\n                p1 = self.find(node1)\n                p2 = self.find(node2)\n                if p1 != p2:\n                    self.parent[p1] = p2\n            def isConnected(selfnode1node2):\n                return self.find(node1) == self.find(node2)\n        def isValidTree(edgesedgen):\n            d = DSU(n)\n            for e in edges:\n                if e == edge:\n                    continue\n                d.union(e[0]e[1])\n            return d.isConnected(edge[0]edge[1])\n\n        indegree = []\n        count = defaultdict(int)\n        for ij in edges:\n            count[j] = count.get(j0)+1\n        n = len(edges)\n        for i in range(n):\n            if count[edges[i][1]] == 2:\n                indegree += [i]\n        if len(indegree) != 0:\n            if isValidTree(edgesedges[indegree[-1]]n):\n                return edges[indegree[-1]]\n            return edges[indegree[0]]\n        else:\n            d2 = DSU(n)\n            for e in edges:\n                if d2.isConnected(e[0]e[1]):\n                    return e\n                d2.union(e[0]e[1])\n\n# def dfs(node):\n# if node in seen:\n# return False\n# seen.add(node)\n# for nb in g[node]:\n# if not dfs(nb):\n# return False\n# return True\n# g = defaultdict(list)\n# v = defaultdict(int)\n# total = set()\n# for ij in edges:\n# g[i] = g.get(i[]) + [j]\n# v[j] = v.get(j0) + 1\n# total.add(i)\n# total.add(j)\n# for e in edges[::-1]:\n# g[e[0]].remove(e[1])\n# v[e[1]] -= 1\n# for root in total:\n# seen = set()\n# if v[root] == 0 and dfs(root) and len(seen) == len(total):\n# return e\n\n# v[e[1]] += 1\n# g[e[0]].append(e[1])\n# return [-1-1]
Reformat Date,"###  1507\. Reformat Date\n\nGiven a `date` string in the form `Day Month Year` where:\n\n  * `Day` is in the set `{""1st"" ""2nd"" ""3rd"" ""4th"" ... ""30th"" ""31st""}`.\n  * `Month` is in the set `{""Jan"" ""Feb"" ""Mar"" ""Apr"" ""May"" ""Jun"" ""Jul"" ""Aug"" ""Sep"" ""Oct"" ""Nov"" ""Dec""}`.\n  * `Year` is in the range `[1900 2100]`.\n\nConvert the date string to the format `YYYY-MM-DD` where:\n\n  * `YYYY` denotes the 4 digit year.\n  * `MM` denotes the 2 digit month.\n  * `DD` denotes the 2 digit day.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** date = ""20th Oct 2052""\n    **Output:** ""2052-10-20""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** date = ""6th Jun 1933""\n    **Output:** ""1933-06-06""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** date = ""26th May 1960""\n    **Output:** ""1960-05-26""\n    \n\n\n\n**Constraints:**\n\n  * The given dates are guaranteed to be valid so no error handling is necessary.\n\n","# Runtime: 31 ms (Top 93.30%) | Memory: 13.8 MB (Top 98.50%)\nclass Solution:\n    def reformatDate(self date: str) -> str:\n\n        m_dict_={""Jan"":""01"" ""Feb"":""02"" ""Mar"":""03"" ""Apr"":""04"" ""May"":""05"" ""Jun"":""06"" ""Jul"":""07"" ""Aug"":""08"" ""Sep"":""09"" ""Oct"":""10"" ""Nov"":""11"" ""Dec"":""12""}\n\n        day=date[:-11]\n\n        if len(day)==1:\n            day=""0""+day\n\n        return(date[-4:] + ""-"" + m_dict_[date[-8:-5]] + ""-"" + day)"
Reformat Phone Number,"###  1694\. Reformat Phone Number\n\nYou are given a phone number as a string `number`. `number` consists of\ndigits spaces `' '` and/or dashes `'-'`.\n\nYou would like to reformat the phone number in a certain manner. Firstly\n**remove** all spaces and dashes. Then **group** the digits from left to\nright into blocks of length 3 **until** there are 4 or fewer digits. The final\ndigits are then grouped as follows:\n\n  * 2 digits: A single block of length 2.\n  * 3 digits: A single block of length 3.\n  * 4 digits: Two blocks of length 2 each.\n\nThe blocks are then joined by dashes. Notice that the reformatting process\nshould **never** produce any blocks of length 1 and produce **at most** two\nblocks of length 2.\n\nReturn _the phone number after formatting._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** number = ""1-23-45 6""\n    **Output:** ""123-456""\n    **Explanation:** The digits are ""123456"".\n    Step 1: There are more than 4 digits so group the next 3 digits. The 1st block is ""123"".\n    Step 2: There are 3 digits remaining so put them in a single block of length 3. The 2nd block is ""456"".\n    Joining the blocks gives ""123-456"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** number = ""123 4-567""\n    **Output:** ""123-45-67""\n    **Explanation:** The digits are ""1234567"".\n    Step 1: There are more than 4 digits so group the next 3 digits. The 1st block is ""123"".\n    Step 2: There are 4 digits left so split them into two blocks of length 2. The blocks are ""45"" and ""67"".\n    Joining the blocks gives ""123-45-67"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** number = ""123 4-5678""\n    **Output:** ""123-456-78""\n    **Explanation:** The digits are ""12345678"".\n    Step 1: The 1st block is ""123"".\n    Step 2: The 2nd block is ""456"".\n    Step 3: There are 2 digits left so put them in a single block of length 2. The 3rd block is ""78"".\n    Joining the blocks gives ""123-456-78"".\n    \n\n\n\n**Constraints:**\n\n  * `2 <= number.length <= 100`\n  * `number` consists of digits and the characters `'-'` and `' '`.\n  * There are at least **two** digits in `number`.\n\n","class Solution:\n    def reformatNumber(self number: str) -> str:\n        s = number.replace("" "" """").replace(""-"" """")\n        pieces = list()\n        while s:\n            if len(s) == 2:\n                pieces.append(s)\n                break\n            elif len(s) == 4:\n                pieces.append(s[:2])\n                pieces.append(s[2:])\n                break\n            else:\n                pieces.append(s[:3])\n                s = s[3:]\n        return ""-"".join(pieces)\n"
Reformat The String,"###  1417\. Reformat The String\n\nYou are given an alphanumeric string `s`. (**Alphanumeric string** is a string\nconsisting of lowercase English letters and digits).\n\nYou have to find a permutation of the string where no letter is followed by\nanother letter and no digit is followed by another digit. That is no two\nadjacent characters have the same type.\n\nReturn _the reformatted string_ or return **an empty string** if it is\nimpossible to reformat the string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""a0b1c2""\n    **Output:** ""0a1b2c""\n    **Explanation:** No two adjacent characters have the same type in ""0a1b2c"". ""a0b1c2"" ""0a1b2c"" ""0c2a1b"" are also valid permutations.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""leetcode""\n    **Output:** """"\n    **Explanation:** ""leetcode"" has only characters so we cannot separate them by digits.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""1229857369""\n    **Output:** """"\n    **Explanation:** ""1229857369"" has only digits so we cannot separate them by characters.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 500`\n  * `s` consists of only lowercase English letters and/or digits.\n\n",class Solution:\n    def reformat(self s: str) -> str:\n        # Store the alphabets and the numerics from the string in a seperat arrays\n        alpha = []\n        num = []\n        # Initiate a res variable to store the resultant string\n        res = ''\n        \n        for i in s:\n            if i.isalpha():\n                alpha.append(i)\n            else:\n                num.append(i)\n                \n        # It's not possible to create a permutation if the absolute difference b/w len(alpha) and len(num) > 1.\n        if abs(len(alpha)-len(num)) > 1: return ''\n        \n        # Use Zip to create list of tuples.\n        # For ex:- if alpha = ['a''b'] and num = ['1' '2'] then\n        # zip(alpha num) = [('a' '1') ('b' '2')]\n        for ch n in zip(alpha num):\n            res += (ch+n)\n            \n        if len(alpha) > len(num):\n            res += alpha[-1]\n        if len(num) > len(alpha):\n            res = num[-1] + res\n            \n        return res\n
Regions Cut By Slashes,"###  959\. Regions Cut By Slashes\n\nAn `n x n` grid is composed of `1 x 1` squares where each `1 x 1` square\nconsists of a `'/'` `'\'` or blank space `' '`. These characters divide the\nsquare into contiguous regions.\n\nGiven the grid `grid` represented as a string array return _the number of\nregions_.\n\nNote that backslash characters are escaped so a `'\'` is represented as\n`'\\'`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/15/1.png)\n\n    \n    \n    **Input:** grid = ["" /""""/ ""]\n    **Output:** 2\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/15/2.png)\n\n    \n    \n    **Input:** grid = ["" /""""  ""]\n    **Output:** 1\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2018/12/15/4.png)\n\n    \n    \n    **Input:** grid = [""/\\""""\\/""]\n    **Output:** 5\n    **Explanation:** Recall that because \ characters are escaped ""\\/"" refers to \/ and ""/\\"" refers to /\.\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length == grid[i].length`\n  * `1 <= n <= 30`\n  * `grid[i][j]` is either `'/'` `'\'` or `' '`.\n\n",# Runtime: 124 ms (Top 90.60%) | Memory: 14.5 MB (Top 61.93%)\nclass Solution:\n    def regionsBySlashes(self grid: List[str]) -> int:\n        n=len(grid)\n        dots=n+1\n        par=[0]*(dots*dots)\n        rank=[0]*(dots*dots)\n        self.count=1\n\n        def find(x):\n            if par[x]==x:\n                return x\n            temp=find(par[x])\n            par[x]=temp\n            return temp\n        def union(xy):\n            lx=find(x)\n            ly=find(y)\n            if lx!=ly:\n                if rank[lx]>rank[ly]:\n                    par[ly]=lx\n                elif rank[lx]<rank[ly]:\n                    par[lx]=ly\n                else:\n                    par[lx]=ly\n                    rank[ly]+=1\n            else:\n                self.count+=1\n    #-------------------------------------------#\n        for i in range(len(par)):\n            par[i]=i\n            rank[i]=1\n        for i in range(dots):\n            for j in range(dots):\n                if i==0 or j==0 or i==dots-1 or j==dots-1:\n                    cellno=i*dots+j\n                    if cellno!=0:\n                        union(0cellno)\n        for i in range(len(grid)):\n            ch=grid[i]\n            for j in range(len(ch)):\n                if ch[j]=='/':\n                    cellno1=i*dots+j+1\n                    cellno2=(i+1)*dots+j\n\n                    union(cellno1cellno2)\n                elif ch[j]=='\\':\n                    cellno1=i*dots+j\n                    cellno2=(i+1)*dots+j+1\n                    union(cellno1cellno2)\n        return self.count
Regular Expression Matching,"###  10\. Regular Expression Matching\n\nGiven an input string `s` and a pattern `p` implement regular expression\nmatching with support for `'.'` and `'*'` where:\n\n  * `'.'` Matches any single character.​​​​\n  * `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aa"" p = ""a""\n    **Output:** false\n    **Explanation:** ""a"" does not match the entire string ""aa"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aa"" p = ""a*""\n    **Output:** true\n    **Explanation:** '*' means zero or more of the preceding element 'a'. Therefore by repeating 'a' once it becomes ""aa"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""ab"" p = "".*""\n    **Output:** true\n    **Explanation:** "".*"" means ""zero or more (*) of any character (.)"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 20`\n  * `1 <= p.length <= 30`\n  * `s` contains only lowercase English letters.\n  * `p` contains only lowercase English letters `'.'` and `'*'`.\n  * It is guaranteed for each appearance of the character `'*'` there will be a previous valid character to match.\n\n",class Solution:\n   def isMatch(self s p):\n       n = len(s)\n       m = len(p)\n       dp = [[False for _ in range (m+1)] for _ in range (n+1)]\n       dp[0][0] = True\n       for c in range(1m+1):\n           if p[c-1] == '*' and c > 1:\n               dp[0][c] = dp[0][c-2]\n       for r in range(1n+1):\n           for c in range(1m+1):\n               if p[c-1] == s[r-1] or p[c-1] == '.':\n                   dp[r][c] = dp[r-1][c-1]\n               elif c > 1 and p[c-1] == '*':\n                   if  p[c-2] =='.' or s[r-1]==p[c-2]:\n                       dp[r][c] =dp[r][c-2] or dp[r-1][c]\n                   else:\n                       dp[r][c] = dp[r][c-2]\n       return dp[n][m]\n
Relative Ranks,"###  506\. Relative Ranks\n\nYou are given an integer array `score` of size `n` where `score[i]` is the\nscore of the `ith` athlete in a competition. All the scores are guaranteed to\nbe **unique**.\n\nThe athletes are **placed** based on their scores where the `1st` place\nathlete has the highest score the `2nd` place athlete has the `2nd` highest\nscore and so on. The placement of each athlete determines their rank:\n\n  * The `1st` place athlete's rank is `""Gold Medal""`.\n  * The `2nd` place athlete's rank is `""Silver Medal""`.\n  * The `3rd` place athlete's rank is `""Bronze Medal""`.\n  * For the `4th` place to the `nth` place athlete their rank is their placement number (i.e. the `xth` place athlete's rank is `""x""`).\n\nReturn an array `answer` of size `n` where `answer[i]` is the **rank** of the\n`ith` athlete.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** score = [54321]\n    **Output:** [""Gold Medal""""Silver Medal""""Bronze Medal""""4""""5""]\n    **Explanation:** The placements are [1st 2nd 3rd 4th 5th].\n\n**Example 2:**\n\n    \n    \n    **Input:** score = [103894]\n    **Output:** [""Gold Medal""""5""""Bronze Medal""""Silver Medal""""4""]\n    **Explanation:** The placements are [1st 5th 3rd 2nd 4th].\n    \n    \n\n\n\n**Constraints:**\n\n  * `n == score.length`\n  * `1 <= n <= 104`\n  * `0 <= score[i] <= 106`\n  * All the values in `score` are **unique**.\n\n","# Runtime: 162 ms (Top 33.91%) | Memory: 15.3 MB (Top 22.09%)\nclass Solution:\n    def findRelativeRanks(self score: List[int]) -> List[str]:\n        scores_ids = []\n        for i in range(len(score)):\n            scores_ids.append((score[i] i))\n        scores_ids.sort(reverse=True)\n\n        ans = [0] * len(scores_ids)\n        for i in range(len(scores_ids)):\n            ans[scores_ids[i][1]] = str(i+1)\n\n        try:\n            ans[scores_ids[0][1]] = ""Gold Medal""\n            ans[scores_ids[1][1]] = ""Silver Medal""\n            ans[scores_ids[2][1]] = ""Bronze Medal""\n        except:\n            pass\n\n        return ans\n"
Relative Sort Array,###  1122\. Relative Sort Array\n\nGiven two arrays `arr1` and `arr2` the elements of `arr2` are distinct and\nall elements in `arr2` are also in `arr1`.\n\nSort the elements of `arr1` such that the relative ordering of items in `arr1`\nare the same as in `arr2`. Elements that do not appear in `arr2` should be\nplaced at the end of `arr1` in **ascending** order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr1 = [231324679219] arr2 = [214396]\n    **Output:** [222143396719]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr1 = [2862284417] arr2 = [222886]\n    **Output:** [2228861744]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr1.length arr2.length <= 1000`\n  * `0 <= arr1[i] arr2[i] <= 1000`\n  * All the elements of `arr2` are **distinct**.\n  * Each `arr2[i]` is in `arr1`.\n\n,"// Runtime: 42 ms (Top 73.46%) | Memory: 17.40 MB (Top 13.95%)\n\nclass Solution:\n    def relativeSortArray(self arr1: List[int] arr2: List[int]) -> List[int]:\n		# initialise a dictionary since we're going to want to count the occurences of each element in arr1\n        dic = {}\n		# this loop populates the dictionary with the number of occurences for each element\n        for elem in arr1:\n            if dic.get(elem) is None:\n                dic[elem] = 1\n            else:\n                dic[elem] = dic[elem] + 1\n		# initialise a new list to store the values which exist in both arr2 and arr1\n        output = []\n		# populate output with the elements multiplied by their occurences (e.g. [1]*2 = [1 1])\n        for elem in arr2:\n            output += [elem]*dic[elem]\n		# initialise a new list to store the elements which are in arr1 but not arr2\n        extra_output = []\n		# populate extra_output with these elements multiplied by their occurences. \n		# Note: set(arr1)-set(arr2) provides us with the set of numbers which exist in arr1 but not in arr2\n        for elem in set(arr1)-set(arr2):\n            extra_output += [elem]*dic[elem]\n		# return the first list and the sorted second list\n        return output + sorted(extra_output)\n"
Remove All Adjacent Duplicates in String II,"###  1209\. Remove All Adjacent Duplicates in String II\n\nYou are given a string `s` and an integer `k` a `k` **duplicate removal**\nconsists of choosing `k` adjacent and equal letters from `s` and removing\nthem causing the left and the right side of the deleted substring to\nconcatenate together.\n\nWe repeatedly make `k` **duplicate removals** on `s` until we no longer can.\n\nReturn _the final string after all such duplicate removals have been made_. It\nis guaranteed that the answer is **unique**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcd"" k = 2\n    **Output:** ""abcd""\n    **Explanation:** There's nothing to delete.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""deeedbbcccbdaa"" k = 3\n    **Output:** ""aa""\n    **Explanation:** First delete ""eee"" and ""ccc"" get ""ddbbbdaa""\n    Then delete ""bbb"" get ""dddaa""\n    Finally delete ""ddd"" get ""aa""\n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""pbbcggttciiippooaais"" k = 2\n    **Output:** ""ps""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `2 <= k <= 104`\n  * `s` only contains lowercase English letters.\n\n",# Runtime: 309 ms (Top 14.94%) | Memory: 18.7 MB (Top 36.81%)\nclass Solution:\n    def removeDuplicates(self s: str k: int) -> str:\n        stack=[]\n        res=''\n        for i in range(len(s)):\n            if len(stack)==0:\n                stack.append([s[i]1])\n            elif stack[-1][0]==s[i]:\n                stack[-1][1]=stack[-1][1]+1\n            else:\n                stack.append([s[i]1])\n            if stack[-1][1]==k:\n                stack.pop()\n        for i in range(len(stack)):\n            res+=stack[i][0]*stack[i][1]\n        return res
Remove All Occurrences of a Substring,"###  1910\. Remove All Occurrences of a Substring\n\nGiven two strings `s` and `part` perform the following operation on `s` until\n**all** occurrences of the substring `part` are removed:\n\n  * Find the **leftmost** occurrence of the substring `part` and **remove** it from `s`.\n\nReturn `s` _after removing all occurrences of_`part`.\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""daabcbaabcbc"" part = ""abc""\n    **Output:** ""dab""\n    **Explanation** : The following operations are done:\n    - s = ""da** _abc_** baabcbc"" remove ""abc"" starting at index 2 so s = ""dabaabcbc"".\n    - s = ""daba** _abc_** bc"" remove ""abc"" starting at index 4 so s = ""dababc"".\n    - s = ""dab** _abc_** "" remove ""abc"" starting at index 3 so s = ""dab"".\n    Now s has no occurrences of ""abc"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""axxxxyyyyb"" part = ""xy""\n    **Output:** ""ab""\n    **Explanation** : The following operations are done:\n    - s = ""axxx** _xy_** yyyb"" remove ""xy"" starting at index 4 so s = ""axxxyyyb"".\n    - s = ""axx** _xy_** yyb"" remove ""xy"" starting at index 3 so s = ""axxyyb"".\n    - s = ""ax** _xy_** yb"" remove ""xy"" starting at index 2 so s = ""axyb"".\n    - s = ""a** _xy_** b"" remove ""xy"" starting at index 1 so s = ""ab"".\n    Now s has no occurrences of ""xy"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `1 <= part.length <= 1000`\n  * `s`​​​​​​ and `part` consists of lowercase English letters.\n\n",class Solution:\n    def removeOccurrences(self s: str part: str) -> str:\n        n=len(part)\n        while part in s:\n            i=s.index(part)\n            s=s[:i]+s[i+n:]\n        return s\n
Remove Boxes,###  546\. Remove Boxes\n\nYou are given several `boxes` with different colors represented by different\npositive numbers.\n\nYou may experience several rounds to remove boxes until there is no box left.\nEach time you can choose some continuous boxes with the same color (i.e.\ncomposed of `k` boxes `k >= 1`) remove them and get `k * k` points.\n\nReturn _the maximum points you can get_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** boxes = [132223431]\n    **Output:** 23\n    **Explanation:**\n    [1 3 2 2 2 3 4 3 1] \n    ----> [1 3 3 4 3 1] (3*3=9 points) \n    ----> [1 3 3 3 1] (1*1=1 points) \n    ----> [1 1] (3*3=9 points) \n    ----> [] (2*2=4 points)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** boxes = [111]\n    **Output:** 9\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** boxes = [1]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= boxes.length <= 100`\n  * `1 <= boxes[i] <= 100`\n\n,class Solution:\n    def removeBoxes(self B):\n        \n        @lru_cache(None)\n        def dp(i j k):\n            if i > j: return 0\n            indx = [m for m in range(i+1 j+1) if B[m] == B[i]]\n            ans = (k+1)**2 + dp(i+1 j 0)\n            return max([ans] + [dp(i+1 m-1 0) + dp(m j k+1) for m in indx])   \n            \n        return dp(0 len(B)-1 0)
Remove Colored Pieces if Both Neighbors are the Same Color,"###  2038\. Remove Colored Pieces if Both Neighbors are the Same Color\n\nThere are `n` pieces arranged in a line and each piece is colored either by\n`'A'` or by `'B'`. You are given a string `colors` of length `n` where\n`colors[i]` is the color of the `ith` piece.\n\nAlice and Bob are playing a game where they take **alternating turns**\nremoving pieces from the line. In this game Alice moves**first**.\n\n  * Alice is only allowed to remove a piece colored `'A'` if **both its neighbors** are also colored `'A'`. She is **not allowed** to remove pieces that are colored `'B'`.\n  * Bob is only allowed to remove a piece colored `'B'` if **both its neighbors** are also colored `'B'`. He is **not allowed** to remove pieces that are colored `'A'`.\n  * Alice and Bob **cannot** remove pieces from the edge of the line.\n  * If a player cannot make a move on their turn that player **loses** and the other player **wins**.\n\nAssuming Alice and Bob play optimally return `true` _if Alice wins or\nreturn_`false` _if Bob wins_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** colors = ""AAABABB""\n    **Output:** true\n    **Explanation:**\n    A _A_ ABABB -> AABABB\n    Alice moves first.\n    She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.\n    \n    Now it's Bob's turn.\n    Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.\n    Thus Alice wins so return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** colors = ""AA""\n    **Output:** false\n    **Explanation:**\n    Alice has her turn first.\n    There are only two 'A's and both are on the edge of the line so she cannot move on her turn.\n    Thus Bob wins so return false.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** colors = ""ABBBBBBBAAA""\n    **Output:** false\n    **Explanation:**\n    ABBBBBBBA _A_ A -> ABBBBBBBAA\n    Alice moves first.\n    Her only option is to remove the second to last 'A' from the right.\n    \n    ABBBB _B_ BBAA -> ABBBBBBAA\n    Next is Bob's turn.\n    He has many options for which 'B' piece to remove. He can pick any.\n    \n    On Alice's second turn she has no more pieces that she can remove.\n    Thus Bob wins so return false.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= colors.length <= 105`\n  * `colors` consists of only the letters `'A'` and `'B'`\n\n",class Solution:\n    def winnerOfGame(self s: str) -> bool:\n        \n        a = b = 0\n        \n        for i in range(1len(s)-1):\n            if s[i-1] == s[i] == s[i+1]:\n                if s[i] == 'A':\n                    a += 1\n                else:\n                    b += 1\n                    \n        return a>b\n
Remove Comments,"###  722\. Remove Comments\n\nGiven a C++ program remove comments from it. The program source is an array\nof strings `source` where `source[i]` is the `ith` line of the source code.\nThis represents the result of splitting the original source code string by the\nnewline character `'\n'`.\n\nIn C++ there are two types of comments line comments and block comments.\n\n  * The string `""//""` denotes a line comment which represents that it and the rest of the characters to the right of it in the same line should be ignored.\n  * The string `""/*""` denotes a block comment which represents that all characters until the next (non-overlapping) occurrence of `""*/""` should be ignored. (Here occurrences happen in reading order: line by line from left to right.) To be clear the string `""/*/""` does not yet end the block comment as the ending would be overlapping the beginning.\n\nThe first effective comment takes precedence over others.\n\n  * For example if the string `""//""` occurs in a block comment it is ignored.\n  * Similarly if the string `""/*""` occurs in a line or block comment it is also ignored.\n\nIf a certain line of code is empty after removing comments you must not\noutput that line: each string in the answer list will be non-empty.\n\nThere will be no control characters single quote or double quote characters.\n\n  * For example `source = ""string s = ""/* Not a comment. */"";""` will not be a test case.\n\nAlso nothing else such as defines or macros will interfere with the comments.\n\nIt is guaranteed that every open block comment will eventually be closed so\n`""/*""` outside of a line or block comment always starts a new comment.\n\nFinally implicit newline characters can be deleted by block comments. Please\nsee the examples below for details.\n\nAfter removing the comments from the source code return _the source code in\nthe same format_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** source = [""/*Test program */"" ""int main()"" ""{ "" ""  // variable declaration "" ""int a b c;"" ""/* This is a test"" ""   multiline  "" ""   comment for "" ""   testing */"" ""a = b + c;"" ""}""]\n    **Output:** [""int main()""""{ """"  """"int a b c;""""a = b + c;""""}""]\n    **Explanation:** The line by line code is visualized as below:\n    /*Test program */\n    int main()\n    { \n      // variable declaration \n    int a b c;\n    /* This is a test\n       multiline  \n       comment for \n       testing */\n    a = b + c;\n    }\n    The string /* denotes a block comment including line 1 and lines 6-9. The string // denotes line 4 as comments.\n    The line by line output code is visualized as below:\n    int main()\n    { \n      \n    int a b c;\n    a = b + c;\n    }\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** source = [""a/*comment"" ""line"" ""more_comment*/b""]\n    **Output:** [""ab""]\n    **Explanation:** The original source string is ""a/*comment\nline\nmore_comment*/b"" where we have bolded the newline characters.  After deletion the implicit newline characters are deleted leaving the string ""ab"" which when delimited by newline characters becomes [""ab""].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= source.length <= 100`\n  * `0 <= source[i].length <= 80`\n  * `source[i]` consists of printable **ASCII** characters.\n  * Every open block comment is eventually closed.\n  * There are no single-quote or double-quote in the input.\n\n","# Runtime: 38 ms (Top 74.6%) | Memory: 16.44 MB (Top 25.3%)\n\nclass Solution:\n    def removeComments(self source: List[str]) -> List[str]:\n        ans inComment = [] False\n        new_str = """"\n        for c in source:\n            if not inComment: new_str = """"\n            i n = 0 len(c)\n            # inComment we find */\n            while i < n:\n                if inComment:\n                    if c[i:i + 2] == '*/' and i + 1 < n:\n                        i += 2\n                        inComment = False\n                        continue\n                    i += 1\n                # not in Comment we find /* // and common character\n                else:\n                    if c[i:i + 2] == '/*' and i + 1 < n:\n                        i += 2\n                        inComment = True\n                        continue\n                    if c[i:i + 2] == '//' and i + 1 < n:\n                        break\n                    new_str += c[i]\n                    i += 1\n            if new_str and not inComment:\n                ans.append(new_str)\n                    \n\n        return ans"
Remove Covered Intervals,###  1288\. Remove Covered Intervals\n\nGiven an array `intervals` where `intervals[i] = [li ri]` represent the\ninterval `[li ri)` remove all intervals that are covered by another interval\nin the list.\n\nThe interval `[a b)` is covered by the interval `[c d)` if and only if `c <=\na` and `b <= d`.\n\nReturn _the number of remaining intervals_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** intervals = [[14][36][28]]\n    **Output:** 2\n    **Explanation:** Interval [36] is covered by [28] therefore it is removed.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** intervals = [[14][23]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= intervals.length <= 1000`\n  * `intervals[i].length == 2`\n  * `0 <= li < ri <= 105`\n  * All the given intervals are **unique**.\n\n,# Runtime: 159 ms (Top 46.41%) | Memory: 14.4 MB (Top 92.31%)\nclass Solution:\n    def removeCoveredIntervals(self intervals: List[List[int]]) -> int:\n\n        intervals.sort(key = lambda x: (x[0] -x[1]))\n        current count = intervals[0] 1\n        for i in range(1 len(intervals)):\n            if current[0] <= intervals[i][0] and intervals[i][1] <= current[1]:\n                continue\n            current = intervals[i]\n            count += 1\n        return count\n\n# time and space complexity\n# time: O(nlog(n))\n# space: O(1)
Remove Digit From Number to Maximize Result,"###  2259\. Remove Digit From Number to Maximize Result\n\nYou are given a string `number` representing a **positive integer** and a\ncharacter `digit`.\n\nReturn _the resulting string after removing**exactly one occurrence** of\n_`digit` _from_`number` _such that the value of the resulting string\nin**decimal** form is **maximized**_. The test cases are generated such that\n`digit` occurs at least once in `number`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** number = ""123"" digit = ""3""\n    **Output:** ""12""\n    **Explanation:** There is only one '3' in ""123"". After removing '3' the result is ""12"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** number = ""1231"" digit = ""1""\n    **Output:** ""231""\n    **Explanation:** We can remove the first '1' to get ""231"" or remove the second '1' to get ""123"".\n    Since 231 > 123 we return ""231"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** number = ""551"" digit = ""5""\n    **Output:** ""51""\n    **Explanation:** We can remove either the first or second '5' from ""551"".\n    Both result in the string ""51"".\n    \n\n\n\n**Constraints:**\n\n  * `2 <= number.length <= 100`\n  * `number` consists of digits from `'1'` to `'9'`.\n  * `digit` is a digit from `'1'` to `'9'`.\n  * `digit` occurs at least once in `number`.\n\n",class Solution:\n    def removeDigit(self number: str digit: str) -> str:\n        \n        # Initializing the last index as zero\n        last_index = 0\n        \n        #iterating each number to find the occurences \\n        # and to find if the number is greater than the next element \ \n\n        for num in range(1 len(number)):\n            \n            # Handling [case 1] and [case 2]\n            if number[num-1] == digit:\n                if int(number[num]) > int(number[num-1]):\n                    return number[:num-1] + number[num:]\n                else:\n                    last_index = num - 1\n        \n        # If digit is the last number (last occurence) in the string [case 3]\n        if number[-1] == digit:\n            last_index = len(number) - 1\n\n        return number[:last_index] + number[last_index + 1:]\n
Remove Duplicate Letters,"###  316\. Remove Duplicate Letters\n\nGiven a string `s` remove duplicate letters so that every letter appears once\nand only once. You must make sure your result is **the smallest in\nlexicographical order** among all possible results.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""bcabc""\n    **Output:** ""abc""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""cbacdcbc""\n    **Output:** ""acdb""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `s` consists of lowercase English letters.\n\n\n\n**Note:** This question is the same as 1081:\n<https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/>\n\n","class Solution:\n    def removeDuplicateLetters(self s: str) -> str:\n        \n		last_occ = {}\n		stack = []\n		visited = set()\n\n		for i in range(len(s)):\n			last_occ[s[i]] = i\n\n		for i in range(len(s)):\n\n			if s[i] not in visited:\n				while (stack and stack[-1] > s[i] and last_occ[stack[-1]] > i):\n					visited.remove(stack.pop())\n\n				stack.append(s[i])\n				visited.add(s[i])\n\n		return ''.join(stack)\n"
Remove Duplicates from Sorted Array,###  26\. Remove Duplicates from Sorted Array\n\nGiven an integer array `nums` sorted in **non-decreasing order**  remove the\nduplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm)\nsuch that each unique element appears only **once**. The **relative order** of\nthe elements should be kept the **same**.\n\nSince it is impossible to change the length of the array in some languages\nyou must instead have the result be placed in the **first part** of the array\n`nums`. More formally if there are `k` elements after removing the\nduplicates then the first `k` elements of `nums` should hold the final\nresult. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` _after placing the final result in the first_`k` _slots of_`nums`.\n\nDo **not** allocate extra space for another array. You must do this by\n**modifying the input array[in-place](https://en.wikipedia.org/wiki/In-\nplace_algorithm)** with O(1) extra memory.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\n    \n    \n    int[] nums = [...]; // Input array\n    int[] expectedNums = [...]; // The expected answer with correct length\n    \n    int k = removeDuplicates(nums); // Calls your implementation\n    \n    assert k == expectedNums.length;\n    for (int i = 0; i < k; i++) {\n        assert nums[i] == expectedNums[i];\n    }\n    \n\nIf all assertions pass then your solution will be **accepted**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [112]\n    **Output:** 2 nums = [12_]\n    **Explanation:** Your function should return k = 2 with the first two elements of nums being 1 and 2 respectively.\n    It does not matter what you leave beyond the returned k (hence they are underscores).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0011122334]\n    **Output:** 5 nums = [01234_____]\n    **Explanation:** Your function should return k = 5 with the first five elements of nums being 0 1 2 3 and 4 respectively.\n    It does not matter what you leave beyond the returned k (hence they are underscores).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 3 * 104`\n  * `-100 <= nums[i] <= 100`\n  * `nums` is sorted in **non-decreasing** order.\n\n,class Solution:\n    def removeDuplicates(self nums: List[int]) -> int:\n        i = 1\n        for index in range(1 len(nums)):\n            if(nums[index] != nums[index-1]):\n                nums[i] = nums[index]\n                i += 1\n        return i\n
Remove Duplicates from Sorted Array II,###  80\. Remove Duplicates from Sorted Array II\n\nGiven an integer array `nums` sorted in **non-decreasing order**  remove some\nduplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm)\nsuch that each unique element appears **at most twice**. The **relative\norder** of the elements should be kept the **same**.\n\nSince it is impossible to change the length of the array in some languages\nyou must instead have the result be placed in the **first part** of the array\n`nums`. More formally if there are `k` elements after removing the\nduplicates then the first `k` elements of `nums` should hold the final\nresult. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` _after placing the final result in the first_`k` _slots of_`nums`.\n\nDo **not** allocate extra space for another array. You must do this by\n**modifying the input array[in-place](https://en.wikipedia.org/wiki/In-\nplace_algorithm)** with O(1) extra memory.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\n    \n    \n    int[] nums = [...]; // Input array\n    int[] expectedNums = [...]; // The expected answer with correct length\n    \n    int k = removeDuplicates(nums); // Calls your implementation\n    \n    assert k == expectedNums.length;\n    for (int i = 0; i < k; i++) {\n        assert nums[i] == expectedNums[i];\n    }\n    \n\nIf all assertions pass then your solution will be **accepted**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [111223]\n    **Output:** 5 nums = [11223_]\n    **Explanation:** Your function should return k = 5 with the first five elements of nums being 1 1 2 2 and 3 respectively.\n    It does not matter what you leave beyond the returned k (hence they are underscores).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [001111233]\n    **Output:** 7 nums = [0011233__]\n    **Explanation:** Your function should return k = 7 with the first seven elements of nums being 0 0 1 1 2 3 and 3 respectively.\n    It does not matter what you leave beyond the returned k (hence they are underscores).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 3 * 104`\n  * `-104 <= nums[i] <= 104`\n  * `nums` is sorted in **non-decreasing** order.\n\n,"class Solution(object):\n    def removeDuplicates(self nums):\n        n=len(nums)\n        if n==2:\n            return 2\n        if n==0:\n            return 0\n        if n==1:\n            return 1\n        same=0\n        start=-1\n        end=-1\n        i=0\n        while i<n-1:\n            if nums[i]==nums[i+1] and same==0:\n                same=1\n                start=i+2\n                i+=1\n                continue\n            while i<n-1 and nums[i]==nums[i+1] and same==1:\n                end=i+1\n                i+=1\n            i+=1\n            if start!=-1 and end!=-1:\n                no_of_shifts=end-start+1\n                while i<n:\n                    nums[i-no_of_shifts]=nums[i]\n                    i+=1\n                n=n-no_of_shifts\n                i=start\n            start=-1\n            end=-1\n            same=0\n            \n        return n\n		```"
Remove Duplicates from Sorted List,###  83\. Remove Duplicates from Sorted List\n\nGiven the `head` of a sorted linked list _delete all duplicates such that\neach element appears only once_. Return _the linked list**sorted** as well_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/list1.jpg)\n\n    \n    \n    **Input:** head = [112]\n    **Output:** [12]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)\n\n    \n    \n    **Input:** head = [11233]\n    **Output:** [123]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[0 300]`.\n  * `-100 <= Node.val <= 100`\n  * The list is guaranteed to be **sorted** in ascending order.\n\n,# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self val=0 next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return head\n        cur=head.next\n        prev=head\n        while cur is not None:\n            if cur.val==prev.val:\n                prev.next=cur.next\n            else:\n                prev=cur\n            cur=cur.next\n        return head\n
Remove Duplicates from Sorted List II,###  82\. Remove Duplicates from Sorted List II\n\nGiven the `head` of a sorted linked list _delete all nodes that have\nduplicate numbers leaving only distinct numbers from the original list_.\nReturn _the linked list**sorted** as well_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)\n\n    \n    \n    **Input:** head = [1233445]\n    **Output:** [125]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)\n\n    \n    \n    **Input:** head = [11123]\n    **Output:** [23]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[0 300]`.\n  * `-100 <= Node.val <= 100`\n  * The list is guaranteed to be **sorted** in ascending order.\n\n,# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self val=0 next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteDuplicates(self head: Optional[ListNode]) -> Optional[ListNode]:\n        if (not head):\n            return None\n\n        result = tail = ListNode(-1)\n\n        while(head):\n            curr = head\n            head = head.next\n            hasDup = False\n            while(head) and (curr.val == head.val):\n                hasDup = True\n                headNext = head.next\n                head = None\n                head = headNext\n\n            if (hasDup == False):\n                tail.next = curr\n                tail = tail.next\n                tail.next = None\n\n        return result.next\n\n
Remove Element,###  27\. Remove Element\n\nGiven an integer array `nums` and an integer `val` remove all occurrences of\n`val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-\nplace_algorithm). The relative order of the elements may be changed.\n\nSince it is impossible to change the length of the array in some languages\nyou must instead have the result be placed in the **first part** of the array\n`nums`. More formally if there are `k` elements after removing the\nduplicates then the first `k` elements of `nums` should hold the final\nresult. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` _after placing the final result in the first_`k` _slots of_`nums`.\n\nDo **not** allocate extra space for another array. You must do this by\n**modifying the input array[in-place](https://en.wikipedia.org/wiki/In-\nplace_algorithm)** with O(1) extra memory.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\n    \n    \n    int[] nums = [...]; // Input array\n    int val = ...; // Value to remove\n    int[] expectedNums = [...]; // The expected answer with correct length.\n                                // It is sorted with no values equaling val.\n    \n    int k = removeElement(nums val); // Calls your implementation\n    \n    assert k == expectedNums.length;\n    sort(nums 0 k); // Sort the first k elements of nums\n    for (int i = 0; i < actualLength; i++) {\n        assert nums[i] == expectedNums[i];\n    }\n    \n\nIf all assertions pass then your solution will be **accepted**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3223] val = 3\n    **Output:** 2 nums = [22__]\n    **Explanation:** Your function should return k = 2 with the first two elements of nums being 2.\n    It does not matter what you leave beyond the returned k (hence they are underscores).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [01223042] val = 2\n    **Output:** 5 nums = [01403___]\n    **Explanation:** Your function should return k = 5 with the first five elements of nums containing 0 0 1 3 and 4.\n    Note that the five elements can be returned in any order.\n    It does not matter what you leave beyond the returned k (hence they are underscores).\n    \n\n\n\n**Constraints:**\n\n  * `0 <= nums.length <= 100`\n  * `0 <= nums[i] <= 50`\n  * `0 <= val <= 100`\n\n,"# Runtime: 74 ms (Top 6.53%) | Memory: 13.9 MB (Top 63.16%)\nclass Solution(object):\n    def removeElement(self nums val):\n        """"""\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        """"""\n        step = 0\n        while step < len(nums):\n            if nums[step] == val:\n                nums.pop(step)\n                continue\n            step+=1\n        return len(nums)"
Remove Invalid Parentheses,"###  301\. Remove Invalid Parentheses\n\nGiven a string `s` that contains parentheses and letters remove the minimum\nnumber of invalid parentheses to make the input string valid.\n\nReturn _all the possible results_. You may return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""()())()""\n    **Output:** [""(())()""""()()()""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""(a)())()""\n    **Output:** [""(a())()""""(a)()()""]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = "")(""\n    **Output:** [""""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 25`\n  * `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n  * There will be at most `20` parentheses in `s`.\n\n","# Runtime: 96 ms (Top 83.6%) | Memory: 18.67 MB (Top 9.9%)\n\nclass Solution:\n    def removeInvalidParentheses(self s: str) -> List[str]:\n        ## RC ##\n        ## APPROACH : BACK-TRACKING ##\n        ## Similar to Leetcode 32. Longest Valid Parentheses ##\n        ## LOGIC ##\n        #   1. use stack to find invalid left and right braces.\n        #   2. if its close brace at index i  you can remove it directly to make it valid and also you can also remove any of the close braces before that i.e in the range [0i-1]\n        #   3. similarly for open brace left over at index i you can remove it or any other open brace after that i.e [i+1 end]\n        #   4. if left over braces are more than 1 say 2 close braces here you need to make combinations of all 2 braces before that index and find valid parentheses.\n        #   5. so we count left and right invalid braces and do backtracking removing them\n        \n		## TIME COMPLEXITY : O(2^N) ## (each brace has 2 options: exits or to be removed)\n		## SPACE COMPLEXITY : O(N) ##\n\n        def isValid(s):\n            stack = []\n            for i in range(len(s)):\n                if( s[i] == '(' ):\n                    stack.append( (i'(') )\n                elif( s[i] == ')' ):\n                    if(stack and stack[-1][1] == '('):\n                        stack.pop()\n                    else:\n                        stack.append( (i')') )         # pushing invalid close braces also\n            return len(stack) == 0 stack\n        \n        \n        def dfs( s left right):\n            visited.add(s)\n            if left == 0 and right == 0 and isValid(s)[0]:  res.append(s)\n            for i ch in enumerate(s):\n                if ch != '(' and ch != ')': continue                                    # if it is any other char ignore.\n                if (ch == '(' and left == 0) or (ch == ')' and right == 0): continue    # if left == 0 then removing '(' will only cause imbalance. Hence skip.\n                if s[:i] + s[i+1:] not in visited:\n                    dfs( s[:i] + s[i+1:] left - (ch == '(') right - (ch == ')') )\n        \n        stack = isValid(s)[1]\n        lc = sum([1 for val in stack if val[1] == ""(""]) # num of left braces\n        rc = len(stack) - lc\n        \n        res visited = [] set()\n        dfs(s lc rc)\n        return res"
Remove K Digits,"###  402\. Remove K Digits\n\nGiven string num representing a non-negative integer `num` and an integer\n`k` return _the smallest possible integer after removing_ `k` _digits from_\n`num`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = ""1432219"" k = 3\n    **Output:** ""1219""\n    **Explanation:** Remove the three digits 4 3 and 2 to form the new number 1219 which is the smallest.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = ""10200"" k = 1\n    **Output:** ""200""\n    **Explanation:** Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = ""10"" k = 2\n    **Output:** ""0""\n    **Explanation:** Remove all the digits from the number and it is left with nothing which is 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= num.length <= 105`\n  * `num` consists of only digits.\n  * `num` does not have any leading zeros except for the zero itself.\n\n",# Lets make monotonically growing stack and save the indexes of popped elements into deletes dict.\n#as soon as len(delete) == k delete those indexes from the initial string and thats the answer.\n#if len(delete) < k remove k-len(delete) chars from right and thats the answer\nclass Solution:\n    def removeKdigits(self s: str k: int) -> str:\n        if len(s) == k:\n            return '0'\n        stack = []\n        delete = {}\n        for i in range(len(s)):\n\n            while stack and s[i] < stack[-1][0]:\n                delete[stack.pop()[1]] = 1\n                if len(delete) == k:\n                    break\n            if len(delete) == k:\n                return self.deleteindexes(s delete k)\n            stack.append([s[i] i])\n        s1 = self.deleteindexes(s delete k)\n\n        return str(int(s1[:len(s1)-k +len(delete)]))\n\n\n    def deleteindexes(self s delete k):\n        if not delete:\n            return s\n        if len(delete) == k:\n            return str(int(''.join([c for ind c in enumerate(s) if ind not in delete])))\n        else:\n            return ''.join([c for ind c in enumerate(s) if ind not in delete])\n\n\n
Remove Max Number of Edges to Keep Graph Fully Traversable,###  1579\. Remove Max Number of Edges to Keep Graph Fully Traversable\n\nAlice and Bob have an undirected graph of `n` nodes and three types of edges:\n\n  * Type 1: Can be traversed by Alice only.\n  * Type 2: Can be traversed by Bob only.\n  * Type 3: Can be traversed by both Alice and Bob.\n\nGiven an array `edges` where `edges[i] = [typei ui vi]` represents a\nbidirectional edge of type `typei` between nodes `ui` and `vi` find the\nmaximum number of edges you can remove so that after removing the edges the\ngraph can still be fully traversed by both Alice and Bob. The graph is fully\ntraversed by Alice and Bob if starting from any node they can reach all other\nnodes.\n\nReturn _the maximum number of edges you can remove or return_ `-1` _if Alice\nand Bob cannot fully traverse the graph._\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2020/08/19/ex1.png)**\n\n    \n    \n    **Input:** n = 4 edges = [[312][323][113][124][112][234]]\n    **Output:** 2\n    **Explanation:** If we remove the 2 edges [112] and [113]. The graph will still be fully traversable by Alice and Bob. Removing any additional edge will not make it so. So the maximum number of edges we can remove is 2.\n    \n\n**Example 2:**\n\n**![](https://assets.leetcode.com/uploads/2020/08/19/ex2.png)**\n\n    \n    \n    **Input:** n = 4 edges = [[312][323][114][214]]\n    **Output:** 0\n    **Explanation:** Notice that removing any edge will not make the graph fully traversable by Alice and Bob.\n    \n\n**Example 3:**\n\n**![](https://assets.leetcode.com/uploads/2020/08/19/ex3.png)**\n\n    \n    \n    **Input:** n = 4 edges = [[323][112][234]]\n    **Output:** -1\n    **Explanation:** In the current graph Alice cannot reach node 4 from the other nodes. Likewise Bob cannot reach 1. Therefore it's impossible to make the graph fully traversable.\n\n\n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `1 <= edges.length <= min(105 3 * n * (n - 1) / 2)`\n  * `edges[i].length == 3`\n  * `1 <= typei <= 3`\n  * `1 <= ui < vi <= n`\n  * All tuples `(typei ui vi)` are distinct.\n\n,class DSUF:\n    def __init__(self n):\n        self.arr = [-1] * n\n    def find(self node):\n        p = self.arr[node]\n        if p == -1:\n            return node\n        self.arr[node] = self.find(p)\n        return self.arr[node]\n    def union(self a b):\n        aP = self.find(a)\n        bP = self.find(b)\n        if aP == bP:\n            return 0\n        self.arr[aP] = bP\n        return 1\n    def countParents(self):\n        count = 0\n        for i in self.arr:\n            if i == -1:\n                count += 1\n        return count\n\nclass Solution:\n    def maxNumEdgesToRemove(self n: int edges: List[List[int]]) -> int:\n        # Solution - DSU\n        # Time - O(ElogV)\n        # Space - O(V)\n        \n        aliceSet = DSUF(n)\n        bobSet = DSUF(n)\n        \n        bothEdges = []\n        bobEdges = []\n        aliceEdges= []\n        for i in range(len(edges)):\n            if edges[i][0] == 3:\n                bothEdges.append(edges[i])\n            elif edges[i][0] == 1:\n                aliceEdges.append(edges[i])\n            else:\n                bobEdges.append(edges[i])\n        \n        usedEdgeCount = 0\n        \n        # connect both edges\n        for edge in bothEdges:\n            aReq = aliceSet.union(edge[1]-1 edge[2]-1)\n            bReq = bobSet.union(edge[1]-1 edge[2]-1)\n            if aReq and bReq:\n                usedEdgeCount += 1\n        \n        # connect individual edges\n        for edge in aliceEdges:\n            usedEdgeCount += aliceSet.union(edge[1]-1 edge[2]-1)\n        \n        for edge in bobEdges:\n            usedEdgeCount += bobSet.union(edge[1]-1 edge[2]-1)\n        \n        if aliceSet.countParents() == 1 and bobSet.countParents() == 1:\n            return len(edges) - usedEdgeCount\n        \n        return -1\n
Remove One Element to Make the Array Strictly Increasing,###  1909\. Remove One Element to Make the Array Strictly Increasing\n\nGiven a **0-indexed** integer array `nums` return `true` _if it can be\nmade**strictly increasing** after removing **exactly one** element or\n_`false` _otherwise. If the array is already strictly increasing\nreturn_`true`.\n\nThe array `nums` is **strictly increasing** if `nums[i - 1] < nums[i]` for\neach index `(1 <= i < nums.length).`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12_10_ 57]\n    **Output:** true\n    **Explanation:** By removing 10 at index 2 from nums it becomes [1257].\n    [1257] is strictly increasing so return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2312]\n    **Output:** false\n    **Explanation:**\n    [312] is the result of removing the element at index 0.\n    [212] is the result of removing the element at index 1.\n    [232] is the result of removing the element at index 2.\n    [231] is the result of removing the element at index 3.\n    No resulting array is strictly increasing so return false.\n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [111]\n    **Output:** false\n    **Explanation:** The result of removing any element is [11].\n    [11] is not strictly increasing so return false.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 1000`\n\n,class Solution:\n    def canBeIncreasing(self nums: List[int]) -> bool:\n        indx = -1\n        count = 0\n        n = len(nums)\n        \n        # count the number of non-increasing elements\n        for i in range(n-1):\n            if nums[i] >= nums[i+1]:\n                indx = i\n                count += 1\n        \n        #the cases explained above\n        if count==0:\n            return True\n        \n        if count == 1:\n            if indx == 0 or indx == n-2:\n                return True\n            if nums[indx-1] < nums[indx+1] or(indx+2 < n and nums[indx] < nums[indx+2]):\n                return True\n            \n        return False\n
Remove Outermost Parentheses,"###  1021\. Remove Outermost Parentheses\n\nA valid parentheses string is either empty `""""` `""("" + A + "")""` or `A + B`\nwhere `A` and `B` are valid parentheses strings and `+` represents string\nconcatenation.\n\n  * For example `""""` `""()""` `""(())()""` and `""(()(()))""` are all valid parentheses strings.\n\nA valid parentheses string `s` is primitive if it is nonempty and there does\nnot exist a way to split it into `s = A + B` with `A` and `B` nonempty valid\nparentheses strings.\n\nGiven a valid parentheses string `s` consider its primitive decomposition: `s\n= P1 + P2 + ... + Pk` where `Pi` are primitive valid parentheses strings.\n\nReturn `s` _after removing the outermost parentheses of every primitive string\nin the primitive decomposition of_`s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""(()())(())""\n    **Output:** ""()()()""\n    **Explanation:** \n    The input string is ""(()())(())"" with primitive decomposition ""(()())"" + ""(())"".\n    After removing outer parentheses of each part this is ""()()"" + ""()"" = ""()()()"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""(()())(())(()(()))""\n    **Output:** ""()()()()(())""\n    **Explanation:** \n    The input string is ""(()())(())(()(()))"" with primitive decomposition ""(()())"" + ""(())"" + ""(()(()))"".\n    After removing outer parentheses of each part this is ""()()"" + ""()"" + ""()(())"" = ""()()()()(())"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""()()""\n    **Output:** """"\n    **Explanation:** \n    The input string is ""()()"" with primitive decomposition ""()"" + ""()"".\n    After removing outer parentheses of each part this is """" + """" = """".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is either `'('` or `')'`.\n  * `s` is a valid parentheses string.\n\n",class Solution:\n    def removeOuterParentheses(self s: str) -> str:\n        c=0\n        res=''\n        for i in s:\n            if i==')' and c==1:\n                c=c-1\n            elif i=='(' and c==0:\n                c=c+1\n            elif i=='(':\n                res=res+'('\n                c=c+1\n            elif i==')':\n                res=res+')'\n                c=c-1\n        return res\n
Remove Palindromic Subsequences,"###  1332\. Remove Palindromic Subsequences\n\nYou are given a string `s` consisting **only** of letters `'a'` and `'b'`. In\na single step you can remove one **palindromic subsequence** from `s`.\n\nReturn _the**minimum** number of steps to make the given string empty_.\n\nA string is a **subsequence** of a given string if it is generated by deleting\nsome characters of a given string without changing its order. Note that a\nsubsequence does **not** necessarily need to be contiguous.\n\nA string is called **palindrome** if is one that reads the same backward as\nwell as forward.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ababa""\n    **Output:** 1\n    **Explanation:** s is already a palindrome so its entirety can be removed in a single step.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abb""\n    **Output:** 2\n    **Explanation:** ""_a_ bb"" -> ""_bb_ "" -> """". \n    Remove palindromic subsequence ""a"" then ""bb"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""baabb""\n    **Output:** 2\n    **Explanation:** ""_baa_ b _b_ "" -> ""_b_ "" -> """". \n    Remove palindromic subsequence ""baab"" then ""b"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s[i]` is either `'a'` or `'b'`.\n\n",class Solution:\n    def removePalindromeSub(self s: str) -> int:\n        return 1 if s[::-1] == s else 2\n        
Remove Stones to Minimize the Total,###  1962\. Remove Stones to Minimize the Total\n\nYou are given a **0-indexed** integer array `piles` where `piles[i]`\nrepresents the number of stones in the `ith` pile and an integer `k`. You\nshould apply the following operation **exactly** `k` times:\n\n  * Choose any `piles[i]` and **remove** `floor(piles[i] / 2)` stones from it.\n\n**Notice** that you can apply the operation on the **same** pile more than\nonce.\n\nReturn _the**minimum** possible total number of stones remaining after\napplying the _`k` _operations_.\n\n`floor(x)` is the **greatest** integer that is **smaller** than or **equal**\nto `x` (i.e. rounds `x` down).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** piles = [549] k = 2\n    **Output:** 12\n    **Explanation:**  Steps of a possible scenario are:\n    - Apply the operation on pile 2. The resulting piles are [54_5_].\n    - Apply the operation on pile 0. The resulting piles are [_3_ 45].\n    The total number of stones in [345] is 12.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** piles = [4367] k = 3\n    **Output:** 12\n    **Explanation:**  Steps of a possible scenario are:\n    - Apply the operation on pile 2. The resulting piles are [43_3_ 7].\n    - Apply the operation on pile 3. The resulting piles are [433_4_].\n    - Apply the operation on pile 0. The resulting piles are [_2_ 334].\n    The total number of stones in [2334] is 12.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= piles.length <= 105`\n  * `1 <= piles[i] <= 104`\n  * `1 <= k <= 105`\n\n,class Solution:\n    def minStoneSum(self piles: List[int] k: int) -> int:\n        heap = [-p for p in piles]\n        heapq.heapify(heap)\n        for _ in range(k):\n            cur = -heapq.heappop(heap)\n            heapq.heappush(heap -(cur-cur//2))\n        return -sum(heap)            \n
Remove Sub-Folders from the Filesystem,"###  1233\. Remove Sub-Folders from the Filesystem\n\nGiven a list of folders `folder` return _the folders after removing all**sub-\nfolders** in those folders_. You may return the answer in **any order**.\n\nIf a `folder[i]` is located within another `folder[j]` it is called a **sub-\nfolder** of it.\n\nThe format of a path is one or more concatenated strings of the form: `'/'`\nfollowed by one or more lowercase English letters.\n\n  * For example `""/leetcode""` and `""/leetcode/problems""` are valid paths while an empty string and `""/""` are not.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** folder = [""/a""""/a/b""""/c/d""""/c/d/e""""/c/f""]\n    **Output:** [""/a""""/c/d""""/c/f""]\n    **Explanation:** Folders ""/a/b"" is a subfolder of ""/a"" and ""/c/d/e"" is inside of folder ""/c/d"" in our filesystem.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** folder = [""/a""""/a/b/c""""/a/b/d""]\n    **Output:** [""/a""]\n    **Explanation:** Folders ""/a/b/c"" and ""/a/b/d"" will be removed because they are subfolders of ""/a"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** folder = [""/a/b/c""""/a/b/ca""""/a/b/d""]\n    **Output:** [""/a/b/c""""/a/b/ca""""/a/b/d""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= folder.length <= 4 * 104`\n  * `2 <= folder[i].length <= 100`\n  * `folder[i]` contains only lowercase letters and `'/'`.\n  * `folder[i]` always starts with the character `'/'`.\n  * Each folder name is **unique**.\n\n","# a TrieNode class for creating new node\nclass TrieNode():\n    def __init__(self):\n        self.children = {}\n        self.main = False\n        \n# the main class\nclass Solution(object):\n    def removeSubfolders(self folder):     \n        node = TrieNode()\n        res = []\n        # sort the list to prevent adding the subfolder to the Trie first\n        folder.sort()\n        for dir in folder:\n            name = dir.split(""/"")\n            if self.addTrie(namenode):\n                res.append(dir)\n        return res\n\n    # usign the same addTrie template and modify the else part\n    def addTrie(selfnamenode):    \n        trie = node\n        for c in name:\n            if c not in trie.children:\n                trie.children[c] = TrieNode()\n            # if char is in trie\n            else:\n                # check if it's the last sub folder. \n                if trie.children[c].main == True:\n                    return False\n            trie = trie.children[c]\n        trie.main = True\n        return True\n"
Removing Minimum and Maximum From Array,###  2091\. Removing Minimum and Maximum From Array\n\nYou are given a **0-indexed** array of **distinct** integers `nums`.\n\nThere is an element in `nums` that has the **lowest** value and an element\nthat has the **highest** value. We call them the **minimum** and **maximum**\nrespectively. Your goal is to remove **both** these elements from the array.\n\nA **deletion** is defined as either removing an element from the **front** of\nthe array or removing an element from the **back** of the array.\n\nReturn _the**minimum** number of deletions it would take to remove **both**\nthe minimum and maximum element from the array._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [2_**10**_ 754_**1**_ 86]\n    **Output:** 5\n    **Explanation:** \n    The minimum element in the array is nums[5] which is 1.\n    The maximum element in the array is nums[1] which is 10.\n    We can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back.\n    This results in 2 + 3 = 5 deletions which is the minimum number possible.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0_**-4**_ _**19**_ 18-2-35]\n    **Output:** 3\n    **Explanation:** \n    The minimum element in the array is nums[1] which is -4.\n    The maximum element in the array is nums[2] which is 19.\n    We can remove both the minimum and maximum by removing 3 elements from the front.\n    This results in only 3 deletions which is the minimum number possible.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [_**101**_]\n    **Output:** 1\n    **Explanation:**  \n    There is only one element in the array which makes it both the minimum and maximum element.\n    We can remove it with 1 deletion.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-105 <= nums[i] <= 105`\n  * The integers in `nums` are **distinct**.\n\n,class Solution:\n    def minimumDeletions(self nums: List[int]) -> int:\n        minFromFront = nums.index(min(nums))\n        maxFromFront = nums.index(max(nums))\n        \n        minFromBack = len(nums) - minFromFront - 1\n        maxFromBack = len(nums) - maxFromFront - 1 \n        \n        return min(max(minFromFront maxFromFront) + 1  # Case 1\n                   max(minFromBack maxFromBack) + 1    # Case 2\n                   minFromBack + maxFromFront + 2       # Case 3 \n                   minFromFront + maxFromBack + 2)       # Case 4\n
Removing Minimum Number of Magic Beans,###  2171\. Removing Minimum Number of Magic Beans\n\nYou are given an array of **positive** integers `beans` where each integer\nrepresents the number of magic beans found in a particular magic bag.\n\n**Remove** any number of beans (**possibly none**) from each bag such that the\nnumber of beans in each remaining **non-empty** bag (still containing **at\nleast one** bean) is **equal**. Once a bean has been removed from a bag you\nare **not** allowed to return it to any of the bags.\n\nReturn _the**minimum** number of magic beans that you have to remove_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** beans = [4_**1**_ 65]\n    **Output:** 4\n    **Explanation:** \n    - We remove 1 bean from the bag with only 1 bean.\n      This results in the remaining bags: [4**_0_** 65]\n    - Then we remove 2 beans from the bag with 6 beans.\n      This results in the remaining bags: [40**_4_** 5]\n    - Then we remove 1 bean from the bag with 5 beans.\n      This results in the remaining bags: [404**_4_**]\n    We removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.\n    There are no other solutions that remove 4 beans or fewer.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** beans = [**_2_** 10_**3**_ **_2_**]\n    **Output:** 7\n    **Explanation:**\n    - We remove 2 beans from one of the bags with 2 beans.\n      This results in the remaining bags: [_**0**_ 1032]\n    - Then we remove 2 beans from the other bag with 2 beans.\n      This results in the remaining bags: [0103_**0**_]\n    - Then we remove 3 beans from the bag with 3 beans. \n      This results in the remaining bags: [010_**0**_ 0]\n    We removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.\n    There are no other solutions that removes 7 beans or fewer.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= beans.length <= 105`\n  * `1 <= beans[i] <= 105`\n\n,// Runtime: 1076 ms (Top 41.88%) | Memory: 30.80 MB (Top 35.63%)\n\nclass Solution:\n    def minimumRemoval(self A: List[int]) -> int:\n        return sum(A) - max((len(A) - i) * n for i n in enumerate(sorted(A)))\n
Reorder List,###  143\. Reorder List\n\nYou are given the head of a singly linked-list. The list can be represented\nas:\n\n    \n    \n    L0 → L1 → … → Ln - 1 → Ln\n    \n\n_Reorder the list to be on the following form:_\n\n    \n    \n    L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …\n    \n\nYou may not modify the values in the list's nodes. Only nodes themselves may\nbe changed.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg)\n\n    \n    \n    **Input:** head = [1234]\n    **Output:** [1423]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg)\n\n    \n    \n    **Input:** head = [12345]\n    **Output:** [15243]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[1 5 * 104]`.\n  * `1 <= Node.val <= 1000`\n\n,class Solution:\n    def reverse(self  head):\n        prev = None\n        after = None\n        curr = head\n        while(curr):\n            after = curr.next\n            curr.next = prev\n            prev = curr\n            curr = after\n        return prev\n            \n    def find_middle(self  head):\n        slow = head\n        fast = head\n        while(fast and fast.next):\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n        \n    def reorderList(self head: Optional[ListNode]) -> None:\n        mid = self.find_middle(head)\n        rev = self.reverse(mid)\n        first = head\n        second = rev\n        \n        while(second.next):\n            temp = first.next\n            first.next = second\n            first = temp\n            \n            temp = second.next\n            second.next = first\n            second = temp\n            \n
Reorder Routes to Make All Paths Lead to the City Zero,###  1466\. Reorder Routes to Make All Paths Lead to the City Zero\n\nThere are `n` cities numbered from `0` to `n - 1` and `n - 1` roads such that\nthere is only one way to travel between two different cities (this network\nform a tree). Last year The ministry of transport decided to orient the roads\nin one direction because they are too narrow.\n\nRoads are represented by `connections` where `connections[i] = [ai bi]`\nrepresents a road from city `ai` to city `bi`.\n\nThis year there will be a big event in the capital (city `0`) and many\npeople want to travel to this city.\n\nYour task consists of reorienting some roads such that each city can visit the\ncity `0`. Return the **minimum** number of edges changed.\n\nIt's **guaranteed** that each city can reach city `0` after reorder.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png)\n\n    \n    \n    **Input:** n = 6 connections = [[01][13][23][40][45]]\n    **Output:** 3\n    **Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/05/13/sample_2_1819.png)\n\n    \n    \n    **Input:** n = 5 connections = [[10][12][32][34]]\n    **Output:** 2\n    **Explanation:** Change the direction of edges show in red such that each node can reach the node 0 (capital).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3 connections = [[10][20]]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 5 * 104`\n  * `connections.length == n - 1`\n  * `connections[i].length == 2`\n  * `0 <= ai bi <= n - 1`\n  * `ai != bi`\n\n,"from collections import defaultdict\nclass Solution:\n    def minReorder(self n: int connections: List[List[int]]) -> int:\n        count stack visited = 0 [ 0 ] set() #Add root node to stack\n        neighbours = defaultdict(list) #To store neighbours\n		adjacency = defaultdict(list) #To store adjacency\n        for i j in connections:\n            adjacency[i].append(j)\n            neighbours[i].append(j)\n            neighbours[j].append(i)\n        while stack:\n            current = stack.pop()\n            if current in visited:\n                continue\n            else:\n                visited.add(current)\n            for i in neighbours[current]:\n                if i in visited:\n                    continue\n                if current not in adjacency[i]:\n                    count += 1\n                stack.append(i)\n        return count\n"
Repeated DNA Sequences,"###  187\. Repeated DNA Sequences\n\nThe **DNA sequence** is composed of a series of nucleotides abbreviated as\n`'A'` `'C'` `'G'` and `'T'`.\n\n  * For example `""ACGAATTCCG""` is a **DNA sequence**.\n\nWhen studying **DNA**  it is useful to identify repeated sequences within the\nDNA.\n\nGiven a string `s` that represents a **DNA sequence**  return all the\n**`10`-letter-long** sequences (substrings) that occur more than once in a DNA\nmolecule. You may return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT""\n    **Output:** [""AAAAACCCCC""""CCCCCAAAAA""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""AAAAAAAAAAAAA""\n    **Output:** [""AAAAAAAAAA""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is either `'A'` `'C'` `'G'` or `'T'`.\n\n","# Runtime: 147 ms (Top 16.98%) | Memory: 27.7 MB (Top 15.14%)\nclass Solution(object):\n    def findRepeatedDnaSequences(self s):\n        """"""\n        :type s: str\n        :rtype: List[str]\n        """"""\n        seqs = {}\n        i = 0\n        while i+10 <= len(s):\n            curr = s[i:i+10]\n            if curr in seqs:\n                seqs[curr] = seqs[curr] + 1\n            else:\n                seqs[curr] = 1\n            i += 1\n\n        repeats = []\n        for seq in list(seqs.keys()):\n            if seqs[seq] > 1:\n                repeats.append(seq)\n\n        return repeats"
Repeated String Match,"###  686\. Repeated String Match\n\nGiven two strings `a` and `b` return _the minimum number of times you should\nrepeat string_`a` _so that string_ `b` _is a substring of it_. If it is\nimpossible for `b`​​​​​​ to be a substring of `a` after repeating\nit return `-1`.\n\n**Notice:** string `""abc""` repeated 0 times is `""""` repeated 1 time is\n`""abc""` and repeated 2 times is `""abcabc""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** a = ""abcd"" b = ""cdabcdab""\n    **Output:** 3\n    **Explanation:** We return 3 because by repeating a three times ""ab**cdabcdab** cd"" b is a substring of it.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** a = ""a"" b = ""aa""\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= a.length b.length <= 104`\n  * `a` and `b` consist of lowercase English letters.\n\n",// Runtime: 30 ms (Top 95.42%) | Memory: 16.60 MB (Top 60.78%)\n\nclass Solution:\n    def repeatedStringMatch(self A: str B: str) -> int:\n        if len(A) >= len(B):\n            if B in A: return 1\n            elif B in A*2: return 2\n            else: return -1\n        prefix = max(0 B.find(A)) #prefix -- length of A1\n        repeat postfix = divmod(len(B)-prefix len(A)) #postfix -- length of A2\n        repeat += bool(prefix) + bool(postfix)\n        if B in A * repeat: return repeat\n        else: return -1 \n
Repeated Substring Pattern,"###  459\. Repeated Substring Pattern\n\nGiven a string `s` check if it can be constructed by taking a substring of it\nand appending multiple copies of the substring together.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abab""\n    **Output:** true\n    **Explanation:** It is the substring ""ab"" twice.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aba""\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""abcabcabcabc""\n    **Output:** true\n    **Explanation:** It is the substring ""abc"" four times or the substring ""abcabc"" twice.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `s` consists of lowercase English letters.\n\n",class Solution:\n    def repeatedSubstringPattern(self s: str) -> bool:\n        for i in range(1 len(s)//2+1):\n            if s[:i] * (len(s)//i) == s:\n                return True\n        return False
Replace Elements in an Array,###  2295\. Replace Elements in an Array\n\nYou are given a **0-indexed** array `nums` that consists of `n` **distinct**\npositive integers. Apply `m` operations to this array where in the `ith`\noperation you replace the number `operations[i][0]` with `operations[i][1]`.\n\nIt is guaranteed that in the `ith` operation:\n\n  * `operations[i][0]` **exists** in `nums`.\n  * `operations[i][1]` does **not** exist in `nums`.\n\nReturn _the array obtained after applying all the operations_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1246] operations = [[13][47][61]]\n    **Output:** [3271]\n    **Explanation:** We perform the following operations on nums:\n    - Replace the number 1 with 3. nums becomes [_**3**_ 246].\n    - Replace the number 4 with 7. nums becomes [32_**7**_ 6].\n    - Replace the number 6 with 1. nums becomes [327_**1**_].\n    We return the final array [3271].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12] operations = [[13][21][32]]\n    **Output:** [21]\n    **Explanation:** We perform the following operations to nums:\n    - Replace the number 1 with 3. nums becomes [_**3**_ 2].\n    - Replace the number 2 with 1. nums becomes [3_**1**_].\n    - Replace the number 3 with 2. nums becomes [_**2**_ 1].\n    We return the array [21].\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `m == operations.length`\n  * `1 <= n m <= 105`\n  * All the values of `nums` are **distinct**.\n  * `operations[i].length == 2`\n  * `1 <= nums[i] operations[i][0] operations[i][1] <= 106`\n  * `operations[i][0]` will exist in `nums` when applying the `ith` operation.\n  * `operations[i][1]` will not exist in `nums` when applying the `ith` operation.\n\n,class Solution:\n    def arrayChange(self nums: List[int] operations: List[List[int]]) -> List[int]:\n            replacements = {}\n            for x y in reversed(operations):\n                replacements[x] = replacements.get(y y)\n            for idx val in enumerate(nums):\n                if val in replacements:\n                    nums[idx] = replacements[val]\n            return nums\n
Replace Elements with Greatest Element on Right Side,###  1299\. Replace Elements with Greatest Element on Right Side\n\nGiven an array `arr` replace every element in that array with the greatest\nelement among the elements to its right and replace the last element with\n`-1`.\n\nAfter doing so return the array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [17185461]\n    **Output:** [186661-1]\n    **Explanation:** \n    - index 0 --> the greatest element to the right of index 0 is index 1 (18).\n    - index 1 --> the greatest element to the right of index 1 is index 4 (6).\n    - index 2 --> the greatest element to the right of index 2 is index 4 (6).\n    - index 3 --> the greatest element to the right of index 3 is index 4 (6).\n    - index 4 --> the greatest element to the right of index 4 is index 5 (1).\n    - index 5 --> there are no elements to the right of index 5 so we put -1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [400]\n    **Output:** [-1]\n    **Explanation:** There are no elements to the right of index 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 104`\n  * `1 <= arr[i] <= 105`\n\n,class Solution:\n    def replaceElements(self arr: List[int]) -> List[int]:\n        maxright = arr[-1]\n        for i in range(len(arr) -1-1-1):\n            temp = arr[i]\n            arr[i] = maxright\n            if temp > maxright:\n                maxright = temp\n        arr[-1] = -1\n        \n        return arr\n
Replace Non-Coprime Numbers in Array,###  2197\. Replace Non-Coprime Numbers in Array\n\nYou are given an array of integers `nums`. Perform the following steps:\n\n  1. Find **any** two **adjacent** numbers in `nums` that are **non-coprime**.\n  2. If no such numbers are found **stop** the process.\n  3. Otherwise delete the two numbers and **replace** them with their **LCM (Least Common Multiple)**.\n  4. **Repeat** this process as long as you keep finding two adjacent non-coprime numbers.\n\nReturn _the**final** modified array._ It can be shown that replacing adjacent\nnon-coprime numbers in **any** arbitrary order will lead to the same result.\n\nThe test cases are generated such that the values in the final array are\n**less than or equal** to `108`.\n\nTwo values `x` and `y` are **non-coprime** if `GCD(x y) > 1` where `GCD(x\ny)` is the **Greatest Common Divisor** of `x` and `y`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [6432762]\n    **Output:** [1276]\n    **Explanation:** \n    - (6 4) are non-coprime with LCM(6 4) = 12. Now nums = [**_12_** 32762].\n    - (12 3) are non-coprime with LCM(12 3) = 12. Now nums = [**_12_** 2762].\n    - (12 2) are non-coprime with LCM(12 2) = 12. Now nums = [**_12_** 762].\n    - (6 2) are non-coprime with LCM(6 2) = 6. Now nums = [127_**6**_].\n    There are no more adjacent non-coprime numbers in nums.\n    Thus the final modified array is [1276].\n    Note that there are other ways to obtain the same resultant array.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2211333]\n    **Output:** [2113]\n    **Explanation:** \n    - (3 3) are non-coprime with LCM(3 3) = 3. Now nums = [2211_**3**_ 3].\n    - (3 3) are non-coprime with LCM(3 3) = 3. Now nums = [2211_**3**_].\n    - (2 2) are non-coprime with LCM(2 2) = 2. Now nums = [_**2**_ 113].\n    There are no more adjacent non-coprime numbers in nums.\n    Thus the final modified array is [2113].\n    Note that there are other ways to obtain the same resultant array.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 105`\n  * The test cases are generated such that the values in the final array are **less than or equal** to `108`.\n\n,class Solution:\n    def replaceNonCoprimes(self nums: List[int]) -> List[int]:\n        res = []\n        for num in nums:\n            while res and gcd(res[-1] num) > 1:\n                num = lcm(res[-1] num)\n                res.pop()\n            res.append(num)\n        return res\n
Replace Words,"###  648\. Replace Words\n\nIn English we have a concept called **root**  which can be followed by some\nother word to form another longer word - let's call this word **successor**.\nFor example when the **root** `""an""` is followed by the **successor** word\n`""other""` we can form a new word `""another""`.\n\nGiven a `dictionary` consisting of many **roots** and a `sentence` consisting\nof words separated by spaces replace all the **successors** in the sentence\nwith the **root** forming it. If a **successor** can be replaced by more than\none **root**  replace it with the **root** that has **the shortest length**.\n\nReturn _the`sentence`_ after the replacement.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** dictionary = [""cat""""bat""""rat""] sentence = ""the cattle was rattled by the battery""\n    **Output:** ""the cat was rat by the bat""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** dictionary = [""a""""b""""c""] sentence = ""aadsfasf absbs bbab cadsfafs""\n    **Output:** ""a a b c""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= dictionary.length <= 1000`\n  * `1 <= dictionary[i].length <= 100`\n  * `dictionary[i]` consists of only lower-case letters.\n  * `1 <= sentence.length <= 106`\n  * `sentence` consists of only lower-case letters and spaces.\n  * The number of words in `sentence` is in the range `[1 1000]`\n  * The length of each word in `sentence` is in the range `[1 1000]`\n  * Every two consecutive words in `sentence` will be separated by exactly one space.\n  * `sentence` does not have leading or trailing spaces.\n\n","class Solution {\npublic:\n    class trii{\n        public:\n        char data;\n        trii* dict[26];\n        bool isTerminal;\n        \n        trii(){\n            \n        }\n        \n        trii(char d){\n           data=d;\n            for(int i=0;i<26;i++){\n                dict[i]=NULL;\n            }\n            isTerminal=false;\n        }\n    };\n    \n    class tree{\n        public:\n        trii* root;\n        tree(){\n            root=new trii('\0');\n        }\n        \n        void insert(string strtrii* node){\n            if(str.size()==0){\n                node->isTerminal=true;\n                return;\n            }\n            int index=str[0]-'a';\n            if(node->dict[index]==NULL ){\n                node->dict[index]=new trii(str[0]);\n            }\n            insert(str.substr(1)node->dict[index]);\n        }\n        \n        string find(string strtrii* nodestring pre){\n            if( node->isTerminal==true ){\n                return pre; \n            }            \n            int index=str[0]-'a';\n            if(str.size()==0 || node->dict[index]==NULL){\n                return ""\0"";\n            }\n           return find(str.substr(1)node->dict[index]pre+str[0]);\n        }\n        \n        string replaceWith(string word trii* node){\n            string temp=find(wordnode"""");\n            if(temp!=""\0""){\n                word=temp;\n            }\n            return word;\n        }\n    };\n    \n    string replaceWords(vector<string>& dictionary string sentence) {\n       tree* t=new tree();\n        for(int i=0;i<dictionary.size();i++){\n            t->insert(dictionary[i]t->root);\n        }\n        string ans=sentence;\n        sentence="""";\n        for(int i=0;i<ans.size();i++){\n            string word="""";\n            while(i<ans.size()&&ans[i]!=' '){\n                word+=ans[i];\n                i++;\n            }\n            \n            sentence+=t->replaceWith(wordt->root)+"" "";\n        }\n        sentence.pop_back();\n        return sentence;\n    }\n};\n\n"
Reshape the Matrix,###  566\. Reshape the Matrix\n\nIn MATLAB there is a handy function called `reshape` which can reshape an `m\nx n` matrix into a new one with a different size `r x c` keeping its original\ndata.\n\nYou are given an `m x n` matrix `mat` and two integers `r` and `c`\nrepresenting the number of rows and the number of columns of the wanted\nreshaped matrix.\n\nThe reshaped matrix should be filled with all the elements of the original\nmatrix in the same row-traversing order as they were.\n\nIf the `reshape` operation with given parameters is possible and legal output\nthe new reshaped matrix; Otherwise output the original matrix.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg)\n\n    \n    \n    **Input:** mat = [[12][34]] r = 1 c = 4\n    **Output:** [[1234]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg)\n\n    \n    \n    **Input:** mat = [[12][34]] r = 2 c = 4\n    **Output:** [[12][34]]\n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat[i].length`\n  * `1 <= m n <= 100`\n  * `-1000 <= mat[i][j] <= 1000`\n  * `1 <= r c <= 300`\n\n,import numpy\nclass Solution:\n    def matrixReshape(self mat: List[List[int]] r: int c: int) -> List[List[int]]:\n        return numpy.reshape(mat(rc)) if r*c==len(mat)*len(mat[0]) else mat
Restore IP Addresses,"###  93\. Restore IP Addresses\n\nA **valid IP address** consists of exactly four integers separated by single\ndots. Each integer is between `0` and `255` (**inclusive**) and cannot have\nleading zeros.\n\n  * For example `""0.1.2.201""` and `""192.168.1.1""` are **valid** IP addresses but `""0.011.255.245""` `""192.168.1.312""` and `""192.168@1.1""` are **invalid** IP addresses.\n\nGiven a string `s` containing only digits return _all possible valid IP\naddresses that can be formed by inserting dots into_`s`. You are **not**\nallowed to reorder or remove any digits in `s`. You may return the valid IP\naddresses in **any** order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""25525511135""\n    **Output:** [""255.255.11.135""""255.255.111.35""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""0000""\n    **Output:** [""0.0.0.0""]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""101023""\n    **Output:** [""1.0.10.23""""1.0.102.3""""10.1.0.23""""10.10.2.3""""101.0.2.3""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 20`\n  * `s` consists of digits only.\n\n","class Solution:\n    def restoreIpAddresses(self s: str):\n        def isValid(st):\n            if(len(st)!=len(str(int(st)))):\n                return False\n            st = int(st)\n            if(st>255 or st<0):\n                return False\n            return True\n        \n        validIps = []\n        for i in range(14):\n            s1 = s[:i]\n            if(not isValid(s1)):\n                continue\n            for j in range(i+1 min(len(s) i+4)):\n                s2 = s[i:j]\n                if(not isValid(s2)):\n                    continue\n                for k in range(j+1min(len(s) j+4)):\n                    s3 = s[j:k]\n                    if(not isValid(s3)):\n                        continue\n                    s4 = s[k:]\n                    if(not isValid(s4)):\n                        continue\n                    currentIp = s1+"".""+s2+"".""+s3+"".""+s4\n                    validIps.append(currentIp)\n        return validIps\n"
Restore The Array,"###  1416\. Restore The Array\n\nA program was supposed to print an array of integers. The program forgot to\nprint whitespaces and the array is printed as a string of digits `s` and all\nwe know is that all integers in the array were in the range `[1 k]` and there\nare no leading zeros in the array.\n\nGiven the string `s` and the integer `k` return _the number of the possible\narrays that can be printed as_`s` _using the mentioned program_. Since the\nanswer may be very large return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""1000"" k = 10000\n    **Output:** 1\n    **Explanation:** The only possible array is [1000]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""1000"" k = 10\n    **Output:** 0\n    **Explanation:** There cannot be an array that was printed this way and has all integer >= 1 and <= 10.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""1317"" k = 2000\n    **Output:** 8\n    **Explanation:** Possible arrays are [1317][1317][1317][1317][1317][1317][1317][1317]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of only digits and does not contain leading zeros.\n  * `1 <= k <= 109`\n\n","""\n                                1317""\n[1 3 1 7]        -> [1] * nums(317 k)\n[1 3 17]         \n[1 31 7]\n[1 317]   \n[13 1 7]          -> [13] * nums(17 k)\n[13 17]\n[131 7]\n[1317]\n\n\n                            ""2020""    k = 30\n[2000] x\n[2 020] x\n[20 20]\n\n                            ""67890"" k = 90\n\n[6 7890] x\n[6 7 8 9 0] x\n[6 7 8 90]   OK\n[6 78 90]     OK\n[67 8 90]     OK\n[67 89 0] x\n[678 90] x\nbreak because 678 > k (90) so neither 678 6789 would be possible numbers\n\n""""""\n\n\n\nclass Solution:\n    def num_arrays(self s k memo):\n        if not s:\n            return 0\n        memo_ans = memo.get(s)\n        if memo_ans is not None:\n            return memo_ans\n        \n        num = int(s)\n        if num <= k:\n            counter = 1\n        else:\n            counter = 0\n    \n        for i in range(len(s) - 1):\n            # Stop when the number to the right side of the array is greater than k\n            if int(s[:i + 1]) > k:\n                break\n            # Don't count leading zeros\n            if s[i + 1] == ""0"":\n                continue\n            counter += self.num_arrays(s[i + 1:] k memo)\n        ans = counter % (10 ** 9 + 7)\n        memo[s] = ans\n        return ans\n    \n    def numberOfArrays(self s: str k: int) -> int:\n        memo = {}\n        return self.num_arrays(s k memo)\n"
Restore the Array From Adjacent Pairs,###  1743\. Restore the Array From Adjacent Pairs\n\nThere is an integer array `nums` that consists of `n` **unique** elements but\nyou have forgotten it. However you do remember every pair of adjacent\nelements in `nums`.\n\nYou are given a 2D integer array `adjacentPairs` of size `n - 1` where each\n`adjacentPairs[i] = [ui vi]` indicates that the elements `ui` and `vi` are\nadjacent in `nums`.\n\nIt is guaranteed that every adjacent pair of elements `nums[i]` and\n`nums[i+1]` will exist in `adjacentPairs` either as `[nums[i] nums[i+1]]` or\n`[nums[i+1] nums[i]]`. The pairs can appear **in any order**.\n\nReturn _the original array_`nums` _. If there are multiple solutions\nreturn**any of them**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** adjacentPairs = [[21][34][32]]\n    **Output:** [1234]\n    **Explanation:** This array has all its adjacent pairs in adjacentPairs.\n    Notice that adjacentPairs[i] may not be in left-to-right order.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** adjacentPairs = [[4-2][14][-31]]\n    **Output:** [-241-3]\n    **Explanation:** There can be negative numbers.\n    Another solution is [-314-2] which would also be accepted.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** adjacentPairs = [[100000-100000]]\n    **Output:** [100000-100000]\n    \n\n\n\n**Constraints:**\n\n  * `nums.length == n`\n  * `adjacentPairs.length == n - 1`\n  * `adjacentPairs[i].length == 2`\n  * `2 <= n <= 105`\n  * `-105 <= nums[i] ui vi <= 105`\n  * There exists some `nums` that has `adjacentPairs` as its pairs.\n\n,// Runtime: 2248 ms (Top 15.65%) | Memory: 166 MB (Top 35.87%)\nclass Solution:\n    def restoreArray(self adjacentPairs: List[List[int]]) -> List[int]:\n        # create the map\n        adj = collections.defaultdict(list)\n        for a b in adjacentPairs:\n            adj[a].append(b)\n            adj[b].append(a)\n\n        # find the start num\n        start = adjacentPairs[0][0]\n        for k v in adj.items():\n            if len(v) ==1:\n                start = k\n                break\n\n        # dfs to connect the graph\n        nums=[]\n        seen = set()\n        def dfs(num):\n            seen.add(num)\n            for next_num in adj[num]:\n                if next_num in seen: continue\n                dfs(next_num)\n            nums.append(num)\n        dfs(start)\n        return nums\n
Reveal Cards In Increasing Order,###  950\. Reveal Cards In Increasing Order\n\nYou are given an integer array `deck`. There is a deck of cards where every\ncard has a unique integer. The integer on the `ith` card is `deck[i]`.\n\nYou can order the deck in any order you want. Initially all the cards start\nface down (unrevealed) in one deck.\n\nYou will do the following steps repeatedly until all cards are revealed:\n\n  1. Take the top card of the deck reveal it and take it out of the deck.\n  2. If there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\n  3. If there are still unrevealed cards go back to step 1. Otherwise stop.\n\nReturn _an ordering of the deck that would reveal the cards in increasing\norder_.\n\n**Note** that the first entry in the answer is considered to be the top of the\ndeck.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** deck = [1713112357]\n    **Output:** [2133115177]\n    **Explanation:** \n    We get the deck in the order [1713112357] (this order does not matter) and reorder it.\n    After reordering the deck starts as [2133115177] where 2 is the top of the deck.\n    We reveal 2 and move 13 to the bottom.  The deck is now [311517713].\n    We reveal 3 and move 11 to the bottom.  The deck is now [51771311].\n    We reveal 5 and move 17 to the bottom.  The deck is now [7131117].\n    We reveal 7 and move 13 to the bottom.  The deck is now [111713].\n    We reveal 11 and move 17 to the bottom.  The deck is now [1317].\n    We reveal 13 and move 17 to the bottom.  The deck is now [17].\n    We reveal 17.\n    Since all the cards revealed are in increasing order the answer is correct.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** deck = [11000]\n    **Output:** [11000]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= deck.length <= 1000`\n  * `1 <= deck[i] <= 106`\n  * All the values of `deck` are **unique**.\n\n,# Runtime: 61 ms (Top 23.0%) | Memory: 16.70 MB (Top 8.0%)\n\nclass Solution:\n    def deckRevealedIncreasing(self deck: List[int]) -> List[int]:\n        def reveal(n):\n            lst = list(range(n))\n            ans = []\n            i = 0\n            while lst:\n                if not i&1: ans.append(lst.pop(0))\n                else: lst.append(lst.pop(0))\n                i += 1\n            return ans\n        ans = reveal(len(deck))\n        ans = sorted([v i] for i v in enumerate(ans))\n        deck.sort()\n        return (deck[j] for ij in ans)
Reverse Bits,###  190\. Reverse Bits\n\nReverse bits of a given 32 bits unsigned integer.\n\n**Note:**\n\n  * Note that in some languages such as Java there is no unsigned integer type. In this case both input and output will be given as a signed integer type. They should not affect your implementation as the integer's internal binary representation is the same whether it is signed or unsigned.\n  * In Java the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore in **Example 2** above the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 00000010100101000001111010011100\n    **Output:**    964176192 (00111001011110000010100101000000)\n    **Explanation:** The input binary string **00000010100101000001111010011100** represents the unsigned integer 43261596 so return 964176192 which its binary representation is **00111001011110000010100101000000**.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 11111111111111111111111111111101\n    **Output:**   3221225471 (10111111111111111111111111111111)\n    **Explanation:** The input binary string **11111111111111111111111111111101** represents the unsigned integer 4294967293 so return 3221225471 which its binary representation is **10111111111111111111111111111111**.\n    \n\n\n\n**Constraints:**\n\n  * The input must be a **binary string** of length `32`\n\n\n\n**Follow up:** If this function is called many times how would you optimize\nit?\n\n,class Solution:\n# @param n an integer\n# @return an integer\ndef reverseBits(self n):\n    res=0\n    for i in range(32):\n        bit=(n>>i)&1\n        res=res|bit<<(31-i)\n    return res\n
Reverse Integer,###  7\. Reverse Integer\n\nGiven a signed 32-bit integer `x` return `x` _with its digits reversed_. If\nreversing `x` causes the value to go outside the signed 32-bit integer range\n`[-231 231 - 1]` then return `0`.\n\n**Assume the environment does not allow you to store 64-bit integers (signed\nor unsigned).**\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** x = 123\n    **Output:** 321\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** x = -123\n    **Output:** -321\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** x = 120\n    **Output:** 21\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= x <= 231 - 1`\n\n,import bisect\nclass Solution:\n    def reverse(self x: int) -> int:\n\n        flag = 0\n        if x<0:\n            x = abs(x)\n            flag = 1\n            \n        l = [i for i in str(x)]\n        l.reverse()\n        \n        ret = ''.join(l)\n        ret = int(ret)\n        \n        if flag == 1:\n            ret = ret*-1\n            \n        if ((ret >= (-(2**31))) and (ret<=((2**31)-1))):\n            return ret\n        else:\n            return 0\n
Reverse Linked List,###  206\. Reverse Linked List\n\nGiven the `head` of a singly linked list reverse the list and return _the\nreversed list_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n    \n    \n    **Input:** head = [12345]\n    **Output:** [54321]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n\n    \n    \n    **Input:** head = [12]\n    **Output:** [21]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** head = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is the range `[0 5000]`.\n  * `-5000 <= Node.val <= 5000`\n\n\n\n**Follow up:** A linked list can be reversed either iteratively or\nrecursively. Could you implement both?\n\n,# Runtime: 71 ms (Top 18.71%) | Memory: 15.5 MB (Top 28.33%)\n# Definition for singly-linked list.\n# class ListNode:\n# def __init__(self val=0 next=None):\n# self.val = val\n# self.next = next\nclass Solution:\n    def reverseList(self head: Optional[ListNode]) -> Optional[ListNode]:\n        if head==None or head.next==None:\n            return head\n        p = None\n        while(head != None):\n            temp = head.next\n            head.next = p\n            p = head\n            head = temp\n        return p\n
Reverse Linked List II,###  92\. Reverse Linked List II\n\nGiven the `head` of a singly linked list and two integers `left` and `right`\nwhere `left <= right` reverse the nodes of the list from position `left` to\nposition `right` and return _the reversed list_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)\n\n    \n    \n    **Input:** head = [12345] left = 2 right = 4\n    **Output:** [14325]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** head = [5] left = 1 right = 1\n    **Output:** [5]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is `n`.\n  * `1 <= n <= 500`\n  * `-500 <= Node.val <= 500`\n  * `1 <= left <= right <= n`\n\n\n\n**Follow up:** Could you do it in one pass?\n\n,"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self val=0 next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reverseBetween(self head: Optional[ListNode] left: int right: int) -> Optional[ListNode]:\n        # revrese api\n        def reverse(start end):\n            prev = None\n            cur = start\n            while prev != end:\n                nextNode = cur.next\n                cur.next = prev\n                prev = cur\n                cur = nextNode\n            return prev\n        \n        if not head or not head.next or right <= left:\n            return head\n        \n        start end = head head\n        node afterRight = 0 0\n        \n        # At the begining\n        if left == 1:\n            # start index \n            inc = left-1\n            while inc > 0:\n                start = start.next\n                inc -= 1\n            # end index\n            inc = right-1\n            while inc > 0:\n                end = end.next\n                inc -= 1\n            afterRight = end.next\n            reverse(start end)\n            head = end\n        else: # Left other then begining\n            # start index \n            inc = left-2\n            while inc > 0:\n                start = start.next\n                inc -= 1\n            # end index\n            inc = right-1\n            while inc > 0:\n                end = end.next\n                inc -= 1\n            afterRight = end.next\n            begin = start # node before left\n            start = start.next\n            reverse(start end)\n            begin.next = end\n            \n        # If their's ll chain left agter right chain it to the updated ll\n        if afterRight:\n            start.next = afterRight\n\n        return head\n    \n""""""\nTC : O(n)\nSc : O(1)\n\n""""""\n"
Reverse Nodes in Even Length Groups,###  2074\. Reverse Nodes in Even Length Groups\n\nYou are given the `head` of a linked list.\n\nThe nodes in the linked list are **sequentially** assigned to **non-empty**\ngroups whose lengths form the sequence of the natural numbers (`1 2 3 4\n...`). The **length** of a group is the number of nodes assigned to it. In\nother words\n\n  * The `1st` node is assigned to the first group.\n  * The `2nd` and the `3rd` nodes are assigned to the second group.\n  * The `4th` `5th` and `6th` nodes are assigned to the third group and so on.\n\nNote that the length of the last group may be less than or equal to `1 + the\nlength of the second to last group`.\n\n**Reverse** the nodes in each group with an **even** length and return _the_\n`head` _of the modified linked list_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/10/25/eg1.png)\n\n    \n    \n    **Input:** head = [5263917384]\n    **Output:** [5623914837]\n    **Explanation:**\n    - The length of the first group is 1 which is odd hence no reversal occurs.\n    - The length of the second group is 2 which is even hence the nodes are reversed.\n    - The length of the third group is 3 which is odd hence no reversal occurs.\n    - The length of the last group is 4 which is even hence the nodes are reversed.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/10/25/eg2.png)\n\n    \n    \n    **Input:** head = [1106]\n    **Output:** [1016]\n    **Explanation:**\n    - The length of the first group is 1. No reversal occurs.\n    - The length of the second group is 2. The nodes are reversed.\n    - The length of the last group is 1. No reversal occurs.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/11/17/ex3.png)\n\n    \n    \n    **Input:** head = [11065]\n    **Output:** [10156]\n    **Explanation:**\n    - The length of the first group is 1. No reversal occurs.\n    - The length of the second group is 2. The nodes are reversed.\n    - The length of the last group is 2. The nodes are reversed.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[1 105]`.\n  * `0 <= Node.val <= 105`\n\n,# Runtime: 3864 ms (Top 51.07%) | Memory: 53.5 MB (Top 68.62%)\nclass Solution:\n    def reverseEvenLengthGroups(self head: Optional[ListNode]) -> Optional[ListNode]:\n        group = 2\n        tail = head # tail of previous group\n        while tail and tail.next:\n            cnt = 1 # actual size of the current group\n            cur = tail.next # first node of the current group\n            while cur.next and cnt < group:\n                cur = cur.next\n                cnt += 1\n            pre cur = tail tail.next\n            if cnt % 2 == 0: # if group size is even\n                while cnt and cur:\n                    nxt = cur.next\n                    cur.next = pre\n                    pre = cur\n                    cur = nxt\n                    cnt -= 1\n                first = tail.next # first node of the original group\n                first.next = cur\n                tail.next = pre\n                tail = first\n            else:\n                while cnt and cur:\n                    pre cur = cur cur.next\n                    cnt -= 1\n                tail = pre\n            group += 1\n        return head
Reverse Nodes in k-Group,###  25\. Reverse Nodes in k-Group\n\nGiven the `head` of a linked list reverse the nodes of the list `k` at a\ntime and return _the modified list_.\n\n`k` is a positive integer and is less than or equal to the length of the\nlinked list. If the number of nodes is not a multiple of `k` then left-out\nnodes in the end should remain as it is.\n\nYou may not alter the values in the list's nodes only nodes themselves may be\nchanged.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)\n\n    \n    \n    **Input:** head = [12345] k = 2\n    **Output:** [21435]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)\n\n    \n    \n    **Input:** head = [12345] k = 3\n    **Output:** [32145]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is `n`.\n  * `1 <= k <= n <= 5000`\n  * `0 <= Node.val <= 1000`\n\n\n\n**Follow-up:** Can you solve the problem in `O(1)` extra memory space?\n\n,# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self val=0 next=None):\n        self.val = val\n        self.next = next\n\n\nclass Solution:\n    def reverseKGroup(self head: ListNode k: int) -> ListNode:\n\n        # Intialize the result and the current node to the head\n        res = node = head\n\n        # Initialize the index of the current node to 0\n        i = 0\n\n        # Initialize the head and tail of the reversed nodes group to None\n        reversedHead reversedTail = None None\n\n        # Initialize the tail of the previous group to None\n        previousTail = None\n\n        # Iterate through all nodes\n        while node:\n\n            # When we reach the first node in a group\n            if i % k == 0:\n\n                # If there is a previous group connect its tail to the current node\n                # This is the case when we have less than k nodes left\n                if previousTail:\n                    previousTail.next = node\n\n                # Initialize the head and tail of the reversed nodes group\n                reversedHead = reversedTail = ListNode(node.val)\n\n            # Continue to reverse subsequent nodes\n            else:\n                reversedHead = ListNode(node.val reversedHead)\n\n            # If we are able to reach the last node in a reversed nodes group\n            if i % k == k - 1:\n\n                # If there is a previous group connect its tail to the current node\n                # This is the case when we have k nodes and thus we should reverse this group\n                if previousTail:\n                    previousTail.next = reversedHead\n\n                # Set the tail of the previous group to the tail of the reversed nodes group\n                previousTail = reversedTail\n\n            # Set the head of the first reversed nodes group as the result\n            if i == k - 1:\n                res = reversedHead\n\n            # Continue to the next node\n            i node = i + 1 node.next\n\n        return res\n
Reverse Pairs,###  493\. Reverse Pairs\n\nGiven an integer array `nums` return _the number of**reverse pairs** in the\narray_.\n\nA reverse pair is a pair `(i j)` where `0 <= i < j < nums.length` and\n`nums[i] > 2 * nums[j]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13231]\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [24351]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5 * 104`\n  * `-231 <= nums[i] <= 231 - 1`\n\n,"from sortedcontainers import SortedList\nclass Solution:\n    """"""\n    For each sub array nums[0 i]\n    We sum the reverse pairs count\n    of x s.t x in [0 i-1] and nums[x] >= 2 * nums[i] + 1 \n    Using a BST(sortedList) to get logN insert and lookup time.\n    Time: O(NlogN)\n    Space: O(N)\n    """"""\n    def reversePairs(self nums: List[int]) -> int:\n        res = 0\n        bst = SortedList()\n        for e in nums:\n            res += len(bst) - bst.bisect_left(2 * e + 1) # the count is the N - index\n            bst.add(e) # add the the bst\n        return res\n"
Reverse Prefix of Word,"###  2000\. Reverse Prefix of Word\n\nGiven a **0-indexed** string `word` and a character `ch` **reverse** the\nsegment of `word` that starts at index `0` and ends at the index of the\n**first occurrence** of `ch` (**inclusive**). If the character `ch` does not\nexist in `word` do nothing.\n\n  * For example if `word = ""abcdefd""` and `ch = ""d""` then you should **reverse** the segment that starts at `0` and ends at `3` (**inclusive**). The resulting string will be `""_dcba_ efd""`.\n\nReturn _the resulting string_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word = ""_abcd_ efd"" ch = ""d""\n    **Output:** ""_dcba_ efd""\n    **Explanation:**  The first occurrence of ""d"" is at index 3. \n    Reverse the part of word from 0 to 3 (inclusive) the resulting string is ""dcbaefd"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word = ""_xyxz_ xe"" ch = ""z""\n    **Output:** ""_zxyx_ xe""\n    **Explanation:**  The first and only occurrence of ""z"" is at index 3.\n    Reverse the part of word from 0 to 3 (inclusive) the resulting string is ""zxyxxe"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** word = ""abcd"" ch = ""z""\n    **Output:** ""abcd""\n    **Explanation:**  ""z"" does not exist in word.\n    You should not do any reverse operation the resulting string is ""abcd"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word.length <= 250`\n  * `word` consists of lowercase English letters.\n  * `ch` is a lowercase English letter.\n\n","// Runtime: 32 ms (Top 84.42%) | Memory: 16.40 MB (Top 68.29%)\n\nclass Solution:\n    def reversePrefix(self word: str ch: str) -> str:\n        """"""\n        #method 1:\n        for i in range(len(word)):\n            if word[i]==ch:\n                return word[:i+1][::-1]+word[i+1:]\n        return word""""""\n        #method 2:\n        l=0\n        r=word.find(ch)\n        word=list(word)\n        while l<r:\n            word[l]word[r]=word[r]word[l]\n            l+=1\n            r-=1\n        return """".join(word)\n        \n\n                \n\n\n        \n\n            \n"
Reverse String,"###  344\. Reverse String\n\nWrite a function that reverses a string. The input string is given as an array\nof characters `s`.\n\nYou must do this by modifying the input array [in-\nplace](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra\nmemory.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = [""h""""e""""l""""l""""o""]\n    **Output:** [""o""""l""""l""""e""""h""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = [""H""""a""""n""""n""""a""""h""]\n    **Output:** [""h""""a""""n""""n""""a""""H""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s[i]` is a [printable ascii character](https://en.wikipedia.org/wiki/ASCII#Printable_characters).\n\n",# Runtime: 1141 ms (Top 5.04%) | Memory: 18.3 MB (Top 98.71%)\n\nclass Solution(object):\n    def reverseString(self s):\n        for i in range(len(s)):\n            s.insert(is.pop())\n        return s
Reverse String II,"###  541\. Reverse String II\n\nGiven a string `s` and an integer `k` reverse the first `k` characters for\nevery `2k` characters counting from the start of the string.\n\nIf there are fewer than `k` characters left reverse all of them. If there are\nless than `2k` but greater than or equal to `k` characters then reverse the\nfirst `k` characters and leave the other as original.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcdefg"" k = 2\n    **Output:** ""bacdfeg""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcd"" k = 2\n    **Output:** ""bacd""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `s` consists of only lowercase English letters.\n  * `1 <= k <= 104`\n\n","# Runtime: 92 ms (Top 5.11%) | Memory: 14.1 MB (Top 58.38%)\nclass Solution:\n    def reverseStr(self s: str k: int) -> str:\n        a=list(s)\n        for i in range(0len(a)2*k):\n            a[i:i+k]=a[i:i+k][::-1]\n        print(a)\n        return("""".join(a))"
Reverse Subarray To Maximize Array Value,###  1330\. Reverse Subarray To Maximize Array Value\n\nYou are given an integer array `nums`. The _value_ of this array is defined as\nthe sum of `|nums[i] - nums[i + 1]|` for all `0 <= i < nums.length - 1`.\n\nYou are allowed to select any subarray of the given array and reverse it. You\ncan perform this operation **only once**.\n\nFind maximum possible value of the final array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [23154]\n    **Output:** 10\n    **Explanation:** By reversing the subarray [315] the array becomes [25134] whose value is 10.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [249242110]\n    **Output:** 68\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 3 * 104`\n  * `-105 <= nums[i] <= 105`\n\n,"class Solution(object):\n    def maxValueAfterReverse(self nums):\n        """"""\n        :type nums: List[int]\n        :rtype: int\n        """"""\n        # basic idea without fancy stuff  \n        # 1. https://leetcode.com/problems/reverse-subarray-to-maximize-array-value/discuss/489929/O(n)-time-O(1)-space.-In-depth-Explanation\n        # 2. https://code.dennyzhang.com/reverse-subarray-to-maximize-array-value\n        \n        # This can be done in three steps each step taking O(N) time\n        \n        res n = 0 len(nums)\n        \n        # Step 1: Assume that no subarray is reversed and so the sum would just accumulate over all the abs differences\n        for index in range(1 n):\n            res += abs(nums[index] - nums[index - 1])\n        \n        # Step 2: Reversing the left or the right half so basically this idea stems from prefix array type question where in which we have the sum upto ith index but then to get at a specific index we substract extra sum following from that idea. Or refer to the reference 1\n        \n        diff = 0\n        for index in range(n):\n            \n            # reversing from 0th index to current\n            if index + 1 < n:\n                diff = max(diff abs(nums[index + 1] - nums[0]) - abs(nums[index + 1] - nums[index])) # diff between 0 and curr - diff curr and curr + 1\n            \n            # reversing from current to last index n - 1\n            if index > 0:\n                diff = max(diff abs(nums[index - 1] - nums[n - 1]) - abs(nums[index - 1] - nums[index]))\n                \n        \n        # Step 3: We still need to check the middle reverse part we can do this using the min max trick\n        low_number high_number = float(""inf"") float(""-inf"")\n        \n        for index in range(n - 1):\n            \n            low_number = min(low_number max(nums[index] nums[index + 1])) # min of low and the max of the current and next number\n            high_number = max(high_number min(nums[index] nums[index + 1]))\n        \n			diff = max(diff 2 * (high_number - low_number)) # This is explained in ref 1\n        \n        return res + diff\n            \n        \n"
Reverse Substrings Between Each Pair of Parentheses,"###  1190\. Reverse Substrings Between Each Pair of Parentheses\n\nYou are given a string `s` that consists of lower case English letters and\nbrackets.\n\nReverse the strings in each pair of matching parentheses starting from the\ninnermost one.\n\nYour result should **not** contain any brackets.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""(abcd)""\n    **Output:** ""dcba""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""(u(love)i)""\n    **Output:** ""iloveu""\n    **Explanation:** The substring ""love"" is reversed first then the whole string is reversed.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""(ed(et(oc))el)""\n    **Output:** ""leetcode""\n    **Explanation:** First we reverse the substring ""oc"" then ""etco"" and finally the whole string.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 2000`\n  * `s` only contains lower case English characters and parentheses.\n  * It is guaranteed that all parentheses are balanced.\n\n","class Solution:\n    def reverseParentheses(self s: str) -> str:\n        stack = []\n        ans = """"\n        res = deque([])\n        s = list(s)\n        for i in s:\n            if i=="")"":\n                while stack[-1] != ""("":\n                    res.append(stack.pop())\n                stack.pop()\n                while res:\n                    stack.append(res.popleft())\n            else:\n                stack.append(i)\n        return """".join(stack)"
Reverse Vowels of a String,"###  345\. Reverse Vowels of a String\n\nGiven a string `s` reverse only all the vowels in the string and return it.\n\nThe vowels are `'a'` `'e'` `'i'` `'o'` and `'u'` and they can appear in\nboth cases.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""hello""\n    **Output:** ""holle""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""leetcode""\n    **Output:** ""leotcede""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 3 * 105`\n  * `s` consist of **printable ASCII** characters.\n\n","class Solution:\n    def reverseVowels(self s: str) -> str:\n        s=list(s)\n        vow=[]\n        for ival in enumerate(s):\n            if val in ('a''e''i''o''u''A''E''I''O''U'):\n                vow.append(val)\n                s[i]='_'\n                \n        vow=vow[::-1]\n        c=0\n        print(vow)\n        for ival in enumerate(s):\n            if val =='_':\n                s[i]=vow[c]\n                c+=1\n        return """".join(s)\n"
Reverse Words in a String,"###  151\. Reverse Words in a String\n\nGiven an input string `s` reverse the order of the **words**.\n\nA **word** is defined as a sequence of non-space characters. The **words** in\n`s` will be separated by at least one space.\n\nReturn _a string of the words in reverse order concatenated by a single\nspace._\n\n**Note** that `s` may contain leading or trailing spaces or multiple spaces\nbetween two words. The returned string should only have a single space\nseparating the words. Do not include any extra spaces.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""the sky is blue""\n    **Output:** ""blue is sky the""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""  hello world  ""\n    **Output:** ""world hello""\n    **Explanation:** Your reversed string should not contain leading or trailing spaces.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""a good   example""\n    **Output:** ""example good a""\n    **Explanation:** You need to reduce multiple spaces between two words to a single space in the reversed string.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `s` contains English letters (upper-case and lower-case) digits and spaces `' '`.\n  * There is **at least one** word in `s`.\n\n\n\n**Follow-up:  **If the string data type is mutable in your language can you\nsolve it **in-place**  with `O(1)` extra space?\n\n","class Solution:\n    def split(self s: str delimiter="" "") -> List[str]:\n        start end = 0 0\n\n        res = []\n        for ch in s:\n            if ch == delimiter:\n                if start == end:\n                    start += 1\n                else:\n                    res.append(s[start:end])\n                    start  = end + 1\n            \n            end += 1\n        \n        if start != end:\n            res.append(s[start:end])\n\n        return res\n\n    def reverse_list(self ll: List[str]) -> List[str]:\n        l r = 0 len(ll) - 1\n\n        while l < r:\n            ll[l] ll[r] = ll[r] ll[l]\n            l += 1\n            r -= 1\n        \n        return ll\n\n    def reverseWords(self s: str) -> str:\n\n        # split first\n        splitted_str_list = self.split(s)\n\n        # reverse splitted list\n        reversed_str_list = self.reverse_list(splitted_str_list)\n\n        # join an return\n        return "" "".join(reversed_str_list)"
Reverse Words in a String III,"###  557\. Reverse Words in a String III\n\nGiven a string `s` reverse the order of characters in each word within a\nsentence while still preserving whitespace and initial word order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""Let's take LeetCode contest""\n    **Output:** ""s'teL ekat edoCteeL tsetnoc""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""God Ding""\n    **Output:** ""doG gniD""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 5 * 104`\n  * `s` contains printable **ASCII** characters.\n  * `s` does not contain any leading or trailing spaces.\n  * There is **at least one** word in `s`.\n  * All the words in `s` are separated by a single space.\n\n","class Solution:\n    def reverseWords(self s: str) -> str:\n        s = s + ' '\n        l = len(s)\n        t = ''\n        w = ''\n        for i in range(l):\n            if s[i]!=' ':\n                t = s[i] + t  # t stores the word in reverse order\n            else:\n				# w stores the reversed word in the same order\n                w = w + t + ' ' # could have used .join() function and not write .strip()\n                t = """" # value of t is null so that it won't affect upcoming words\n        return w.strip() # removes extra whitespace\n"
Richest Customer Wealth,###  1672\. Richest Customer Wealth\n\nYou are given an `m x n` integer grid `accounts` where `accounts[i][j]` is the\namount of money the `i​​​​​​​​​​​th​​​​`\ncustomer has in the `j​​​​​​​​​​​th`​​​​ bank.\nReturn _the**wealth** that the richest customer has._\n\nA customer's **wealth** is the amount of money they have in all their bank\naccounts. The richest customer is the customer that has the maximum\n**wealth**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** accounts = [[123][321]]\n    **Output:** 6\n    **Explanation****:**\n    1st customer has wealth = 1 + 2 + 3 = 6\n    2nd customer has wealth = 3 + 2 + 1 = 6\n    Both customers are considered the richest with a wealth of 6 each so return 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** accounts = [[15][73][35]]\n    **Output:** 10\n    **Explanation** : \n    1st customer has wealth = 6\n    2nd customer has wealth = 10 \n    3rd customer has wealth = 8\n    The 2nd customer is the richest with a wealth of 10.\n\n**Example 3:**\n\n    \n    \n    **Input:** accounts = [[287][713][195]]\n    **Output:** 17\n    \n\n\n\n**Constraints:**\n\n  * `m == accounts.length`\n  * `n == accounts[i].length`\n  * `1 <= m n <= 50`\n  * `1 <= accounts[i][j] <= 100`\n\n,# Runtime: 132 ms (Top 5.33%) | Memory: 13.9 MB (Top 32.60%)\nclass Solution:\n    def maximumWealth(self accounts: List[List[int]]) -> int:\n        return max(map(sum accounts))
Rings and Rods,"###  2103\. Rings and Rods\n\nThere are `n` rings and each ring is either red green or blue. The rings are\ndistributed **across ten rods** labeled from `0` to `9`.\n\nYou are given a string `rings` of length `2n` that describes the `n` rings\nthat are placed onto the rods. Every two characters in `rings` forms a\n**color-position pair** that is used to describe each ring where:\n\n  * The **first** character of the `ith` pair denotes the `ith` ring's **color** (`'R'` `'G'` `'B'`).\n  * The **second** character of the `ith` pair denotes the **rod** that the `ith` ring is placed on (`'0'` to `'9'`).\n\nFor example `""R3G2B1""` describes `n == 3` rings: a red ring placed onto the\nrod labeled 3 a green ring placed onto the rod labeled 2 and a blue ring\nplaced onto the rod labeled 1.\n\nReturn _the number of rods that have**all three colors** of rings on them._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/11/23/ex1final.png)\n\n    \n    \n    **Input:** rings = ""B0B6G0R6R0R6G9""\n    **Output:** 1\n    **Explanation:** \n    - The rod labeled 0 holds 3 rings with all colors: red green and blue.\n    - The rod labeled 6 holds 3 rings but it only has red and blue.\n    - The rod labeled 9 holds only a green ring.\n    Thus the number of rods with all three colors is 1.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/11/23/ex2final.png)\n\n    \n    \n    **Input:** rings = ""B0R0G0R9R0B0G0""\n    **Output:** 1\n    **Explanation:** \n    - The rod labeled 0 holds 6 rings with all colors: red green and blue.\n    - The rod labeled 9 holds only a red ring.\n    Thus the number of rods with all three colors is 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** rings = ""G4""\n    **Output:** 0\n    **Explanation:** \n    Only one ring is given. Thus no rods have all three colors.\n    \n\n\n\n**Constraints:**\n\n  * `rings.length == 2 * n`\n  * `1 <= n <= 100`\n  * `rings[i]` where `i` is **even** is either `'R'` `'G'` or `'B'` (**0-indexed**).\n  * `rings[i]` where `i` is **odd** is a digit from `'0'` to `'9'` (**0-indexed**).\n\n",# Runtime: 56 ms (Top 27.28%) | Memory: 13.8 MB (Top 63.52%)\nclass Solution:\n    def countPoints(self r: str) -> int:\n        ans = 0\n        for i in range(10):\n            i = str(i)\n            if 'R'+i in r and 'G'+i in r and 'B'+i in r:\n                ans += 1\n        return ans
RLE Iterator,"###  900\. RLE Iterator\n\nWe can use run-length encoding (i.e. **RLE**) to encode a sequence of\nintegers. In a run-length encoded array of even length `encoding`\n(**0-indexed**) for all even `i` `encoding[i]` tells us the number of times\nthat the non-negative integer value `encoding[i + 1]` is repeated in the\nsequence.\n\n  * For example the sequence `arr = [88855]` can be encoded to be `encoding = [3825]`. `encoding = [380925]` and `encoding = [281825]` are also valid **RLE** of `arr`.\n\nGiven a run-length encoded array design an iterator that iterates through it.\n\nImplement the `RLEIterator` class:\n\n  * `RLEIterator(int[] encoded)` Initializes the object with the encoded array `encoded`.\n  * `int next(int n)` Exhausts the next `n` elements and returns the last element exhausted in this way. If there is no element left to exhaust return `-1` instead.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""RLEIterator"" ""next"" ""next"" ""next"" ""next""]\n    [[[3 8 0 9 2 5]] [2] [1] [1] [2]]\n    **Output**\n    [null 8 8 5 -1]\n    \n    **Explanation**\n    RLEIterator rLEIterator = new RLEIterator([3 8 0 9 2 5]); // This maps to the sequence [88855].\n    rLEIterator.next(2); // exhausts 2 terms of the sequence returning 8. The remaining sequence is now [8 5 5].\n    rLEIterator.next(1); // exhausts 1 term of the sequence returning 8. The remaining sequence is now [5 5].\n    rLEIterator.next(1); // exhausts 1 term of the sequence returning 5. The remaining sequence is now [5].\n    rLEIterator.next(2); // exhausts 2 terms returning -1. This is because the first term exhausted was 5\n    but the second term did not exist. Since the last term exhausted does not exist we return -1.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= encoding.length <= 1000`\n  * `encoding.length` is even.\n  * `0 <= encoding[i] <= 109`\n  * `1 <= n <= 109`\n  * At most `1000` calls will be made to `next`.\n\n",# Runtime: 64 ms (Top 41.88%) | Memory: 14.5 MB (Top 71.25%)\nclass RLEIterator:\n\n    def __init__(self encoding: List[int]):\n        self.encoding = encoding\n\n    def next(self n: int) -> int:\n\n        if self.encoding:\n\n            count = self.encoding[0]\n\n            if count >= n:\n                # Partially exhaust and return the current value.\n                self.encoding[0] -= n\n                return self.encoding[1]\n\n            # Exhaust all of current value and continue.\n            self.encoding = self.encoding[2:]\n            return self.next(n - count)\n\n        return -1
Robot Bounded In Circle,"###  1041\. Robot Bounded In Circle\n\nOn an infinite plane a robot initially stands at `(0 0)` and faces north.\nNote that:\n\n  * The **north direction** is the positive direction of the y-axis.\n  * The **south direction** is the negative direction of the y-axis.\n  * The **east direction** is the positive direction of the x-axis.\n  * The **west direction** is the negative direction of the x-axis.\n\nThe robot can receive one of three instructions:\n\n  * `""G""`: go straight 1 unit.\n  * `""L""`: turn 90 degrees to the left (i.e. anti-clockwise direction).\n  * `""R""`: turn 90 degrees to the right (i.e. clockwise direction).\n\nThe robot performs the `instructions` given in order and repeats them\nforever.\n\nReturn `true` if and only if there exists a circle in the plane such that the\nrobot never leaves the circle.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** instructions = ""GGLLGG""\n    **Output:** true\n    **Explanation:** The robot is initially at (0 0) facing the north direction.\n    ""G"": move one step. Position: (0 1). Direction: North.\n    ""G"": move one step. Position: (0 2). Direction: North.\n    ""L"": turn 90 degrees anti-clockwise. Position: (0 2). Direction: West.\n    ""L"": turn 90 degrees anti-clockwise. Position: (0 2). Direction: South.\n    ""G"": move one step. Position: (0 1). Direction: South.\n    ""G"": move one step. Position: (0 0). Direction: South.\n    Repeating the instructions the robot goes into the cycle: (0 0) --> (0 1) --> (0 2) --> (0 1) --> (0 0).\n    Based on that we return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** instructions = ""GG""\n    **Output:** false\n    **Explanation:** The robot is initially at (0 0) facing the north direction.\n    ""G"": move one step. Position: (0 1). Direction: North.\n    ""G"": move one step. Position: (0 2). Direction: North.\n    Repeating the instructions keeps advancing in the north direction and does not go into cycles.\n    Based on that we return false.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** instructions = ""GL""\n    **Output:** true\n    **Explanation:** The robot is initially at (0 0) facing the north direction.\n    ""G"": move one step. Position: (0 1). Direction: North.\n    ""L"": turn 90 degrees anti-clockwise. Position: (0 1). Direction: West.\n    ""G"": move one step. Position: (-1 1). Direction: West.\n    ""L"": turn 90 degrees anti-clockwise. Position: (-1 1). Direction: South.\n    ""G"": move one step. Position: (-1 0). Direction: South.\n    ""L"": turn 90 degrees anti-clockwise. Position: (-1 0). Direction: East.\n    ""G"": move one step. Position: (0 0). Direction: East.\n    ""L"": turn 90 degrees anti-clockwise. Position: (0 0). Direction: North.\n    Repeating the instructions the robot goes into the cycle: (0 0) --> (0 1) --> (-1 1) --> (-1 0) --> (0 0).\n    Based on that we return true.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= instructions.length <= 100`\n  * `instructions[i]` is `'G'` `'L'` or `'R'`.\n\n","# Runtime: 34 ms (Top 89.04%) | Memory: 14 MB (Top 22.71%)\n\nclass Solution:\n    def isRobotBounded(self instructions: str) -> bool:\n        pos d = [00] ""N""\n        def move(d pos instructions):\n            for i in instructions:\n                if i == ""G"":\n                    if d == ""N"": pos[1] += 1\n                    elif d == ""S"": pos[1] -= 1\n                    elif d == ""W"": pos[0] -= 1\n                    else: pos[0] += 1\n                elif i == ""L"":\n                    if d == ""N"": d = ""W""\n                    elif d == ""W"": d = ""S""\n                    elif d == ""S"": d = ""E""\n                    else: d = ""N""\n                else:\n                    if d == ""N"": d = ""E""\n                    elif d == ""W"": d = ""N""\n                    elif d == ""S"": d = ""W""\n                    else: d = ""S""\n            return (d pos)\n        for i in range(4):\n            d pos = (move(d pos instructions))\n        return True if pos == [00] else False"
Roman to Integer,"###  13\. Roman to Integer\n\nRoman numerals are represented by seven different symbols: `I` `V` `X` `L`\n`C` `D` and `M`.\n\n    \n    \n    **Symbol**       **Value**\n    I             1\n    V             5\n    X             10\n    L             50\n    C             100\n    D             500\n    M             1000\n\nFor example `2` is written as `II` in Roman numeral just two ones added\ntogether. `12` is written as `XII` which is simply `X + II`. The number `27`\nis written as `XXVII` which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right.\nHowever the numeral for four is not `IIII`. Instead the number four is\nwritten as `IV`. Because the one is before the five we subtract it making\nfour. The same principle applies to the number nine which is written as `IX`.\nThere are six instances where subtraction is used:\n\n  * `I` can be placed before `V` (5) and `X` (10) to make 4 and 9. \n  * `X` can be placed before `L` (50) and `C` (100) to make 40 and 90. \n  * `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven a roman numeral convert it to an integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""III""\n    **Output:** 3\n    **Explanation:** III = 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""LVIII""\n    **Output:** 58\n    **Explanation:** L = 50 V= 5 III = 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""MCMXCIV""\n    **Output:** 1994\n    **Explanation:** M = 1000 CM = 900 XC = 90 and IV = 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 15`\n  * `s` contains only the characters `('I' 'V' 'X' 'L' 'C' 'D' 'M')`.\n  * It is **guaranteed**  that `s` is a valid roman numeral in the range `[1 3999]`.\n\n","# Runtime: 89 ms (Top 30.66%) | Memory: 13.8 MB (Top 76.49%)\nclass Solution:\n    def romanToInt(self s: str) -> int:\n        roman = {\n            ""I"": 1\n            ""V"": 5\n            ""X"": 10\n            ""L"": 50\n            ""C"": 100\n            ""D"": 500\n            ""M"": 1000\n        }\n\n        sum = 0;\n        for i in range(0 len(s) - 1):\n            curr = roman[s[i]]\n            nxt = roman[s[i + 1]]\n            if curr < nxt:\n                sum -= curr\n            else:\n                sum += curr\n        sum += roman[s[-1]]\n        return sum"
Root Equals Sum of Children,###  2236\. Root Equals Sum of Children\n\nYou are given the `root` of a **binary tree** that consists of exactly `3`\nnodes: the root its left child and its right child.\n\nReturn `true` _if the value of the root is equal to the**sum** of the values\nof its two children or _`false` _otherwise_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/04/08/graph3drawio.png)\n\n    \n    \n    **Input:** root = [1046]\n    **Output:** true\n    **Explanation:** The values of the root its left child and its right child are 10 4 and 6 respectively.\n    10 is equal to 4 + 6 so we return true.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/04/08/graph3drawio-1.png)\n\n    \n    \n    **Input:** root = [531]\n    **Output:** false\n    **Explanation:** The values of the root its left child and its right child are 5 3 and 1 respectively.\n    5 is not equal to 3 + 1 so we return false.\n    \n\n\n\n**Constraints:**\n\n  * The tree consists only of the root its left child and its right child.\n  * `-100 <= Node.val <= 100`\n\n,class Solution:\n    def checkTree(self root: Optional[TreeNode]) -> bool:\n        return root.val == (root.left.val + root.right.val)
Rotate Array,###  189\. Rotate Array\n\nGiven an array rotate the array to the right by `k` steps where `k` is non-\nnegative.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234567] k = 3\n    **Output:** [5671234]\n    **Explanation:**\n    rotate 1 steps to the right: [7123456]\n    rotate 2 steps to the right: [6712345]\n    rotate 3 steps to the right: [5671234]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-1-100399] k = 2\n    **Output:** [399-1-100]\n    **Explanation:** \n    rotate 1 steps to the right: [99-1-1003]\n    rotate 2 steps to the right: [399-1-100]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-231 <= nums[i] <= 231 - 1`\n  * `0 <= k <= 105`\n\n\n\n**Follow up:**\n\n  * Try to come up with as many solutions as you can. There are at least **three** different ways to solve this problem.\n  * Could you do it in-place with `O(1)` extra space?\n\n,# Runtime: 484 ms (Top 40.41%) | Memory: 25.4 MB (Top 28.89%)\nclass Solution:\n    def reverse(selfarrleftright):\n        while left < right:\n            arr[left]arr[right] = arr[right] arr[left]\n            left right = left + 1 right - 1\n        return arr\n    def rotate(self nums: List[int] k: int) -> None:\n        length = len(nums)\n        k = k % length\n        l r = 0 length - 1\n        nums = self.reverse(numslr)\n        l r = 0 k - 1\n        nums = self.reverse(numslr)\n        l r = k length - 1\n        nums = self.reverse(numslr)\n        return nums
Rotate Function,###  396\. Rotate Function\n\nYou are given an integer array `nums` of length `n`.\n\nAssume `arrk` to be an array obtained by rotating `nums` by `k` positions\nclock-wise. We define the **rotation function** `F` on `nums` as follow:\n\n  * `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].`\n\nReturn _the maximum value of_ `F(0) F(1) ... F(n-1)`.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [4326]\n    **Output:** 26\n    **Explanation:**\n    F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\n    F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\n    F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\n    F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n    So the maximum value of F(0) F(1) F(2) F(3) is F(3) = 26.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [100]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 105`\n  * `-100 <= nums[i] <= 100`\n\n,# Runtime: 1737 ms (Top 72.92%) | Memory: 23.1 MB (Top 74.40%)\nclass Solution:\n    def maxRotateFunction(self nums: List[int]) -> int:\n        preSum cur = 0 0\n        for i in range(len(nums)):\n            cur += i * nums[i]\n            preSum += nums[i]\n        ans = cur\n        for i in range(1 len(nums)):\n            cur -= len(nums) * nums[len(nums) - i]\n            cur += preSum\n            ans = max(ans cur)\n        return ans
Rotate Image,###  48\. Rotate Image\n\nYou are given an `n x n` 2D `matrix` representing an image rotate the image\nby **90** degrees (clockwise).\n\nYou have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-\nplace_algorithm) which means you have to modify the input 2D matrix directly.\n**DO NOT** allocate another 2D matrix and do the rotation.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)\n\n    \n    \n    **Input:** matrix = [[123][456][789]]\n    **Output:** [[741][852][963]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)\n\n    \n    \n    **Input:** matrix = [[51911][24810][13367][15141216]]\n    **Output:** [[151325][14341][12689][1671011]]\n    \n\n\n\n**Constraints:**\n\n  * `n == matrix.length == matrix[i].length`\n  * `1 <= n <= 20`\n  * `-1000 <= matrix[i][j] <= 1000`\n\n,"class Solution:\n    \n    def rotate(self matrix: List[List[int]]) -> None:\n        """"""\n        Do not return anything modify matrix in-place instead.\n        """"""\n        # transpose \n        size = len(matrix)\n        for i in range(size):\n            for j in range(i+1 size):\n                matrix[j][i]matrix[i][j] = matrix[i][j]matrix[j][i]\n        \n        print(matrix)\n        \n        # reverse row\n        for row in range(len(matrix)):\n            matrix[row] = matrix[row][::-1]\n        \n        print(matrix)\n"
Rotate List,###  61\. Rotate List\n\nGiven the `head` of a linked list rotate the list to the right by `k` places.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\n\n    \n    \n    **Input:** head = [12345] k = 2\n    **Output:** [45123]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)\n\n    \n    \n    **Input:** head = [012] k = 4\n    **Output:** [201]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[0 500]`.\n  * `-100 <= Node.val <= 100`\n  * `0 <= k <= 2 * 109`\n\n,# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self val=0 next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self head: Optional[ListNode] k: int) -> Optional[ListNode]:\n        if k==0 or head is None or head.next is None:\n            return head\n        cur=head\n        n=0\n        while cur is not None:\n            cur=cur.next\n            n+=1\n        k=n-k%n\n        if k==n:\n            return head\n        cur=head\n        prev=None\n        while k>0 and cur is not None:\n            prev=cur\n            cur=cur.next\n            k-=1\n        prev.next=None\n        prev=cur\n        while cur.next is not None:\n            cur=cur.next\n        cur.next=head\n        return prev\n        \n
Rotate String,"###  796\. Rotate String\n\nGiven two strings `s` and `goal` return `true` _if and only if_ `s` _can\nbecome_ `goal` _after some number of**shifts** on_ `s`.\n\nA **shift** on `s` consists of moving the leftmost character of `s` to the\nrightmost position.\n\n  * For example if `s = ""abcde""` then it will be `""bcdea""` after one shift.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abcde"" goal = ""cdeab""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcde"" goal = ""abced""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length goal.length <= 100`\n  * `s` and `goal` consist of lowercase English letters.\n\n",# Runtime: 33 ms faster than 90.10% of Python3 online submissions for Rotate String.\n# Memory Usage: 13.8 MB less than 97.64% of Python3 online submissions for Rotate String.\n\nclass Solution:\n    def rotateString(self s: str goal: str) -> bool:\n        for x in range(len(s)):\n            s = s[-1] + s[:-1]\n            if (goal == s):\n                return True\n        return False\n
Rotated Digits,###  788\. Rotated Digits\n\nAn integer `x` is a **good** if after rotating each digit individually by 180\ndegrees we get a valid number that is different from `x`. Each digit must be\nrotated - we cannot choose to leave it alone.\n\nA number is valid if each digit remains a digit after rotation. For example:\n\n  * `0` `1` and `8` rotate to themselves\n  * `2` and `5` rotate to each other (in this case they are rotated in a different direction in other words `2` or `5` gets mirrored)\n  * `6` and `9` rotate to each other and\n  * the rest of the numbers do not rotate to any other number and become invalid.\n\nGiven an integer `n` return _the number of**good** integers in the range\n_`[1 n]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 4\n    **Explanation:** There are four good numbers in the range [1 10] : 2 5 6 9.\n    Note that 1 and 10 are not good numbers since they remain unchanged after rotating.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n\n,# Runtime: 226 ms (Top 14.46%) | Memory: 13.9 MB (Top 71.45%)\nclass Solution:\n    def rotatedDigits(self n: int) -> int:\n        d={\n            0:0\n            1:1\n            2:5\n            3:None\n            4: None\n            5:2\n            6:9\n            7:None\n            8:8\n            9:6\n        }\n        res=0\n        for i in range(n+1):\n            t=i\n            pos=0\n            temp=0\n            status=True\n            while t>0:\n                r=d[t%10] #Every Digit Rotation Is Must We Don't Have Choice To Leave It Without Rotating\n                if r is None:\n                    status=False\n                    break\n\n                temp+=((10**pos)*r)\n                pos+=1\n                t=t//10\n\n            if temp!=i and status:\n                res+=1\n        return res
Rotating the Box,"###  1861\. Rotating the Box\n\nYou are given an `m x n` matrix of characters `box` representing a side-view\nof a box. Each cell of the box is one of the following:\n\n  * A stone `'#'`\n  * A stationary obstacle `'*'`\n  * Empty `'.'`\n\nThe box is rotated **90 degrees clockwise**  causing some of the stones to\nfall due to gravity. Each stone falls down until it lands on an obstacle\nanother stone or the bottom of the box. Gravity **does not** affect the\nobstacles' positions and the inertia from the box's rotation **does not**\naffect the stones' horizontal positions.\n\nIt is **guaranteed** that each stone in `box` rests on an obstacle another\nstone or the bottom of the box.\n\nReturn _an_`n x m` _matrix representing the box after the rotation described\nabove_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcodewithstones.png)\n\n    \n    \n    **Input:** box = [[""#"""".""""#""]]\n    **Output:** [["".""]\n             [""#""]\n             [""#""]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode2withstones.png)\n\n    \n    \n    **Input:** box = [[""#"""".""""*"""".""]\n                  [""#""""#""""*"""".""]]\n    **Output:** [[""#"""".""]\n             [""#""""#""]\n             [""*""""*""]\n             [""."""".""]]\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/04/08/rotatingtheboxleetcode3withstone.png)\n\n    \n    \n    **Input:** box = [[""#""""#""""*"""".""""*"""".""]\n                  [""#""""#""""#""""*""""."""".""]\n                  [""#""""#""""#"""".""""#"""".""]]\n    **Output:** [["".""""#""""#""]\n             ["".""""#""""#""]\n             [""#""""#""""*""]\n             [""#""""*"""".""]\n             [""#"""".""""*""]\n             [""#""""."""".""]]\n    \n\n\n\n**Constraints:**\n\n  * `m == box.length`\n  * `n == box[i].length`\n  * `1 <= m n <= 500`\n  * `box[i][j]` is either `'#'` `'*'` or `'.'`.\n\n",class Solution:\n    def rotateTheBox(self box: List[List[str]]) -> List[List[str]]:\n        # move stones to right row by row\n        for i in range(len(box)):\n            stone = 0\n            for j in range(len(box[0])):\n                if box[i][j] == '#': # if a stone\n                    stone += 1\n                    box[i][j] = '.'\n                elif box[i][j] == '*': # if a obstacle\n                    for m in range(stone):\n                        box[i][j-m-1] = '#'\n                    stone = 0\n            # if reaches the end of j but still have stone\n            if stone != 0:\n                for m in range(stone):\n                        box[i][j-m] = '#'\n        \n        # rotate box same as leetcode #48\n        box[:]  = zip(*box[::-1])\n        \n        return box\n
Rotting Oranges,###  994\. Rotting Oranges\n\nYou are given an `m x n` `grid` where each cell can have one of three values:\n\n  * `0` representing an empty cell\n  * `1` representing a fresh orange or\n  * `2` representing a rotten orange.\n\nEvery minute any fresh orange that is **4-directionally adjacent** to a\nrotten orange becomes rotten.\n\nReturn _the minimum number of minutes that must elapse until no cell has a\nfresh orange_. If _this is impossible return_ `-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)\n\n    \n    \n    **Input:** grid = [[211][110][011]]\n    **Output:** 4\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[211][011][101]]\n    **Output:** -1\n    **Explanation:** The orange in the bottom left corner (row 2 column 0) is never rotten because rotting only happens 4-directionally.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[02]]\n    **Output:** 0\n    **Explanation:** Since there are already no fresh oranges at minute 0 the answer is just 0.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 10`\n  * `grid[i][j]` is `0` `1` or `2`.\n\n,"class Solution:\n    def orangesRotting(self grid: List[List[int]]) -> int:\n        visited = set()\n        res = 0\n        def bfs(grid):\n            que = collections.deque()\n            for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 2:\n                        que.append((ij))\n            que.append(None)\n            count = 0    \n            while len(que)>0:\n                left  right = 00\n				# This other while loop is to make sure that we traverse from all the rotten oranges in one turn.\n                while que[0] != None:\n                    rc = que.popleft()\n                    for Cols in [-11]:\n                        if c+Cols>=0 and c+Cols<len(grid[0]) and grid[r][c+Cols]==1:\n                            grid[r][c+Cols] = 2\n                            left += 1\n                            que.append((rc+Cols))\n                    \n                    for Rows in [-11]:\n                        if r+Rows>=0 and r+Rows<len(grid) and grid[r+Rows][c]==1:\n                            grid[r+Rows][c] = 2\n                            right += 1\n                            que.append((r+Rowsc))\n				'''\n				if either left or right or both is incremented it means that we have moved in either direction\n				and then this will be counted as a turn(or minute as per the problem description.).\n				\n				'''\n                if left is not 0 or right is not 0:\n                    count+=1\n                que.popleft()\n                if len(que)>0:\n				    '''\n				    This is required to terminate the loop and prevent infinite loop.\n				    This only appends a None if there is still some values in the que \n				    else we have completed our traversal and we can stop going any futher.\n				    '''\n                    que.append(None)\n            return count\n        res = bfs(grid)\n        for i in range(len(grid)):\n                for j in range(len(grid[0])):\n                    if grid[i][j] == 1:\n                        return -1\n        return res\n"
Russian Doll Envelopes,###  354\. Russian Doll Envelopes\n\nYou are given a 2D array of integers `envelopes` where `envelopes[i] = [wi\nhi]` represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of\none envelope are greater than the other envelope's width and height.\n\nReturn _the maximum number of envelopes you can Russian doll (i.e. put one\ninside the other)_.\n\n**Note:** You cannot rotate an envelope.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** envelopes = [[54][64][67][23]]\n    **Output:** 3\n    **Explanation:** The maximum number of envelopes you can Russian doll is 3 ([23] => [54] => [67]).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** envelopes = [[11][11][11]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= envelopes.length <= 105`\n  * `envelopes[i].length == 2`\n  * `1 <= wi hi <= 105`\n\n,# Runtime: 1587 ms (Top 72.81%) | Memory: 61.7 MB (Top 65.15%)\n\nfrom bisect import bisect_left\nclass Solution:\n    def maxEnvelopes(self envelopes: List[List[int]]) -> int:\n        envelopes = sorted(envelopes key= lambda x:(x[0]-x[1]))\n        rst = []\n        for _h in envelopes:\n            i = bisect_left(rsth)\n            if i == len(rst):\n                rst.append(h)\n            else:\n                rst[i] = h\n        return len(rst)
Same Tree,###  100\. Same Tree\n\nGiven the roots of two binary trees `p` and `q` write a function to check if\nthey are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical\nand the nodes have the same value.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)\n\n    \n    \n    **Input:** p = [123] q = [123]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/20/ex2.jpg)\n\n    \n    \n    **Input:** p = [12] q = [1null2]\n    **Output:** false\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/12/20/ex3.jpg)\n\n    \n    \n    **Input:** p = [121] q = [112]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in both trees is in the range `[0 100]`.\n  * `-104 <= Node.val <= 104`\n\n,"// Runtime: 43 ms (Top 21.7%) | Memory: 17.30 MB (Top 8.84%)\n\nclass Solution:\n    def isSameTree(self p: Optional[TreeNode] q: Optional[TreeNode]) -> bool:\n        stack = [[pq]]\n        while stack:\n            pq = stack.pop()\n            if not p and not q:					#(1)\n                continue\n            elif p and q and p.val == q.val:	#(2)\n                stack.append([p.left q.left])\n                stack.append([p.right q.right])\n            else:								#(3)\n                return False\n        return True\n"
Satisfiability of Equality Equations,"###  990\. Satisfiability of Equality Equations\n\nYou are given an array of strings `equations` that represent relationships\nbetween variables where each string `equations[i]` is of length `4` and takes\none of two different forms: `""xi==yi""` or `""xi!=yi""`.Here `xi` and `yi` are\nlowercase letters (not necessarily different) that represent one-letter\nvariable names.\n\nReturn `true` _if it is possible to assign integers to variable names so as to\nsatisfy all the given equations or_`false` _otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** equations = [""a==b""""b!=a""]\n    **Output:** false\n    **Explanation:** If we assign say a = 1 and b = 1 then the first equation is satisfied but not the second.\n    There is no way to assign the variables to satisfy both equations.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** equations = [""b==a""""a==b""]\n    **Output:** true\n    **Explanation:** We could assign a = 1 and b = 1 to satisfy both equations.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= equations.length <= 500`\n  * `equations[i].length == 4`\n  * `equations[i][0]` is a lowercase letter.\n  * `equations[i][1]` is either `'='` or `'!'`.\n  * `equations[i][2]` is `'='`.\n  * `equations[i][3]` is a lowercase letter.\n\n",class Solution:\n    def equationsPossible(self equations: List[str]) -> bool:\n        from collections import defaultdict\n        g = defaultdict(list)\n        for e in equations:\n            if e[1] == '=':\n                x = e[0]\n                y = e[3]\n                g[x].append(y)\n                g[y].append(x)\n        \n        # marked the connected components as 012...25\n        ccs = defaultdict(lambda: -1) # -1 means unmarked or unseen\n\n        def dfs(node cc):\n            if node not in ccs:\n                ccs[node] = cc\n                for neighbour in g[node]:\n                    dfs(neighbour cc)\n        \n        for i in range(26):\n            dfs(chr(i+97) i)\n        \n        for e in equations:\n            if e[1] == '!':\n                x = e[0]\n                y = e[3]\n                if ccs[x] == ccs[y]:\n                    return False\n        return True
Score After Flipping Matrix,###  861\. Score After Flipping Matrix\n\nYou are given an `m x n` binary matrix `grid`.\n\nA **move** consists of choosing any row or column and toggling each value in\nthat row or column (i.e. changing all `0`'s to `1`'s and all `1`'s to\n`0`'s).\n\nEvery row of the matrix is interpreted as a binary number and the **score**\nof the matrix is the sum of these numbers.\n\nReturn _the highest possible**score** after making any number of **moves**\n(including zero moves)_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/23/lc-toogle1.jpg)\n\n    \n    \n    **Input:** grid = [[0011][1010][1100]]\n    **Output:** 39\n    **Explanation:** 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[0]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 20`\n  * `grid[i][j]` is either `0` or `1`.\n\n,class Solution:\n\n    def calcScore(self):\n        score = 0\n        \n        for row in self.grid:\n            for i in range(self.width):\n                score += row[i] * (2 ** (self.width - i - 1))\n        return score\n    \n    def flipRow(self row):\n        for i in range(self.width):\n            self.grid[row][i] = int(not self.grid[row][i])\n        \n    def flipCol(self col):\n        for i in range(self.height):\n            self.grid[i][col] = int(not self.grid[i][col])\n            \n    def colSum(self col):\n        total = 0\n        \n        for i in range(self.height):\n            total += self.grid[i][col]\n            \n        return total\n    \n    def matrixScore(self grid: List[List[int]]) -> int:\n        self.grid = grid\n        self.height = len(grid)\n        self.width = len(grid[0])\n        \n        for r in range(self.height):\n            if not self.grid[r][0]:\n                if not self.grid[r][0]:\n                    self.flipRow(r)\n                    \n        for c in range(1 self.width):\n            colSum = self.colSum(c)\n            \n            if colSum < ceil(self.height/2):\n                self.flipCol(c)\n            \n        return self.calcScore()\n        \n
Score of Parentheses,"###  856\. Score of Parentheses\n\nGiven a balanced parentheses string `s` return _the**score** of the string_.\n\nThe **score** of a balanced parentheses string is based on the following rule:\n\n  * `""()""` has score `1`.\n  * `AB` has score `A + B` where `A` and `B` are balanced parentheses strings.\n  * `(A)` has score `2 * A` where `A` is a balanced parentheses string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""()""\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""(())""\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""()()""\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 50`\n  * `s` consists of only `'('` and `')'`.\n  * `s` is a balanced parentheses string.\n\n","class Solution:\n    def scoreOfParentheses(self s: str) -> int:\n        \n        level = 0\n        result = 0\n        prev = """"\n        \n        for c in s:           \n            if c == ""("":\n                level += 1\n            if c == "")"":\n                if prev == ""("":\n                    result += 2 ** (level - 1)\n                level -= 1                \n            prev = c\n            \n        return result\n"
Scramble String,"###  87\. Scramble String\n\nWe can scramble a string s to get a string t using the following algorithm:\n\n  1. If the length of the string is 1 stop.\n  2. If the length of the string is > 1 do the following: \n     * Split the string into two non-empty substrings at a random index i.e. if the string is `s` divide it to `x` and `y` where `s = x + y`.\n     * **Randomly**  decide to swap the two substrings or to keep them in the same order. i.e. after this step `s` may become `s = x + y` or `s = y + x`.\n     * Apply step 1 recursively on each of the two substrings `x` and `y`.\n\nGiven two strings `s1` and `s2` of **the same length**  return `true` if `s2`\nis a scrambled string of `s1` otherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s1 = ""great"" s2 = ""rgeat""\n    **Output:** true\n    **Explanation:** One possible scenario applied on s1 is:\n    ""great"" --> ""gr/eat"" // divide at random index.\n    ""gr/eat"" --> ""gr/eat"" // random decision is not to swap the two substrings and keep them in order.\n    ""gr/eat"" --> ""g/r / e/at"" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n    ""g/r / e/at"" --> ""r/g / e/at"" // random decision was to swap the first substring and to keep the second substring in the same order.\n    ""r/g / e/at"" --> ""r/g / e/ a/t"" // again apply the algorithm recursively divide ""at"" to ""a/t"".\n    ""r/g / e/ a/t"" --> ""r/g / e/ a/t"" // random decision is to keep both substrings in the same order.\n    The algorithm stops now and the result string is ""rgeat"" which is s2.\n    As one possible scenario led s1 to be scrambled to s2 we return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""abcde"" s2 = ""caebd""\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s1 = ""a"" s2 = ""a""\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `s1.length == s2.length`\n  * `1 <= s1.length <= 30`\n  * `s1` and `s2` consist of lowercase English letters.\n\n","class Solution(object):\n    def isScramble(self s1 s2):\n        """"""\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        """"""\n        if s1 == s2:\n            return True\n        if len(s1) != len(s2):\n            return False\n            \n        # Check both strings have same count of letters\n        count1 = collections.defaultdict(int)\n        count2 = collections.defaultdict(int)\n        for c1 c2 in zip(s1 s2):\n            count1[c1] += 1\n            count2[c2] += 1\n        if count1 != count2: return False\n        \n        # Iterate through letters and check if it results in a partition of \n        # string 1 where the collection of letters are the same\n        # on the left (non-swapped) or right (swapped) sides of string 2\n        # Then we recursively check these partitioned strings to see if they are scrambled\n        lcount1 = collections.defaultdict(int) # s1 count from left\n        lcount2 = collections.defaultdict(int) # s2 count from left\n        rcount2 = collections.defaultdict(int) # s2 count from right\n        for i in xrange(len(s1) - 1):\n            lcount1[s1[i]] += 1          \n            lcount2[s2[i]] += 1\n            rcount2[s2[len(s1) - 1 - i]] += 1\n            if lcount1 == lcount2:  # Left sides of both strings have same letters\n                if self.isScramble(s1[:i + 1] s2[:i + 1]) and \\n                   self.isScramble(s1[i + 1:] s2[i + 1:]):\n                    return True\n            elif lcount1 == rcount2: # Left side of s1 has same letters as right side of s2\n                if self.isScramble(s1[:i + 1] s2[-(i + 1):]) and \\n                   self.isScramble(s1[i + 1:] s2[:-(i + 1)]):\n                    return True\n        return False\n"
Search a 2D Matrix,###  74\. Search a 2D Matrix\n\nWrite an efficient algorithm that searches for a value `target` in an `m x n`\ninteger matrix `matrix`. This matrix has the following properties:\n\n  * Integers in each row are sorted from left to right.\n  * The first integer of each row is greater than the last integer of the previous row.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)\n\n    \n    \n    **Input:** matrix = [[1357][10111620][23303460]] target = 3\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)\n\n    \n    \n    **Input:** matrix = [[1357][10111620][23303460]] target = 13\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m n <= 100`\n  * `-104 <= matrix[i][j] target <= 104`\n\n,// Runtime: 38 ms (Top 96.94%) | Memory: 17.90 MB (Top 11.07%)\n\nclass Solution:\n    def searchMatrix(self matrix: List[List[int]] target: int) -> bool:\n        n = len(matrix[0])\n        def get(idx: int) -> int:\n            r c = divmod(idx n)\n            return matrix[r][c]\n        return get(bisect_left(range(len(matrix)*n-1) target key=get)) == target\n
Search a 2D Matrix II,###  240\. Search a 2D Matrix II\n\nWrite an efficient algorithm that searches for a value `target` in an `m x n`\ninteger matrix `matrix`. This matrix has the following properties:\n\n  * Integers in each row are sorted in ascending from left to right.\n  * Integers in each column are sorted in ascending from top to bottom.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg)\n\n    \n    \n    **Input:** matrix = [[1471115][2581219][3691622][1013141724][1821232630]] target = 5\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg)\n\n    \n    \n    **Input:** matrix = [[1471115][2581219][3691622][1013141724][1821232630]] target = 20\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= n m <= 300`\n  * `-109 <= matrix[i][j] <= 109`\n  * All the integers in each row are **sorted** in ascending order.\n  * All the integers in each column are **sorted** in ascending order.\n  * `-109 <= target <= 109`\n\n,"# Runtime: 121 ms (Top 76.1%) | Memory: 19.55 MB (Top 13.9%)\n\nclass Solution(object):\n    def searchMatrix(self matrix target):\n        """"""\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        """"""\n        found=False\n        for X in matrix:\n             for M in X:\n                if M==target:\n                    found=True\n        return found"
Search in a Binary Search Tree,###  700\. Search in a Binary Search Tree\n\nYou are given the `root` of a binary search tree (BST) and an integer `val`.\n\nFind the node in the BST that the node's value equals `val` and return the\nsubtree rooted with that node. If such a node does not exist return `null`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg)\n\n    \n    \n    **Input:** root = [42713] val = 2\n    **Output:** [213]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg)\n\n    \n    \n    **Input:** root = [42713] val = 5\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 5000]`.\n  * `1 <= Node.val <= 107`\n  * `root` is a binary search tree.\n  * `1 <= val <= 107`\n\n,# Runtime: 87 ms (Top 85.77%) | Memory: 16.7 MB (Top 24.56%)\n# Definition for a binary tree node.\n# class TreeNode:\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass Solution:\n    def searchBST(self root: Optional[TreeNode] val: int) -> Optional[TreeNode]:\n        def search(root):\n            if not root:return None\n            if root.val==val:\n                return root\n            elif root.val<val:\n                ans=search(root.right)\n                if ans:\n                    return ans\n                return None\n            else:\n                ans=search(root.left)\n                if ans:\n                    return ans\n                return None\n        return search(root)
Search in Rotated Sorted Array,###  33\. Search in Rotated Sorted Array\n\nThere is an integer array `nums` sorted in ascending order (with **distinct**\nvalues).\n\nPrior to being passed to your function `nums` is **possibly rotated** at an\nunknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array\nis `[nums[k] nums[k+1] ... nums[n-1] nums[0] nums[1] ... nums[k-1]]`\n(**0-indexed**). For example `[0124567]` might be rotated at pivot\nindex `3` and become `[4567012]`.\n\nGiven the array `nums` **after** the possible rotation and an integer\n`target` return _the index of_`target` _if it is in_`nums` _ or_`-1` _if it\nis not in_`nums`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [4567012] target = 0\n    **Output:** 4\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [4567012] target = 3\n    **Output:** -1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1] target = 0\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5000`\n  * `-104 <= nums[i] <= 104`\n  * All values of `nums` are **unique**.\n  * `nums` is an ascending array that is possibly rotated.\n  * `-104 <= target <= 104`\n\n,class Solution:\n    def search(self nums: List[int] target: int) -> int:\n        l r = 0 len(nums) - 1\n        \n        while l<=r:\n            mid = (l+r)//2\n            if target == nums[mid]:\n                return mid\n            \n            if nums[l]<=nums[mid]:\n                if target > nums[mid] or target<nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            \n            else:\n                if target < nums[mid] or target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        \n        return -1\n
Search in Rotated Sorted Array II,###  81\. Search in Rotated Sorted Array II\n\nThere is an integer array `nums` sorted in non-decreasing order (not\nnecessarily with **distinct** values).\n\nBefore being passed to your function `nums` is **rotated** at an unknown\npivot index `k` (`0 <= k < nums.length`) such that the resulting array is\n`[nums[k] nums[k+1] ... nums[n-1] nums[0] nums[1] ... nums[k-1]]`\n(**0-indexed**). For example `[0124445667]` might be rotated at\npivot index `5` and become `[4566701244]`.\n\nGiven the array `nums` **after** the rotation and an integer `target` return\n`true` _if_`target` _is in_`nums` _ or_`false` _if it is not in_`nums` _._\n\nYou must decrease the overall operation steps as much as possible.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [2560012] target = 0\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2560012] target = 3\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5000`\n  * `-104 <= nums[i] <= 104`\n  * `nums` is guaranteed to be rotated at some pivot.\n  * `-104 <= target <= 104`\n\n\n\n**Follow up:** This problem is similar to [Search in Rotated Sorted\nArray](/problems/search-in-rotated-sorted-array/description/) but `nums` may\ncontain **duplicates**. Would this affect the runtime complexity? How and why?\n\n,class Solution:\n    def search(self nums: List[int] target: int) -> bool:\n        nums.sort()\n        low=0\n        high=len(nums)-1\n        while low<=high:\n            mid=(low+high)//2\n            if nums[mid]==target:\n                return True\n            elif nums[mid]>target:\n                high=mid-1\n            else:\n                low=mid+1\n        return False\n
Search Insert Position,###  35\. Search Insert Position\n\nGiven a sorted array of distinct integers and a target value return the index\nif the target is found. If not return the index where it would be if it were\ninserted in order.\n\nYou must write an algorithm with `O(log n)` runtime complexity.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1356] target = 5\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1356] target = 2\n    **Output:** 1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1356] target = 7\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-104 <= nums[i] <= 104`\n  * `nums` contains **distinct** values sorted in **ascending** order.\n  * `-104 <= target <= 104`\n\n,class Solution:\n    def searchInsert(self nums target):\n        for i num in enumerate(nums):\n            if num >= target:\n                return i\n        return len(nums)
Search Suggestions System,"###  1268\. Search Suggestions System\n\nYou are given an array of strings `products` and a string `searchWord`.\n\nDesign a system that suggests at most three product names from `products`\nafter each character of `searchWord` is typed. Suggested products should have\ncommon prefix with `searchWord`. If there are more than three products with a\ncommon prefix return the three lexicographically minimums products.\n\nReturn _a list of lists of the suggested products after each character\nof_`searchWord` _is typed_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** products = [""mobile""""mouse""""moneypot""""monitor""""mousepad""] searchWord = ""mouse""\n    **Output:** [\n    [""mobile""""moneypot""""monitor""]\n    [""mobile""""moneypot""""monitor""]\n    [""mouse""""mousepad""]\n    [""mouse""""mousepad""]\n    [""mouse""""mousepad""]\n    ]\n    **Explanation:** products sorted lexicographically = [""mobile""""moneypot""""monitor""""mouse""""mousepad""]\n    After typing m and mo all products match and we show user [""mobile""""moneypot""""monitor""]\n    After typing mou mous and mouse the system suggests [""mouse""""mousepad""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** products = [""havana""] searchWord = ""havana""\n    **Output:** [[""havana""][""havana""][""havana""][""havana""][""havana""][""havana""]]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** products = [""bags""""baggage""""banner""""box""""cloths""] searchWord = ""bags""\n    **Output:** [[""baggage""""bags""""banner""][""baggage""""bags""""banner""][""baggage""""bags""][""bags""]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= products.length <= 1000`\n  * `1 <= products[i].length <= 3000`\n  * `1 <= sum(products[i].length) <= 2 * 104`\n  * All the strings of `products` are **unique**.\n  * `products[i]` consists of lowercase English letters.\n  * `1 <= searchWord.length <= 1000`\n  * `searchWord` consists of lowercase English letters.\n\n",// Runtime: 78 ms (Top 77.93%) | Memory: 19.60 MB (Top 79.27%)\n\nclass Solution:\n    def suggestedProducts(self products: List[str] searchWord: str) -> List[List[str]]:\n        list_ = []\n        products.sort()\n        for i c in enumerate(searchWord):\n            products = [ p for p in products if len(p) > i and p[i] == c ]\n            list_.append(products[:3])\n        return list_\n
Seat Reservation Manager,"###  1845\. Seat Reservation Manager\n\nDesign a system that manages the reservation state of `n` seats that are\nnumbered from `1` to `n`.\n\nImplement the `SeatManager` class:\n\n  * `SeatManager(int n)` Initializes a `SeatManager` object that will manage `n` seats numbered from `1` to `n`. All seats are initially available.\n  * `int reserve()` Fetches the **smallest-numbered** unreserved seat reserves it and returns its number.\n  * `void unreserve(int seatNumber)` Unreserves the seat with the given `seatNumber`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""SeatManager"" ""reserve"" ""reserve"" ""unreserve"" ""reserve"" ""reserve"" ""reserve"" ""reserve"" ""unreserve""]\n    [[5] [] [] [2] [] [] [] [] [5]]\n    **Output**\n    [null 1 2 null 2 3 4 5 null]\n    \n    **Explanation**\n    SeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.\n    seatManager.reserve();    // All seats are available so return the lowest numbered seat which is 1.\n    seatManager.reserve();    // The available seats are [2345] so return the lowest of them which is 2.\n    seatManager.unreserve(2); // Unreserve seat 2 so now the available seats are [2345].\n    seatManager.reserve();    // The available seats are [2345] so return the lowest of them which is 2.\n    seatManager.reserve();    // The available seats are [345] so return the lowest of them which is 3.\n    seatManager.reserve();    // The available seats are [45] so return the lowest of them which is 4.\n    seatManager.reserve();    // The only available seat is seat 5 so return 5.\n    seatManager.unreserve(5); // Unreserve seat 5 so now the available seats are [5].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `1 <= seatNumber <= n`\n  * For each call to `reserve` it is guaranteed that there will be at least one unreserved seat.\n  * For each call to `unreserve` it is guaranteed that `seatNumber` will be reserved.\n  * At most `105` calls **in total** will be made to `reserve` and `unreserve`.\n\n",class SeatManager:\n    def __init__(self n: int):\n        self.lis = list(range(1n+1))\n    def reserve(self) -> int:\n        mini = min(self.lis)\n        self.lis.remove(mini)\n        return mini\n\n    def unreserve(self seatNumber: int) -> None:\n        self.lis.append(seatNumber)\n
Second Largest Digit in a String,"###  1796\. Second Largest Digit in a String\n\nGiven an alphanumeric string `s` return _the**second largest** numerical\ndigit that appears in _`s` _ or_`-1` _if it does not exist_.\n\nAn **alphanumeric****** string is a string consisting of lowercase English\nletters and digits.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""dfa12321afd""\n    **Output:** 2\n    **Explanation:** The digits that appear in s are [1 2 3]. The second largest digit is 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abc1111""\n    **Output:** -1\n    **Explanation:** The digits that appear in s are [1]. There is no second largest digit. \n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 500`\n  * `s` consists of only lowercase English letters and/or digits.\n\n",# Runtime: 80 ms (Top 5.3%) | Memory: 16.30 MB (Top 72.1%)\n\nclass Solution:\n    def secondHighest(self s: str) -> int:\n        nums = []\n        for char in s:\n            if char.isdigit():\n                nums.append(int(char))\n        nums = [num for num in nums if num != max(nums)]\n        if len(nums) >= 1: return max(nums)\n        else: return -1
Second Minimum Node In a Binary Tree,###  671\. Second Minimum Node In a Binary Tree\n\nGiven a non-empty special binary tree consisting of nodes with the non-\nnegative value where each node in this tree has exactly `two` or `zero` sub-\nnode. If the node has two sub-nodes then this node's value is the smaller\nvalue among its two sub-nodes. More formally the property `root.val =\nmin(root.left.val root.right.val)` always holds.\n\nGiven such a binary tree you need to output the **second minimum** value in\nthe set made of all the nodes' value in the whole tree.\n\nIf no such second minimum value exists output -1 instead.\n\n\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg)\n\n    \n    \n    **Input:** root = [225nullnull57]\n    **Output:** 5\n    **Explanation:** The smallest value is 2 the second smallest value is 5.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg)\n\n    \n    \n    **Input:** root = [222]\n    **Output:** -1\n    **Explanation:** The smallest value is 2 but there isn't any second smallest value.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 25]`.\n  * `1 <= Node.val <= 231 - 1`\n  * `root.val == min(root.left.val root.right.val)` for each internal node of the tree.\n\n,# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findSecondMinimumValue(self root: Optional[TreeNode]) -> int:\n        temp1=temp2=float(inf)\n        from collections import deque\n        a=deque([root])\n        while a:\n            node=a.popleft()\n            if node.valtemp1:\n                if node.val
Second Minimum Time to Reach Destination,###  2045\. Second Minimum Time to Reach Destination\n\nA city is represented as a **bi-directional connected** graph with `n`\nvertices where each vertex is labeled from `1` to `n` (**inclusive**). The\nedges in the graph are represented as a 2D integer array `edges` where each\n`edges[i] = [ui vi]` denotes a bi-directional edge between vertex `ui` and\nvertex `vi`. Every vertex pair is connected by **at most one** edge and no\nvertex has an edge to itself. The time taken to traverse any edge is `time`\nminutes.\n\nEach vertex has a traffic signal which changes its color from **green** to\n**red** and vice versa every `change` minutes. All signals change **at the\nsame time**. You can enter a vertex at **any time**  but can leave a vertex\n**only when the signal is green**. You **cannot wait** at a vertex if the\nsignal is **green**.\n\nThe **second minimum value** is defined as the smallest value**strictly\nlarger** than the minimum value.\n\n  * For example the second minimum value of `[2 3 4]` is `3` and the second minimum value of `[2 2 4]` is `4`.\n\nGiven `n` `edges` `time` and `change` return _the**second minimum time**\nit will take to go from vertex _`1` _to vertex_`n`.\n\n**Notes:**\n\n  * You can go through any vertex **any** number of times **including** `1` and `n`.\n  * You can assume that when the journey **starts**  all signals have just turned **green**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/09/29/e1.png)      \n ![](https://assets.leetcode.com/uploads/2021/09/29/e2.png)\n\n    \n    \n    **Input:** n = 5 edges = [[12][13][14][34][45]] time = 3 change = 5\n    **Output:** 13\n    **Explanation:**\n    The figure on the left shows the given graph.\n    The blue path in the figure on the right is the minimum time path.\n    The time taken is:\n    - Start at 1 time elapsed=0\n    - 1 -> 4: 3 minutes time elapsed=3\n    - 4 -> 5: 3 minutes time elapsed=6\n    Hence the minimum time needed is 6 minutes.\n    \n    The red path shows the path to get the second minimum time.\n    - Start at 1 time elapsed=0\n    - 1 -> 3: 3 minutes time elapsed=3\n    - 3 -> 4: 3 minutes time elapsed=6\n    - Wait at 4 for 4 minutes time elapsed=10\n    - 4 -> 5: 3 minutes time elapsed=13\n    Hence the second minimum time is 13 minutes.      \n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/09/29/eg2.png)\n\n    \n    \n    **Input:** n = 2 edges = [[12]] time = 3 change = 2\n    **Output:** 11\n    **Explanation:**\n    The minimum time path is 1 -> 2 with time = 3 minutes.\n    The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\n\n\n**Constraints:**\n\n  * `2 <= n <= 104`\n  * `n - 1 <= edges.length <= min(2 * 104 n * (n - 1) / 2)`\n  * `edges[i].length == 2`\n  * `1 <= ui vi <= n`\n  * `ui != vi`\n  * There are no duplicate edges.\n  * Each vertex can be reached directly or indirectly from every other vertex.\n  * `1 <= time change <= 103`\n\n,from heapq import heappopheappush\nfrom collections import defaultdict\n\nclass Solution:\n    def secondMinimum(self n: int edges: List[List[int]] time: int change: int) -> int:\n        G = defaultdict(list)\n        dist = defaultdict(set)\n        for v w in edges:\n            G[v].append(w)\n            G[w].append(v)\n        h = [(0 1)]\n        res = []\n        while h:\n            d v = heappop(h)\n            if len(dist[v]) > 1:\n                continue\n            if d in dist[v]:\n                continue\n            dist[v].add(d)\n            q r = divmod(d change)\n            if q%2 == 1:\n                d += change - r\n            for w in G[v]:\n                if w == n:\n                    if  res:\n                        if d+time not in res:\n                            return d+time\n                    else:\n                        res.append(d+time)\n                if len(dist[w]) < 2:\n                    heappush(h (d+timew))\n
Self Crossing,###  335\. Self Crossing\n\nYou are given an array of integers `distance`.\n\nYou start at point `(00)` on an **X-Y** plane and you move `distance[0]`\nmeters to the north then `distance[1]` meters to the west `distance[2]`\nmeters to the south `distance[3]` meters to the east and so on. In other\nwords after each move your direction changes counter-clockwise.\n\nReturn `true` if your path crosses itself and `false` if it does not.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/selfcross1-plane.jpg)\n\n    \n    \n    **Input:** distance = [2112]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/selfcross2-plane.jpg)\n\n    \n    \n    **Input:** distance = [1234]\n    **Output:** false\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/03/14/selfcross3-plane.jpg)\n\n    \n    \n    **Input:** distance = [1111]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= distance.length <= 105`\n  * `1 <= distance[i] <= 105`\n\n,class Solution:\n    def isSelfCrossing(self x):\n        n = len(x)\n        if n < 4: return False\n        for i in range(3 n):\n            if x[i] >= x[i-2] and x[i-1] <= x[i-3]: return True\n            if i >= 4 and x[i-1]==x[i-3] and x[i]+x[i-4]>=x[i-2]: return True\n            if i >= 5 and 0<=x[i-2]-x[i-4]<=x[i] and 0<=x[i-3]-x[i-1]<=x[i-5]: return True\n        return False\n        \n
Self Dividing Numbers,###  728\. Self Dividing Numbers\n\nA **self-dividing number** is a number that is divisible by every digit it\ncontains.\n\n  * For example `128` is **a self-dividing number** because `128 % 1 == 0` `128 % 2 == 0` and `128 % 8 == 0`.\n\nA **self-dividing number** is not allowed to contain the digit zero.\n\nGiven two integers `left` and `right` return _a list of all the**self-\ndividing numbers** in the range_ `[left right]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** left = 1 right = 22\n    **Output:** [12345678911121522]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** left = 47 right = 85\n    **Output:** [48556677]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= left <= right <= 104`\n\n,# Runtime: 99 ms (Top 32.60%) | Memory: 13.9 MB (Top 25.64%)\nclass Solution:\n    def selfDividingNumbers(self left: int right: int) -> List[int]:\n        res = []\n        for num in range(left right + 1):\n            num_str = str(num)\n            if '0' in num_str:\n                continue\n            elif all([num % int(digit_str) == 0 for digit_str in num_str]):\n                res.append(num)\n        return res
Sell Diminishing-Valued Colored Balls,###  1648\. Sell Diminishing-Valued Colored Balls\n\nYou have an `inventory` of different colored balls and there is a customer\nthat wants `orders` balls of **any** color.\n\nThe customer weirdly values the colored balls. Each colored ball's value is\nthe number of balls **of that color  **you currently have in your `inventory`.\nFor example if you own `6` yellow balls the customer would pay `6` for the\nfirst yellow ball. After the transaction there are only `5` yellow balls\nleft so the next yellow ball is then valued at `5` (i.e. the value of the\nballs decreases as you sell more to the customer).\n\nYou are given an integer array `inventory` where `inventory[i]` represents\nthe number of balls of the `ith` color that you initially own. You are also\ngiven an integer `orders` which represents the total number of balls that the\ncustomer wants. You can sell the balls **in any order**.\n\nReturn _the**maximum** total value that you can attain after selling _`orders`\n_colored balls_. As the answer may be too large return it **modulo**`109 +\n7`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/05/jj.gif)\n\n    \n    \n    **Input:** inventory = [25] orders = 4\n    **Output:** 14\n    **Explanation:** Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\n    The maximum total value is 2 + 5 + 4 + 3 = 14.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** inventory = [35] orders = 6\n    **Output:** 19\n    **Explanation:** Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\n    The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= inventory.length <= 105`\n  * `1 <= inventory[i] <= 109`\n  * `1 <= orders <= min(sum(inventory[i]) 109)`\n\n,class Solution:\n    def maxProfit(self inventory: List[int] orders: int) -> int:\n        inventory.sort(reverse=True) \n        inventory += [0]\n        res = 0\n        k = 1\n        \n        for i in range(len(inventory)-1): \n            if inventory[i] > inventory[i+1]: \n                if k*(inventory[i]-inventory[i+1]) < orders:\n                    diff = inventory[i]-inventory[i+1]\n                    res += k*(inventory[i]+inventory[i+1]+1)*(diff)//2\n                    orders -= k*diff\n                else: \n                    q r = divmod(orders k)\n                    res += k*(inventory[i]+(inventory[i]-q+1))*q//2\n                    res += r*(inventory[i]-q)\n                    return res%(10**9+7)\n            k += 1\n
Sentence Similarity III,"###  1813\. Sentence Similarity III\n\nA sentence is a list of words that are separated by a single space with no\nleading or trailing spaces. For example `""Hello World""` `""HELLO""` `""hello\nworld hello world""` are all sentences. Words consist of **only** uppercase and\nlowercase English letters.\n\nTwo sentences `sentence1` and `sentence2` are **similar** if it is possible to\ninsert an arbitrary sentence **(possibly empty)** inside one of these\nsentences such that the two sentences become equal. For example `sentence1 =\n""Hello my name is Jane""` and `sentence2 = ""Hello Jane""` can be made equal by\ninserting `""my name is""` between `""Hello""` and `""Jane""` in `sentence2`.\n\nGiven two sentences `sentence1` and `sentence2` return `true` _if_`sentence1`\n_and_`sentence2` _are similar._ Otherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** sentence1 = ""My name is Haley"" sentence2 = ""My Haley""\n    **Output:** true\n    **Explanation:** sentence2 can be turned to sentence1 by inserting ""name is"" between ""My"" and ""Haley"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** sentence1 = ""of"" sentence2 = ""A lot of words""\n    **Output:** false\n    **Explanation:** No single sentence can be inserted inside one of the sentences to make it equal to the other.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** sentence1 = ""Eating right now"" sentence2 = ""Eating""\n    **Output:** true\n    **Explanation:** sentence2 can be turned to sentence1 by inserting ""right now"" at the end of the sentence.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= sentence1.length sentence2.length <= 100`\n  * `sentence1` and `sentence2` consist of lowercase and uppercase English letters and spaces.\n  * The words in `sentence1` and `sentence2` are separated by a single space.\n\n",2
Sequentially Ordinal Rank Tracker,"###  2102\. Sequentially Ordinal Rank Tracker\n\nA scenic location is represented by its `name` and attractiveness `score`\nwhere `name` is a **unique** string among all locations and `score` is an\ninteger. Locations can be ranked from the best to the worst. The **higher**\nthe score the better the location. If the scores of two locations are equal\nthen the location with the **lexicographically smaller** name is better.\n\nYou are building a system that tracks the ranking of locations with the system\ninitially starting with no locations. It supports:\n\n  * **Adding** scenic locations **one at a time**.\n  * **Querying** the `ith` **best** location of **all locations already added**  where `i` is the number of times the system has been queried (including the current query). \n    * For example when the system is queried for the `4th` time it returns the `4th` best location of all locations already added.\n\nNote that the test data are generated so that **at any time**  the number of\nqueries **does not exceed** the number of locations added to the system.\n\nImplement the `SORTracker` class:\n\n  * `SORTracker()` Initializes the tracker system.\n  * `void add(string name int score)` Adds a scenic location with `name` and `score` to the system.\n  * `string get()` Queries and returns the `ith` best location where `i` is the number of times this method has been invoked (including this invocation).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""SORTracker"" ""add"" ""add"" ""get"" ""add"" ""get"" ""add"" ""get"" ""add"" ""get"" ""add"" ""get"" ""get""]\n    [[] [""bradford"" 2] [""branford"" 3] [] [""alps"" 2] [] [""orland"" 2] [] [""orlando"" 3] [] [""alpine"" 2] [] []]\n    **Output**\n    [null null null ""branford"" null ""alps"" null ""bradford"" null ""bradford"" null ""bradford"" ""orland""]\n    \n    **Explanation**\n    SORTracker tracker = new SORTracker(); // Initialize the tracker system.\n    tracker.add(""bradford"" 2); // Add location with name=""bradford"" and score=2 to the system.\n    tracker.add(""branford"" 3); // Add location with name=""branford"" and score=3 to the system.\n    tracker.get();              // The sorted locations from best to worst are: branford bradford.\n                                // Note that branford precedes bradford due to its **higher score** (3 > 2).\n                                // This is the 1st time get() is called so return the best location: ""branford"".\n    tracker.add(""alps"" 2);     // Add location with name=""alps"" and score=2 to the system.\n    tracker.get();              // Sorted locations: branford alps bradford.\n                                // Note that alps precedes bradford even though they have the same score (2).\n                                // This is because ""alps"" is **lexicographically smaller** than ""bradford"".\n                                // Return the 2nd best location ""alps"" as it is the 2nd time get() is called.\n    tracker.add(""orland"" 2);   // Add location with name=""orland"" and score=2 to the system.\n    tracker.get();              // Sorted locations: branford alps bradford orland.\n                                // Return ""bradford"" as it is the 3rd time get() is called.\n    tracker.add(""orlando"" 3);  // Add location with name=""orlando"" and score=3 to the system.\n    tracker.get();              // Sorted locations: branford orlando alps bradford orland.\n                                // Return ""bradford"".\n    tracker.add(""alpine"" 2);   // Add location with name=""alpine"" and score=2 to the system.\n    tracker.get();              // Sorted locations: branford orlando alpine alps bradford orland.\n                                // Return ""bradford"".\n    tracker.get();              // Sorted locations: branford orlando alpine alps bradford orland.\n                                // Return ""orland"".\n    \n\n\n\n**Constraints:**\n\n  * `name` consists of lowercase English letters and is unique among all locations.\n  * `1 <= name.length <= 10`\n  * `1 <= score <= 105`\n  * At any time the number of calls to `get` does not exceed the number of calls to `add`.\n  * At most `4 * 104` calls **in total** will be made to `add` and `get`.\n\n",// Runtime: 675 ms (Top 95.65%) | Memory: 40.70 MB (Top 63.04%)\n\nfrom sortedcontainers import SortedList\nclass SORTracker:\n\n    def __init__(self):\n        self.arr=SortedList()\n        self.index=-1\n    def add(self name: str score: int) -> None:\n        self.arr.add([-scorename])\n        \n    def get(self) -> str:\n       \n        self.index+=1\n        return self.arr[self.index][1]\n\n\n# Your SORTracker object will be instantiated and called as such:\n# obj = SORTracker()\n# obj.add(namescore)\n# param_2 = obj.get()\n
Serialize and Deserialize Binary Tree,###  297\. Serialize and Deserialize Binary Tree\n\nSerialization is the process of converting a data structure or object into a\nsequence of bits so that it can be stored in a file or memory buffer or\ntransmitted across a network connection link to be reconstructed later in the\nsame or another computer environment.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no\nrestriction on how your serialization/deserialization algorithm should work.\nYou just need to ensure that a binary tree can be serialized to a string and\nthis string can be deserialized to the original tree structure.\n\n**Clarification:** The input/output format is the same as [how LeetCode\nserializes a binary tree](https://support.leetcode.com/hc/en-\nus/articles/360011883654-What-does-1-null-2-3-mean-in-binary-tree-\nrepresentation-). You do not necessarily need to follow this format so please\nbe creative and come up with different approaches yourself.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)\n\n    \n    \n    **Input:** root = [123nullnull45]\n    **Output:** [123nullnull45]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 104]`.\n  * `-1000 <= Node.val <= 1000`\n\n,# Runtime: 372 ms (Top 18.39%) | Memory: 20.4 MB (Top 30.28%)\nclass Codec:\n\n    def serialize(self root):\n        if not root: return 'N'\n\n        left = self.serialize(root.left)\n        right = self.serialize(root.right)\n\n        return ''.join([str(root.val) left right])\n\n    def deserialize(self data):\n        data = data.split('')\n        root = self.buildTree(data)\n        return root\n\n    def buildTree(self data):\n        val = data.pop(0)\n        if val == 'N': return None\n        node = TreeNode(val)\n        node.left = self.buildTree(data)\n        node.right = self.buildTree(data)\n        return node
Serialize and Deserialize BST,###  449\. Serialize and Deserialize BST\n\nSerialization is converting a data structure or object into a sequence of bits\nso that it can be stored in a file or memory buffer or transmitted across a\nnetwork connection link to be reconstructed later in the same or another\ncomputer environment.\n\nDesign an algorithm to serialize and deserialize a **binary search tree**.\nThere is no restriction on how your serialization/deserialization algorithm\nshould work. You need to ensure that a binary search tree can be serialized to\na string and this string can be deserialized to the original tree structure.\n\n**The encoded string should be as compact as possible.**\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** root = [213]\n    **Output:** [213]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[0 104]`.\n  * `0 <= Node.val <= 104`\n  * The input tree is **guaranteed** to be a binary search tree.\n\n,"class Codec:\n    def serialize(self root: Optional[TreeNode]) -> str:\n        """"""Encodes a tree to a single string.\n        """"""\n        if not root:\n            return """"\n        res = []\n        def dfs(node):\n            res.append(str(node.val))\n            if node.left:\n                dfs(node.left)\n            if node.right:\n                dfs(node.right)\n        dfs(root)\n        return ''.join(res)\n    def deserialize(self data: str) -> Optional[TreeNode]:\n        """"""Decodes your encoded data to tree.\n        """"""\n        if len(data) == 0:\n            return []\n        splitdata = data.split("""") \n        preorder = []\n        for item in splitdata:\n            preorder.append(int(item))          \n        inorder = sorted(preorder)\n        hash_map = {}  \n        for i in range(len(inorder)):\n            hash_map[inorder[i]] = i\n        def helper(preorder pstart pend inorder istart iend):\n            if pstart > pend:\n                return None\n            elif pstart == pend:\n                return TreeNode(preorder[pstart])\n\n            root = TreeNode(preorder[pstart])\n            \n            rootindex = hash_map[preorder[pstart]]\n            \n            numleft = rootindex - istart\n            \n            root.left = helper(preorder pstart+1 pstart + numleft inorder istartrootindex-1 )\n            root.right = helper(preorder pstart + numleft +1 pend inorder rootindex +1 iend)\n            \n            return root\n            \n        return (helper(preorder 0 len(preorder)-1 inorder 0 len(inorder)-1))\n"
Set Intersection Size At Least Two,###  757\. Set Intersection Size At Least Two\n\nAn integer interval `[a b]` (for integers `a < b`) is a set of all\nconsecutive integers from `a` to `b` including `a` and `b`.\n\nFind the minimum size of a set S such that for every integer interval A in\n`intervals` the intersection of S with A has a size of at least two.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** intervals = [[13][14][25][35]]\n    **Output:** 3\n    **Explanation:** Consider the set S = {2 3 4}.  For each interval there are at least 2 elements from S in the interval.\n    Also there isn't a smaller size set that fulfills the above condition.\n    Thus we output the size of this set which is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** intervals = [[12][23][24][45]]\n    **Output:** 5\n    **Explanation:** An example of a minimum sized set is {1 2 3 4 5}.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= intervals.length <= 3000`\n  * `intervals[i].length == 2`\n  * `0 <= ai < bi <= 108`\n\n,class Solution:\n    def intersectionSizeTwo(self intervals: List[List[int]]) -> int:\n        ans = []\n        for x y in sorted(intervals key=lambda x: (x[1] -x[0])): \n            if not ans or ans[-2] < x: \n                if ans and x <= ans[-1]: ans.append(y)\n                else: ans.extend([y-1 y])\n        return len(ans)
Set Matrix Zeroes,###  73\. Set Matrix Zeroes\n\nGiven an `m x n` integer matrix `matrix` if an element is `0` set its entire\nrow and column to `0`'s.\n\nYou must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)\n\n    \n    \n    **Input:** matrix = [[111][101][111]]\n    **Output:** [[101][000][101]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)\n\n    \n    \n    **Input:** matrix = [[0120][3452][1315]]\n    **Output:** [[0000][0450][0310]]\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[0].length`\n  * `1 <= m n <= 200`\n  * `-231 <= matrix[i][j] <= 231 - 1`\n\n\n\n**Follow up:**\n\n  * A straightforward solution using `O(mn)` space is probably a bad idea.\n  * A simple improvement uses `O(m + n)` space but still not the best solution.\n  * Could you devise a constant space solution?\n\n,"class Solution:\n    def setZeroes(self matrix: List[List[int]]) -> None:\n        rows = len(matrix)\n        cols = len(matrix[0])\n        visited=set()\n        for r in range(rows):\n            for c in range(cols):\n                \n                if matrix[r][c]==0 and (rc) not in visited :\n                    for t in range(cols):\n                        if matrix[r][t]!=0:\n                            matrix[r][t]=0\n                            visited.add((rt))\n                    for h in range(rows):\n                        if matrix[h][c]!=0:\n                            matrix[h][c]=0\n                            visited.add((hc))\n        ##Time Complexity :- O(m*n)\n        ##Space Complexity:- O(m+n)\n		\n		```"
Set Mismatch,###  645\. Set Mismatch\n\nYou have a set of integers `s` which originally contains all the numbers from\n`1` to `n`. Unfortunately due to some error one of the numbers in `s` got\nduplicated to another number in the set which results in **repetition of\none** number and **loss of another** number.\n\nYou are given an integer array `nums` representing the data status of this set\nafter the error.\n\nFind the number that occurs twice and the number that is missing and return\n_them in the form of an array_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1224]\n    **Output:** [23]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [11]\n    **Output:** [12]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 104`\n  * `1 <= nums[i] <= 104`\n\n,// Runtime: 150 ms (Top 93.95%) | Memory: 18.00 MB (Top 86.53%)\n\nclass Solution:\n    def findErrorNums(self nums):\n        n = len(nums)\n        v = [0] * (n + 1)\n        missing duplicate = 0 0\n\n        for num in nums:\n            v[num] += 1\n\n        for i in range(1 len(v)):\n            if v[i] == 2:\n                duplicate = i\n            if v[i] == 0:\n                missing = i\n\n        return [duplicate missing]\n\n\n
Shift 2D Grid,###  1260\. Shift 2D Grid\n\nGiven a 2D `grid` of size `m x n` and an integer `k`. You need to shift the\n`grid` `k` times.\n\nIn one shift operation:\n\n  * Element at `grid[i][j]` moves to `grid[i][j + 1]`.\n  * Element at `grid[i][n - 1]` moves to `grid[i + 1][0]`.\n  * Element at `grid[m - 1][n - 1]` moves to `grid[0][0]`.\n\nReturn the _2D grid_ after applying shift operation `k` times.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/11/05/e1.png)\n\n    \n    \n    **Input:** grid = [[123][456][789]] k = 1\n    **Output:** [[912][345][678]]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/11/05/e2.png)\n\n    \n    \n    **Input:** grid = [[3819][19725][461110][1202113]] k = 4\n    **Output:** [[1202113][3819][19725][461110]]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[123][456][789]] k = 9\n    **Output:** [[123][456][789]]\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m <= 50`\n  * `1 <= n <= 50`\n  * `-1000 <= grid[i][j] <= 1000`\n  * `0 <= k <= 100`\n\n,class Solution:\n    def shiftGrid(self grid: List[List[int]] k: int) -> List[List[int]]:\n        m n = len(grid) len(grid[0])\n        cache = []\n        for i in range(m):\n            for j in range(n):\n                cache.append(grid[i][j])\n        \n        k %= len(cache)\n        new_vals = cache[-k:] + cache[:-k]\n        \n        cur = 0\n        for i in range(m):\n            for j in range(n):\n                grid[i][j] = new_vals[cur]\n                cur += 1\n        \n        return grid\n
Shifting Letters,"###  848\. Shifting Letters\n\nYou are given a string `s` of lowercase English letters and an integer array\n`shifts` of the same length.\n\nCall the `shift()` of a letter the next letter in the alphabet (wrapping\naround so that `'z'` becomes `'a'`).\n\n  * For example `shift('a') = 'b'` `shift('t') = 'u'` and `shift('z') = 'a'`.\n\nNow for each `shifts[i] = x` we want to shift the first `i + 1` letters of\n`s` `x` times.\n\nReturn _the final string after all such shifts to s are applied_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abc"" shifts = [359]\n    **Output:** ""rpl""\n    **Explanation:** We start with ""abc"".\n    After shifting the first 1 letters of s by 3 we have ""dbc"".\n    After shifting the first 2 letters of s by 5 we have ""igc"".\n    After shifting the first 3 letters of s by 9 we have ""rpl"" the answer.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aaa"" shifts = [123]\n    **Output:** ""gfd""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of lowercase English letters.\n  * `shifts.length == s.length`\n  * `0 <= shifts[i] <= 109`\n\n",class Solution:\n    def shiftingLetters(self s: str shifts: List[int]) -> str:\n        n = len(s)\n        nums = []\n        sums = 0\n        for i in shifts[::-1]:\n            sums = (sums+i)%26\n            nums.append(sums)\n        nums = nums[::-1]\n        \n        res = ''\n        for i ch in enumerate(s):\n            val = ord(s[i]) + nums[i]\n            while val > 122:\n                val -= 26\n            res += chr(val)\n        \n        return res
Short Encoding of Words,"###  820\. Short Encoding of Words\n\nA **valid encoding** of an array of `words` is any reference string `s` and\narray of indices `indices` such that:\n\n  * `words.length == indices.length`\n  * The reference string `s` ends with the `'#'` character.\n  * For each index `indices[i]` the **substring** of `s` starting from `indices[i]` and up to (but not including) the next `'#'` character is equal to `words[i]`.\n\nGiven an array of `words` return _the**length of the shortest reference\nstring** _`s` _possible of any**valid encoding** of _`words` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""time"" ""me"" ""bell""]\n    **Output:** 10\n    **Explanation:** A valid encoding would be s = ""time#bell#"" and indices = [0 2 5].\n    words[0] = ""time"" the substring of s starting from indices[0] = 0 to the next '#' is underlined in ""_time_ #bell#""\n    words[1] = ""me"" the substring of s starting from indices[1] = 2 to the next '#' is underlined in ""ti _me_ #bell#""\n    words[2] = ""bell"" the substring of s starting from indices[2] = 5 to the next '#' is underlined in ""time#_bell_ #""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""t""]\n    **Output:** 2\n    **Explanation:** A valid encoding would be s = ""t#"" and indices = [0].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 2000`\n  * `1 <= words[i].length <= 7`\n  * `words[i]` consists of only lowercase letters.\n\n",class Solution:\n    def minimumLengthEncoding(self words):\n        \n        \n        # root of suffix trie\n        trie_root = dict()\n        \n        # helper function to judge leaf node\n        isLeafNode = lambda node: len(node) == 0\n        \n        # collection of tail nodes\n        tail_nodes = []\n        \n        # set of unique words\n        unique_words = set(words)\n        \n        # scan each word\n        for word in unique_words:\n            \n            # build suffix trie from root node\n            cur = trie_root\n            \n            # scan each character in reversed order\n            for char in reversed(word):\n                \n                # update trie\n                cur[char] = cur.get(char dict() )\n                \n                # go to next level\n                cur = cur[char]\n            \n            # save tail nodes with corresponding word length +1 is for '#' symbol\n            tail_nodes.append( (cur len(word)+1) )\n\n        # summation of the length with all tail node which is also a leaf node\n        return sum( suffix_length for node suffix_length in tail_nodes if isLeafNode(node) )
Shortest Bridge,###  934\. Shortest Bridge\n\nYou are given an `n x n` binary matrix `grid` where `1` represents land and\n`0` represents water.\n\nAn **island** is a 4-directionally connected group of `1`'s not connected to\nany other `1`'s. There are **exactly two islands** in `grid`.\n\nYou may change `0`'s to `1`'s to connect the two islands to form **one\nisland**.\n\nReturn _the smallest number of_`0` _'s you must flip to connect the two\nislands_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** grid = [[01][10]]\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[010][000][001]]\n    **Output:** 2\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[11111][10001][10101][10001][11111]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length == grid[i].length`\n  * `2 <= n <= 100`\n  * `grid[i][j]` is either `0` or `1`.\n  * There are exactly two islands in `grid`.\n\n,# Runtime: 329 ms (Top 84.2%) | Memory: 17.67 MB (Top 84.2%)\n\nclass Solution:\n    def shortestBridge(self grid):\n        m n = len(grid) len(grid[0])\n        start_i start_j = next((i j) for i in range(m) for j in range(n) if grid[i][j])\n        \n        \n        stack = [(start_i start_j)]\n        visited = set(stack)\n        while stack:\n            i j = stack.pop()\n            visited.add((i j))  \n            for ii jj in (i-1 j) (i j-1) (i j+1) (i+1 j):\n                if 0 <= ii < m and 0 <= jj < n and grid[ii][jj] and (ii jj) not in visited:\n                    stack.append((ii jj))\n                    visited.add((ii jj))\n        \n        \n        ans = 0\n        queue = list(visited)\n        while queue:\n            new_queue = []\n            for i j in queue:\n                for ii jj in (i-1 j) (i j-1) (i j+1) (i+1 j):\n                    if 0 <= ii < m and 0 <= jj < n and (ii jj) not in visited:\n                        if grid[ii][jj] == 1:\n                            return ans\n                        new_queue.append((ii jj))\n                        visited.add((ii jj))\n            queue = new_queue\n            ans += 1\n
Shortest Common Supersequence,"###  1092\. Shortest Common Supersequence\n\nGiven two strings `str1` and `str2` return _the shortest string that has\nboth_`str1` _and_`str2` _as**subsequences**_. If there are multiple valid\nstrings return **any** of them.\n\nA string `s` is a **subsequence** of string `t` if deleting some number of\ncharacters from `t` (possibly `0`) results in the string `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** str1 = ""abac"" str2 = ""cab""\n    **Output:** ""cabac""\n    **Explanation:** \n    str1 = ""abac"" is a subsequence of ""cabac"" because we can delete the first ""c"".\n    str2 = ""cab"" is a subsequence of ""cabac"" because we can delete the last ""ac"".\n    The answer provided is the shortest such string that satisfies these properties.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** str1 = ""aaaaaaaa"" str2 = ""aaaaaaaa""\n    **Output:** ""aaaaaaaa""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= str1.length str2.length <= 1000`\n  * `str1` and `str2` consist of lowercase English letters.\n\n",class Solution:\n    def shortestCommonSupersequence(self A B):\n        n m = len(A) len(B)\n        dp = [B[:i] for i in range(m + 1)]\n        for i in range(n):\n            prev = A[:i]\n            dp[0] = A[:i + 1]\n            for j in range(m):\n                if A[i] == B[j]:\n                    prev dp[j + 1] = dp[j + 1] prev + A[i]\n                else:\n                    prev dp[j + 1] = dp[j + 1] min(dp[j] + B[j] dp[j + 1] + A[i] key = len)\n        return dp[-1]\n
Shortest Completing Word,"###  748\. Shortest Completing Word\n\nGiven a string `licensePlate` and an array of strings `words` find the\n**shortest completing** word in `words`.\n\nA **completing** word is a word that **contains all the letters** in\n`licensePlate`. **Ignore numbers and spaces** in `licensePlate` and treat\nletters as **case insensitive**. If a letter appears more than once in\n`licensePlate` then it must appear in the word the same number of times or\nmore.\n\nFor example if `licensePlate`` = ""aBc 12c""` then it contains letters `'a'`\n`'b'` (ignoring case) and `'c'` twice. Possible **completing** words are\n`""abccdef""` `""caaacab""` and `""cbca""`.\n\nReturn _the shortest**completing** word in _`words` _._ It is guaranteed an\nanswer exists. If there are multiple shortest **completing** words return the\n**first** one that occurs in `words`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** licensePlate = ""1s3 PSt"" words = [""step""""steps""""stripe""""stepple""]\n    **Output:** ""steps""\n    **Explanation:** licensePlate contains letters 's' 'p' 's' (ignoring case) and 't'.\n    ""step"" contains 't' and 'p' but only contains 1 's'.\n    ""steps"" contains 't' 'p' and both 's' characters.\n    ""stripe"" is missing an 's'.\n    ""stepple"" is missing an 's'.\n    Since ""steps"" is the only word containing all the letters that is the answer.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** licensePlate = ""1s3 456"" words = [""looks""""pest""""stew""""show""]\n    **Output:** ""pest""\n    **Explanation:** licensePlate only contains the letter 's'. All the words contain 's' but among these ""pest"" ""stew"" and ""show"" are shortest. The answer is ""pest"" because it is the word that appears earliest of the 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= licensePlate.length <= 7`\n  * `licensePlate` contains digits letters (uppercase or lowercase) or space `' '`.\n  * `1 <= words.length <= 1000`\n  * `1 <= words[i].length <= 15`\n  * `words[i]` consists of lower case English letters.\n\n",class Solution:\n    def shortestCompletingWord(self licensePlate: str words: List[str]) -> str:\n        newPlate = ''         # modify the licensePlate\n        for i in licensePlate:\n            if i.isalpha():\n                newPlate += i.lower()\n                \n        c = Counter(newPlate)\n        l1 = []         # store (wordlenindex)\n        for idxword in enumerate(words):\n            if Counter(word) >= c:\n                l1.append((wordlen(word)idx))\n        l1.sort(key = lambda x:(x[1]idx))\n        return l1[0][0]\n
Shortest Palindrome,"###  214\. Shortest Palindrome\n\nYou are given a string `s`. You can convert `s` to a palindrome by adding\ncharacters in front of it.\n\nReturn _the shortest palindrome you can find by performing this\ntransformation_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aacecaaa""\n    **Output:** ""aaacecaaa""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcd""\n    **Output:** ""dcbabcd""\n    \n\n\n\n**Constraints:**\n\n  * `0 <= s.length <= 5 * 104`\n  * `s` consists of lowercase English letters only.\n\n",class Solution:\n    def shortestPalindrome(self s: str) -> str:\n        \n        end = 0\n        \n        # if the string itself is a palindrome return it\n        if(s == s[::-1]):\n            return s\n        \n        # Otherwise find the end index of the longest palindrome that starts\n        # from the first character of the string\n        \n        for i in range(len(s)+1):\n            if(s[:i]==s[:i][::-1]):\n                end=i-1\n        \n        # return the string with the remaining characters other than\n        # the palindrome reversed and added at the beginning\n        \n        return (s[end+1:][::-1])+s\n
Shortest Path in a Grid with Obstacles Elimination,###  1293\. Shortest Path in a Grid with Obstacles Elimination\n\nYou are given an `m x n` integer matrix `grid` where each cell is either `0`\n(empty) or `1` (obstacle). You can move up down left or right from and to\nan empty cell in **one step**.\n\nReturn _the minimum number of**steps** to walk from the upper left corner\n_`(0 0)`_to the lower right corner_`(m - 1 n - 1)`_given that you can\neliminate**at most** _`k` _obstacles_. If it is not possible to find such walk\nreturn `-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg)\n\n    \n    \n    **Input:** grid = [[000][110][000][011][000]] k = 1\n    **Output:** 6\n    **Explanation:** \n    The shortest path without eliminating any obstacle is 10.\n    The shortest path with one obstacle elimination at position (32) is 6. Such path is (00) -> (01) -> (02) -> (12) -> (22) -> **(32)** -> (42).\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg)\n\n    \n    \n    **Input:** grid = [[011][111][100]] k = 1\n    **Output:** -1\n    **Explanation:** We need to eliminate at least two obstacles to find such a walk.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 40`\n  * `1 <= k <= m * n`\n  * `grid[i][j]` is either `0` **or** `1`.\n  * `grid[0][0] == grid[m - 1][n - 1] == 0`\n\n,"class Solution:\n    def shortestPath(self grid: List[List[int]] k: int) -> int:\n        Q = [[0 0 k]] # m n remaining elimination quota \n        rows cols = len(grid) len(grid[0])\n        V counter = {(0 0):k} 0 # I use a V to keep track of how cells have been visited\n        \n        while Q: \n            frontier = []\n            for m n rem in Q: \n                if m == rows - 1 and n == cols - 1: \n                    return counter \n                for dm dn in [[1 0] [-1 0] [0 1] [0 -1]]: \n                    if 0 <= m+dm < rows and 0 <= n+dn < cols: # check inbound \n                        if grid[m+dm][n+dn] == 0: \n                            if (m+dm n+dn) not in V or V[(m+dm n+dn)] < rem: # if not visited or could be visited with fewer elimination \n                                frontier.append([m+dm n+dn rem])\n                                V[(m+dm n+dn)] = rem\n                        elif rem > 0: # I see a wall and I can still eliminate\n                            if (m+dm n+dn) not in V or V[(m+dm n+dn)] < rem - 1: # if not visited or could be visited with fewer elimination \n                                frontier.append([m+dm n+dn rem-1])\n                                V[(m+dm n+dn)] = rem - 1\n            Q = frontier \n            counter += 1\n                \n        return -1\n	```"
Shortest Path in Binary Matrix,###  1091\. Shortest Path in Binary Matrix\n\nGiven an `n x n` binary matrix `grid` return _the length of the\nshortest**clear path** in the matrix_. If there is no clear path return `-1`.\n\nA **clear path** in a binary matrix is a path from the **top-left** cell\n(i.e. `(0 0)`) to the **bottom-right** cell (i.e. `(n - 1 n - 1)`) such\nthat:\n\n  * All the visited cells of the path are `0`.\n  * All the adjacent cells of the path are **8-directionally** connected (i.e. they are different and they share an edge or a corner).\n\nThe **length of a clear path** is the number of visited cells of this path.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/18/example1_1.png)\n\n    \n    \n    **Input:** grid = [[01][10]]\n    **Output:** 2\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/18/example2_1.png)\n\n    \n    \n    **Input:** grid = [[000][110][110]]\n    **Output:** 4\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[100][110][110]]\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length`\n  * `n == grid[i].length`\n  * `1 <= n <= 100`\n  * `grid[i][j] is 0 or 1`\n\n,"'''\nfrom collections import deque\nclass Solution:\n	def shortestPathBinaryMatrix(self grid: List[List[int]]) -> int:\n		L=len(grid)\n		def generate_next_state(ij):\n			return [(i+1j)(i-1j)(ij+1)(ij-1)(i+1j-1)(i+1j+1)(i-1j-1)(i-1j+1)]\n		def valid_state(states):\n			res=[]\n			for (ij) in states:\n				if i>L-1:continue\n				if i<0:continue\n				if j<0:continue\n				if j>L-1:continue\n				if grid[i][j]==0:\n					res.append((ij))\n			return res\n		queue=deque([(00)])\n		res=1\n		while queue:\n			for _ in range(len(queue)):\n				ij=queue.popleft()\n				val=grid[i][j]\n				grid[i][j]=1\n				if not val:\n					if i==L-1 and j==L-1:\n						return res\n\n					next_state=valid_state(generate_next_state(ij))\n					for (kikj) in next_state:\n						queue.append((kikj))\n			res+=1\n		return -1\n                \n        \n        \n    \n'''"
Shortest Path to Get All Keys,"###  864\. Shortest Path to Get All Keys\n\nYou are given an `m x n` grid `grid` where:\n\n  * `'.'` is an empty cell.\n  * `'#'` is a wall.\n  * `'@'` is the starting point.\n  * Lowercase letters represent keys.\n  * Uppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in\none of the four cardinal directions. You cannot walk outside the grid or walk\ninto a wall.\n\nIf you walk over a key you can pick it up and you cannot walk over a lock\nunless you have its corresponding key.\n\nFor some `1 <= k <= 6` there is exactly one lowercase and one uppercase\nletter of the first `k` letters of the English alphabet in the grid. This\nmeans that there is exactly one key for each lock and one lock for each key;\nand also that the letters used to represent the keys and locks were chosen in\nthe same order as the English alphabet.\n\nReturn _the lowest number of moves to acquire all keys_. If it is impossible\nreturn `-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg)\n\n    \n    \n    **Input:** grid = [""@.a..""""###.#""""b.A.B""]\n    **Output:** 8\n    **Explanation:** Note that the goal is to obtain all the keys not to open all the locks.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg)\n\n    \n    \n    **Input:** grid = [""@..aA""""..B#.""""....b""]\n    **Output:** 6\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg)\n\n    \n    \n    **Input:** grid = [""@Aa""]\n    **Output:** -1\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 30`\n  * `grid[i][j]` is either an English letter `'.'` `'#'` or `'@'`.\n  * The number of keys in the grid is in the range `[1 6]`.\n  * Each key in the grid is **unique**.\n  * Each key in the grid has a matching lock.\n\n","class Solution:\n    def shortestPathAllKeys(self grid: List[str]) -> int:\n        \n        m=len(grid)\n        n=len(grid[0])\n        visited=set()\n        \n        steps=0\n        q=deque([])\n        keyCt=0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]==""@"":\n                    q.append((ij''))\n                elif grid[i][j].islower():\n                    keyCt+=1\n        \n        while q:\n            for _ in range(len(q)):\n                curr_xcurr_ykeys = q.popleft()\n                if (curr_xcurr_ykeys) in visited:\n                    continue\n                \n                visited.add((curr_xcurr_ykeys))\n                \n                if len(keys)==keyCt:\n                    return steps\n                \n                for xy in ((01)(10)(-10)(0-1)):\n                    nx=curr_x+x\n                    ny=curr_y+y\n                    if nx<0 or ny<0 or nx>=m or ny>=n or grid[nx][ny]=='#' or (nxnykeys) in visited:\n                        continue\n                        \n                    curr=grid[nx][ny]                    \n                    if curr in 'abcdef' and curr not in keys:\n                        q.append((nxnykeys+curr))                            \n                    elif curr.isupper() and curr.lower() not in keys:\n                        continue\n                    else:\n                        q.append((nxnykeys))\n            steps+=1\n        \n        return -1"
Shortest Path Visiting All Nodes,###  847\. Shortest Path Visiting All Nodes\n\nYou have an undirected connected graph of `n` nodes labeled from `0` to `n -\n1`. You are given an array `graph` where `graph[i]` is a list of all the nodes\nconnected with node `i` by an edge.\n\nReturn _the length of the shortest path that visits every node_. You may start\nand stop at any node you may revisit nodes multiple times and you may reuse\nedges.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/12/shortest1-graph.jpg)\n\n    \n    \n    **Input:** graph = [[123][0][0][0]]\n    **Output:** 4\n    **Explanation:** One possible path is [10203]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/05/12/shortest2-graph.jpg)\n\n    \n    \n    **Input:** graph = [[1][024][134][2][12]]\n    **Output:** 4\n    **Explanation:** One possible path is [01423]\n    \n\n\n\n**Constraints:**\n\n  * `n == graph.length`\n  * `1 <= n <= 12`\n  * `0 <= graph[i].length < n`\n  * `graph[i]` does not contain `i`.\n  * If `graph[a]` contains `b` then `graph[b]` contains `a`.\n  * The input graph is always connected.\n\n,class Solution:\n    def shortestPathLength(self graph: List[List[int]]) -> int:\n        n = len(graph)\n        dist = [[inf]*n for _ in range(n)]\n        \n        for i x in enumerate(graph): \n            dist[i][i] = 0\n            for ii in x: dist[i][ii] = 1\n        \n        # floyd-warshall \n        for k in range(n): \n            for i in range(n): \n                for j in range(n): \n                    dist[i][j] = min(dist[i][j] dist[i][k] + dist[k][j])\n        \n        @cache \n        def fn(x mask): \n            if mask == 0: return 0 \n            ans = inf \n            for i in range(n): \n                if mask & (1 << i): \n                    ans = min(ans dist[x][i] + fn(i mask ^ (1<<i)))\n            return ans \n        \n        return min(fn(x (1 << n)-1) for x in range(n))
Shortest Path with Alternating Colors,###  1129\. Shortest Path with Alternating Colors\n\nYou are given an integer `n` the number of nodes in a directed graph where\nthe nodes are labeled from `0` to `n - 1`. Each edge is red or blue in this\ngraph and there could be self-edges and parallel edges.\n\nYou are given two arrays `redEdges` and `blueEdges` where:\n\n  * `redEdges[i] = [ai bi]` indicates that there is a directed red edge from node `ai` to node `bi` in the graph and\n  * `blueEdges[j] = [uj vj]` indicates that there is a directed blue edge from node `uj` to node `vj` in the graph.\n\nReturn an array `answer` of length `n` where each `answer[x]` is the length\nof the shortest path from node `0` to node `x` such that the edge colors\nalternate along the path or `-1` if such a path does not exist.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 redEdges = [[01][12]] blueEdges = []\n    **Output:** [01-1]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3 redEdges = [[01]] blueEdges = [[21]]\n    **Output:** [01-1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 100`\n  * `0 <= redEdges.length blueEdges.length <= 400`\n  * `redEdges[i].length == blueEdges[j].length == 2`\n  * `0 <= ai bi uj vj < n`\n\n,"class Solution:\n    def shortestAlternatingPaths(self n: int redEdges: List[List[int]] blueEdges: List[List[int]]) -> List[int]:\n        g = [[[] for _ in range(2)] for _ in range(n)]\n        \n        for ij in redEdges:\n            g[i][0] += [j]\n        for ij in blueEdges:\n            g[i][1] += [j]\n        distance = [float(""inf"") for _ in range(n)]\n        distance[0] = 0\n        q = queue.Queue()\n        q.put((00False))\n        q.put((00True))\n        \n        redS = set([0])\n        blueS = set([0])\n        while not q.empty():\n            nodedistred = q.get()\n            if red:\n                neighbours = g[node][0]\n                redS.add(node)\n                curr = blueS\n            else:\n                neighbours = g[node][1]\n                blueS.add(node)\n                curr = redS\n            for neighbour in neighbours:\n                if dist + 1 < distance[neighbour]:\n                    distance[neighbour] = dist + 1\n                    q.put((neighbourdist + 1not red))\n                if not (neighbour in curr):\n                    q.put((neighbourdist + 1not red))\n        for i in range(n):\n            if distance[i] == float(""inf""):\n                distance[i] = -1\n        return distance\n            \n"
Shortest Subarray to be Removed to Make Array Sorted,###  1574\. Shortest Subarray to be Removed to Make Array Sorted\n\nGiven an integer array `arr` remove a subarray (can be empty) from `arr` such\nthat the remaining elements in `arr` are **non-decreasing**.\n\nReturn _the length of the shortest subarray to remove_.\n\nA **subarray** is a contiguous subsequence of the array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [123104235]\n    **Output:** 3\n    **Explanation:** The shortest subarray we can remove is [1042] of length 3. The remaining elements after that will be [12335] which are sorted.\n    Another correct solution is to remove the subarray [3104].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [54321]\n    **Output:** 4\n    **Explanation:** Since the array is strictly decreasing we can only keep a single element. Therefore we need to remove a subarray of length 4 either [5432] or [4321].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [123]\n    **Output:** 0\n    **Explanation:** The array is already non-decreasing. We do not need to remove any elements.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 105`\n  * `0 <= arr[i] <= 109`\n\n,class Solution:\n    def findLengthOfShortestSubarray(self arr: List[int]) -> int:\n        n = len(arr)\n        i = 0\n        while i < n-1 and arr[i+1] >= arr[i]:\n            i += 1\n        \n        if i == n-1:\n            return 0\n        \n        j = n-1\n        while j >= 0 and arr[j-1] <= arr[j]:\n            j -= 1\n        \n        ans = min(n n-i-1 j)\n        \n        for l in range(i+1):\n            r = j\n            while r < n and arr[r] < arr[l]:\n                r += 1\n            ans = min(ans r-l-1)\n        \n        return ans
Shortest Subarray with Sum at Least K,###  862\. Shortest Subarray with Sum at Least K\n\nGiven an integer array `nums` and an integer `k` return _the length of the\nshortest non-empty**subarray** of _`nums` _with a sum of at least_`k`. If\nthere is no such **subarray**  return `-1`.\n\nA **subarray** is a **contiguous** part of an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1] k = 1\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12] k = 4\n    **Output:** -1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [2-12] k = 3\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-105 <= nums[i] <= 105`\n  * `1 <= k <= 109`\n\n,# 1. we can not use sliding window to solve the problem because the numbers in nums can be negative \n# the numbers in sliding window are not always incrementing\n# ex [8-4316] 10\n\n# 2. prefixsum2 - prefixsum1 >= k is used to find a subarray whose sum >= k.\n# 3. monotonic queue is used to keep the prefix sums are in the incrementing order\n# 4. If the diffenence between the cur and the tail of monotonic queue is greater than or equal to k we can find the shortest length of the subarray at this time.\n\nclass Solution:\n    def shortestSubarray(self nums: List[int] k: int) -> int:\n        prefixsum = [0]\n        monoq = deque()\n        minLen = float('inf')\n        # to calculate prefix sum\n        for n in nums:\n            prefixsum.append(n+prefixsum[-1])\n        for idx cur in enumerate(prefixsum):\n            while monoq and prefixsum[monoq[-1]] >= cur: monoq.pop() # to maintain monotonic queue\n\n            # If the diffenence between the head and the tail of monotonic queue is greater than or equal to k we can find the shortest length of the subarray at this time.\n            while monoq and cur-prefixsum[monoq[0]]>=k: \n                minLen = min(minLen idx-monoq.popleft())\n            monoq.append(idx)\n        return -1 if minLen == float('inf') else minLen\n
Shortest Unsorted Continuous Subarray,###  581\. Shortest Unsorted Continuous Subarray\n\nGiven an integer array `nums` you need to find one **continuous subarray**\nthat if you only sort this subarray in ascending order then the whole array\nwill be sorted in ascending order.\n\nReturn _the shortest such subarray and output its length_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [264810915]\n    **Output:** 5\n    **Explanation:** You need to sort [6 4 8 10 9] in ascending order to make the whole array sorted in ascending order.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-105 <= nums[i] <= 105`\n\n\n\n**Follow up:** Can you solve it in `O(n)` time complexity?\n\n,# Runtime: 250 ms (Top 81.05%) | Memory: 16.2 MB (Top 5.39%)\n#lets start adding elements to stack. We have to fin the min length [a b] interval (corresponding to the problem description).\n# a has to be the first element's index we pop from the array. lets say y is the last element's index we pop.\n# and max_pop is the maximum element(not index) we pop during stacking.After stacking process is done we are going to have\n#last elements in the stack E(E is the stack after stacking is done).We have to find M = maximum_element(max_pop all elements of E)\n#Index of M is going to be right edge of the [a b] interval\n\nclass Solution:\n    def findUnsortedSubarray(self nums) -> int:\n        stack = []\n        min_index = len(nums)\n        max_index = 0\n        max_pop = float('-inf')\n        for i in range(len(nums)):\n            while stack and nums[i] < stack[-1][0]:\n\n                p = stack.pop()\n                if p[0] > max_pop:\n                    max_pop = p[0]\n                if p[1] < min_index:\n                    min_index = p[1]\n                if p[1] > max_index:\n                    max_index = p[1]\n            stack.append([nums[i] i])\n        max_r = max_index\n        for st in stack:\n            if st[0] < max_pop:\n                max_r = st[1]\n        if min_index == len(nums):\n            return 0\n        return max_r - min_index +1\n
Shuffle an Array,"###  384\. Shuffle an Array\n\nGiven an integer array `nums` design an algorithm to randomly shuffle the\narray. All permutations of the array should be **equally likely** as a result\nof the shuffling.\n\nImplement the `Solution` class:\n\n  * `Solution(int[] nums)` Initializes the object with the integer array `nums`.\n  * `int[] reset()` Resets the array to its original configuration and returns it.\n  * `int[] shuffle()` Returns a random shuffling of the array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Solution"" ""shuffle"" ""reset"" ""shuffle""]\n    [[[1 2 3]] [] [] []]\n    **Output**\n    [null [3 1 2] [1 2 3] [1 3 2]]\n    \n    **Explanation**\n    Solution solution = new Solution([1 2 3]);\n    solution.shuffle();    // Shuffle the array [123] and return its result.\n                           // Any permutation of [123] must be equally likely to be returned.\n                           // Example: return [3 1 2]\n    solution.reset();      // Resets the array back to its original configuration [123]. Return [1 2 3]\n    solution.shuffle();    // Returns the random shuffling of array [123]. Example: return [1 3 2]\n    \n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 50`\n  * `-106 <= nums[i] <= 106`\n  * All the elements of `nums` are **unique**.\n  * At most `104` calls **in total** will be made to `reset` and `shuffle`.\n\n",import random \n\nclass Solution:\n\n    def __init__(self nums: List[int]):\n        self.nums = nums\n\n    def reset(self) -> List[int]:  \n        return self.nums\n\n    def shuffle(self) -> List[int]:\n        shuffled_array = self.nums.copy()\n        # randomly generates the idx of the element that'll be the ith element of the array \n        for i in range(len(self.nums) - 1 0 -1):\n            idx = random.randint(0 i)\n            shuffled_array[i] shuffled_array[idx] = shuffled_array[idx] shuffled_array[i]\n        return shuffled_array
Shuffle String,"###  1528\. Shuffle String\n\nYou are given a string `s` and an integer array `indices` of the **same\nlength**. The string `s` will be shuffled such that the character at the `ith`\nposition moves to `indices[i]` in the shuffled string.\n\nReturn _the shuffled string_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/07/09/q1.jpg)\n\n    \n    \n    **Input:** s = ""codeleet"" indices = [45670213]\n    **Output:** ""leetcode""\n    **Explanation:** As shown ""codeleet"" becomes ""leetcode"" after shuffling.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abc"" indices = [012]\n    **Output:** ""abc""\n    **Explanation:** After shuffling each character remains in its position.\n    \n\n\n\n**Constraints:**\n\n  * `s.length == indices.length == n`\n  * `1 <= n <= 100`\n  * `s` consists of only lowercase English letters.\n  * `0 <= indices[i] < n`\n  * All values of `indices` are **unique**.\n\n","# Runtime: 81 ms (Top 68.03%) | Memory: 13.9 MB (Top 63.45%)\nclass Solution:\n    def restoreString(self s: str indices: List[int]) -> str:\n        dec = {}\n        c = 0\n        res=''\n        for i in indices:\n            dec[i] = s[c]\n            c += 1\n        # dec = {""4"":""c""""5"":""o""""6"":""d""""7"":""e""""0"":""l""""2"":""e""""1"":""e""""3"":""t""}\n        for x in range(len(indices)):\n            res += dec[x]\n            # x in range 0 1 2....... len *indices or s*\n        return res"
Shuffle the Array,###  1470\. Shuffle the Array\n\nGiven the array `nums` consisting of `2n` elements in the form\n`[x1x2...xny1y2...yn]`.\n\n_Return the array in the form_ `[x1y1x2y2...xnyn]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [251347] n = 3\n    **Output:** [235417] \n    **Explanation:** Since x1=2 x2=5 x3=1 y1=3 y2=4 y3=7 then the answer is [235417].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12344321] n = 4\n    **Output:** [14233241]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1122] n = 2\n    **Output:** [1212]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 500`\n  * `nums.length == 2n`\n  * `1 <= nums[i] <= 10^3`\n\n,'''\nFirst of all I'm making a few tuples  using zip function.\nThen extracting every created tuple. (for tup in zip())\nAfter that I can take numbers from the extracted tuples in order to add them to a list and return. (for number in tup)\n'''\nclass Solution:\n    def shuffle(self nums: List[int] n: int) -> List[int]:\n        return [number for tup in zip(nums[:n] nums[n:]) for number in tup]\n
Sign of the Product of an Array,###  1822\. Sign of the Product of an Array\n\nThere is a function `signFunc(x)` that returns:\n\n  * `1` if `x` is positive.\n  * `-1` if `x` is negative.\n  * `0` if `x` is equal to `0`.\n\nYou are given an integer array `nums`. Let `product` be the product of all\nvalues in the array `nums`.\n\nReturn `signFunc(product)`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [-1-2-3-4321]\n    **Output:** 1\n    **Explanation:** The product of all values in the array is 144 and signFunc(144) = 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1502-3]\n    **Output:** 0\n    **Explanation:** The product of all values in the array is 0 and signFunc(0) = 0\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [-11-11-1]\n    **Output:** -1\n    **Explanation:** The product of all values in the array is -1 and signFunc(-1) = -1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `-100 <= nums[i] <= 100`\n\n,"class Solution:\n    def arraySign(self nums: List[int]) -> int:\n		return 0 if 0 in nums else -1 if sum(x < 0 for x in nums) % 2 else 1\n"
Similar String Groups,"###  839\. Similar String Groups\n\nTwo strings `X` and `Y` are similar if we can swap two letters (in different\npositions) of `X` so that it equals `Y`. Also two strings `X` and `Y` are\nsimilar if they are equal.\n\nFor example `""tars""` and `""rats""` are similar (swapping at positions `0` and\n`2`) and `""rats""` and `""arts""` are similar but `""star""` is not similar to\n`""tars""` `""rats""` or `""arts""`.\n\nTogether these form two connected groups by similarity: `{""tars"" ""rats""\n""arts""}` and `{""star""}`.  Notice that `""tars""` and `""arts""` are in the same\ngroup even though they are not similar.  Formally each group is such that a\nword is in the group if and only if it is similar to at least one other word\nin the group.\n\nWe are given a list `strs` of strings where every string in `strs` is an\nanagram of every other string in `strs`. How many groups are there?\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** strs = [""tars""""rats""""arts""""star""]\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** strs = [""omv""""ovm""]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= strs.length <= 300`\n  * `1 <= strs[i].length <= 300`\n  * `strs[i]` consists of lowercase letters only.\n  * All words in `strs` have the same length and are anagrams of each other.\n\n",# Runtime: 5068 ms (Top 15.23%) | Memory: 14.3 MB (Top 64.62%)\nclass Solution: #839. Similar String Groups\n    def numSimilarGroups(self strs: List[str]) -> int:\n        #memo\n        visited = set()\n        count = 0\n        for i in range(len(strs)):\n            if i not in visited:\n                #dfs\n                self.dfs(strs i visited)\n                #add a new connected area\n                count += 1\n        return count\n\n    #dfs to search the similar string from 0 to n-1\n    def dfs(self strs i visited):\n        #add current string to memo\n        visited.add(i)\n        for j in range(len(strs)):\n            if self.isSimilar(strs[i] strs[j]) and j not in visited:\n                self.dfs(strs j  visited)\n\n    # calculate the similarity of two strings\n    def isSimilar(self str1 str2):\n        diff_count = 0\n        for i in range(len(str1)):\n            if str1[i] != str2[i]:\n                diff_count += 1\n        return diff_count <= 2
Simple Bank System,"###  2043\. Simple Bank System\n\nYou have been tasked with writing a program for a popular bank that will\nautomate all its incoming transactions (transfer deposit and withdraw). The\nbank has `n` accounts numbered from `1` to `n`. The initial balance of each\naccount is stored in a **0-indexed** integer array `balance` with the `(i +\n1)th` account having an initial balance of `balance[i]`.\n\nExecute all the **valid** transactions. A transaction is **valid** if:\n\n  * The given account number(s) are between `1` and `n` and\n  * The amount of money withdrawn or transferred from is **less than or equal** to the balance of the account.\n\nImplement the `Bank` class:\n\n  * `Bank(long[] balance)` Initializes the object with the **0-indexed** integer array `balance`.\n  * `boolean transfer(int account1 int account2 long money)` Transfers `money` dollars from the account numbered `account1` to the account numbered `account2`. Return `true` if the transaction was successful `false` otherwise.\n  * `boolean deposit(int account long money)` Deposit `money` dollars into the account numbered `account`. Return `true` if the transaction was successful `false` otherwise.\n  * `boolean withdraw(int account long money)` Withdraw `money` dollars from the account numbered `account`. Return `true` if the transaction was successful `false` otherwise.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""Bank"" ""withdraw"" ""transfer"" ""deposit"" ""transfer"" ""withdraw""]\n    [[[10 100 20 50 30]] [3 10] [5 1 20] [5 20] [3 4 15] [10 50]]\n    **Output**\n    [null true true true false false]\n    \n    **Explanation**\n    Bank bank = new Bank([10 100 20 50 30]);\n    bank.withdraw(3 10);    // return true account 3 has a balance of $20 so it is valid to withdraw $10.\n                             // Account 3 has $20 - $10 = $10.\n    bank.transfer(5 1 20); // return true account 5 has a balance of $30 so it is valid to transfer $20.\n                             // Account 5 has $30 - $20 = $10 and account 1 has $10 + $20 = $30.\n    bank.deposit(5 20);     // return true it is valid to deposit $20 to account 5.\n                             // Account 5 has $10 + $20 = $30.\n    bank.transfer(3 4 15); // return false the current balance of account 3 is $10\n                             // so it is invalid to transfer $15 from it.\n    bank.withdraw(10 50);   // return false it is invalid because account 10 does not exist.\n    \n\n\n\n**Constraints:**\n\n  * `n == balance.length`\n  * `1 <= n account account1 account2 <= 105`\n  * `0 <= balance[i] money <= 1012`\n  * At most `104` calls will be made to **each** function `transfer` `deposit` `withdraw`.\n\n",# Runtime: 1834 ms (Top 5.30%) | Memory: 43.9 MB (Top 45.70%)\nclass Bank:\n\n    def __init__(self bal: List[int]):\n        self.store = bal # storage list\n\n    def transfer(self a1: int a2: int money: int) -> bool:\n        try:\n            # checking if both accounts exist. and if the transaction would be valid\n            if self.store[a1 - 1] >= money and self.store[a2 - 1] >= 0:\n                # performing the transaction\n                self.store[a1 - 1] -= money\n                self.store[a2 - 1] += money\n                return True\n            else:\n                # retrning false on invalid transaction\n                return False\n        except:\n            # returning false when accounts don't exist\n            return False\n\n    def deposit(self ac: int mn: int) -> bool:\n        try:\n            # if account exists performing transaction\n            self.store[ac - 1] += mn\n            return True\n        except:\n            # returning false when account doesn't exist\n            return False\n\n    def withdraw(self ac: int mn: int) -> bool:\n        try:\n            # checking if transaction is valid\n            if self.store[ac - 1] >= mn:\n                # performing the transaction\n                self.store[ac - 1] -= mn\n                return True\n            else:\n                # returning false in case on invalid transaction\n                return False\n        except:\n            # returning false when account doesn't exist\n            return False
Simplified Fractions,"###  1447\. Simplified Fractions\n\nGiven an integer `n` return _a list of all**simplified** fractions between\n_`0` _and_`1` _(exclusive) such that the denominator is less-than-or-equal-\nto_`n`. You can return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** [""1/2""]\n    **Explanation:** ""1/2"" is the only unique fraction with a denominator less-than-or-equal-to 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 3\n    **Output:** [""1/2""""1/3""""2/3""]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** [""1/2""""1/3""""1/4""""2/3""""3/4""]\n    **Explanation:** ""2/4"" is not a simplified fraction because it can be simplified to ""1/2"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 100`\n\n","class Solution:\n    def simplifiedFractions(self n: int) -> List[str]:\n        \n        collect = {}\n        for b in range(2 n+1):\n            for a in range(1 b):\n                if a/b not in collect:\n                    collect[a/b] = f""{a}/{b}""  \n        return list(collect.values())\n"
Simplify Path,"###  71\. Simplify Path\n\nGiven a string `path` which is an **absolute path** (starting with a slash\n`'/'`) to a file or directory in a Unix-style file system convert it to the\nsimplified **canonical path**.\n\nIn a Unix-style file system a period `'.'` refers to the current directory a\ndouble period `'..'` refers to the directory up a level and any multiple\nconsecutive slashes (i.e. `'//'`) are treated as a single slash `'/'`. For\nthis problem any other format of periods such as `'...'` are treated as\nfile/directory names.\n\nThe **canonical path** should have the following format:\n\n  * The path starts with a single slash `'/'`.\n  * Any two directories are separated by a single slash `'/'`.\n  * The path does not end with a trailing `'/'`.\n  * The path only contains the directories on the path from the root directory to the target file or directory (i.e. no period `'.'` or double period `'..'`)\n\nReturn _the simplified**canonical path**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** path = ""/home/""\n    **Output:** ""/home""\n    **Explanation:** Note that there is no trailing slash after the last directory name.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** path = ""/../""\n    **Output:** ""/""\n    **Explanation:** Going one level up from the root directory is a no-op as the root level is the highest level you can go.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** path = ""/home//foo/""\n    **Output:** ""/home/foo""\n    **Explanation:** In the canonical path multiple consecutive slashes are replaced by a single one.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= path.length <= 3000`\n  * `path` consists of English letters digits period `'.'` slash `'/'` or `'_'`.\n  * `path` is a valid absolute Unix path.\n\n","class Solution:\n   def simplifyPath(self path: str) -> str:\n   	stack = []\n   	\n   	i = 0\n       while i < len(path):\n           if path[i] == '/':\n               i += 1\n               continue\n\n           else:\n               cur = ''\n               while i < len(path) and path[i] != '/':\n                   cur += path[i]\n                   i += 1\n\n               if cur == '..':\n                   if stack:\n                       stack.pop()\n               elif cur == '.' or cur == '':\n                   i += 1\n                   continue\n               else:\n                    stack.append(cur)\n\n       return '/' + '/'.join(stack)\n"
Single Element in a Sorted Array,###  540\. Single Element in a Sorted Array\n\nYou are given a sorted array consisting of only integers where every element\nappears exactly twice except for one element which appears exactly once.\n\nReturn _the single element that appears only once_.\n\nYour solution must run in `O(log n)` time and `O(1)` space.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [112334488]\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [3377101111]\n    **Output:** 10\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] <= 105`\n\n,"class Solution:\n    def singleNonDuplicate(self nums: List[int]) -> int:\n        return self.b_search(nums)[0]\n    \n    def b_search(self nums):\n        if len(nums) == 1:\n            return nums\n        mid = len(nums)//2\n        a = nums[:mid]\n        b = nums[mid:]\n		\n		# check if last & first element of the two sub lists are same\n        if a[-1] == b[0]:\n            a = a[:-1]\n            b = b[1:]\n		\n		# ignore the sub list with even number of elements\n        if len(a)%2:\n            return self.b_search(a)\n        else:\n            return self.b_search(b)\n"
Single Number,###  136\. Single Number\n\nGiven a **non-empty**  array of integers `nums` every element appears _twice_\nexcept for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only\nconstant extra space.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [221]\n    **Output:** 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [41212]\n    **Output:** 4\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 3 * 104`\n  * `-3 * 104 <= nums[i] <= 3 * 104`\n  * Each element in the array appears twice except for one element which appears only once.\n\n,# Runtime: 301 ms (Top 20.49%) | Memory: 16.1 MB (Top 98.97%)\nclass Solution:\n    def singleNumber(self nums: List[int]) -> int:\n        nums.sort()\n        i=0\n        while i<len(nums)-1:\n            if nums[i]==nums[i+1]:\n                i+=2\n            else:\n                return nums[i]\n\n        return nums[-1]
Single Number II,###  137\. Single Number II\n\nGiven an integer array `nums` where every element appears **three times**\nexcept for one which appears **exactly once**. _Find the single element and\nreturn it_.\n\nYou must implement a solution with a linear runtime complexity and use only\nconstant extra space.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [2232]\n    **Output:** 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [01010199]\n    **Output:** 99\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 3 * 104`\n  * `-231 <= nums[i] <= 231 - 1`\n  * Each element in `nums` appears exactly **three times** except for one element which appears **once**.\n\n,"import math\nclass Solution(object):\n    def singleNumber(self nums):\n        """"""\n        :type nums: List[int]\n        :rtype: int\n        [0-110]\n        \n        [2232]\n        [2232]\n        [2232]\n        10   10   11  10\n        """"""\n        total = sum(nums)\n        \n        uniqueTotals = set()\n        while nums:\n            uniqueTotals.add(nums.pop())\n        return (sum(uniqueTotals)*3 - total)/2\n"
Single Number III,###  260\. Single Number III\n\nGiven an integer array `nums` in which exactly two elements appear only once\nand all the other elements appear exactly twice. Find the two elements that\nappear only once. You can return the answer in **any order**.\n\nYou must write an algorithm that runs in linear runtime complexity and uses\nonly constant extra space.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [121325]\n    **Output:** [35]\n    **Explanation:** [5 3] is also a valid answer.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-10]\n    **Output:** [-10]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [01]\n    **Output:** [10]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 3 * 104`\n  * `-231 <= nums[i] <= 231 - 1`\n  * Each integer in `nums` will appear twice only two integers will appear once.\n\n,class Solution:\n    def singleNumber(self nums: List[int]) -> List[int]:\n        x = Counter(nums)\n        return([y for y in x if x[y] == 1])\n
Single-Threaded CPU,###  1834\. Single-Threaded CPU\n\nYou are given `n`​​​​​​ tasks labeled from `0` to `n - 1`\nrepresented by a 2D integer array `tasks` where `tasks[i] = [enqueueTimei\nprocessingTimei]` means that the `i​​​​​​th`​​​​ task will\nbe available to process at `enqueueTimei` and will take `processingTimei` to\nfinish processing.\n\nYou have a single-threaded CPU that can process **at most one** task at a time\nand will act in the following way:\n\n  * If the CPU is idle and there are no available tasks to process the CPU remains idle.\n  * If the CPU is idle and there are available tasks the CPU will choose the one with the **shortest processing time**. If multiple tasks have the same shortest processing time it will choose the task with the smallest index.\n  * Once a task is started the CPU will **process the entire task** without stopping.\n  * The CPU can finish a task then start a new one instantly.\n\nReturn _the order in which the CPU will process the tasks._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** tasks = [[12][24][32][41]]\n    **Output:** [0231]\n    **Explanation:** The events go as follows: \n    - At time = 1 task 0 is available to process. Available tasks = {0}.\n    - Also at time = 1 the idle CPU starts processing task 0. Available tasks = {}.\n    - At time = 2 task 1 is available to process. Available tasks = {1}.\n    - At time = 3 task 2 is available to process. Available tasks = {1 2}.\n    - Also at time = 3 the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n    - At time = 4 task 3 is available to process. Available tasks = {1 3}.\n    - At time = 5 the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n    - At time = 6 the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n    - At time = 10 the CPU finishes task 1 and becomes idle.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** tasks = [[710][712][75][74][72]]\n    **Output:** [43201]\n    **Explanation****:** The events go as follows:\n    - At time = 7 all the tasks become available. Available tasks = {01234}.\n    - Also at time = 7 the idle CPU starts processing task 4. Available tasks = {0123}.\n    - At time = 9 the CPU finishes task 4 and starts processing task 3. Available tasks = {012}.\n    - At time = 13 the CPU finishes task 3 and starts processing task 2. Available tasks = {01}.\n    - At time = 18 the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n    - At time = 28 the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n    - At time = 40 the CPU finishes task 1 and becomes idle.\n    \n\n\n\n**Constraints:**\n\n  * `tasks.length == n`\n  * `1 <= n <= 105`\n  * `1 <= enqueueTimei processingTimei <= 109`\n\n,class Solution:\n    def getOrder(self tasks: List[List[int]]) -> List[int]:\n        # For better readability\n        Task = namedtuple('Task' ['etime' 'ptime' 'index'])\n        \n        # Sort the tasks by enqueue time shortest processing time and index\n        stasks = sorted([Task(task[0] task[1] i) for i task in enumerate(tasks)])\n        # t: current CPU clock; i: current task index\n        t = i = 0\n        heap result = [] []\n        \n        while len(result) < len(stasks):\n            # Push all the tasks available at current CPU clock\n            while i < len(stasks) and stasks[i].etime <= t:\n                heappush(heap (stasks[i].ptime stasks[i].index))\n                i += 1\n            if heap:\n                ptime index = heappop(heap)\n                result.append(index)\n                t += ptime\n            else:\n                # Jump to the next available task\n                t = stasks[i].etime\n        return result\n
Sliding Window Maximum,###  239\. Sliding Window Maximum\n\nYou are given an array of integers `nums` there is a sliding window of size\n`k` which is moving from the very left of the array to the very right. You can\nonly see the `k` numbers in the window. Each time the sliding window moves\nright by one position.\n\nReturn _the max sliding window_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13-1-35367] k = 3\n    **Output:** [335567]\n    **Explanation:** \n    Window position                Max\n    ---------------               -----\n    [1  3  -1] -3  5  3  6  7       **3**\n     1 [3  -1  -3] 5  3  6  7       **3**\n     1  3 [-1  -3  5] 3  6  7      **5**\n     1  3  -1 [-3  5  3] 6  7       **5**\n     1  3  -1  -3 [5  3  6] 7       **6**\n     1  3  -1  -3  5 [3  6  7]      **7**\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1] k = 1\n    **Output:** [1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-104 <= nums[i] <= 104`\n  * `1 <= k <= nums.length`\n\n,# Runtime: 4951 ms (Top 7.51%) | Memory: 39.4 MB (Top 5.02%)\nclass Solution:\n    def maxSlidingWindow(self nums: List[int] k: int) -> List[int]:\n        ans = []\n        pq = []\n\n        for i in range(k): heapq.heappush(pq(-nums[i]i))\n\n        ans.append(-pq[0][0])\n\n        for i in range(klen(nums)):\n            heapq.heappush(pq(-nums[i]i))\n            while pq and pq[0][1] < i-k+1 : heapq.heappop(pq)\n            ans.append(-pq[0][0])\n\n        return ans
Sliding Window Median,###  480\. Sliding Window Median\n\nThe **median** is the middle value in an ordered integer list. If the size of\nthe list is even there is no middle value. So the median is the mean of the\ntwo middle values.\n\n  * For examples if `arr = [2_3_ 4]` the median is `3`.\n  * For examples if `arr = [1_23_ 4]` the median is `(2 + 3) / 2 = 2.5`.\n\nYou are given an integer array `nums` and an integer `k`. There is a sliding\nwindow of size `k` which is moving from the very left of the array to the very\nright. You can only see the `k` numbers in the window. Each time the sliding\nwindow moves right by one position.\n\nReturn _the median array for each window in the original array_. Answers\nwithin `10-5` of the actual value will be accepted.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13-1-35367] k = 3\n    **Output:** [1.00000-1.00000-1.000003.000005.000006.00000]\n    **Explanation:** \n    Window position                Median\n    ---------------                -----\n    [**1  3  -1**] -3  5  3  6  7        1\n     1 [**3  -1  -3**] 5  3  6  7       -1\n     1  3 [**-1  -3  5**] 3  6  7       -1\n     1  3  -1 [**-3  5  3**] 6  7        3\n     1  3  -1  -3 [**5  3  6**] 7        5\n     1  3  -1  -3  5 [**3  6  7**]       6\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [123423142] k = 3\n    **Output:** [2.000003.000003.000003.000002.000003.000002.00000]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= nums.length <= 105`\n  * `-231 <= nums[i] <= 231 - 1`\n\n,// Runtime: 447 ms (Top 43.48%) | Memory: 30.40 MB (Top 31.32%)\n\nimport heapq\nfrom collections import defaultdict\nclass Solution:\n    def medianSlidingWindow(self nums: List[int] k: int) -> List[float]:\n        if not nums or not k:\n            return []\n        lo = [] # max heap\n        hi = [] # min heap\n        for i in range(k):\n            if len(lo) == len(hi):\n                heapq.heappush(hi -heapq.heappushpop(lo -nums[i]))\n            else:\n                heapq.heappush(lo -heapq.heappushpop(hi nums[i]))\n        ans = [float(hi[0])] if k & 1 else [(hi[0] - lo[0]) / 2.0]\n        to_remove = defaultdict(int)\n        for i in range(k len(nums)): # right bound of window\n            heapq.heappush(lo -heapq.heappushpop(hi nums[i])) # always push to lo\n            out_num = nums[i-k]\n            if out_num > -lo[0]:\n                heapq.heappush(hi -heapq.heappop(lo))\n            to_remove[out_num] += 1\n            while lo and to_remove[-lo[0]]:\n                to_remove[-lo[0]] -= 1\n                heapq.heappop(lo)\n            while to_remove[hi[0]]:\n                to_remove[hi[0]] -= 1\n                heapq.heappop(hi)\n            if k % 2:\n                ans.append(float(hi[0]))\n            else:\n                ans.append((hi[0] - lo[0]) / 2.0)\n        return ans\n
Slowest Key,"###  1629\. Slowest Key\n\nA newly designed keypad was tested where a tester pressed a sequence of `n`\nkeys one at a time.\n\nYou are given a string `keysPressed` of length `n` where `keysPressed[i]` was\nthe `ith` key pressed in the testing sequence and a sorted list\n`releaseTimes` where `releaseTimes[i]` was the time the `ith` key was\nreleased. Both arrays are **0-indexed**. The `0th` key was pressed at the time\n`0` and every subsequent key was pressed at the **exact** time the previous\nkey was released.\n\nThe tester wants to know the key of the keypress that had the **longest\nduration**. The `ith` keypress had a **duration** of `releaseTimes[i] -\nreleaseTimes[i - 1]` and the `0th` keypress had a duration of\n`releaseTimes[0]`.\n\nNote that the same key could have been pressed multiple times during the test\nand these multiple presses of the same key **may not** have had the same\n**duration**.\n\n_Return the key of the keypress that had the**longest duration**. If there are\nmultiple such keypresses return the lexicographically largest key of the\nkeypresses._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** releaseTimes = [9294950] keysPressed = ""cbcd""\n    **Output:** ""c""\n    **Explanation:** The keypresses were as follows:\n    Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).\n    Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).\n    Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).\n    Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).\n    The longest of these was the keypress for 'b' and the second keypress for 'c' both with duration 20.\n    'c' is lexicographically larger than 'b' so the answer is 'c'.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** releaseTimes = [1223364662] keysPressed = ""spuda""\n    **Output:** ""a""\n    **Explanation:** The keypresses were as follows:\n    Keypress for 's' had a duration of 12.\n    Keypress for 'p' had a duration of 23 - 12 = 11.\n    Keypress for 'u' had a duration of 36 - 23 = 13.\n    Keypress for 'd' had a duration of 46 - 36 = 10.\n    Keypress for 'a' had a duration of 62 - 46 = 16.\n    The longest of these was the keypress for 'a' with duration 16.\n\n\n\n**Constraints:**\n\n  * `releaseTimes.length == n`\n  * `keysPressed.length == n`\n  * `2 <= n <= 1000`\n  * `1 <= releaseTimes[i] <= 109`\n  * `releaseTimes[i] < releaseTimes[i+1]`\n  * `keysPressed` contains only lowercase English letters.\n\n",# Runtime: 111 ms (Top 25.49%) | Memory: 14.1 MB (Top 45.43%)\nclass Solution:\n    def slowestKey(self releaseTimes: List[int] keysPressed: str) -> str:\n        max_dur = releaseTimes[0]\n        max_key = keysPressed[0]\n\n        for i in range(1 len(releaseTimes)):\n            if releaseTimes[i] - releaseTimes[i-1] > max_dur:\n                max_dur = releaseTimes[i] - releaseTimes[i-1]\n                max_key = keysPressed[i]\n            elif releaseTimes[i] - releaseTimes[i-1] == max_dur and max_key < keysPressed[i]:\n                 max_key = keysPressed[i]\n\n        return max_key
Smallest Good Base,"###  483\. Smallest Good Base\n\nGiven an integer `n` represented as a string return _the smallest**good\nbase** of_ `n`.\n\nWe call `k >= 2` a **good base** of `n` if all digits of `n` base `k` are\n`1`'s.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = ""13""\n    **Output:** ""3""\n    **Explanation:** 13 base 3 is 111.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = ""4681""\n    **Output:** ""8""\n    **Explanation:** 4681 base 8 is 11111.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = ""1000000000000000000""\n    **Output:** ""999999999999999999""\n    **Explanation:** 1000000000000000000 base 999999999999999999 is 11.\n    \n\n\n\n**Constraints:**\n\n  * `n` is an integer in the range `[3 1018]`.\n  * `n` does not contain any leading zeros.\n\n",class Solution:\n    def smallestGoodBase(self n: str) -> str:\n        import math\n        n = int(n)\n        max_m = math.floor(math.log(n 2))\n        ans = 0\n        for m in range(max_m 0 -1):\n            k = int(n ** (1 / m))\n            if (k ** (m + 1)  - 1) // (k - 1) == n:\n                return str(k)\n        return str(n - 1)\n
Smallest Index With Equal Value,###  2057\. Smallest Index With Equal Value\n\nGiven a **0-indexed** integer array `nums` return _the**smallest** index _`i`\n_of_`nums` _such that_`i mod 10 == nums[i]`_ or_`-1` _if such index does not\nexist_.\n\n`x mod y` denotes the **remainder** when `x` is divided by `y`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [012]\n    **Output:** 0\n    **Explanation:** \n    i=0: 0 mod 10 = 0 == nums[0].\n    i=1: 1 mod 10 = 1 == nums[1].\n    i=2: 2 mod 10 = 2 == nums[2].\n    All indices have i mod 10 == nums[i] so we return the smallest index 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [4321]\n    **Output:** 2\n    **Explanation:** \n    i=0: 0 mod 10 = 0 != nums[0].\n    i=1: 1 mod 10 = 1 != nums[1].\n    i=2: 2 mod 10 = 2 == nums[2].\n    i=3: 3 mod 10 = 3 != nums[3].\n    2 is the only index which has i mod 10 == nums[i].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [1234567890]\n    **Output:** -1\n    **Explanation:** No index satisfies i mod 10 == nums[i].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `0 <= nums[i] <= 9`\n\n,class Solution:\n    def smallestEqual(self nums: List[int]) -> int:\n        for idx n in enumerate(nums):\n            if idx%10==n:\n                return idx\n        return -1 
Smallest Integer Divisible by K,###  1015\. Smallest Integer Divisible by K\n\nGiven a positive integer `k` you need to find the **length** of the\n**smallest** positive integer `n` such that `n` is divisible by `k` and `n`\nonly contains the digit `1`.\n\nReturn _the**length** of _`n`. If there is no such `n` return -1.\n\n**Note:** `n` may not fit in a 64-bit signed integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** k = 1\n    **Output:** 1\n    **Explanation:** The smallest answer is n = 1 which has length 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** k = 2\n    **Output:** -1\n    **Explanation:** There is no such positive integer n divisible by 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** k = 3\n    **Output:** 3\n    **Explanation:** The smallest answer is n = 111 which has length 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= 105`\n\n,class Solution:\n    def smallestRepunitDivByK(self k: int) -> int:\n        if k % 2 == 0: return -1\n        n = 1\n        leng = 1\n        mapp = {}\n        while True:\n            rem = n % k\n            if rem == 0: return leng\n            if rem in mapp : return -1\n            mapp[rem] = True\n            n = n*10 + 1\n            leng += 1\n        \n
Smallest K-Length Subsequence With Occurrences of a Letter,"###  2030\. Smallest K-Length Subsequence With Occurrences of a Letter\n\nYou are given a string `s` an integer `k` a letter `letter` and an integer\n`repetition`.\n\nReturn _the**lexicographically smallest** subsequence of_ `s` _of length_ `k`\n_that has the letter_ `letter` _appear**at least**_ `repetition` _times_. The\ntest cases are generated so that the `letter` appears in `s` **at least**\n`repetition` times.\n\nA **subsequence** is a string that can be derived from another string by\ndeleting some or no characters without changing the order of the remaining\ncharacters.\n\nA string `a` is **lexicographically smaller** than a string `b` if in the\nfirst position where `a` and `b` differ string `a` has a letter that appears\nearlier in the alphabet than the corresponding letter in `b`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""leet"" k = 3 letter = ""e"" repetition = 1\n    **Output:** ""eet""\n    **Explanation:** There are four subsequences of length 3 that have the letter 'e' appear at least 1 time:\n    - ""lee"" (from ""**_lee_** t"")\n    - ""let"" (from ""**_le_** e _**t**_ "")\n    - ""let"" (from ""_**l**_ e _**et**_ "")\n    - ""eet"" (from ""l _**eet**_ "")\n    The lexicographically smallest subsequence among them is ""eet"".\n    \n\n**Example 2:**\n\n![example-2](https://assets.leetcode.com/uploads/2021/09/13/smallest-k-length-\nsubsequence.png)\n\n    \n    \n    **Input:** s = ""leetcode"" k = 4 letter = ""e"" repetition = 2\n    **Output:** ""ecde""\n    **Explanation:** ""ecde"" is the lexicographically smallest subsequence of length 4 that has the letter ""e"" appear at least 2 times.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""bb"" k = 2 letter = ""b"" repetition = 2\n    **Output:** ""bb""\n    **Explanation:** ""bb"" is the only subsequence of length 2 that has the letter ""b"" appear at least 2 times.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= repetition <= k <= s.length <= 5 * 104`\n  * `s` consists of lowercase English letters.\n  * `letter` is a lowercase English letter and appears in `s` at least `repetition` times.\n\n",class Solution:\n    def smallestSubsequence(self s: str k: int letter: str r: int) -> str:\n        n_letters = len([c for c in s if c == letter])\n        stack = []\n        \n        for i c in enumerate(s):\n            while stack and stack[-1] > c and (len(s) - i + len(stack) > k) and (stack[-1] != letter or n_letters > r):\n                d = stack.pop()\n                if d == letter:\n                    r += 1\n                \n            if len(stack) < k:\n                if c == letter:\n                    stack.append(c)\n                    r -= 1\n                elif k - len(stack) > r:\n                    stack.append(c)\n            \n            if c == letter:\n                n_letters -= 1\n            \n        return ''.join(stack)\n
Smallest Range Covering Elements from K Lists,###  632\. Smallest Range Covering Elements from K Lists\n\nYou have `k` lists of sorted integers in **non-decreasing  order**. Find the\n**smallest** range that includes at least one number from each of the `k`\nlists.\n\nWe define the range `[a b]` is smaller than range `[c d]` if `b - a < d - c`\n**or** `a < c` if `b - a == d - c`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [[410152426][091220][5182230]]\n    **Output:** [2024]\n    **Explanation:**\n    List 1: [4 10 15 2426] 24 is in range [2024].\n    List 2: [0 9 12 20] 20 is in range [2024].\n    List 3: [5 18 22 30] 22 is in range [2024].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [[123][123][123]]\n    **Output:** [11]\n    \n\n\n\n**Constraints:**\n\n  * `nums.length == k`\n  * `1 <= k <= 3500`\n  * `1 <= nums[i].length <= 50`\n  * `-105 <= nums[i][j] <= 105`\n  * `nums[i]` is sorted in **non-decreasing** order.\n\n,"// Runtime: 188 ms (Top 86.16%) | Memory: 23.30 MB (Top 59.07%)\n\nfrom typing import List\nimport heapq\n\n\nclass Solution:\n    def smallestRange(self nums: List[List[int]]) -> List[int]:\n        heap = [(row[0] i 0) for i row in enumerate(nums)]\n        heapq.heapify(heap)\n        ans = [-10**9 10**9]\n        right = max(row[0] for row in nums)\n        while heap:\n            left row col = heapq.heappop(heap)\n            if right - left < ans[1] - ans[0]:\n                ans = [left right]\n            if col + 1 == len(nums[row]):\n                return ans\n            right = max(right nums[row][col + 1])\n            heapq.heappush(heap (nums[row][col + 1] row col + 1))\n\n# Tests:\nif __name__ == '__main__':\n    s = Solution()\n    # test case 1\n    output1 = s.smallestRange([[410152426][091220][5182230]])\n    expected_output1 = [2024]\n    assert output1 == expected_output1 f""Expected {expected_output1} but got {output1}""\n    # test case 2\n    output2 = s.smallestRange([[123][123][123]])\n    expected_output2 = [11]\n    assert output2 == expected_output2 f""Expected {expected_output2} but got {output2}""\n    print(""All tests passed!"")\n"
Smallest Range I,###  908\. Smallest Range I\n\nYou are given an integer array `nums` and an integer `k`.\n\nIn one operation you can choose any index `i` where `0 <= i < nums.length`\nand change `nums[i]` to `nums[i] + x` where `x` is an integer from the range\n`[-k k]`. You can apply this operation **at most once** for each index `i`.\n\nThe **score** of `nums` is the difference between the maximum and minimum\nelements in `nums`.\n\nReturn _the minimum**score** of _`nums` _after applying the mentioned\noperation at most once for each index in it_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1] k = 0\n    **Output:** 0\n    **Explanation:** The score is max(nums) - min(nums) = 1 - 1 = 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [010] k = 2\n    **Output:** 6\n    **Explanation:** Change nums to be [2 8]. The score is max(nums) - min(nums) = 8 - 2 = 6.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [136] k = 3\n    **Output:** 0\n    **Explanation:** Change nums to be [4 4 4]. The score is max(nums) - min(nums) = 4 - 4 = 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `0 <= nums[i] <= 104`\n  * `0 <= k <= 104`\n\n,// Runtime: 156 ms (Top 5.06%) | Memory: 18.40 MB (Top 7.47%)\n\nclass Solution:\n    def smallestRangeI(self A: List[int] K: int) -> int:\n        maxi = max(A)\n        mini = min(A)\n        return max(0 maxi-K-mini-K)\n
Smallest Range II,###  910\. Smallest Range II\n\nYou are given an integer array `nums` and an integer `k`.\n\nFor each index `i` where `0 <= i < nums.length` change `nums[i]` to be either\n`nums[i] + k` or `nums[i] - k`.\n\nThe **score** of `nums` is the difference between the maximum and minimum\nelements in `nums`.\n\nReturn _the minimum**score** of _`nums` _after changing the values at each\nindex_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1] k = 0\n    **Output:** 0\n    **Explanation:** The score is max(nums) - min(nums) = 1 - 1 = 0.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [010] k = 2\n    **Output:** 6\n    **Explanation:** Change nums to be [2 8]. The score is max(nums) - min(nums) = 8 - 2 = 6.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [136] k = 3\n    **Output:** 3\n    **Explanation:** Change nums to be [4 6 3]. The score is max(nums) - min(nums) = 6 - 3 = 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `0 <= nums[i] <= 104`\n  * `0 <= k <= 104`\n\n,// Runtime: 129 ms (Top 83.03%) | Memory: 18.50 MB (Top 25.76%)\n\nclass Solution:\n    def smallestRangeII(self nums: List[int] k: int) -> int:\n        nums.sort()\n        ans = nums[-1] - nums[0]\n\n        for i in range(0 len(nums) - 1):\n            ans = min(ans max(nums[i] + k nums[-1] -\n                      k) - min(nums[i+1] - k nums[0] + k))\n\n        return ans\n
Smallest Rotation with Highest Score,###  798\. Smallest Rotation with Highest Score\n\nYou are given an array `nums`. You can rotate it by a non-negative integer `k`\nso that the array becomes `[nums[k] nums[k + 1] ... nums[nums.length - 1]\nnums[0] nums[1] ... nums[k-1]]`. Afterward any entries that are less than\nor equal to their index are worth one point.\n\n  * For example if we have `nums = [24130]` and we rotate by `k = 2` it becomes `[13024]`. This is worth `3` points because `1 > 0` [no points] `3 > 1` [no points] `0 <= 2` [one point] `2 <= 3` [one point] `4 <= 4` [one point].\n\nReturn _the rotation index_`k` _that corresponds to the highest score we can\nachieve if we rotated_`nums` _by it_. If there are multiple answers return\nthe smallest such index `k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [23140]\n    **Output:** 3\n    **Explanation:** Scores for each k are listed below: \n    k = 0  nums = [23140]    score 2\n    k = 1  nums = [31402]    score 3\n    k = 2  nums = [14023]    score 3\n    k = 3  nums = [40231]    score 4\n    k = 4  nums = [02314]    score 3\n    So we should choose k = 3 which has the highest score.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [13024]\n    **Output:** 0\n    **Explanation:** nums will always have 3 points no matter how it shifts.\n    So we will choose the smallest k which is 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `0 <= nums[i] < nums.length`\n\n,class Solution:\n    def bestRotation(self nums: List[int]) -> int:\n        diff = [i - nums[i] for i in range(len(nums))]\n        \n        target = 0\n        qualified = []\n        for d in diff:\n            if d >= target:\n                heappush(qualified d)\n        smallest_rotate = 0\n        highest_score = len(qualified)\n        \n        \n        for rotate in range(1 len(nums)):\n            target += 1\n            while qualified and qualified[0] < target:\n                heappop(qualified)\n            modified = diff[rotate-1] + len(diff)\n            heappush(qualified modified)\n            score = len(qualified)\n            if score > highest_score:\n                smallest_rotate = rotate\n                highest_score = score\n        \n        return smallest_rotate\n\n
Smallest String Starting From Leaf,"###  988\. Smallest String Starting From Leaf\n\nYou are given the `root` of a binary tree where each node has a value in the\nrange `[0 25]` representing the letters `'a'` to `'z'`.\n\nReturn _the**lexicographically smallest** string that starts at a leaf of this\ntree and ends at the root_.\n\nAs a reminder any shorter prefix of a string is **lexicographically\nsmaller**.\n\n  * For example `""ab""` is lexicographically smaller than `""aba""`.\n\nA leaf of a node is a node that has no children.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/01/30/tree1.png)\n\n    \n    \n    **Input:** root = [0123434]\n    **Output:** ""dba""\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/01/30/tree2.png)\n\n    \n    \n    **Input:** root = [25131302]\n    **Output:** ""adz""\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/02/01/tree3.png)\n\n    \n    \n    **Input:** root = [221null10null0]\n    **Output:** ""abc""\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 8500]`.\n  * `0 <= Node.val <= 25`\n\n","class Solution:\n    res = 'z' * 13           # init max result tree depth  12< log2(8000) < 13\n    \n    def smallestFromLeaf(self root: TreeNode) -> str:\n        \n        def helper(node: TreeNode prev):\n            prev = chr(97 + node.val) + prev\n            \n            if not node.left and not node.right:\n                self.res = min(self.res prev)\n                return\n            \n            if node.left:\n                helper(node.left prev)\n            if node.right:\n                helper(node.right prev)\n        \n        helper(root """")\n        return self.res"
Smallest String With A Given Numeric Value,"###  1663\. Smallest String With A Given Numeric Value\n\nThe **numeric value** of a **lowercase character** is defined as its position\n`(1-indexed)` in the alphabet so the numeric value of `a` is `1` the numeric\nvalue of `b` is `2` the numeric value of `c` is `3` and so on.\n\nThe **numeric value** of a **string** consisting of lowercase characters is\ndefined as the sum of its characters' numeric values. For example the numeric\nvalue of the string `""abe""` is equal to `1 + 2 + 5 = 8`.\n\nYou are given two integers `n` and `k`. Return _the**lexicographically\nsmallest string** with **length** equal to `n` and **numeric value** equal to\n`k`._\n\nNote that a string `x` is lexicographically smaller than string `y` if `x`\ncomes before `y` in dictionary order that is either `x` is a prefix of `y`\nor if `i` is the first position such that `x[i] != y[i]` then `x[i]` comes\nbefore `y[i]` in alphabetic order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 k = 27\n    **Output:** ""aay""\n    **Explanation:** The numeric value of the string is 1 + 1 + 25 = 27 and it is the smallest string with such a value and length equal to 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 5 k = 73\n    **Output:** ""aaszz""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `n <= k <= 26 * n`\n\n",# Runtime: 1870 ms (Top 22.43%) | Memory: 15.5 MB (Top 41.47%)\nclass Solution:\n    def getSmallestString(self n: int k: int) -> str:\n        ans = ['a']*n # Initialize the answer to be 'aaa'.. length n\n        val = n #Value would be length as all are 'a'\n\n        for i in range(n-1 -1 -1):\n            if val == k: # if value has reached k we have created our lexicographically smallest string\n                break\n            val -= 1 # reduce value by one as we are removing 'a' and replacing by a suitable character\n            ans[i] = chr(96 + min(k - val 26)) # replace with a character which is k - value or 'z'\n            val += ord(ans[i]) - 96 # add the value of newly appended character to value\n\n        return ''.join(ans) # return the ans string in the by concatenating the list
Smallest String With Swaps,"###  1202\. Smallest String With Swaps\n\nYou are given a string `s` and an array of pairs of indices in the string\n`pairs` where `pairs[i] = [a b]` indicates 2 indices(0-indexed) of the\nstring.\n\nYou can swap the characters at any pair of indices in the given `pairs` **any\nnumber of times**.\n\nReturn the lexicographically smallest string that `s` can be changed to after\nusing the swaps.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""dcab"" pairs = [[03][12]]\n    **Output:** ""bacd""\n    **Explaination:** \n    Swap s[0] and s[3] s = ""bcad""\n    Swap s[1] and s[2] s = ""bacd""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""dcab"" pairs = [[03][12][02]]\n    **Output:** ""abcd""\n    **Explaination:**\n    Swap s[0] and s[3] s = ""bcad""\n    Swap s[0] and s[2] s = ""acbd""\n    Swap s[1] and s[2] s = ""abcd""\n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""cba"" pairs = [[01][12]]\n    **Output:** ""abc""\n    **Explaination:**\n    Swap s[0] and s[1] s = ""bca""\n    Swap s[1] and s[2] s = ""bac""\n    Swap s[0] and s[1] s = ""abc""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 10^5`\n  * `0 <= pairs.length <= 10^5`\n  * `0 <= pairs[i][0] pairs[i][1] < s.length`\n  * `s` only contains lower case English letters.\n\n","class DSU:\n    def __init__(self):\n        self.parentof = [-1 for _ in range(100001)]\n        self.rankof = [1 for _ in range(100001)]\n\n    def find(selfele):\n        def recur(ele):\n            if self.parentof[ele]==-1: \n                return ele\n            par = recur(self.parentof[ele])\n            self.parentof[ele] = par\n            return par\n        return recur(ele)\n\n    def unify(selfele1ele2):\n        p1p2 = self.find(ele1)self.find(ele2)\n        r1r2 = self.rankof[p1]self.rankof[p2]\n\n        if p1==p2: return \n        if r1>r2:\n            self.parentof[p2] = p1\n        else:\n            self.parentof[p1]=p2\n            if r1==r2: self.rankof[p2]+=1\n\nclass Solution:\n    def smallestStringWithSwaps(self s: str pairs: List[List[int]]) -> str:\n        dsu = DSU()\n        nodes = set()\n        smallest = [s[i] for i in range(len(s))]\n\n        for ij in pairs:\n            dsu.unify(ij)\n            nodes.add(i)\n            nodes.add(j)\n\n        groups = {}\n        for node in nodes:\n            par = dsu.find(node)\n            if par not in groups:\n                groups[par] = [node]\n            else:\n                groups[par].append(node)\n        \n        for group in groups.values():\n            lettersk = sorted([s[i] for i in group])0\n            \n            for i in group:\n                smallest[i] = letters[k]\n                k+=1\n\n        return """".join(smallest)\n"
Smallest Subtree with all the Deepest Nodes,###  865\. Smallest Subtree with all the Deepest Nodes\n\nGiven the `root` of a binary tree the depth of each node is **the shortest\ndistance to the root**.\n\nReturn _the smallest subtree_ such that it contains **all the deepest nodes**\nin the original tree.\n\nA node is called **the deepest** if it has the largest depth possible among\nany node in the entire tree.\n\nThe **subtree** of a node is a tree consisting of that node plus the set of\nall descendants of that node.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png)\n\n    \n    \n    **Input:** root = [3516208nullnull74]\n    **Output:** [274]\n    **Explanation:** We return the node with value 2 colored in yellow in the diagram.\n    The nodes coloured in blue are the deepest nodes of the tree.\n    Notice that nodes 5 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them so we return it.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [1]\n    **Output:** [1]\n    **Explanation:** The root is the deepest node in the tree.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** root = [013null2]\n    **Output:** [2]\n    **Explanation:** The deepest node in the tree is 2 the valid subtrees are the subtrees of nodes 2 1 and 0 but the subtree of node 2 is the smallest.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree will be in the range `[1 500]`.\n  * `0 <= Node.val <= 500`\n  * The values of the nodes in the tree are **unique**.\n\n\n\n**Note:** This question is the same as 1123:\n<https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/>\n\n,# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def subtreeWithAllDeepest(self root: TreeNode) -> TreeNode:\n\n        # find a set of deepest nodes first\n        deepest_nodes = [0]\n        self.find_deepest(root 0 deepest_nodes)\n        \n        # extract the depth and also make a set out of the values\n        targets = set(deepest_nodes[1:])\n\n        # get the subtree\n        return self.find_merge(root targets)[0]\n\n    def find_deepest(self node current_depth deepest_nodes):\n\n        # make a check\n        if not node:\n            return\n        \n        # make a check if we are a deep node\n        if current_depth > deepest_nodes[0]:\n            deepest_nodes.clear()\n            deepest_nodes.append(current_depth)\n            deepest_nodes.append(node.val)\n        elif current_depth == deepest_nodes[0]:\n            deepest_nodes.append(node.val)\n        \n        # go deeper\n        self.find_deepest(node.left current_depth+1 deepest_nodes)\n        self.find_deepest(node.right current_depth+1 deepest_nodes)\n    \n    def find_merge(self node targets):\n\n        # make a check\n        if not node:\n            return None set()\n\n        # check whether we are a target\n        found = set()\n        if node.val in targets:\n            found.add(node.val)\n\n        # go deeper and get result nodes\n        nleft left = self.find_merge(node.left targets)\n        if nleft is not None:\n            return nleft set()\n        nright right = self.find_merge(node.right targets)\n        if nright is not None:\n            return nright set()\n\n        # merge the found set\n        found = found | left | right\n\n        # check whether we found all\n        if not (targets - found):\n            return node set()\n        else:\n            return None found
Smallest Sufficient Team,"###  1125\. Smallest Sufficient Team\n\nIn a project you have a list of required skills `req_skills` and a list of\npeople. The `ith` person `people[i]` contains a list of skills that the person\nhas.\n\nConsider a sufficient team: a set of people such that for every required skill\nin `req_skills` there is at least one person in the team who has that skill.\nWe can represent these teams by the index of each person.\n\n  * For example `team = [0 1 3]` represents the people with skills `people[0]` `people[1]` and `people[3]`.\n\nReturn _any sufficient team of the smallest possible size represented by the\nindex of each person_. You may return the answer in **any order**.\n\nIt is **guaranteed** an answer exists.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** req_skills = [""java""""nodejs""""reactjs""] people = [[""java""][""nodejs""][""nodejs""""reactjs""]]\n    **Output:** [02]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** req_skills = [""algorithms""""math""""java""""reactjs""""csharp""""aws""] people = [[""algorithms""""math""""java""][""algorithms""""math""""reactjs""][""java""""csharp""""aws""][""reactjs""""csharp""][""csharp""""math""][""aws""""java""]]\n    **Output:** [12]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= req_skills.length <= 16`\n  * `1 <= req_skills[i].length <= 16`\n  * `req_skills[i]` consists of lowercase English letters.\n  * All the strings of `req_skills` are **unique**.\n  * `1 <= people.length <= 60`\n  * `0 <= people[i].length <= 16`\n  * `1 <= people[i][j].length <= 16`\n  * `people[i][j]` consists of lowercase English letters.\n  * All the strings of `people[i]` are **unique**.\n  * Every skill in `people[i]` is a skill in `req_skills`.\n  * It is guaranteed a sufficient team exists.\n\n",# Runtime: 2036 ms (Top 22.82%) | Memory: 203 MB (Top 6.04%)\nfrom collections import defaultdict\nfrom functools import lru_cache\n\nclass Solution:\n    def smallestSufficientTeam(self req_skills: List[str] people: List[List[str]]) -> List[int]:\n        N = len(req_skills)\n        skills = {skill: i for i skill in enumerate(req_skills)}\n        people_mask = defaultdict(int)\n        for i cur_skills in enumerate(people):\n            mask = 0\n            for skill in cur_skills:\n                mask |= 1<<skills[skill]\n            people_mask[i] = mask\n        self.path = []\n        self.res = float('inf')\n        self.respath = None\n        @lru_cache(None)\n        #i: people i\n        #l: length of current self.path\n        #mask: mask for current skills\n        def dfs(i l mask):\n            if mask == (1<<N) - 1:\n                if l < self.res:\n                    self.res = l\n                    self.respath = self.path[:]\n                return\n            if i == len(people): return\n            if l >= self.res:\n                return\n            dfs(i+1 l mask)\n            self.path.append(i)\n            if mask & people_mask[i] != people_mask[i]: dfs(i+1 l+1 mask | people_mask[i])\n            self.path.pop()\n        dfs(000)\n        return self.respath
Smallest Value of the Rearranged Number,###  2165\. Smallest Value of the Rearranged Number\n\nYou are given an integer `num.` **Rearrange** the digits of `num` such that\nits value is **minimized** and it does not contain **any** leading zeros.\n\nReturn _the rearranged number with minimal value_.\n\nNote that the sign of the number does not change after rearranging the digits.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 310\n    **Output:** 103\n    **Explanation:** The possible arrangements for the digits of 310 are 013 031 103 130 301 310. \n    The arrangement with the smallest value that does not contain any leading zeros is 103.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = -7605\n    **Output:** -7650\n    **Explanation:** Some possible arrangements for the digits of -7605 are -7650 -6705 -5076 -0567.\n    The arrangement with the smallest value that does not contain any leading zeros is -7650.\n    \n\n\n\n**Constraints:**\n\n  * `-1015 <= num <= 1015`\n\n,# Runtime: 68 ms (Top 17.05%) | Memory: 13.9 MB (Top 69.77%)\nclass Solution:\n    def smallestNumber(self num: int) -> int:\n        lst=[i for i in str(num)]\n        if num<0:\n            return ''.join(['-'] + sorted(lst[1:]reverse=True))\n        lst=sorted(lst)\n        if '0' in lst:\n            itr=0\n            while itr<len(lst) and lst[itr]=='0':\n                itr+=1\n            if itr==len(lst): #All zeroes\n                return ''.join(lst)\n            return ''.join([lst[itr]]+lst[:itr]+lst[itr+1:])\n        return ''.join(lst)
Snakes and Ladders,###  909\. Snakes and Ladders\n\nYou are given an `n x n` integer matrix `board` where the cells are labeled\nfrom `1` to `n2` in a [**Boustrophedon\nstyle**](https://en.wikipedia.org/wiki/Boustrophedon) starting from the bottom\nleft of the board (i.e. `board[n - 1][0]`) and alternating direction each row.\n\nYou start on square `1` of the board. In each move starting from square\n`curr` do the following:\n\n  * Choose a destination square `next` with a label in the range `[curr + 1 min(curr + 6 n2)]`. \n    * This choice simulates the result of a standard **6-sided die roll** : i.e. there are always at most 6 destinations regardless of the size of the board.\n  * If `next` has a snake or ladder you **must** move to the destination of that snake or ladder. Otherwise you move to `next`.\n  * The game ends when you reach the square `n2`.\n\nA board square on row `r` and column `c` has a snake or ladder if `board[r][c]\n!= -1`. The destination of that snake or ladder is `board[r][c]`. Squares `1`\nand `n2` do not have a snake or ladder.\n\nNote that you only take a snake or ladder at most once per move. If the\ndestination to a snake or ladder is the start of another snake or ladder you\ndo **not** follow the subsequent snake or ladder.\n\n  * For example suppose the board is `[[-14][-13]]` and on the first move your destination square is `2`. You follow the ladder to square `3` but do **not** follow the subsequent ladder to `4`.\n\nReturn _the least number of moves required to reach the square_`n2` _. If it\nis not possible to reach the square return_`-1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/09/23/snakes.png)\n\n    \n    \n    **Input:** board = [[-1-1-1-1-1-1][-1-1-1-1-1-1][-1-1-1-1-1-1][-135-1-113-1][-1-1-1-1-1-1][-115-1-1-1-1]]\n    **Output:** 4\n    **Explanation:** \n    In the beginning you start at square 1 (at row 5 column 0).\n    You decide to move to square 2 and must take the ladder to square 15.\n    You then decide to move to square 17 and must take the snake to square 13.\n    You then decide to move to square 14 and must take the ladder to square 35.\n    You then decide to move to square 36 ending the game.\n    This is the lowest possible number of moves to reach the last square so return 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** board = [[-1-1][-13]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `n == board.length == board[i].length`\n  * `2 <= n <= 20`\n  * `grid[i][j]` is either `-1` or in the range `[1 n2]`.\n  * The squares labeled `1` and `n2` do not have any ladders or snakes.\n\n,// Runtime: 228 ms (Top 5.16%) | Memory: 17.50 MB (Top 5.8%)\n\nclass Solution:\n    def snakesAndLadders(self board: List[List[int]]) -> int:\n        n = len(board)\n        moves = 0\n        q = collections.deque([1])\n        visited = [[False for _ in range(n)] for _ in range(n)]\n        visited[n-1][0] = True\n        while q:\n            size = len(q)\n            for i in range(size):\n                currBoardVal = q.popleft()\n                if currBoardVal == n*n:\n                    return moves\n                for diceVal in range(1 7):\n                    if currBoardVal + diceVal > n*n:\n                        break\n                    pos = self.findCoordinates(currBoardVal + diceVal n)\n                    row col = pos\n                    if not visited[row][col]:\n                        visited[row][col] = True\n                        if board[row][col] == -1:\n                            q.append(currBoardVal + diceVal)\n                        else:\n                            q.append(board[row][col])\n            moves += 1\n        return -1\n    \n    def findCoordinates(self curr: int n: int) -> Tuple[int int]:\n        row = n - (curr - 1) // n - 1\n        col = (curr - 1) % n\n        if row % 2 == n % 2:\n            return (row n - 1 - col)\n        else:\n            return (row col)\n\n
Snapshot Array,"###  1146\. Snapshot Array\n\nImplement a SnapshotArray that supports the following interface:\n\n  * `SnapshotArray(int length)` initializes an array-like data structure with the given length. **Initially each element equals 0**.\n  * `void set(index val)` sets the element at the given `index` to be equal to `val`.\n  * `int snap()` takes a snapshot of the array and returns the `snap_id`: the total number of times we called `snap()` minus `1`.\n  * `int get(index snap_id)` returns the value at the given `index` at the time we took the snapshot with the given `snap_id`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** [""SnapshotArray""""set""""snap""""set""""get""]\n    [[3][05][][06][00]]\n    **Output:** [nullnull0null5]\n    **Explanation:**\n    SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\n    snapshotArr.set(05);  // Set array[0] = 5\n    snapshotArr.snap();  // Take a snapshot return snap_id = 0\n    snapshotArr.set(06);\n    snapshotArr.get(00);  // Get the value of array[0] with snap_id = 0 return 5\n\n\n\n**Constraints:**\n\n  * `1 <= length <= 5 * 104`\n  * `0 <= index < length`\n  * `0 <= val <= 109`\n  * `0 <= snap_id < `(the total number of times we call `snap()`)\n  * At most `5 * 104` calls will be made to `set` `snap` and `get`.\n\n",# Runtime: 600 ms (Top 65.10%) | Memory: 33.5 MB (Top 72.09%)\nclass SnapshotArray:\n\n    def __init__(self length: int):\n        self.snap_id = 0\n        self.history = defaultdict(dict)\n\n    def set(self index: int val: int) -> None:\n        self.history[self.snap_id][index] = val\n\n    def snap(self) -> int:\n        self.snap_id += 1\n        return self.snap_id-1\n\n    def get(self index: int snap_id: int) -> int:\n        for i in range(snap_id-1-1):\n            if index in self.history[i]:\n                return self.history[i][index]\n        return 0 # default value in case it wasn't set earlier
Solve the Equation,"###  640\. Solve the Equation\n\nSolve a given equation and return the value of `'x'` in the form of a string\n`""x=#value""`. The equation contains only `'+'` `'-'` operation the variable\n`'x'` and its coefficient. You should return `""No solution""` if there is no\nsolution for the equation or `""Infinite solutions""` if there are infinite\nsolutions for the equation.\n\nIf there is exactly one solution for the equation we ensure that the value of\n`'x'` is an integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** equation = ""x+5-3+x=6+x-2""\n    **Output:** ""x=2""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** equation = ""x=x""\n    **Output:** ""Infinite solutions""\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** equation = ""2x=x""\n    **Output:** ""x=0""\n    \n\n\n\n**Constraints:**\n\n  * `3 <= equation.length <= 1000`\n  * `equation` has exactly one `'='`.\n  * `equation` consists of integers with an absolute value in the range `[0 100]` without any leading zeros and the variable `'x'`.\n\n","    def solveEquation(self equation: str) -> str:\n    """""" O(N)TS """"""\n    x y p = 0 0 1\n    for i in re.finditer(r""=|[+-]?\d*x|[+-]?\d+"" equation):\n        g = i.group()\n        if g == '=':\n            p = -1\n        elif g[-1] == 'x':\n            x += p * int(g.replace('x' '1' if len(g) == 1 or not g[-2].isdigit() else ''))\n        else:\n            y += -p * int(g)\n\n    if x == 0 == y:\n        return 'Infinite solutions'\n    elif x == 0:\n        return ""No solution""\n    return f'x={y // x}'"
Solving Questions With Brainpower,###  2140\. Solving Questions With Brainpower\n\nYou are given a **0-indexed** 2D integer array `questions` where `questions[i]\n= [pointsi brainpoweri]`.\n\nThe array describes the questions of an exam where you have to process the\nquestions **in order** (i.e. starting from question `0`) and make a decision\nwhether to **solve** or **skip** each question. Solving question `i` will\n**earn** you `pointsi` points but you will be **unable** to solve each of the\nnext `brainpoweri` questions. If you skip question `i` you get to make the\ndecision on the next question.\n\n  * For example given `questions = [[3 2] [4 3] [4 4] [2 5]]`: \n    * If question `0` is solved you will earn `3` points but you will be unable to solve questions `1` and `2`.\n    * If instead question `0` is skipped and question `1` is solved you will earn `4` points but you will be unable to solve questions `2` and `3`.\n\nReturn _the**maximum** points you can earn for the exam_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** questions = [[32][43][44][25]]\n    **Output:** 5\n    **Explanation:** The maximum points can be earned by solving questions 0 and 3.\n    - Solve question 0: Earn 3 points will be unable to solve the next 2 questions\n    - Unable to solve questions 1 and 2\n    - Solve question 3: Earn 2 points\n    Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** questions = [[11][22][33][44][55]]\n    **Output:** 7\n    **Explanation:** The maximum points can be earned by solving questions 1 and 4.\n    - Skip question 0\n    - Solve question 1: Earn 2 points will be unable to solve the next 2 questions\n    - Unable to solve questions 2 and 3\n    - Solve question 4: Earn 5 points\n    Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= questions.length <= 105`\n  * `questions[i].length == 2`\n  * `1 <= pointsi brainpoweri <= 105`\n\n,class Solution:\n    def mostPoints(self q: List[List[int]]) -> int:\n        @cache\n        def dfs(i: int) -> int:\n            return 0 if i >= len(q) else max(dfs(i + 1) q[i][0] + dfs(i + 1 + q[i][1]))\n        return dfs(0)\n
Sort an Array,###  912\. Sort an Array\n\nGiven an array of integers `nums` sort the array in ascending order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [5231]\n    **Output:** [1235]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [511200]\n    **Output:** [001125]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5 * 104`\n  * `-5 * 104 <= nums[i] <= 5 * 104`\n\n,import heapq\nclass Solution:\n    def sortArray(self nums: List[int]) -> List[int]:\n        \n        h = {}\n        for i in nums:\n            if i in h:\n                h[i]+=1\n            else:\n                h[i]=1\n        \n        heap = []\n        for i in h:\n            heap.append([ih[i]])\n        \n        heapq.heapify(heap)\n        ans = []\n        \n        while heap:\n            x = heapq.heappop(heap)\n            ans.append(x[0])\n            if x[1]>1:\n                heapq.heappush(heap[x[0]x[1]-1])\n                \n        return ans\n
Sort Array by Increasing Frequency,###  1636\. Sort Array by Increasing Frequency\n\nGiven an array of integers `nums` sort the array in **increasing** order\nbased on the frequency of the values. If multiple values have the same\nfrequency sort them in **decreasing** order.\n\nReturn the _sorted array_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [112223]\n    **Output:** [311222]\n    **Explanation:** '3' has a frequency of 1 '1' has a frequency of 2 and '2' has a frequency of 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [23132]\n    **Output:** [13322]\n    **Explanation:** '2' and '3' both have a frequency of 2 so they are sorted in decreasing order.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [-11-645-6141]\n    **Output:** [5-144-6-6111]\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `-100 <= nums[i] <= 100`\n\n,class Solution:\n    def frequencySort(self nums: List[int]) -> List[int]:\n        \n        r = Counter(nums).most_common()\n        r.sort(key = lambda x: x[0] reverse=True)\n        r.sort(key = lambda x: x[1])\n        \n        t = []\n        for i in r:\n            a b = i\n            t.extend([a]*b)\n            \n        return t\n
Sort Array By Parity,###  905\. Sort Array By Parity\n\nGiven an integer array `nums` move all the even integers at the beginning of\nthe array followed by all the odd integers.\n\nReturn _**any array** that satisfies this condition_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [3124]\n    **Output:** [2431]\n    **Explanation:** The outputs [4231] [2413] and [4213] would also be accepted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0]\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5000`\n  * `0 <= nums[i] <= 5000`\n\n,"# Runtime: 84 ms (Top 42.8%) | Memory: 17.10 MB (Top 53.6%)\n\nclass Solution:\n    def sortArrayByParity(self A: List[int]) -> List[int]:\n        i j = 0 len(A) - 1\n        while i < j:\n        	if A[i] % 2 == 1 and A[j] % 2 == 0: A[i] A[j] = A[j] A[i]\n        	i j = i + 1 - A[i] % 2 j - A[j] % 2\n        return A"
Sort Array By Parity II,###  922\. Sort Array By Parity II\n\nGiven an array of integers `nums` half of the integers in `nums` are **odd**\n and the other half are **even**.\n\nSort the array so that whenever `nums[i]` is odd `i` is **odd**  and\nwhenever `nums[i]` is even `i` is **even**.\n\nReturn _any answer array that satisfies this condition_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [4257]\n    **Output:** [4527]\n    **Explanation:** [4725] [2547] [2745] would also have been accepted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [23]\n    **Output:** [23]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 2 * 104`\n  * `nums.length` is even.\n  * Half of the integers in `nums` are even.\n  * `0 <= nums[i] <= 1000`\n\n\n\n**Follow Up:** Could you solve it in-place?\n\n,// Runtime: 148 ms (Top 91.55%) | Memory: 19.90 MB (Top 17.18%)\n\nclass Solution:\n    def sortArrayByParityII(self nums: List[int]) -> List[int]:\n        even = []\n        odd = []\n        lst=[]\n        for i in range(len(nums)):\n            if nums[i]%2 == 0:\n                even.append(nums[i])\n            else:\n                odd.append(nums[i])\n        for i in range(len(even)):\n            lst.append(even[i])\n            lst.append(odd[i])\n        return lst\n
Sort Characters By Frequency,"###  451\. Sort Characters By Frequency\n\nGiven a string `s` sort it in **decreasing order** based on the **frequency**\nof the characters. The **frequency** of a character is the number of times it\nappears in the string.\n\nReturn _the sorted string_. If there are multiple answers return _any of\nthem_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""tree""\n    **Output:** ""eert""\n    **Explanation:** 'e' appears twice while 'r' and 't' both appear once.\n    So 'e' must appear before both 'r' and 't'. Therefore ""eetr"" is also a valid answer.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""cccaaa""\n    **Output:** ""aaaccc""\n    **Explanation:** Both 'c' and 'a' appear three times so both ""cccaaa"" and ""aaaccc"" are valid answers.\n    Note that ""cacaca"" is incorrect as the same characters must be together.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""Aabb""\n    **Output:** ""bbAa""\n    **Explanation:** ""bbaA"" is also a valid answer but ""Aabb"" is incorrect.\n    Note that 'A' and 'a' are treated as two different characters.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 5 * 105`\n  * `s` consists of uppercase and lowercase English letters and digits.\n\n","class Solution:\n    def frequencySort(self s: str) -> str:\n        di = Counter(s)\n        #it wont strike immediately that this is a heap kind of question.\n        heap = []\n        heapq.heapify(heap)\n        for keyval in di.items():\n            heapq.heappush(heap(-1*valkey))\n        # n = len(s)\n        res = """"\n        # print(heap)\n        while(len(heap)):\n            valch = heapq.heappop(heap)\n            res+=(ch*(-1*val))\n        return res\n"
Sort Colors,###  75\. Sort Colors\n\nGiven an array `nums` with `n` objects colored red white or blue sort them\n**[in-place](https://en.wikipedia.org/wiki/In-place_algorithm) **so that\nobjects of the same color are adjacent with the colors in the order red\nwhite and blue.\n\nWe will use the integers `0` `1` and `2` to represent the color red white\nand blue respectively.\n\nYou must solve this problem without using the library's sort function.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [202110]\n    **Output:** [001122]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [201]\n    **Output:** [012]\n    \n\n\n\n**Constraints:**\n\n  * `n == nums.length`\n  * `1 <= n <= 300`\n  * `nums[i]` is either `0` `1` or `2`.\n\n\n\n**Follow up:**  Could you come up with a one-pass algorithm using only\nconstant extra space?\n\n,// Runtime: 49 ms (Top 8.88%) | Memory: 16.20 MB (Top 55.73%)\n\nclass Solution:\n    def sortColors(self nums: List[int]) -> None:\n\n        red white blue = 0 0 len(nums) - 1\n\n        while white <= blue:\n            if nums[white] == 0:\n                nums[white] nums[red] = nums[red] nums[white]\n                red += 1\n                white += 1\n            elif nums[white] == 1:\n                white += 1\n            else:\n                nums[white] nums[blue] = nums[blue] nums[white]\n                blue -= 1\n
Sort Even and Odd Indices Independently,###  2164\. Sort Even and Odd Indices Independently\n\nYou are given a **0-indexed** integer array `nums`. Rearrange the values of\n`nums` according to the following rules:\n\n  1. Sort the values at **odd indices** of `nums` in **non-increasing** order. \n     * For example if `nums = [4**_1_** 2_**3**_]` before this step it becomes `[4_**3**_ 2**_1_**]` after. The values at odd indices `1` and `3` are sorted in non-increasing order.\n  2. Sort the values at **even indices** of `nums` in **non-decreasing** order. \n     * For example if `nums = [_**4**_ 1_**2**_ 3]` before this step it becomes `[_**2**_ 1_**4**_ 3]` after. The values at even indices `0` and `2` are sorted in non-decreasing order.\n\nReturn _the array formed after rearranging the values of_ `nums`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [4123]\n    **Output:** [2341]\n    **Explanation:** \n    First we sort the values present at odd indices (1 and 3) in non-increasing order.\n    So nums changes from [4**_1_** 2**_3_**] to [4_**3**_ 2**_1_**].\n    Next we sort the values present at even indices (0 and 2) in non-decreasing order.\n    So nums changes from [_**4**_ 1**_2_** 3] to [_**2**_ 3_**4**_ 1].\n    Thus the array formed after rearranging the values is [2341].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [21]\n    **Output:** [21]\n    **Explanation:** \n    Since there is exactly one odd index and one even index no rearrangement of values takes place.\n    The resultant array formed is [21] which is the same as the initial array. \n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `1 <= nums[i] <= 100`\n\n,"# Runtime: 63 ms (Top 80.35%) | Memory: 13.8 MB (Top 69.47%)\n\nclass Solution(object):\n    def sortEvenOdd(self nums):\n        """"""\n        :type nums: List[int]\n        :rtype: List[int]\n        """"""\n        nums[::2] nums[1::2] = sorted(nums[::2]) sorted(nums[1::2] reverse=True)\n        return nums"
Sort Integers by The Number of 1 Bits,###  1356\. Sort Integers by The Number of 1 Bits\n\nYou are given an integer array `arr`. Sort the integers in the array in\nascending order by the number of `1`'s in their binary representation and in\ncase of two or more integers have the same number of `1`'s you have to sort\nthem in ascending order.\n\nReturn _the array after sorting it_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [012345678]\n    **Output:** [012483567]\n    **Explantion:** [0] is the only integer with 0 bits.\n    [1248] all have 1 bit.\n    [356] have 2 bits.\n    [7] has 3 bits.\n    The sorted array by bits is [012483567]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [10245122561286432168421]\n    **Output:** [12481632641282565121024]\n    **Explantion:** All integers have 1 bit in the binary representation you should just sort them in ascending order.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 500`\n  * `0 <= arr[i] <= 104`\n\n,"class Solution:\n    def sortByBits(self arr: List[int]) -> List[int]:\n        binary = []\n        final = []\n        arr.sort()\n        for i in arr:\n            binary.append(bin(i).count(""1""))\n        for ij in zip(arrbinary):\n            final.append((ij))\n        z = sorted(final key=lambda x:x[1])\n        \n        ls = []\n        for k in z:\n            ls.append(k[0])\n        \n        return ls\n"
Sort Integers by The Power Value,###  1387\. Sort Integers by The Power Value\n\nThe power of an integer `x` is defined as the number of steps needed to\ntransform `x` into `1` using the following steps:\n\n  * if `x` is even then `x = x / 2`\n  * if `x` is odd then `x = 3 * x + 1`\n\nFor example the power of `x = 3` is `7` because `3` needs `7` steps to become\n`1` (`3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1`).\n\nGiven three integers `lo` `hi` and `k`. The task is to sort all integers in\nthe interval `[lo hi]` by the power value in **ascending order**  if two or\nmore integers have **the same** power value sort them by **ascending order**.\n\nReturn the `kth` integer in the range `[lo hi]` sorted by the power value.\n\nNotice that for any integer `x` `(lo <= x <= hi)` it is **guaranteed** that\n`x` will transform into `1` using these steps and that the power of `x` is\nwill **fit** in a 32-bit signed integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** lo = 12 hi = 15 k = 2\n    **Output:** 13\n    **Explanation:** The power of 12 is 9 (12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1)\n    The power of 13 is 9\n    The power of 14 is 17\n    The power of 15 is 17\n    The interval sorted by the power value [12131415]. For k = 2 answer is the second element which is 13.\n    Notice that 12 and 13 have the same power value and we sorted them in ascending order. Same for 14 and 15.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** lo = 7 hi = 11 k = 4\n    **Output:** 7\n    **Explanation:** The power array corresponding to the interval [7 8 9 10 11] is [16 3 19 6 14].\n    The interval sorted by power is [8 10 11 7 9].\n    The fourth number in the sorted array is 7.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= lo <= hi <= 1000`\n  * `1 <= k <= hi - lo + 1`\n\n,// Runtime: 156 ms (Top 74.13%) | Memory: 16.70 MB (Top 42.43%)\n\nimport heapq\nclass Solution:\n    def power(selfn):\n        if n in self.dic:\n            return self.dic[n]\n        if n % 2:\n            self.dic[n] = self.power(3 * n + 1) + 1\n        else:\n            self.dic[n] = self.power(n // 2) + 1\n        return self.dic[n]    \n    def getKth(self lo: int hi: int k: int) -> int:\n        self.dic = {1:0}\n        for i in range(lohi+1):\n            self.power(i)\n                        \n        lst = [(self.dic[i]i) for i in range(lohi+1)]\n        heapq.heapify(lst)\n        \n        for i in range(k):\n            ans = heapq.heappop(lst)\n        \n        return ans[1]     \n
Sort Items by Groups Respecting Dependencies,###  1203\. Sort Items by Groups Respecting Dependencies\n\nThere are `n` items each belonging to zero or one of `m` groups where\n`group[i]` is the group that the `i`-th item belongs to and it's equal to `-1`\nif the `i`-th item belongs to no group. The items and the groups are zero\nindexed. A group can have no item belonging to it.\n\nReturn a sorted list of the items such that:\n\n  * The items that belong to the same group are next to each other in the sorted list.\n  * There are some relations between these items where `beforeItems[i]` is a list containing all the items that should come before the `i`-th item in the sorted array (to the left of the `i`-th item).\n\nReturn any solution if there is more than one solution and return an **empty\nlist**  if there is no solution.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2019/09/11/1359_ex1.png)**\n\n    \n    \n    **Input:** n = 8 m = 2 group = [-1-110010-1] beforeItems = [[][6][5][6][36][][][]]\n    **Output:** [63415207]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 8 m = 2 group = [-1-110010-1] beforeItems = [[][6][5][6][3][][4][]]\n    **Output:** []\n    **Explanation:**  This is the same as example 1 except that 4 needs to be before 6 in the sorted list.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m <= n <= 3 * 104`\n  * `group.length == beforeItems.length == n`\n  * `-1 <= group[i] <= m - 1`\n  * `0 <= beforeItems[i].length <= n - 1`\n  * `0 <= beforeItems[i][j] <= n - 1`\n  * `i != beforeItems[i][j]`\n  * `beforeItems[i] `does not contain duplicates elements.\n\n,class Solution:\n    def sortItems(self n: int m: int group: List[int] beforeItems: List[List[int]]) -> List[int]:\n        before = {i:set() for i in range(n)}\n        after = {i:set() for i in range(n)}\n        beforeG = {i:set() for i in range(m)}\n        afterG = {i:set() for i in range(m)}\n        groups = {i:set() for i in range(m)}\n        qg = collections.deque()\n        lazy = collections.deque()\n        for i in range(n):\n            if group[i] != -1:\n                groups[group[i]].add(i)\n            for x in beforeItems[i]:\n                before[i].add(x)\n                after[x].add(i)\n                if group[x] != group[i] and group[x] != -1 and group[i] != -1:\n                    beforeG[group[i]].add(group[x])\n                    afterG[group[x]].add(group[i])\n        for i in range(n):\n            if group[i] == -1 and not before[i]:\n                lazy.append(i)\n\n        for i in range(m):\n            if not beforeG[i]:\n                qg.append(i)\n        ans = []\n        while qg:\n            while lazy:\n                i = lazy.popleft()\n                ans.append(i)\n                for j in after[i]:\n                    before[j].remove(i)\n                    if not before[j] and group[j] == -1:\n                        lazy.append(j)\n            g = qg.popleft()\n            q = collections.deque()\n            for member in groups[g]:\n                if not before[member]:\n                    q.append(member)\n            while q:\n                i = q.popleft()\n                ans.append(i)\n                groups[g].remove(i)\n                for j in after[i]:\n                    before[j].remove(i)\n                    if not before[j]:\n                        if group[j] == g:\n                            q.append(j)\n                        if group[j] == -1:\n                            lazy.append(j)     \n            if groups[g]:\n                return []\n            for p in afterG[g]:\n                beforeG[p].remove(g)\n                if not beforeG[p]:\n                    qg.append(p)\n        while lazy:\n            i = lazy.popleft()\n            ans.append(i)\n            for j in after[i]:\n                before[j].remove(i)\n                if not before[j] and group[j] == -1:\n                    lazy.append(j)\n        return ans if len(ans) == n else []
Sort List,###  148\. Sort List\n\nGiven the `head` of a linked list return _the list after sorting it\nin**ascending order**_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)\n\n    \n    \n    **Input:** head = [4213]\n    **Output:** [1234]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)\n\n    \n    \n    **Input:** head = [-15340]\n    **Output:** [-10345]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** head = []\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[0 5 * 104]`.\n  * `-105 <= Node.val <= 105`\n\n\n\n**Follow up:** Can you sort the linked list in `O(n logn)` time and `O(1)`\nmemory (i.e. constant space)?\n\n,class Solution:\n    def sortList(self head: Optional[ListNode]) -> Optional[ListNode]:\n        store = []\n        curr = head\n        while curr:\n            store.append(curr.val)\n            curr = curr.next\n        store.sort()\n        dummyNode = ListNode(0)\n        temp = dummyNode\n        \n        for i in store:\n            x = ListNode(val = i)\n            temp.next = x\n            temp = x\n        return dummyNode.next
Sort the Jumbled Numbers,###  2191\. Sort the Jumbled Numbers\n\nYou are given a **0-indexed** integer array `mapping` which represents the\nmapping rule of a shuffled decimal system. `mapping[i] = j` means digit `i`\nshould be mapped to digit `j` in this system.\n\nThe **mapped value** of an integer is the new integer obtained by replacing\neach occurrence of digit `i` in the integer with `mapping[i]` for all `0 <= i\n<= 9`.\n\nYou are also given another integer array `nums`. Return _the array_`nums`\n_sorted in**non-decreasing** order based on the **mapped values** of its\nelements._\n\n**Notes:**\n\n  * Elements with the same mapped values should appear in the **same relative order** as in the input.\n  * The elements of `nums` should only be sorted based on their mapped values and **not be replaced** by them.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** mapping = [8940213576] nums = [99133838]\n    **Output:** [33838991]\n    **Explanation:** \n    Map the number 991 as follows:\n    1. mapping[9] = 6 so all occurrences of the digit 9 will become 6.\n    2. mapping[1] = 9 so all occurrences of the digit 1 will become 9.\n    Therefore the mapped value of 991 is 669.\n    338 maps to 007 or 7 after removing the leading zeros.\n    38 maps to 07 which is also 7 after removing leading zeros.\n    Since 338 and 38 share the same mapped value they should remain in the same relative order so 338 comes before 38.\n    Thus the sorted array is [33838991].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mapping = [0123456789] nums = [789456123]\n    **Output:** [123456789]\n    **Explanation:** 789 maps to 789 456 maps to 456 and 123 maps to 123. Thus the sorted array is [123456789].\n    \n\n\n\n**Constraints:**\n\n  * `mapping.length == 10`\n  * `0 <= mapping[i] <= 9`\n  * All the values of `mapping[i]` are **unique**.\n  * `1 <= nums.length <= 3 * 104`\n  * `0 <= nums[i] < 109`\n\n,"class Solution:\n    def sortJumbled(self mapping: List[int] nums: List[int]) -> List[int]:\n        \n        return sorted(nums key = lambda x: int("""".join([str(mapping[int(digit)]) for digit in str(x)])))\n"
Sort the Matrix Diagonally,###  1329\. Sort the Matrix Diagonally\n\nA **matrix diagonal** is a diagonal line of cells starting from some cell in\neither the topmost row or leftmost column and going in the bottom-right\ndirection until reaching the matrix's end. For example the **matrix\ndiagonal** starting from `mat[2][0]` where `mat` is a `6 x 3` matrix\nincludes cells `mat[2][0]` `mat[3][1]` and `mat[4][2]`.\n\nGiven an `m x n` matrix `mat` of integers sort each **matrix diagonal** in\nascending order and return _the resulting matrix_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/01/21/1482_example_1_2.png)\n\n    \n    \n    **Input:** mat = [[3311][2212][1112]]\n    **Output:** [[1111][1222][1233]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mat = [[1125661697][235517451552][75313644588][22273325684][84281411550]]\n    **Output:** [[51741527][11112545869][142325445815][222731365066][842875335568]]\n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat[i].length`\n  * `1 <= m n <= 100`\n  * `1 <= mat[i][j] <= 100`\n\n,class Solution:\n    def diagonalSort(self A: List[List[int]]) -> List[List[int]]:\n        n m d = len(A) len(A[0]) defaultdict(list)\n        any(d[i - j].append(A[i][j]) for i in range(n) for j in range(m))\n        any(d[sum_].sort(reverse=1) for sum_ in d)\n        return [[d[i-j].pop() for j in range(m)] for i in range(n)]
Special Array With X Elements Greater Than or Equal X,###  1608\. Special Array With X Elements Greater Than or Equal X\n\nYou are given an array `nums` of non-negative integers. `nums` is considered\n**special** if there exists a number `x` such that there are **exactly** `x`\nnumbers in `nums` that are **greater than or equal to** `x`.\n\nNotice that `x` **does not** have to be an element in `nums`.\n\nReturn `x` _if the array is**special**  otherwise return _`-1`. It can be\nproven that if `nums` is special the value for `x` is **unique**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [35]\n    **Output:** 2\n    **Explanation:** There are 2 values (3 and 5) that are greater than or equal to 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [00]\n    **Output:** -1\n    **Explanation:** No numbers fit the criteria for x.\n    If x = 0 there should be 0 numbers >= x but there are 2.\n    If x = 1 there should be 1 number >= x but there are 0.\n    If x = 2 there should be 2 numbers >= x but there are 0.\n    x cannot be greater since there are only 2 numbers in nums.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [04304]\n    **Output:** 3\n    **Explanation:** There are 3 values that are greater than or equal to 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `0 <= nums[i] <= 1000`\n\n,# Runtime: 58 ms (Top 23.2%) | Memory: 16.30 MB (Top 28.6%)\n\nclass Solution:\n    def specialArray(self nums: List[int]) -> int:\n        nums.sort()\n        for i in range(max(nums)+1):\n            y=len(nums)-bisect.bisect_left(numsi)\n            if y==i:\n                return i\n        return -1\n\n        \n        
Special Binary String,"###  761\. Special Binary String\n\n**Special binary strings** are binary strings with the following two\nproperties:\n\n  * The number of `0`'s is equal to the number of `1`'s.\n  * Every prefix of the binary string has at least as many `1`'s as `0`'s.\n\nYou are given a **special binary** string `s`.\n\nA move consists of choosing two consecutive non-empty special substrings of\n`s` and swapping them. Two strings are consecutive if the last character of\nthe first string is exactly one index before the first character of the second\nstring.\n\nReturn _the lexicographically largest resulting string possible after applying\nthe mentioned operations on the string_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""11011000""\n    **Output:** ""11100100""\n    **Explanation:** The strings ""10"" [occuring at s[1]] and ""1100"" [at s[3]] are swapped.\n    This is the lexicographically largest string possible after some number of swaps.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""10""\n    **Output:** ""10""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 50`\n  * `s[i]` is either `'0'` or `'1'`.\n  * `s` is a special binary string.\n\n","class Solution:\n    def makeLargestSpecial(self s: str) -> str:\n        \n        l = 0\n        balance = 0\n        sublist = []\n        for r in range(len(s)):\n            balance += 1 if s[r]=='1' else -1\n            if balance==0:\n                sublist.append(""1"" + self.makeLargestSpecial(s[l+1:r])+ ""0"")\n                l = r+1\n        \n        sublist.sort(reverse=True)\n        return ''.join(sublist)"
Spiral Matrix,###  54\. Spiral Matrix\n\nGiven an `m x n` `matrix` return _all elements of the_ `matrix` _in spiral\norder_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)\n\n    \n    \n    **Input:** matrix = [[123][456][789]]\n    **Output:** [123698745]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)\n\n    \n    \n    **Input:** matrix = [[1234][5678][9101112]]\n    **Output:** [123481211109567]\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m n <= 10`\n  * `-100 <= matrix[i][j] <= 100`\n\n,"class Solution:\n    def spiralOrder(self matrix: List[List[int]]) -> List[int]:\n        col row = len(matrix[0]) len(matrix)\n        l t r b = 0 0 col - 1 row - 1\n        res = []\n        while l <= r and t <= b:\n            for i in range(l r):\n                res.append(matrix[t][i])\n            for i in range(t b):\n                res.append(matrix[i][r])\n            \n			# Append the orphan left by the open interval\n            if t == b:\n                res.append(matrix[t][r])\n            else:\n                # From right to left at the bottom\n                for i in range(r l -1):\n                    res.append(matrix[b][i])\n            \n			# Avoid duplicated appending if it is a square\n            if l == r and t != b:\n                res.append(matrix[b][r])\n            else:\n                # From bottom to top at the left\n                for i in range(b t -1):\n                    res.append(matrix[i][l])\n            l += 1\n            t += 1\n            r -= 1\n            b -= 1\n\n        return res\n"
Spiral Matrix II,###  59\. Spiral Matrix II\n\nGiven a positive integer `n` generate an `n x n` `matrix` filled with\nelements from `1` to `n2` in spiral order.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)\n\n    \n    \n    **Input:** n = 3\n    **Output:** [[123][894][765]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** [[1]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 20`\n\n,// Runtime: 34 ms (Top 84.25%) | Memory: 16.50 MB (Top 59.83%)\n\nclass Solution:\n    def generateMatrix(self n: int) -> List[List[int]]:\n        if not n:\n            return []\n        matrix = [[0 for _ in range(n)] for _ in range(n)]\n        left right top bottom num = 0 n-1 0 n-1 1\n        while left <= right and top <= bottom:\n            for i in range(left right+1):\n                matrix[top][i] = num \n                num += 1\n            top += 1\n            for i in range(top bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            if top <= bottom:\n                for i in range(right left-1 -1):\n                    matrix[bottom][i] = num\n                    num += 1\n                bottom -= 1\n            if left <= right:\n                for i in range(bottom top-1 -1):\n                    matrix[i][left] = num\n                    num += 1\n                left += 1\n        return matrix\n\n
Spiral Matrix III,###  885\. Spiral Matrix III\n\nYou start at the cell `(rStart cStart)` of an `rows x cols` grid facing east.\nThe northwest corner is at the first row and column in the grid and the\nsoutheast corner is at the last row and column.\n\nYou will walk in a clockwise spiral shape to visit every position in this\ngrid. Whenever you move outside the grid's boundary we continue our walk\noutside the grid (but may return to the grid boundary later.). Eventually we\nreach all `rows * cols` spaces of the grid.\n\nReturn _an array of coordinates representing the positions of the grid in the\norder you visited them_.\n\n\n\n**Example 1:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png)\n\n    \n    \n    **Input:** rows = 1 cols = 4 rStart = 0 cStart = 0\n    **Output:** [[00][01][02][03]]\n    \n\n**Example 2:**\n\n![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png)\n\n    \n    \n    **Input:** rows = 5 cols = 6 rStart = 1 cStart = 4\n    **Output:** [[14][15][25][24][23][13][03][04][05][35][34][33][32][22][12][02][45][44][43][42][41][31][21][11][01][40][30][20][10][00]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= rows cols <= 100`\n  * `0 <= rStart < rows`\n  * `0 <= cStart < cols`\n\n,class Solution:\n    def spiralMatrixIII(self rows: int cols: int rStart: int cStart: int) -> List[List[int]]:\n        ans = [[rStart cStart]]\n        val = 1\n        i j = rStart cStart\n        def is_valid(i j):\n            if 0 <= i < rows and 0 <= j < cols:\n                return True\n            return False\n        \n        while True:\n            if len(ans) == rows * cols:\n                return ans\n            \n            # go right val times\n            for _ in range(val):\n                j+=1\n                if is_valid(ij):\n                    ans.append([ij])\n            # go bottom val times\n            for _ in range(val):\n                i+=1\n                if is_valid(ij):\n                    ans.append([ij])\n            # go left val+1 times\n            for _ in range(val+1):\n                j-=1\n                if is_valid(ij):\n                    ans.append([ij])\n            # go up val+1 times\n            for _ in range(val+1):\n                i-=1\n                if is_valid(ij):\n                    ans.append([ij])\n            val+=2\n
Spiral Matrix IV,###  2326\. Spiral Matrix IV\n\nYou are given two integers `m` and `n` which represent the dimensions of a\nmatrix.\n\nYou are also given the `head` of a linked list of integers.\n\nGenerate an `m x n` matrix that contains the integers in the linked list\npresented in **spiral** order **(clockwise)**  starting from the **top-left**\nof the matrix. If there are remaining empty spaces fill them with `-1`.\n\nReturn _the generated matrix_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg)\n\n    \n    \n    **Input:** m = 3 n = 5 head = [3026817942550]\n    **Output:** [[30268][50-1-11][52497]]\n    **Explanation:** The diagram above shows how the values are printed in the matrix.\n    Note that the remaining spaces in the matrix are filled with -1.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg)\n\n    \n    \n    **Input:** m = 1 n = 4 head = [012]\n    **Output:** [[012-1]]\n    **Explanation:** The diagram above shows how the values are printed from left to right in the matrix.\n    The last space in the matrix is set to -1.\n\n\n\n**Constraints:**\n\n  * `1 <= m n <= 105`\n  * `1 <= m * n <= 105`\n  * The number of nodes in the list is in the range `[1 m * n]`.\n  * `0 <= Node.val <= 1000`\n\n,// Runtime: 2522 ms (Top 39.98%) | Memory: 66.3 MB (Top 18.63%)\nclass Solution:\n    def spiralMatrix(self m: int n: int head: Optional[ListNode]) -> List[List[int]]:\n        num = m * n\n        res = [[-1 for j in range(n)] for i in range(m)]\n        x y = 0 0\n        dx dy = 1 0\n        while head:\n            res[y][x] = head.val\n            if x + dx < 0 or x + dx >= n or y + dy < 0 or y + dy >= m or res[y+dy][x+dx] != -1:\n                dx dy = -dy dx\n            x = x + dx\n            y = y + dy\n            head = head.next\n        return res
Split a String in Balanced Strings,"###  1221\. Split a String in Balanced Strings\n\n**Balanced** strings are those that have an equal quantity of `'L'` and `'R'`\ncharacters.\n\nGiven a **balanced** string `s` split it into some number of substrings such\nthat:\n\n  * Each substring is balanced.\n\nReturn _the**maximum** number of balanced strings you can obtain._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""RLRRLLRLRL""\n    **Output:** 4\n    **Explanation:** s can be split into ""RL"" ""RRLL"" ""RL"" ""RL"" each substring contains same number of 'L' and 'R'.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""RLRRRLLRLL""\n    **Output:** 2\n    **Explanation:** s can be split into ""RL"" ""RRRLLRLL"" each substring contains same number of 'L' and 'R'.\n    Note that s cannot be split into ""RL"" ""RR"" ""RL"" ""LR"" ""LL"" because the 2nd and 5th substrings are not balanced.\n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""LLLLRRRR""\n    **Output:** 1\n    **Explanation:** s can be split into ""LLLLRRRR"".\n    \n\n\n\n**Constraints:**\n\n  * `2 <= s.length <= 1000`\n  * `s[i]` is either `'L'` or `'R'`.\n  * `s` is a **balanced** string.\n\n",class Solution:\n    def balancedStringSplit(self s: str) -> int:\n        r_count=l_count=t_count=0\n        for i in s:\n            if i=='R':\n                r_count+=1\n            elif i=='L':\n                l_count+=1\n            if r_count==l_count:\n                t_count+=1\n                r_count=0\n                l_count=0\n            continue\n        return t_count\n
Split a String Into the Max Number of Unique Substrings,"###  1593\. Split a String Into the Max Number of Unique Substrings\n\nGiven a string `s` return _the maximum  number of unique substrings that the\ngiven string can be split into_.\n\nYou can split string `s` into any list of **non-empty substrings**  where the\nconcatenation of the substrings forms the original string. However you must\nsplit the substrings such that all of them are **unique**.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""ababccc""\n    **Output:** 5\n    **Explanation** : One way to split maximally is ['a' 'b' 'ab' 'c' 'cc']. Splitting like ['a' 'b' 'a' 'b' 'c' 'cc'] is not valid as you have 'a' and 'b' multiple times.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aba""\n    **Output:** 2\n    **Explanation** : One way to split maximally is ['a' 'ba'].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""aa""\n    **Output:** 1\n    **Explanation** : It is impossible to split the string any further.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 16`\n\n  * `s` contains only lower case English letters.\n\n",class Solution:\n    def maxUniqueSplit(self s: str) -> int:\n        ans n = 0 len(s)\n        def dfs(i cnt visited):\n            nonlocal ans n\n            if i == n: ans = max(ans cnt); return  # stop condition\n            for j in range(i+1 n+1):    \n                if s[i:j] in visited: continue      # avoid re-visit/duplicates\n                visited.add(s[i:j])                 # update visited set\n                dfs(j cnt+1 visited)              # backtracking\n                visited.remove(s[i:j])              # recover visited set for next possibility\n        dfs(0 0 set())                            # function call\n        return ans\n
Split Array into Consecutive Subsequences,###  659\. Split Array into Consecutive Subsequences\n\nYou are given an integer array `nums` that is **sorted in non-decreasing\norder**.\n\nDetermine if it is possible to split `nums` into **one or more subsequences**\nsuch that **both** of the following conditions are true:\n\n  * Each subsequence is a **consecutive increasing sequence** (i.e. each integer is **exactly one** more than the previous integer).\n  * All subsequences have a length of `3`**or more**.\n\nReturn `true` _if you can split_`nums` _according to the above conditions\nor_`false` _otherwise_.\n\nA **subsequence** of an array is a new array that is formed from the original\narray by deleting some (can be none) of the elements without disturbing the\nrelative positions of the remaining elements. (i.e. `[135]` is a\nsubsequence of `[_1_ 2_3_ 4_5_]` while `[132]` is not).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123345]\n    **Output:** true\n    **Explanation:** nums can be split into the following subsequences:\n    [**_1_** **_2_** **_3_** 345] --> 1 2 3\n    [123**_3_** **_4_** **_5_**] --> 3 4 5\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12334455]\n    **Output:** true\n    **Explanation:** nums can be split into the following subsequences:\n    [**_1_** **_2_** **_3_** 3**_4_** 4**_5_** 5] --> 1 2 3 4 5\n    [123**_3_** 4**_4_** 5**_5_**] --> 3 4 5\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [123445]\n    **Output:** false\n    **Explanation:** It is impossible to split nums into consecutive increasing subsequences of length 3 or more.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-1000 <= nums[i] <= 1000`\n  * `nums` is sorted in **non-decreasing** order.\n\n,class Solution:\n\n    from collections import defaultdict\n\n    def isPossible(self nums):\n        # If the length of the array is less than 3 it's not possible to create subsequences of length 3 or more.\n        if len(nums) < 3:\n            return False\n\n        # 'count' dictionary stores the frequency of each number in the input array.\n        count = defaultdict(int)\n\n        # 'tails' dictionary stores the number of subsequences that end at a certain number.\n        tails = defaultdict(int)\n\n        # Populate the 'count' dictionary with the frequency of each number.\n        for num in nums:\n            count[num] += 1\n\n        # Iterate through the input array.\n        for num in nums:\n            # If the count of the current number is 0 it means this number has already been used in a subsequence.\n            if count[num] == 0:\n                continue\n            # If there is a subsequence that ends with the current number minus 1\n            # it means we can extend that subsequence by adding the current number.\n            elif tails[num - 1] > 0:\n                tails[num - 1] -= 1  # Decrease the count of the tails that end with the current number minus 1.\n                tails[num] += 1  # Increase the count of the tails that end with the current number.\n            # If there are enough numbers after the current number to form a subsequence\n            # create a new subsequence starting with the current number.\n            elif count[num + 1] > 0 and count[num + 2] > 0:\n                count[num + 1] -= 1  # Decrease the count of the next number.\n                count[num + 2] -= 1  # Decrease the count of the number after the next number.\n                tails[num + 2] += 1  # Increase the count of the tails that end with the number after the next number.\n            else:\n                # If we can't extend an existing subsequence or start a new one return False.\n                return False\n\n            # Decrease the count of the current number since it's used in a subsequence.\n            count[num] -= 1\n\n        # If the function successfully iterates through the entire array return True.\n        return True\n
Split Array into Fibonacci Sequence,"###  842\. Split Array into Fibonacci Sequence\n\nYou are given a string of digits `num` such as `""123456579""`. We can split it\ninto a Fibonacci-like sequence `[123 456 579]`.\n\nFormally a **Fibonacci-like** sequence is a list `f` of non-negative integers\nsuch that:\n\n  * `0 <= f[i] < 231` (that is each integer fits in a **32-bit** signed integer type)\n  * `f.length >= 3` and\n  * `f[i] + f[i + 1] == f[i + 2]` for all `0 <= i < f.length - 2`.\n\nNote that when splitting the string into pieces each piece must not have\nextra leading zeroes except if the piece is the number `0` itself.\n\nReturn any Fibonacci-like sequence split from `num` or return `[]` if it\ncannot be done.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = ""1101111""\n    **Output:** [1101111]\n    **Explanation:** The output [110 1 111] would also be accepted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = ""112358130""\n    **Output:** []\n    **Explanation:** The task is impossible.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = ""0123""\n    **Output:** []\n    **Explanation:** Leading zeroes are not allowed so ""01"" ""2"" ""3"" is not valid.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num.length <= 200`\n  * `num` contains only digits.\n\n","MAX=2**31\ndef consume_tail(current s):\n    # Following the definition of the fibonacci sequence\n    # we know that the sum of the last two values in our \n    # `current` list determines the next value in the sequence.\n    # So that value our ""target"" is what we're looking for next in\n    # `s`.\n    target = current[-1] + current[-2]\n    \n    if target > MAX:\n        return False\n    \n    sTarget = str(target) \n    # If the next value in the fibonacci sequence\n    # is found at the beginning of s\n    # we can continue to process the remaining \n    # portion of the string.\n    if s.find(sTarget) == 0:\n        current.append(target)\n    else:\n        return False\n    \n    if sTarget != s:\n        return consume_tail(current s[len(sTarget):])\n    \n    return current\n        \n\nclass Solution:    \n    def splitIntoFibonacci(self num: str) -> List[int]:\n        \n        # Identify candidate for the first\n        # number in fibonacci sequence\n        for i in range(len(num)):\n            if num[0] == ""0"" and i > 0:\n                break\n                \n            first = num[0:i+1]\n            \n            # If our current candidate for the first number\n            # of the sequence is already larger that our \n            # maximum value in the spec don't bother doing anymore work.\n            if int(first) > MAX:\n                return []\n            \n            tail = num[i+1:]\n            \n            # Identify candidate for the scond\n            # number in fibonacci sequence\n            for j in range(len(tail)):\n                if tail[0] == ""0"" and j > 0:\n                    break\n                    \n                second = tail[0:j+1]\n                if int(second) > MAX:\n                    break\n                \n                # With our current candidates (first and second)\n                # we can consume the remaining portion of the string (tail[j+1:])\n                # to determine if it contains the correct values for a fibonacci sequence\n                # beginning with [first second]\n                result = consume_tail([int(first) int(second)] tail[j+1:])\n                if result:\n                    return result\n        return []\n"
Split Array Largest Sum,###  410\. Split Array Largest Sum\n\nGiven an array `nums` which consists of non-negative integers and an integer\n`m` you can split the array into `m` non-empty continuous subarrays.\n\nWrite an algorithm to minimize the largest sum among these `m` subarrays.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [725108] m = 2\n    **Output:** 18\n    **Explanation:**\n    There are four ways to split nums into two subarrays.\n    The best way is to split it into [725] and [108]\n    where the largest sum among the two subarrays is only 18.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12345] m = 2\n    **Output:** 9\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [144] m = 3\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `0 <= nums[i] <= 106`\n  * `1 <= m <= min(50 nums.length)`\n\n,class Solution:\n    def splitArray(self nums: List[int] m: int) -> int:\n        lo hi = max(nums) sum(nums)\n        while lo < hi:\n            mid = (lo+hi)//2\n            tot cnt = 0 1\n            for num in nums:\n                if tot+num<=mid: \n                    tot += num\n                else:\n                    tot = num\n                    cnt += 1\n            if cnt>m: lo = mid+1\n            else: hi = mid\n        return hi\n
Split Array With Same Average,###  805\. Split Array With Same Average\n\nYou are given an integer array `nums`.\n\nYou should move each element of `nums` into one of the two arrays `A` and `B`\nsuch that `A` and `B` are non-empty and `average(A) == average(B)`.\n\nReturn `true` if it is possible to achieve that and `false` otherwise.\n\n**Note** that for an array `arr` `average(arr)` is the sum of all the\nelements of `arr` over the length of `arr`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12345678]\n    **Output:** true\n    **Explanation:** We can split the array into [1458] and [2367] and both of them have an average of 4.5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [31]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 30`\n  * `0 <= nums[i] <= 104`\n\n,class Solution:\n    def splitArraySameAverage(self A: List[int]) -> bool:\n        A.sort()\n        DP=[set() for _ in range(len(A)//2+1)]    #DP[i] stores the all available sum with i items in a bracket\n        all_sum=sum(A)\n        DP[0]=set([0])\n        for item in A:                  #iterate over items in the list\n            for count in range(len(DP)-2-1-1):          # iterate backwards w.r.t. the bracket size\n                if len(DP[count])>0:                             # if DP[i] is not empty then update DP[i+1] by adding the current item into all sums in DP[i]\n                    for a in DP[count]:\n                        DP[count+1].add(a+item)\n        for size in range(1len(DP)):\n            if all_sum*size/len(A) in DP[size]:\n                return True\n        return False
Split Linked List in Parts,###  725\. Split Linked List in Parts\n\nGiven the `head` of a singly linked list and an integer `k` split the linked\nlist into `k` consecutive linked list parts.\n\nThe length of each part should be as equal as possible: no two parts should\nhave a size differing by more than one. This may lead to some parts being\nnull.\n\nThe parts should be in the order of occurrence in the input list and parts\noccurring earlier should always have a size greater than or equal to parts\noccurring later.\n\nReturn _an array of the_`k` _parts_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg)\n\n    \n    \n    **Input:** head = [123] k = 5\n    **Output:** [[1][2][3][][]]\n    **Explanation:**\n    The first element output[0] has output[0].val = 1 output[0].next = null.\n    The last element output[4] is null but its string representation as a ListNode is [].\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg)\n\n    \n    \n    **Input:** head = [12345678910] k = 3\n    **Output:** [[1234][567][8910]]\n    **Explanation:**\n    The input has been split into consecutive parts with size difference at most 1 and earlier parts are a larger size than the later parts.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[0 1000]`.\n  * `0 <= Node.val <= 1000`\n  * `1 <= k <= 50`\n\n,# Runtime: 50 ms (Top 81.38%) | Memory: 14.5 MB (Top 12.03%)\n# Definition for singly-linked list.\n# class ListNode:\n# def __init__(self val=0 next=None):\n# self.val = val\n# self.next = next\nclass Solution:\n    def splitListToParts(self head: Optional[ListNode] k: int) -> List[Optional[ListNode]]:\n        length = 0\n        cur = head\n        while cur:\n            length += 1\n            cur = cur.next\n        # DON'T do following since this makes head become null\n        # while head:\n        # length += 1\n        # head = head.next\n\n        # calculate the base size and the number of parts contain extra number\n        size extra = length // k length % k\n\n        # create empty list to store split parts\n        res = [[] for _ in range(k)]\n\n        # use two ptrs to split parts\n        prev cur = None head\n\n        for i in range(k):\n            res[i] = cur\n            # if this part contains extra number it has (size+1) number\n            for j in range(size + (1 if extra > 0 else 0)):\n                prev cur = cur cur.next\n            if prev: prev.next = None\n            extra -= 1\n\n        return res
Splitting a String Into Descending Consecutive Values,"###  1849\. Splitting a String Into Descending Consecutive Values\n\nYou are given a string `s` that consists of only digits.\n\nCheck if we can split `s` into **two or more non-empty substrings** such that\nthe **numerical values** of the substrings are in **descending order** and the\n**difference** between numerical values of every two **adjacent**\n**substrings** is equal to `1`.\n\n  * For example the string `s = ""0090089""` can be split into `[""0090"" ""089""]` with numerical values `[9089]`. The values are in descending order and adjacent values differ by `1` so this way is valid.\n  * Another example the string `s = ""001""` can be split into `[""0"" ""01""]` `[""00"" ""1""]` or `[""0"" ""0"" ""1""]`. However all the ways are invalid because they have numerical values `[01]` `[01]` and `[001]` respectively all of which are not in descending order.\n\nReturn `true` _if it is possible to split_ `s`​​​​​​ _as described\nabove_ _ or_`false` _otherwise._\n\nA **substring** is a contiguous sequence of characters in a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""1234""\n    **Output:** false\n    **Explanation:** There is no valid way to split s.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""050043""\n    **Output:** true\n    **Explanation:** s can be split into [""05"" ""004"" ""3""] with numerical values [543].\n    The values are in descending order with adjacent values differing by 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""9080701""\n    **Output:** false\n    **Explanation:** There is no valid way to split s.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 20`\n  * `s` only consists of digits.\n\n",# Runtime: 66 ms (Top 24.00%) | Memory: 13.8 MB (Top 70.18%)\nclass Solution:\n    def splitString(self s: str last_val: int = None) -> bool:\n        # Base case remaining string is a valid solution\n        if last_val and int(s) == last_val - 1:\n            return True\n\n        # Iterate through increasingly larger slices of s\n        for i in range(1 len(s)):\n            cur = int(s[:i])\n            # If current slice is equal to last_val - 1 make\n            # recursive call with remaining string and updated last_val\n            if last_val is None or cur == last_val - 1:\n                if self.splitString(s[i:] cur):\n                    return True\n\n        return False
Sqrt(x),###  69\. Sqrt(x)\n\nGiven a non-negative integer `x` compute and return _the square root of_ `x`.\n\nSince the return type is an integer the decimal digits are **truncated** \nand only **the integer part** of the result is returned.\n\n**Note:  **You are not allowed to use any built-in exponent function or\noperator such as `pow(x 0.5)` or `x ** 0.5`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** x = 4\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** x = 8\n    **Output:** 2\n    **Explanation:** The square root of 8 is 2.82842... and since the decimal part is truncated 2 is returned.\n\n\n\n**Constraints:**\n\n  * `0 <= x <= 231 - 1`\n\n,class Solution:\n    def mySqrt(self x: int) -> int:\n        beg =0\n        end =x\n        while beg <=end:\n            mid = (beg+end)//2\n            sqr = mid*mid\n            if sqr == x:\n                return mid\n            elif sqr < x:\n                beg = mid+1\n            else:\n                end = mid-1\n        return end\n        \n
Squares of a Sorted Array,###  977\. Squares of a Sorted Array\n\nGiven an integer array `nums` sorted in **non-decreasing** order return _an\narray of**the squares of each number** sorted in non-decreasing order_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [-4-10310]\n    **Output:** [01916100]\n    **Explanation:** After squaring the array becomes [16109100].\n    After sorting it becomes [01916100].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [-7-32311]\n    **Output:** [49949121]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-104 <= nums[i] <= 104`\n  * `nums` is sorted in **non-decreasing** order.\n\n\n\n**Follow up:** Squaring each element and sorting the new array is very\ntrivial could you find an `O(n)` solution using a different approach?\n\n,class Solution:\n    def sortedSquares(self nums: List[int]) -> List[int]:\n        lr = 0 len(nums)-1\n        pointer = 0\n        arr = [0] *len(nums)\n        pointer = r\n        while l<=r:\n            if abs(nums[r]) > abs(nums[l]):\n                arr[pointer] = nums[r] **2\n                r-=1\n                pointer-=1\n            else:\n                arr[pointer] = nums[l] **2\n                l+=1\n                pointer-=1\n                \n            \n        return arr\n            \n            \n            \n
Stamping the Grid,###  2132\. Stamping the Grid\n\nYou are given an `m x n` binary matrix `grid` where each cell is either `0`\n(empty) or `1` (occupied).\n\nYou are then given stamps of size `stampHeight x stampWidth`. We want to fit\nthe stamps such that they follow the given **restrictions** and\n**requirements** :\n\n  1. Cover all the **empty** cells.\n  2. Do not cover any of the **occupied** cells.\n  3. We can put as **many** stamps as we want.\n  4. Stamps can **overlap** with each other.\n  5. Stamps are not allowed to be **rotated**.\n  6. Stamps must stay completely **inside** the grid.\n\nReturn `true` _if it is possible to fit the stamps while following the given\nrestrictions and requirements. Otherwise return_ `false`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/11/03/ex1.png)\n\n    \n    \n    **Input:** grid = [[1000][1000][1000][1000][1000]] stampHeight = 4 stampWidth = 3\n    **Output:** true\n    **Explanation:** We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/11/03/ex2.png)\n\n    \n    \n    **Input:** grid = [[1000][0100][0010][0001]] stampHeight = 2 stampWidth = 2 \n    **Output:** false \n    **Explanation:** There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[r].length`\n  * `1 <= m n <= 105`\n  * `1 <= m * n <= 2 * 105`\n  * `grid[r][c]` is either `0` or `1`.\n  * `1 <= stampHeight stampWidth <= 105`\n\n,"class Solution:\n    def prefix_sum(self grid: List[List[int]]) -> List[List[int]]:\n            ps = [[grid[row][col] for col in range(len(grid[0]))]for row in range(len(grid))]\n            \n            for row in range(len(grid)):\n                for col in range(1 len(grid[0])):\n                    ps[row][col] = ps[row][col-1] + grid[row][col]\n            \n            for row in range(1 len(grid)):\n                for col in range(len(grid[0])):\n                    ps[row][col] = ps[row-1][col] + ps[row][col]\n            \n            return ps\n			\n    def sumRegion(self ps row1: int col1: int row2: int col2: int) -> int:\n            ans = 0\n            if row1 == 0 and col1 == 0:\n                ans = ps[row2][col2]\n            elif row1 == 0:\n                ans = ps[row2][col2] - ps[row2][col1-1]\n            elif col1 == 0:\n                ans = ps[row2][col2] - ps[row1-1][col2]\n            else:\n                ans = ps[row2][col2] - ps[row1-1][col2] - ps[row2][col1-1] + ps[row1-1][col1-1]\n            return ans\n\n    def possibleToStamp(self grid: List[List[int]] stampHeight: int stampWidth: int) -> bool:\n        diff = [[0 for col in range(len(grid[0])+1)]for row in range(len(grid)+1)]\n        \n        ps = self.prefix_sum(grid)\n        cover = 0\n        \n        for row in range(len(grid)-(stampHeight-1)):\n            for col in range(len(grid[0])-(stampWidth-1)):\n                sub_sum = self.sumRegion(ps row col row+stampHeight-1 col+stampWidth-1)\n                if sub_sum == 0:\n                    diff[row][col] += 1\n                    diff[row][col+stampWidth] -= 1\n                    diff[row+stampHeight][col] -= 1\n                    diff[row+stampHeight][col+stampWidth] = 1\n        pref_diff = self.prefix_sum(diff)\n        m n = len(grid) len(grid[0])\n        \n        for row in range(len(grid)):\n            for col in range(len(grid[0])):\n                if grid[row][col] == 0 and pref_diff[row][col] == 0: return False \n        \n        return True\n"
Stamping The Sequence,"###  936\. Stamping The Sequence\n\nYou are given two strings `stamp` and `target`. Initially there is a string\n`s` of length `target.length` with all `s[i] == '?'`.\n\nIn one turn you can place `stamp` over `s` and replace every letter in the\n`s` with the corresponding letter from `stamp`.\n\n  * For example if `stamp = ""abc""` and `target = ""abcba""` then `s` is `""?????""` initially. In one turn you can: \n    * place `stamp` at index `0` of `s` to obtain `""abc??""`\n    * place `stamp` at index `1` of `s` to obtain `""?abc?""` or\n    * place `stamp` at index `2` of `s` to obtain `""??abc""`.\nNote that `stamp` must be fully contained in the boundaries of `s` in order to\nstamp (i.e. you cannot place `stamp` at index `3` of `s`).\n\nWe want to convert `s` to `target` using **at most** `10 * target.length`\nturns.\n\nReturn _an array of the index of the left-most letter being stamped at each\nturn_. If we cannot obtain `target` from `s` within `10 * target.length`\nturns return an empty array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** stamp = ""abc"" target = ""ababc""\n    **Output:** [02]\n    **Explanation:** Initially s = ""?????"".\n    - Place stamp at index 0 to get ""abc??"".\n    - Place stamp at index 2 to get ""ababc"".\n    [102] would also be accepted as an answer as well as some other answers.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** stamp = ""abca"" target = ""aabcaca""\n    **Output:** [301]\n    **Explanation:** Initially s = ""???????"".\n    - Place stamp at index 3 to get ""???abca"".\n    - Place stamp at index 0 to get ""abcabca"".\n    - Place stamp at index 1 to get ""aabcaca"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= stamp.length <= target.length <= 1000`\n  * `stamp` and `target` consist of lowercase English letters.\n\n","class Solution:\n    def movesToStamp(self S: str T: str) -> List[int]:\n        if S == T: return [0]\n        S T = list(S) list(T)\n        slen tlen = len(S) len(T) - len(S) + 1\n        ans tdiff sdiff = [] True True\n        while tdiff:\n            tdiff = False\n            for i in range(tlen):\n                sdiff = False\n                for j in range(slen):\n                    if T[i+j] == ""*"": continue\n                    if T[i+j] != S[j]: break\n                    sdiff = True\n                else: \n                    if sdiff:\n                        tdiff = True\n                        for j in range(i i + slen): T[j] = ""*""\n                        ans.append(i)\n        for i in range(len(T)):\n            if T[i] != ""*"": return []\n        return reversed(ans)\n"
Statistics from a Large Sample,###  1093\. Statistics from a Large Sample\n\nYou are given a large sample of integers in the range `[0 255]`. Since the\nsample is so large it is represented by an array `count` where `count[k]` is\nthe **number of times** that `k` appears in the sample.\n\nCalculate the following statistics:\n\n  * `minimum`: The minimum element in the sample.\n  * `maximum`: The maximum element in the sample.\n  * `mean`: The average of the sample calculated as the total sum of all elements divided by the total number of elements.\n  * `median`: \n    * If the sample has an odd number of elements then the `median` is the middle element once the sample is sorted.\n    * If the sample has an even number of elements then the `median` is the average of the two middle elements once the sample is sorted.\n  * `mode`: The number that appears the most in the sample. It is guaranteed to be **unique**.\n\nReturn _the statistics of the sample as an array of floating-point\nnumbers_`[minimum maximum mean median mode]`_. Answers within_`10-5` _of\nthe actual answer will be accepted._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** count = [0134000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]\n    **Output:** [1.000003.000002.375002.500003.00000]\n    **Explanation:** The sample represented by count is [12223333].\n    The minimum and maximum are 1 and 3 respectively.\n    The mean is (1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375.\n    Since the size of the sample is even the median is the average of the two middle elements 2 and 3 which is 2.5.\n    The mode is 3 as it appears the most in the sample.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** count = [0432200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]\n    **Output:** [1.000004.000002.181822.000001.00000]\n    **Explanation:** The sample represented by count is [11112223344].\n    The minimum and maximum are 1 and 4 respectively.\n    The mean is (1+1+1+1+2+2+2+3+3+4+4) / 11 = 24 / 11 = 2.18181818... (for display purposes the output shows the rounded number 2.18182).\n    Since the size of the sample is odd the median is the middle element 2.\n    The mode is 1 as it appears the most in the sample.\n    \n\n\n\n**Constraints:**\n\n  * `count.length == 256`\n  * `0 <= count[i] <= 109`\n  * `1 <= sum(count) <= 109`\n  * The mode of the sample that `count` represents is **unique**.\n\n,"class Solution(object):\n    def sampleStats(self count):\n        """"""\n        :type count: List[int]\n        :rtype: List[float]\n        """"""\n        maxvminvacccntmodemodev=NoneNone00.000\n        for in in enumerate(count):\n            if minv==None and n!=0:minv=i\n            if n!=0:maxv=i\n            if n>modev:modevmode=ni\n            acccnt=acc+n*icnt+n\n          \n        midCntccmidvprei=cnt//200i\n        for in in enumerate(count):\n            if n==0:continue\n            if cc+n<=midCnt:\n                ccprei=cc+ni\n                continue\n            if cnt%2==1:midv=i\n            else:midv=(prei+i)/2.0 if cc==midCnt else i\n            break\n        return (minvmaxvacc/cntmidvmode)   \n"
Step-By-Step Directions From a Binary Tree Node to Another,"###  2096\. Step-By-Step Directions From a Binary Tree Node to Another\n\nYou are given the `root` of a **binary tree** with `n` nodes. Each node is\nuniquely assigned a value from `1` to `n`. You are also given an integer\n`startValue` representing the value of the start node `s` and a different\ninteger `destValue` representing the value of the destination node `t`.\n\nFind the **shortest path** starting from node `s` and ending at node `t`.\nGenerate step-by-step directions of such path as a string consisting of only\nthe **uppercase** letters `'L'` `'R'` and `'U'`. Each letter indicates a\nspecific direction:\n\n  * `'L'` means to go from a node to its **left child** node.\n  * `'R'` means to go from a node to its **right child** node.\n  * `'U'` means to go from a node to its **parent** node.\n\nReturn _the step-by-step directions of the**shortest path** from node _`s` _to\nnode_ `t`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/11/15/eg1.png)\n\n    \n    \n    **Input:** root = [5123null64] startValue = 3 destValue = 6\n    **Output:** ""UURL""\n    **Explanation:** The shortest path is: 3 → 1 → 5 → 2 → 6.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/11/15/eg2.png)\n\n    \n    \n    **Input:** root = [21] startValue = 2 destValue = 1\n    **Output:** ""L""\n    **Explanation:** The shortest path is: 2 → 1.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is `n`.\n  * `2 <= n <= 105`\n  * `1 <= Node.val <= n`\n  * All the values in the tree are **unique**.\n  * `1 <= startValue destValue <= n`\n  * `startValue != destValue`\n\n","class Solution:\n    def getDirections(self root: Optional[TreeNode] startValue: int destValue: int) -> str:\n        def find(n: TreeNode val: int path: List[str]) -> bool:\n            if n.val == val:\n                return True\n            if n.left and find(n.left val path):\n                path += ""L""\n            elif n.right and find(n.right val path):\n                path += ""R""\n            return path\n        s d = [] []\n        find(root startValue s)\n        find(root destValue d)\n        while len(s) and len(d) and s[-1] == d[-1]:\n            s.pop()\n            d.pop()\n        return """".join(""U"" * len(s)) + """".join(reversed(d))\n"
Stock Price Fluctuation,"###  2034\. Stock Price Fluctuation\n\nYou are given a stream of **records** about a particular stock. Each record\ncontains a **timestamp** and the corresponding **price** of the stock at that\ntimestamp.\n\nUnfortunately due to the volatile nature of the stock market the records do\nnot come in order. Even worse some records may be incorrect. Another record\nwith the same timestamp may appear later in the stream **correcting** the\nprice of the previous wrong record.\n\nDesign an algorithm that:\n\n  * **Updates** the price of the stock at a particular timestamp **correcting** the price from any previous records at the timestamp.\n  * Finds the **latest price** of the stock based on the current records. The **latest price** is the price at the latest timestamp recorded.\n  * Finds the **maximum price** the stock has been based on the current records.\n  * Finds the **minimum price** the stock has been based on the current records.\n\nImplement the `StockPrice` class:\n\n  * `StockPrice()` Initializes the object with no price records.\n  * `void update(int timestamp int price)` Updates the `price` of the stock at the given `timestamp`.\n  * `int current()` Returns the **latest price** of the stock.\n  * `int maximum()` Returns the **maximum price** of the stock.\n  * `int minimum()` Returns the **minimum price** of the stock.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""StockPrice"" ""update"" ""update"" ""current"" ""maximum"" ""update"" ""maximum"" ""update"" ""minimum""]\n    [[] [1 10] [2 5] [] [] [1 3] [] [4 2] []]\n    **Output**\n    [null null null 5 10 null 5 null 2]\n    \n    **Explanation**\n    StockPrice stockPrice = new StockPrice();\n    stockPrice.update(1 10); // Timestamps are [1] with corresponding prices [10].\n    stockPrice.update(2 5);  // Timestamps are [12] with corresponding prices [105].\n    stockPrice.current();     // return 5 the latest timestamp is 2 with the price being 5.\n    stockPrice.maximum();     // return 10 the maximum price is 10 at timestamp 1.\n    stockPrice.update(1 3);  // The previous timestamp 1 had the wrong price so it is updated to 3.\n                              // Timestamps are [12] with corresponding prices [35].\n    stockPrice.maximum();     // return 5 the maximum price is 5 after the correction.\n    stockPrice.update(4 2);  // Timestamps are [124] with corresponding prices [352].\n    stockPrice.minimum();     // return 2 the minimum price is 2 at timestamp 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= timestamp price <= 109`\n  * At most `105` calls will be made **in total** to `update` `current` `maximum` and `minimum`.\n  * `current` `maximum` and `minimum` will be called **only after** `update` has been called **at least once**.\n\n","class StockPrice:\n\n    def __init__(self):\n        self.timestamps = {}\n        self.highestTimestamp = 0\n        self.minHeap = []\n        self.maxHeap = []\n\n    def update(self timestamp: int price: int) -> None:\n	    #Keep track of current prices\n        self.timestamps[timestamp] = price\n        self.highestTimestamp = max(self.highestTimestamp timestamp)\n        \n		#For maximum/minimum\n        heappush(self.minHeap (price timestamp))\n        heappush(self.maxHeap (-price timestamp))\n\n    def current(self) -> int:\n	    #Just return the highest timestamp in O(1)\n        return self.timestamps[self.highestTimestamp]\n\n    def maximum(self) -> int:\n        currPrice timestamp = heappop(self.maxHeap)\n		\n		#If the price from the heap doesn't match the price the timestamp indicates keep popping from the heap\n        while -currPrice != self.timestamps[timestamp]:\n            currPrice timestamp = heappop(self.maxHeap)\n            \n        heappush(self.maxHeap (currPrice timestamp))\n        return -currPrice\n\n    def minimum(self) -> int:\n        currPrice timestamp = heappop(self.minHeap)\n		\n		#If the price from the heap doesn't match the price the timestamp indicates keep popping from the heap\n        while currPrice != self.timestamps[timestamp]:\n            currPrice timestamp = heappop(self.minHeap)\n            \n        heappush(self.minHeap (currPrice timestamp))\n        return currPrice\n"
Stone Game,###  877\. Stone Game\n\nAlice and Bob play a game with piles of stones. There are an **even** number\nof piles arranged in a row and each pile has a **positive** integer number of\nstones `piles[i]`.\n\nThe objective of the game is to end with the most stones. The **total** number\nof stones across all the piles is **odd**  so there are no ties.\n\nAlice and Bob take turns with **Alice starting first**. Each turn a player\ntakes the entire pile of stones either from the **beginning** or from the\n**end** of the row. This continues until there are no more piles left at\nwhich point the person with the **most stones wins**.\n\nAssuming Alice and Bob play optimally return `true` _if Alice wins the game\nor_`false` _if Bob wins_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** piles = [5345]\n    **Output:** true\n    **Explanation:** \n    Alice starts first and can only take the first 5 or the last 5.\n    Say she takes the first 5 so that the row becomes [3 4 5].\n    If Bob takes 3 then the board is [4 5] and Alice takes 5 to win with 10 points.\n    If Bob takes the last 5 then the board is [3 4] and Alice takes 4 to win with 9 points.\n    This demonstrated that taking the first 5 was a winning move for Alice so we return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** piles = [3723]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `2 <= piles.length <= 500`\n  * `piles.length` is **even**.\n  * `1 <= piles[i] <= 500`\n  * `sum(piles[i])` is **odd**.\n\n,class Solution:\n    def stoneGame(self piles: List[int]) -> bool:\n        return True\n
Stone Game II,###  1140\. Stone Game II\n\nAlice and Bob continue their games with piles of stones.  There are a number\nof piles **arranged in a row**  and each pile has a positive integer number\nof stones `piles[i]`.  The objective of the game is to end with the most\nstones.\n\nAlice and Bob take turns with Alice starting first.  Initially `M = 1`.\n\nOn each player's turn that player can take **all the stones** in the\n**first** `X` remaining piles where `1 <= X <= 2M`.  Then we set `M = max(M\nX)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally return the maximum number of stones\nAlice can get.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** piles = [27944]\n    **Output:** 10\n    **Explanation:**  If Alice takes one pile at the beginning Bob takes two piles then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning then Bob can take all three piles left. In this case Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** piles = [12345100]\n    **Output:** 104\n    \n\n\n\n**Constraints:**\n\n  * `1 <= piles.length <= 100`\n  * `1 <= piles[i] <= 104`\n\n,class Solution:\n    def stoneGameII(self piles: List[int]) -> int:\n        n = len(piles)\n        dp = {} \n        def recursion(indexM):\n            # if we reached to the end we cannot score any value\n            if index == n:\n                return 0\n            # we search if we have solved the same case earlier\n            if (indexM) in dp:\n                return dp[(indexM)] \n            # total remaining score is the sum of array from index to the end\n            total = sum(piles[index:])           \n            # if we can take the complete array it is the best choice\n            if index + 2*M >= n :return total\n            # my_score is the score we are getting as the player who is playing\n            my_score = 0\n            for x in range(indexindex+2*M):\n                # opponent score will be calculated by next recursion\n                opponent_score = recursion(x+1max(Mx-index+1))\n                # my_score is the remaining value of total - opponent_score\n                my_score = max(my_scoretotal - opponent_score)          \n            # this is memoization part\n            dp[(indexM)] = my_score\n            # return the score\n            return my_score\n        \n        return recursion(01)\n
Stone Game III,"###  1406\. Stone Game III\n\nAlice and Bob continue their games with piles of stones. There are several\nstones **arranged in a row**  and each stone has an associated value which is\nan integer given in the array `stoneValue`.\n\nAlice and Bob take turns with Alice starting first. On each player's turn\nthat player can take `1` `2` or `3` stones from the **first** remaining\nstones in the row.\n\nThe score of each player is the sum of the values of the stones taken. The\nscore of each player is `0` initially.\n\nThe objective of the game is to end with the highest score and the winner is\nthe player with the highest score and there could be a tie. The game continues\nuntil all the stones have been taken.\n\nAssume Alice and Bob **play optimally**.\n\nReturn `""Alice""`_if Alice will win_`""Bob""`_if Bob will win or_`""Tie""`_if\nthey will end the game with the same score_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** values = [1237]\n    **Output:** ""Bob""\n    **Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** values = [123-9]\n    **Output:** ""Alice""\n    **Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\n    If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move Alice will take the pile with value = -9 and lose.\n    If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move Alice will take the pile with value = -9 and also lose.\n    Remember that both play optimally so here Alice will choose the scenario that makes her win.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** values = [1236]\n    **Output:** ""Tie""\n    **Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles otherwise she will lose.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= stoneValue.length <= 5 * 104`\n  * `-1000 <= stoneValue[i] <= 1000`\n\n","class Solution(object):\n    def stoneGameIII(self stoneValue):\n        """"""\n        :type stoneValue: List[int]\n        :rtype: str\n        """"""\n        n = len(stoneValue)\n        suffixSum = [0 for _ in range(n+1)]\n        dp = [0 for _ in range(n+1)]\n        for i in range(n-1 -1 -1):\n            suffixSum[i] = suffixSum[i+1] + stoneValue[i]\n        for i in range(n-1 -1 -1):\n            dp[i] = stoneValue[i] + suffixSum[i+1] - dp[i+1]\n            for k in range(i+1 min(n i+3)):\n                dp[i] = max(dp[i] suffixSum[i] - dp[k+1])\n        if dp[0]*2 == suffixSum[0]:\n            return ""Tie""\n        elif dp[0]*2 > suffixSum[0]:\n            return ""Alice""\n        else:\n            return ""Bob""\n"
Stone Game IV,###  1510\. Stone Game IV\n\nAlice and Bob take turns playing a game with Alice starting first.\n\nInitially there are `n` stones in a pile. On each player's turn that player\nmakes a _move_ consisting of removing **any** non-zero **square number** of\nstones in the pile.\n\nAlso if a player cannot make a move he/she loses the game.\n\nGiven a positive integer `n` return `true` if and only if Alice wins the game\notherwise return `false` assuming both players play optimally.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** true\n    **Explanation:** Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n\n**Example 2:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** false\n    **Explanation:** Alice can only remove 1 stone after that Bob removes the last one winning the game (2 -> 1 -> 0).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** true\n    **Explanation:** n is already a perfect square Alice can win with one move removing 4 stones (4 -> 0).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n\n,# Runtime: 189 ms (Top 93.6%) | Memory: 21.09 MB (Top 49.0%)\n\nclass Solution:\n    def winnerSquareGame(self n: int) -> bool:\n        squares = lambda x: (i * i for i in range(isqrt(x) 0 -1))\n        \n        @cache\n        def can_win(n: int) -> bool:\n            return n and not all(can_win(n - s) for s in squares(n))\n        \n        return can_win(n)\n\n
Stone Game IX,###  2029\. Stone Game IX\n\nAlice and Bob continue their games with stones. There is a row of n stones\nand each stone has an associated value. You are given an integer array\n`stones` where `stones[i]` is the **value** of the `ith` stone.\n\nAlice and Bob take turns with **Alice** starting first. On each turn the\nplayer may remove any stone from `stones`. The player who removes a stone\n**loses** if the **sum** of the values of **all removed stones** is divisible\nby `3`. Bob will win automatically if there are no remaining stones (even if\nit is Alice's turn).\n\nAssuming both players play **optimally**  return `true` _if Alice wins and_\n`false` _if Bob wins_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** stones = [21]\n    **Output:** true\n    **Explanation:**  The game will be played as follows:\n    - Turn 1: Alice can remove either stone.\n    - Turn 2: Bob removes the remaining stone. \n    The sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore Bob loses and Alice wins the game.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** stones = [2]\n    **Output:** false\n    **Explanation:**  Alice will remove the only stone and the sum of the values on the removed stones is 2. \n    Since all the stones are removed and the sum of values is not divisible by 3 Bob wins the game.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** stones = [51243]\n    **Output:** false\n    **Explanation:** Bob will always win. One possible way for Bob to win is shown below:\n    - Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.\n    - Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.\n    - Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.\n    - Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.\n    - Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.\n    Alice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= stones.length <= 105`\n  * `1 <= stones[i] <= 104`\n\n,# Runtime: 2982 ms (Top 22.53%) | Memory: 27.5 MB (Top 95.77%)\nclass Solution:\n    def stoneGameIX(self stones: List[int]) -> bool:\n        u d t = 0 0 0\n        for stone in stones:\n            if stone % 3 == 1:\n                u += 1\n            elif stone % 3 == 2:\n                d += 1\n            else:\n                t += 1\n        if not u and d <= 2 or u <= 2 and not d: #situation 1 part 2\n            return False\n        if not u and d > 2 or u > 2 and not d: #situation 1 part 1\n            if not t % 2:\n                return False\n            else:\n                return True\n        if u == d or abs(u - d) <= 2: #situation 2 and situation 3\n            if t % 2:\n                return False\n            else:\n                return True\n        return True #default situation
Stone Game V,###  1563\. Stone Game V\n\nThere are several stones **arranged in a row**  and each stone has an\nassociated value which is an integer given in the array `stoneValue`.\n\nIn each round of the game Alice divides the row into **two non-empty rows**\n(i.e. left row and right row) then Bob calculates the value of each row which\nis the sum of the values of all the stones in this row. Bob throws away the\nrow which has the maximum value and Alice's score increases by the value of\nthe remaining row. If the value of the two rows are equal Bob lets Alice\ndecide which row will be thrown away. The next round starts with the remaining\nrow.\n\nThe game ends when there is only **one stone remaining**. Alice's is initially\n**zero**.\n\nReturn _the maximum score that Alice can obtain_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** stoneValue = [623455]\n    **Output:** 18\n    **Explanation:** In the first round Alice divides the row to [623] [455]. The left row has the value 11 and the right row has value 14. Bob throws away the right row and Alice's score is now 11.\n    In the second round Alice divides the row to [6] [23]. This time Bob throws away the left row and Alice's score becomes 16 (11 + 5).\n    The last round Alice has only one choice to divide the row which is [2] [3]. Bob throws away the right row and Alice's score is now 18 (16 + 2). The game ends because only one stone is remaining in the row.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** stoneValue = [7777777]\n    **Output:** 28\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** stoneValue = [4]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= stoneValue.length <= 500`\n  * `1 <= stoneValue[i] <= 106`\n\n,# Runtime: 6408 ms (Top 13.33%) | Memory: 26.1 MB (Top 43.33%)\nfrom collections import defaultdict\nfrom itertools import accumulate\n\nclass Solution:\n\n    def stoneGameV(self stoneValue: List[int]) -> int:\n        n = len(stoneValue)\n        dp = [[0]*n for _ in range(n)]\n        left = [[0]*n for _ in range(n)]\n        prefix = list(accumulate(stoneValue))\n        prefix = [0]+prefix+[prefix[-1]]\n\n        def sum(ij):\n            return prefix[j+1]-prefix[i]\n\n        row_idx = [i for i in range(n)]\n        for i in range(n):\n            left[i][i] = stoneValue[i]\n        for d in range(1n):\n            for i in range(n-d):\n                j = i+d\n                while sum(irow_idx[i]) < sum(row_idx[i]+1j):\n                    row_idx[i] +=1\n                if sum(i row_idx[i]) == sum(row_idx[i]+1j):\n                    dp[i][j] = max(left[i][row_idx[i]] left[j][row_idx[i]+1])\n                else:\n                    if row_idx[i] == i:\n                        dp[i][j] = left[j][i+1]\n                    elif row_idx[i] == j:\n                        dp[i][j] = left[i][j-1]\n                    else:\n                        dp[i][j] = max(left[i][row_idx[i]-1] left[j][row_idx[i]+1])\n                left[j][i] = max(left[j][i+1]sum(ij)+dp[i][j])\n                left[i][j] = max(left[i][j-1]sum(ij)+dp[i][j])\n        return dp[0][n-1]
Stone Game VI,###  1686\. Stone Game VI\n\nAlice and Bob take turns playing a game with Alice starting first.\n\nThere are `n` stones in a pile. On each player's turn they can **remove** a\nstone from the pile and receive points based on the stone's value. Alice and\nBob may **value the stones differently**.\n\nYou are given two integer arrays of length `n` `aliceValues` and `bobValues`.\nEach `aliceValues[i]` and `bobValues[i]` represents how Alice and Bob\nrespectively value the `ith` stone.\n\nThe winner is the person with the most points after all the stones are chosen.\nIf both players have the same amount of points the game results in a draw.\nBoth players will play **optimally**. Both players know the other's values.\n\nDetermine the result of the game and:\n\n  * If Alice wins return `1`.\n  * If Bob wins return `-1`.\n  * If the game results in a draw return `0`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** aliceValues = [13] bobValues = [21]\n    **Output:** 1\n    **Explanation:**\n    If Alice takes stone 1 (0-indexed) first Alice will receive 3 points.\n    Bob can only choose stone 0 and will only receive 2 points.\n    Alice wins.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** aliceValues = [12] bobValues = [31]\n    **Output:** 0\n    **Explanation:**\n    If Alice takes stone 0 and Bob takes stone 1 they will both have 1 point.\n    Draw.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** aliceValues = [243] bobValues = [167]\n    **Output:** -1\n    **Explanation:**\n    Regardless of how Alice plays Bob will be able to have more points than Alice.\n    For example if Alice takes stone 1 Bob can take stone 2 and Alice takes stone 0 Alice will have 6 points to Bob's 7.\n    Bob wins.\n    \n\n\n\n**Constraints:**\n\n  * `n == aliceValues.length == bobValues.length`\n  * `1 <= n <= 105`\n  * `1 <= aliceValues[i] bobValues[i] <= 100`\n\n,class Solution:\n    def stoneGameVI(self A B):\n        G  = [a+b for ab in zip(AB)]\n        G.sort()\n        L  = len(A)\n        d  = -sum(B) + sum( G[i] for i in range(L-1-1-2) )\n        return 1 if d>0 else ( -1 if d<0 else 0 )
Stone Game VII,###  1690\. Stone Game VII\n\nAlice and Bob take turns playing a game with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn they can\n**remove** either the leftmost stone or the rightmost stone from the row and\nreceive points equal to the **sum** of the remaining stones' values in the\nrow. The winner is the one with the higher score when there are no stones left\nto remove.\n\nBob found that he will always lose this game (poor Bob he always loses) so\nhe decided to **minimize the score's difference**. Alice's goal is to\n**maximize the difference** in the score.\n\nGiven an array of integers `stones` where `stones[i]` represents the value of\nthe `ith` stone **from the left**  return _the**difference** in Alice and\nBob's score if they both play **optimally**._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** stones = [53142]\n    **Output:** 6\n    **Explanation:** \n    - Alice removes 2 and gets 5 + 3 + 1 + 4 = 13 points. Alice = 13 Bob = 0 stones = [5314].\n    - Bob removes 5 and gets 3 + 1 + 4 = 8 points. Alice = 13 Bob = 8 stones = [314].\n    - Alice removes 3 and gets 1 + 4 = 5 points. Alice = 18 Bob = 8 stones = [14].\n    - Bob removes 1 and gets 4 points. Alice = 18 Bob = 12 stones = [4].\n    - Alice removes 4 and gets 0 points. Alice = 18 Bob = 12 stones = [].\n    The score difference is 18 - 12 = 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** stones = [7905110010102]\n    **Output:** 122\n\n\n\n**Constraints:**\n\n  * `n == stones.length`\n  * `2 <= n <= 1000`\n  * `1 <= stones[i] <= 1000`\n\n,# Runtime: 6869 ms (Top 56.16%) | Memory: 13.9 MB (Top 96.15%)\nclass Solution:\n    def stoneGameVII(self S: List[int]) -> int:\n        N dp = len(S) [0] * len(S)\n        for i in range(N - 2 -1 -1):\n            total = S[i]\n            for j in range(i + 1 N):\n                total += S[j]\n                dp[j] = max(total - S[i] - dp[j] total - S[j] - dp[j-1])\n        return dp[-1]
Stone Game VIII,###  1872\. Stone Game VIII\n\nAlice and Bob take turns playing a game with **Alice starting first**.\n\nThere are `n` stones arranged in a row. On each player's turn while the\nnumber of stones is **more than one**  they will do the following:\n\n  1. Choose an integer `x > 1` and **remove** the leftmost `x` stones from the row.\n  2. Add the **sum** of the **removed** stones' values to the player's score.\n  3. Place a **new stone**  whose value is equal to that sum on the left side of the row.\n\nThe game stops when **only** **one** stone is left in the row.\n\nThe **score difference** between Alice and Bob is `(Alice's score - Bob's\nscore)`. Alice's goal is to **maximize** the score difference and Bob's goal\nis the **minimize** the score difference.\n\nGiven an integer array `stones` of length `n` where `stones[i]` represents the\nvalue of the `ith` stone **from the left**  return _the**score difference**\nbetween Alice and Bob if they both play **optimally**._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** stones = [-12-34-5]\n    **Output:** 5\n    **Explanation:**\n    - Alice removes the first 4 stones adds (-1) + 2 + (-3) + 4 = 2 to her score and places a stone of\n      value 2 on the left. stones = [2-5].\n    - Bob removes the first 2 stones adds 2 + (-5) = -3 to his score and places a stone of value -3 on\n      the left. stones = [-3].\n    The difference between their scores is 2 - (-3) = 5.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** stones = [7-65105-2-6]\n    **Output:** 13\n    **Explanation:**\n    - Alice removes all stones adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score and places a\n      stone of value 13 on the left. stones = [13].\n    The difference between their scores is 13 - 0 = 13.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** stones = [-10-12]\n    **Output:** -22\n    **Explanation:**\n    - Alice can only make one move which is to remove both stones. She adds (-10) + (-12) = -22 to her\n      score and places a stone of value -22 on the left. stones = [-22].\n    The difference between their scores is (-22) - 0 = -22.\n    \n\n\n\n**Constraints:**\n\n  * `n == stones.length`\n  * `2 <= n <= 105`\n  * `-104 <= stones[i] <= 104`\n\n,# OJ: https://leetcode.com/problems/stone-game-viii/\n# Author: github.com/lzl124631x\nclass Solution:\n    def stoneGameVIII(self A: List[int]) -> int:\n        return reduce(lambda memo cur : max(memo cur - memo) list(accumulate(A))[::-1][:-1])\n
Strange Printer,"###  664\. Strange Printer\n\nThere is a strange printer with the following two special properties:\n\n  * The printer can only print a sequence of **the same character** each time.\n  * At each turn the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string `s` return _the minimum number of turns the printer needed to\nprint it_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aaabbb""\n    **Output:** 2\n    **Explanation:** Print ""aaa"" first and then print ""bbb"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aba""\n    **Output:** 2\n    **Explanation:** Print ""aaa"" first and then print ""b"" from the second place of the string which will cover the existing character 'a'.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s` consists of lowercase English letters.\n\n","# Runtime: 878 ms (Top 47.91%) | Memory: 16.1 MB (Top 47.44%)\nclass Solution(object):\n    def strangePrinter(self s):\n        """"""\n        :type s: str\n        :rtype: int\n        """"""\n        # remove duplicate letters from s.\n        tmp = []\n        for c in s:\n            if len(tmp) == 0 or tmp[-1] != c:\n                tmp.append(c)\n        s = """".join(tmp)\n\n        _m = {}\n        def _dp(i j background):\n            if j < i:\n                return 0\n            elif i == j:\n                return 1 if background != s[i] else 0\n            elif (i j background) in _m:\n                return _m[(i j background)]\n\n            ans = len(s)\n\n            # shrink s[i:j+1] to s[i_:j_+1] according to the background letter\n            i_ = i + 1 if s[i] == background else i\n            j_ = j - 1 if s[j] == background else j\n\n            if s[i_] == s[j_]:\n                # case ""AxxxA"" => best strategy is printing A first\n                ans = _dp(i_ + 1 j_ - 1 s[i_]) + 1\n            else:\n                # otherwise print first letter try every possible print length\n                for p in range(i_ j_ + 1):\n                    # searching is needed only if s[p] == s[i_]\n                    # e.g. s=""ABCDEA""print 'A' on s[0:1] is equivalent to s[0:5]\n                    if s[p] != s[i_]:\n                        continue\n                    l = _dp(i_ p s[i_])\n                    r = _dp(p + 1 j_ background)\n                    ans = min(ans l + r + 1)\n            _m[(i j background)] = ans\n            return ans\n\n        return _dp(0 len(s) - 1 '')"
Strange Printer II,###  1591\. Strange Printer II\n\nThere is a strange printer with the following two special requirements:\n\n  * On each turn the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n  * Once the printer has used a color for the above operation **the same color cannot be used again**.\n\nYou are given a `m x n` matrix `targetGrid` where `targetGrid[row][col]` is\nthe color in the position `(row col)` of the grid.\n\nReturn `true` _if it is possible to print the matrix_`targetGrid`\n___otherwise return_`false`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/12/23/print1.jpg)\n\n    \n    \n    **Input:** targetGrid = [[1111][1221][1221][1111]]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/12/23/print2.jpg)\n\n    \n    \n    **Input:** targetGrid = [[1111][1133][1134][5514]]\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** targetGrid = [[121][212][121]]\n    **Output:** false\n    **Explanation:** It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n    \n\n\n\n**Constraints:**\n\n  * `m == targetGrid.length`\n  * `n == targetGrid[i].length`\n  * `1 <= m n <= 60`\n  * `1 <= targetGrid[row][col] <= 60`\n\n,"# Runtime: 514 ms (Top 80.64%) | Memory: 14.5 MB (Top 44.35%)\nfrom graphlib import TopologicalSorter CycleError\n\nColor = int\nCorner = Tuple[int int]\nRect = Tuple[Corner Corner] # [upper-left lower-right (non-inclusive)]\nLayer = Tuple[Color Rect]\n\nclass Solution:\n    def isPrintable(self targetGrid: List[List[int]]) -> bool:\n        # Runtime is the summation of several steps but is dominated by the second step\n        # O(M*N + C*C*M*N + (O(C*C) + O(M*N)) + M*N) -> O(C*C*M*N)\n        def compare(a:Layer b:Layer) -> int:\n            """"""\n            Determine if two rectangles overlap.\n\n            Return:\n                -1 if b is over a\n                0 if there is no overlap or an order cannot be determined (the overlap contains no elements of a or b)\n                1 if a is over b\n            """"""\n            val_a (a_ul a_lr) = a\n            val_b (b_ul b_lr) = b\n\n            # Get overlap rectangle\n            ul lr = (\n                (max(a_ul[0] b_ul[0]) max(a_ul[1] b_ul[1]))\n                (min(a_lr[0] b_lr[0]) min(a_lr[1] b_lr[1]))\n            )\n\n            # If either dimension is non-positive there is no overlap\n            if lr[0] - ul[0] <= 0 or lr[1] - ul[1] <= 0:\n                return 0\n\n            # Find the first element matching a or b in the overlap rectangle.\n            # We'll consider that the ""over"" value.\n            for r in range(ul[0] lr[0]):\n                for c in range(ul[1] lr[1]):\n                    if targetGrid[r][c] == val_b:\n                        return -1\n                    elif targetGrid[r][c] == val_a:\n                        return 1\n            # We could find no values from a or b in the overlap.\n            # The result is indeterminate.\n            return 0\n\n        # Generate the enclosing rectangles for each visible color (ie. layers).\n        # O(M*N)\n        rects:Dict[Color Rect] = defaultdict(lambda: ([100 100] [0 0]))\n        for r row in enumerate(targetGrid):\n            for c val in enumerate(row):\n                ul lr = rects[val]\n                rects[val] = (\n                    (min(ul[0] r) min(ul[1] c))\n                    (max(lr[0] r + 1) max(lr[1] c + 1))\n                )\n\n        # Compare every pair of layers.\n        # If overlap is detected record that the ""upper"" rectangle depends on the ""lower"" one.\n        # O(C*C*M*N) # Number of colors\n        layers:List[Layer] = list(rects.items())\n        graph:Dict[Layer Set[Layer]] = {layer: set() for layer in layers}\n        for i a in enumerate(layers):\n            for b in layers[i + 1 :]:\n                if (cmp := compare(a b)) < 0:\n                    graph[b].add(a)\n                elif cmp > 0:\n                    graph[a].add(b)\n\n        # Use topological sort on the graph to reproduce the printing order (in the absence\n        # of cycles) and print our own grid.\n        # O(C*C) + O(M*N) // O(C*C) is derived from topological sort O(V+E)\n        try:\n            grid = [[0] * len(targetGrid[0]) for _ in targetGrid]\n            for color (ul lr) in TopologicalSorter(graph).static_order():\n                for r in range(ul[0] lr[0]):\n                    for c in range(ul[1] lr[1]):\n                        grid[r][c] = color\n        except CycleError:\n            return False\n\n        # Compare the grids\n        # O(M*N)\n        return grid == targetGrid"
Stream of Characters,"###  1032\. Stream of Characters\n\nDesign an algorithm that accepts a stream of characters and checks if a suffix\nof these characters is a string of a given array of strings `words`.\n\nFor example if `words = [""abc"" ""xyz""]` and the stream added the four\ncharacters (one by one) `'a'` `'x'` `'y'` and `'z'` your algorithm should\ndetect that the suffix `""xyz""` of the characters `""axyz""` matches `""xyz""` from\n`words`.\n\nImplement the `StreamChecker` class:\n\n  * `StreamChecker(String[] words)` Initializes the object with the strings array `words`.\n  * `boolean query(char letter)` Accepts a new character from the stream and returns `true` if any non-empty suffix from the stream forms a word that is in `words`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""StreamChecker"" ""query"" ""query"" ""query"" ""query"" ""query"" ""query"" ""query"" ""query"" ""query"" ""query"" ""query"" ""query""]\n    [[[""cd"" ""f"" ""kl""]] [""a""] [""b""] [""c""] [""d""] [""e""] [""f""] [""g""] [""h""] [""i""] [""j""] [""k""] [""l""]]\n    **Output**\n    [null false false false true false true false false false false false true]\n    \n    **Explanation**\n    StreamChecker streamChecker = new StreamChecker([""cd"" ""f"" ""kl""]);\n    streamChecker.query(""a""); // return False\n    streamChecker.query(""b""); // return False\n    streamChecker.query(""c""); // return False\n    streamChecker.query(""d""); // return True because 'cd' is in the wordlist\n    streamChecker.query(""e""); // return False\n    streamChecker.query(""f""); // return True because 'f' is in the wordlist\n    streamChecker.query(""g""); // return False\n    streamChecker.query(""h""); // return False\n    streamChecker.query(""i""); // return False\n    streamChecker.query(""j""); // return False\n    streamChecker.query(""k""); // return False\n    streamChecker.query(""l""); // return True because 'kl' is in the wordlist\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 2000`\n  * `1 <= words[i].length <= 200`\n  * `words[i]` consists of lowercase English letters.\n  * `letter` is a lowercase English letter.\n  * At most `4 * 104` calls will be made to query.\n\n",class TrieNode:\n    \n    def __init__(self):\n        self.children = {}\n        self.endOfWord = False\n\nclass StreamChecker:\n\n    def __init__(self words: List[str]):\n        self.root = TrieNode()\n        self.qCur = self.root\n        self.stream = collections.deque()\n        cur = self.root\n        for word in words:\n            for i in range(len(word) - 1 -1 -1):\n                ch = word[i]\n                if ch not in cur.children:\n                    cur.children[ch] = TrieNode()\n                cur = cur.children[ch]\n            cur.endOfWord = True\n            cur = self.root\n\n    def query(self letter: str) -> bool:\n        self.stream.appendleft(letter)\n        cur = self.root\n        for ch in self.stream:\n            if ch not in cur.children:\n                return False\n            else:\n                cur = cur.children[ch]\n                if cur.endOfWord:\n                    return True\n        return False\n
String Compression II,"###  1531\. String Compression II\n\n[Run-length encoding](http://en.wikipedia.org/wiki/Run-length_encoding) is a\nstring compression method that works by replacing consecutive identical\ncharacters (repeated 2 or more times) with the concatenation of the character\nand the number marking the count of the characters (length of the run). For\nexample to compress the string `""aabccc""` we replace `""aa""` by `""a2""` and\nreplace `""ccc""` by `""c3""`. Thus the compressed string becomes `""a2bc3""`.\n\nNotice that in this problem we are not adding `'1'` after single characters.\n\nGiven a string `s` and an integer `k`. You need to delete **at most**  `k`\ncharacters from `s` such that the run-length encoded version of `s` has\nminimum length.\n\nFind the _minimum length of the run-length encoded  version of _`s` _after\ndeleting at most_`k` _characters_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aaabcccd"" k = 2\n    **Output:** 4\n    **Explanation:** Compressing s without deleting anything will give us ""a3bc3d"" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5 for instance delete 2 'a' then we will have s = ""abcccd"" which compressed is abc3d. Therefore the optimal way is to delete 'b' and 'd' then the compressed version of s will be ""a3c3"" of length 4.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aabbaa"" k = 2\n    **Output:** 2\n    **Explanation:** If we delete both 'b' characters the resulting compressed string would be ""a4"" of length 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""aaaaaaaaaaa"" k = 0\n    **Output:** 3\n    **Explanation:** Since k is zero we cannot delete anything. The compressed string is ""a11"" of length 3.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `0 <= k <= s.length`\n  * `s` contains only lowercase English letters.\n\n","// Runtime: 1997 ms (Top 68.37%) | Memory: 360.00 MB (Top 27.55%)\n\nclass Solution:\n    def getLengthOfOptimalCompression(self s: str k: int) -> int:\n        # We define f(i curr_run_ch run_length nb_dels_remain) to return \n        # the minimum additional number of characters it will cost to run-length \n        # compress the substring s[i..n-1].\n        # `curr_run_ch` is the character we have in the current ""run"" or the same\n        # contiguous block of characters. \n        # `run_length` is the length of the current ""run"" or the length of the\n        # contiguous block of identical characters.\n		#     e.g. if we just encoded ""aaaaa"" `curr_run_ch` is ""a"" and `run_length` = 5\n        # `nb_dels_remain` is the number of delete operations we have available to us\n        # should we choose to use them\n        memo = {}\n        def f(i curr_run_ch run_length nb_dels_remain):\n            if i == len(s):\n                return 0\n            \n            key = (i curr_run_ch run_length nb_dels_remain)\n            if key in memo:\n                return memo[key]\n            \n            # At character i we have two possible options we could choose to either\n            # delete this character or keep this character. Each choice we make will\n            # incurr some additional run-length encoding length for s[i..n-1]. We return\n            # the minimum of the two.\n            \n            # Delete s[i]\n            del_ch_cost = float('inf')\n            if nb_dels_remain > 0:\n                # Deleting s[i] means the latest character we kept stays the same AND\n                # the current run-length of characters stays the same as well\n                del_ch_cost = f(i + 1 curr_run_ch run_length nb_dels_remain - 1)\n            \n            # Keep s[i]\n            keep_ch_cost = 0\n            if s[i] == curr_run_ch:\n			    # The new character at s[i] we are about to encode is the same as the character in the\n				# current ""run"" we could choose to include it into the current run of course.\n                # Be careful that if we started with run-length of 1 9 99 999 and etc encoding another\n                # character same as `curr_run_ch`  into the same ""run"" will require an extra digit.\n                # e.g. 'a' => '2a' '9a' => '10a' '99a' => '100a'\n                extra_digit_cost = 0\n                if run_length == 1 or len(str(run_length + 1)) > len(str(run_length)):\n                    extra_digit_cost = 1\n                keep_ch_cost = extra_digit_cost + f(i + 1 curr_run_ch run_length + 1 nb_dels_remain)\n            else:\n                # s[i] != curr_run_ch we are going to need to run-length encode at least\n                # one instance of s[i] which would cost 1 plus whatever the cost to encode\n                # the rest. Of course that also means the current ""run"" will ""reset"" and start anew with\n				# a single character s[i]\n                keep_ch_cost = 1 + f(i + 1 s[i] 1 nb_dels_remain)\n            \n            memo[key] = min(keep_ch_cost del_ch_cost)\n            return memo[key]\n        \n        return f(0 '' 0 k)\n"
String Matching in an Array,"###  1408\. String Matching in an Array\n\nGiven an array of string `words`. Return all strings in `words` which is\nsubstring of another word in **any** order.\n\nString `words[i]` is substring of `words[j]` if can be obtained removing some\ncharacters to left and/or right side of `words[j]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""mass""""as""""hero""""superhero""]\n    **Output:** [""as""""hero""]\n    **Explanation:** ""as"" is substring of ""mass"" and ""hero"" is substring of ""superhero"".\n    [""hero""""as""] is also a valid answer.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""leetcode""""et""""code""]\n    **Output:** [""et""""code""]\n    **Explanation:** ""et"" ""code"" are substring of ""leetcode"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""blue""""green""""bu""]\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 100`\n  * `1 <= words[i].length <= 30`\n  * `words[i]` contains only lowercase English letters.\n  * It's **guaranteed**  that `words[i]` will be unique.\n\n",class Solution:\n    def stringMatching(self words: List[str]) -> List[str]:\n        ans=set()\n        l=len(words)\n        for i in range(l):\n            for j in range(l):\n                if (words[i] in words[j]) & (i!=j):\n                    ans.add(words[i])\n        return ans\n
String to Integer (atoi),"###  8\. String to Integer (atoi)\n\nImplement the `myAtoi(string s)` function which converts a string to a 32-bit\nsigned integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n  1. Read in and ignore any leading whitespace.\n  2. Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n  3. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n  4. Convert these digits into an integer (i.e. `""123"" -> 123` `""0032"" -> 32`). If no digits were read then the integer is `0`. Change the sign as necessary (from step 2).\n  5. If the integer is out of the 32-bit signed integer range `[-231 231 - 1]` then clamp the integer so that it remains in the range. Specifically integers less than `-231` should be clamped to `-231` and integers greater than `231 - 1` should be clamped to `231 - 1`.\n  6. Return the integer as the final result.\n\n**Note:**\n\n  * Only the space character `' '` is considered a whitespace character.\n  * **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""42""\n    **Output:** 42\n    **Explanation:** The underlined characters are what is read in the caret is the current reader position.\n    Step 1: ""42"" (no characters read because there is no leading whitespace)\n             ^\n    Step 2: ""42"" (no characters read because there is neither a '-' nor '+')\n             ^\n    Step 3: ""_42_ "" (""42"" is read in)\n               ^\n    The parsed integer is 42.\n    Since 42 is in the range [-231 231 - 1] the final result is 42.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""   -42""\n    **Output:** -42\n    **Explanation:**\n    Step 1: ""__ -42"" (leading whitespace is read and ignored)\n                ^\n    Step 2: ""   _-_ 42"" ('-' is read so the result should be negative)\n                 ^\n    Step 3: ""   -_42_ "" (""42"" is read in)\n                   ^\n    The parsed integer is -42.\n    Since -42 is in the range [-231 231 - 1] the final result is -42.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""4193 with words""\n    **Output:** 4193\n    **Explanation:**\n    Step 1: ""4193 with words"" (no characters read because there is no leading whitespace)\n             ^\n    Step 2: ""4193 with words"" (no characters read because there is neither a '-' nor '+')\n             ^\n    Step 3: ""_4193_ with words"" (""4193"" is read in; reading stops because the next character is a non-digit)\n                 ^\n    The parsed integer is 4193.\n    Since 4193 is in the range [-231 231 - 1] the final result is 4193.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= s.length <= 200`\n  * `s` consists of English letters (lower-case and upper-case) digits (`0-9`) `' '` `'+'` `'-'` and `'.'`.\n\n","# Runtime: 69 ms (Top 20.00%) | Memory: 13.9 MB (Top 79.88%)\n\nclass Solution:\n\n    def assign_sign(self sign):\n      # verify that we haven't already got a sign\n      #&nbsp;""+42-"" -> we don't want to return -42; hence check\n      if not self.is_neg and not self.is_pos:\n          # no sign has been set yet\n        if sign==""+"":\n          self.is_pos = True\n        elif sign==""-"":\n          self.is_neg = True\n      return\n\n    def add_to_int(self num):\n      if not self.num:\n        self.num = num\n      else:\n        self.num = (self.num*10) + num\n\n    def myAtoi(self s: str) -> int:\n        #&nbsp;remove the leading and trailing spaces\n        self.is_neg = False\n        self.is_pos = False\n        self.num = None\n        s=s.strip()\n        for i in s:\n          # ignore the rest of the string if a non digit character is read\n          if i in (""+""""-""):\n            #&nbsp;only read the first symbol; break if second symbol is read\n            if self.is_pos or self.is_neg or isinstance(self.num int):\n              #&nbsp;one of the two symbols is read or a number is read\n              break\n            self.assign_sign(i)\n            continue\n          try:\n            i = int(i)\n            self.add_to_int(i)\n          except ValueError:\n            # it's neither a sign nor a number; terminate\n            break\n\n        # outside the loop; compile the result\n        if not self.num:\n          return 0\n        upper_limit = 2**31 - 1\n        if self.is_pos or (not self.is_pos and not self.is_neg):\n          if self.num > upper_limit:\n            self.num = upper_limit\n        elif self.is_neg:\n          if self.num > upper_limit+1:\n            self.num = upper_limit+1\n          self.num = -1 * self.num\n        return self.num\n"
Strong Password Checker,"###  420\. Strong Password Checker\n\nA password is considered strong if the below conditions are all met:\n\n  * It has at least `6` characters and at most `20` characters.\n  * It contains at least **one lowercase** letter at least **one uppercase** letter and at least **one digit**.\n  * It does not contain three repeating characters in a row (i.e. `""...aaa...""` is weak but `""...aa...a...""` is strong assuming other conditions are met).\n\nGiven a string `password` return _the minimum number of steps required to\nmake`password` strong. if `password` is already strong return `0`._\n\nIn one step you can:\n\n  * Insert one character to `password`\n  * Delete one character from `password` or\n  * Replace one character of `password` with another character.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** password = ""a""\n    **Output:** 5\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** password = ""aA1""\n    **Output:** 3\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** password = ""1337C0d3""\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= password.length <= 50`\n  * `password` consists of letters digits dot `'.'` or exclamation mark `'!'`.\n\n",class Solution:\n    def strongPasswordChecker(self password: str) -> int:\n        #vimla_kushwaha\n        s = password\n        missing_type = 3\n        if any('a' <= c <= 'z' for c in s): missing_type -= 1\n        if any('A' <= c <= 'Z' for c in s): missing_type -= 1\n        if any(c.isdigit() for c in s): missing_type -= 1\n\n        change = 0\n        one = two = 0\n        p = 2\n        while p < len(s):\n            if s[p] == s[p-1] == s[p-2]:\n                length = 2\n                while p < len(s) and s[p] == s[p-1]:\n                    length += 1\n                    p += 1\n                    \n                change += length // 3\n                if length % 3 == 0: one += 1\n                elif length % 3 == 1: two += 1\n            else:\n                p += 1\n        \n        if len(s) < 6:\n            return max(missing_type 6 - len(s))\n        elif len(s) <= 20:\n            return max(missing_type change)\n        else:\n            delete = len(s) - 20\n            \n            change -= min(delete one)\n            change -= min(max(delete - one 0) two * 2) // 2\n            change -= max(delete - one - 2 * two 0) // 3\n                \n            return int(delete + max(missing_type change))\n
Strong Password Checker II,"###  2299\. Strong Password Checker II\n\nA password is said to be **strong** if it satisfies all the following\ncriteria:\n\n  * It has at least `8` characters.\n  * It contains at least **one lowercase** letter.\n  * It contains at least **one uppercase** letter.\n  * It contains at least **one digit**.\n  * It contains at least **one special character**. The special characters are the characters in the following string: `""!@#$%^&*()-+""`.\n  * It does **not** contain `2` of the same character in adjacent positions (i.e. `""aab""` violates this condition but `""aba""` does not).\n\nGiven a string `password` return `true` _if it is a**strong** password_.\nOtherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** password = ""IloveLe3tcode!""\n    **Output:** true\n    **Explanation:** The password meets all the requirements. Therefore we return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** password = ""Me+You--IsMyDream""\n    **Output:** false\n    **Explanation:** The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore we return false.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** password = ""1aB!""\n    **Output:** false\n    **Explanation:** The password does not meet the length requirement. Therefore we return false.\n\n\n\n**Constraints:**\n\n  * `1 <= password.length <= 100`\n  * `password` consists of letters digits and special characters: `""!@#$%^&*()-+""`.\n\n",# Runtime: 65 ms (Top 11.66%) | Memory: 13.9 MB (Top 19.37%)\n\nclass Solution:\n    def strongPasswordCheckerII(self pwd: str) -> bool:\n        return (\n            len(pwd) > 7\n            and max(len(list(p[1])) for p in groupby(pwd)) == 1\n            and reduce(\n                lambda a b: a | (1 if b.isdigit() else 2 if b.islower() else 4 if b.isupper() else 8) pwd 0\n            ) == 15\n        )
Student Attendance Record I,"###  551\. Student Attendance Record I\n\nYou are given a string `s` representing an attendance record for a student\nwhere each character signifies whether the student was absent late or\npresent on that day. The record only contains the following three characters:\n\n  * `'A'`: Absent.\n  * `'L'`: Late.\n  * `'P'`: Present.\n\nThe student is eligible for an attendance award if they meet **both** of the\nfollowing criteria:\n\n  * The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n  * The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nReturn `true` _if the student is eligible for an attendance award or_`false`\n_otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""PPALLP""\n    **Output:** true\n    **Explanation:** The student has fewer than 2 absences and was never late 3 or more consecutive days.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""PPALLL""\n    **Output:** false\n    **Explanation:** The student was late 3 consecutive days in the last 3 days so is not eligible for the award.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s[i]` is either `'A'` `'L'` or `'P'`.\n\n","# Runtime: 76 ms (Top 5.14%) | Memory: 13.9 MB (Top 11.51%)\nclass Solution:\n    def checkRecord(self s: str) -> bool:\n        eligible = True\n\n        for i in range(0 len(s)-2):\n            if s[i:i+3] == ""LLL"":\n                eligible = False\n        absent = 0\n        for i in range(len(s)):\n            if s[i] == ""A"":\n                absent +=1\n\n        if absent>=2:\n            eligible = False\n\n        return(eligible)"
Student Attendance Record II,"###  552\. Student Attendance Record II\n\nAn attendance record for a student can be represented as a string where each\ncharacter signifies whether the student was absent late or present on that\nday. The record only contains the following three characters:\n\n  * `'A'`: Absent.\n  * `'L'`: Late.\n  * `'P'`: Present.\n\nAny student is eligible for an attendance award if they meet **both** of the\nfollowing criteria:\n\n  * The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n  * The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nGiven an integer `n` return _the**number** of possible attendance records of\nlength_ `n` _that make a student eligible for an attendance award. The answer\nmay be very large so return it**modulo** _`109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** 8\n    **Explanation:** There are 8 records with length 2 that are eligible for an award:\n    ""PP"" ""AP"" ""PA"" ""LP"" ""PL"" ""AL"" ""LA"" ""LL""\n    Only ""AA"" is not eligible because there are 2 absences (there need to be fewer than 2).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 3\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 10101\n    **Output:** 183236316\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n\n",// Runtime: 228 ms (Top 90.78%) | Memory: 35.80 MB (Top 36.89%)\n\nimport numpy as np\n\nclass Solution:\n    \n    def checkRecord(self n: int) -> int:\n        MODULUS = 10**9 + 7\n\n        initial_counts = np.array(\n            [1 0 0 0 0 0] \n            dtype=np.int64\n        )\n\n        adjacency_matrix = np.array([\n            [1 1 1 0 0 0]\n            [1 0 0 0 0 0]\n            [0 1 0 0 0 0]\n            [1 1 1 1 1 1]\n            [0 0 0 1 0 0]\n            [0 0 0 0 1 0]\n        ] dtype=np.int64)\n\n        def power(A exp):\n            B = np.identity(len(A) dtype=np.int64)\n            for bit in reversed(bin(exp)[2:]):\n                if bit == '1':\n                    B = B @ A\n                    B %= MODULUS\n                A = A @ A\n                A %= MODULUS\n            return B\n\n        final_counts = power(adjacency_matrix n) @ initial_counts\n\n        return sum(final_counts) % MODULUS\n
Subarray Product Less Than K,###  713\. Subarray Product Less Than K\n\nGiven an array of integers `nums` and an integer `k` return _the number of\ncontiguous subarrays where the product of all the elements in the subarray is\nstrictly less than_`k`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [10526] k = 100\n    **Output:** 8\n    **Explanation:** The 8 subarrays that have product less than 100 are:\n    [10] [5] [2] [6] [10 5] [5 2] [2 6] [5 2 6]\n    Note that [10 5 2] is not included as the product of 100 is not strictly less than k.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [123] k = 0\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 3 * 104`\n  * `1 <= nums[i] <= 1000`\n  * `0 <= k <= 106`\n\n,class Solution:\n    def numSubarrayProductLessThanK(self nums: List[int] k: int) -> int:\n        if k==0 or k==1:\n            return 0\n        p=1\n        ini=0\n        fin=0\n        n=len(nums)\n        c=0\n        while fin<n:\n            p=p*nums[fin]\n            while p>=k :\n                p=p//nums[ini]\n                ini+=1\n\n            n1=fin-ini+1\n            c+=n1\n            fin+=1\n        return c\n
Subarray Sum Equals K,###  560\. Subarray Sum Equals K\n\nGiven an array of integers `nums` and an integer `k` return _the total number\nof subarrays whose sum equals to_ `k`.\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [111] k = 2\n    **Output:** 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [123] k = 3\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 104`\n  * `-1000 <= nums[i] <= 1000`\n  * `-107 <= k <= 107`\n\n,"class Solution:\n	def subarraySum(self nums: List[int] k: int) -> int:\n\n		ans=0\n		prefsum=0\n		d={0:1}\n\n		for num in nums:\n			prefsum = prefsum + num\n\n			if prefsum-k in d:\n				ans = ans + d[prefsum-k]\n\n			if prefsum not in d:\n				d[prefsum] = 1\n			else:\n				d[prefsum] = d[prefsum]+1\n\n		return ans\n"
Subarray Sums Divisible by K,###  974\. Subarray Sums Divisible by K\n\nGiven an integer array `nums` and an integer `k` return _the number of non-\nempty**subarrays** that have a sum divisible by _`k`.\n\nA **subarray** is a **contiguous** part of an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [450-2-31] k = 5\n    **Output:** 7\n    **Explanation:** There are 7 subarrays with a sum divisible by k = 5:\n    [4 5 0 -2 -3 1] [5] [5 0] [5 0 -2 -3] [0] [0 -2 -3] [-2 -3]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [5] k = 9\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 3 * 104`\n  * `-104 <= nums[i] <= 104`\n  * `2 <= k <= 104`\n\n,# Runtime: 209 ms (Top 98.8%) | Memory: 16.64 MB (Top 51.7%)\n\nclass Solution:\n    def subarraysDivByK(self nums k):\n        n = len(nums)\n        prefix_mod = 0\n        result = 0\n\n        # There are k mod groups 0...k-1.\n        mod_groups = [0] * k\n        mod_groups[0] = 1\n\n        for num in nums:\n            # Take modulo twice to avoid negative remainders.\n            prefix_mod = (prefix_mod + num % k + k) % k\n            # Add the count of subarrays that have the same remainder as the current\n            # one to cancel out the remainders.\n            result += mod_groups[prefix_mod]\n            mod_groups[prefix_mod] += 1\n\n        return result
Subarray With Elements Greater Than Varying Threshold,###  2334\. Subarray With Elements Greater Than Varying Threshold\n\nYou are given an integer array `nums` and an integer `threshold`.\n\nFind any subarray of `nums` of length `k` such that **every** element in the\nsubarray is **greater** than `threshold / k`.\n\nReturn _the**size** of **any** such subarray_. If there is no such subarray\nreturn `-1`.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13431] threshold = 6\n    **Output:** 3\n    **Explanation:** The subarray [343] has a size of 3 and every element is greater than 6 / 3 = 2.\n    Note that this is the only valid subarray.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [65658] threshold = 7\n    **Output:** 1\n    **Explanation:** The subarray [8] has a size of 1 and 8 > 7 / 1 = 7. So 1 is returned.\n    Note that the subarray [65] has a size of 2 and every element is greater than 7 / 2 = 3.5. \n    Similarly the subarrays [656] [6565] [65658] also satisfy the given conditions.\n    Therefore 2 3 4 or 5 may also be returned.\n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] threshold <= 109`\n\n,# Runtime: 3127 ms (Top 12.36%) | Memory: 28.8 MB (Top 64.23%)\nclass Solution:\n    def validSubarraySize(self nums: List[int] threshold: int) -> int:\n        nums = [0] + nums + [0]\n        stack = [0]\n        for i in range(1len(nums)):\n            while nums[i] < nums[stack[-1]]:\n                tmp = nums[stack.pop()]\n                if tmp > threshold / (i - stack[-1] - 1):\n                    return i - stack[-1] - 1\n            stack.append(i)\n        return -1
Subarrays with K Different Integers,###  992\. Subarrays with K Different Integers\n\nGiven an integer array `nums` and an integer `k` return _the number of**good\nsubarrays** of _`nums`.\n\nA **good array** is an array where the number of different integers in that\narray is exactly `k`.\n\n  * For example `[12312]` has `3` different integers: `1` `2` and `3`.\n\nA **subarray** is a **contiguous** part of an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [12123] k = 2\n    **Output:** 7\n    **Explanation:** Subarrays formed with exactly 2 different integers: [12] [21] [12] [23] [121] [212] [1212]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12134] k = 3\n    **Output:** 3\n    **Explanation:** Subarrays formed with exactly 3 different integers: [1213] [213] [134].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 2 * 104`\n  * `1 <= nums[i] k <= nums.length`\n\n,class Solution:\n    def subarraysWithKDistinct(self nums: List[int] k: int) -> int:\n        return self.lengthOfLongestSubstringKDistinct(nums k) - self.lengthOfLongestSubstringKDistinct(nums k-1)\n    \n    def lengthOfLongestSubstringKDistinct(self s k):\n        n = len(s)\n        if n * k == 0:\n            return 0\n        left = 0\n\n        hashmap = collections.OrderedDict()\n\n        subarray = 0\n        for right in range(n):\n            if s[right] in hashmap:\n                del hashmap[s[right]]\n            hashmap[s[right]] = right\n\n            if len(hashmap) == k + 1:\n                _ del_idx = hashmap.popitem(last = False)\n                left = del_idx + 1\n            subarray += right - left + 1\n\n        return subarray\n    \n    \n            \n
Subdomain Visit Count,"###  811\. Subdomain Visit Count\n\nA website domain `""discuss.leetcode.com""` consists of various subdomains. At\nthe top level we have `""com""` at the next level we have `""leetcode.com""`\nand at the lowest level `""discuss.leetcode.com""`. When we visit a domain like\n`""discuss.leetcode.com""` we will also visit the parent domains\n`""leetcode.com""` and `""com""` implicitly.\n\nA **count-paired domain** is a domain that has one of the two formats `""rep\nd1.d2.d3""` or `""rep d1.d2""` where `rep` is the number of visits to the domain\nand `d1.d2.d3` is the domain itself.\n\n  * For example `""9001 discuss.leetcode.com""` is a **count-paired domain** that indicates that `discuss.leetcode.com` was visited `9001` times.\n\nGiven an array of **count-paired domains** `cpdomains` return _an array of\nthe**count-paired domains** of each subdomain in the input_. You may return\nthe answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** cpdomains = [""9001 discuss.leetcode.com""]\n    **Output:** [""9001 leetcode.com""""9001 discuss.leetcode.com""""9001 com""]\n    **Explanation:** We only have one website domain: ""discuss.leetcode.com"".\n    As discussed above the subdomain ""leetcode.com"" and ""com"" will also be visited. So they will all be visited 9001 times.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** cpdomains = [""900 google.mail.com"" ""50 yahoo.com"" ""1 intel.mail.com"" ""5 wiki.org""]\n    **Output:** [""901 mail.com""""50 yahoo.com""""900 google.mail.com""""5 wiki.org""""5 org""""1 intel.mail.com""""951 com""]\n    **Explanation:** We will visit ""google.mail.com"" 900 times ""yahoo.com"" 50 times ""intel.mail.com"" once and ""wiki.org"" 5 times.\n    For the subdomains we will visit ""mail.com"" 900 + 1 = 901 times ""com"" 900 + 50 + 1 = 951 times and ""org"" 5 times.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= cpdomain.length <= 100`\n  * `1 <= cpdomain[i].length <= 100`\n  * `cpdomain[i]` follows either the `""repi d1i.d2i.d3i""` format or the `""repi d1i.d2i""` format.\n  * `repi` is an integer in the range `[1 104]`.\n  * `d1i` `d2i` and `d3i` consist of lowercase English letters.\n\n",class Solution:\n    def subdomainVisits(self cpdomains: List[str]) -> List[str]:\n        output ans = {} []\n        for domain in cpdomains : \n            number domain = domain.split(' ')\n            sub_domain = domain.split('.')\n            pair = ''\n            print(sub_domain)\n            for i in reversed(range(len(sub_domain))) :\n                if i == len(sub_domain)-1 : \n                    pair += sub_domain[i]\n                else : \n                    pair = sub_domain[i] +'.'+ pair \n                print(pair)\n                \n                # output.append(str(number) + ' '+pair)\n                if pair not in output.keys() : \n                    output[pair] = int(number)\n                else : \n                    output[pair] += int(number)\n                    \n        for key in output.keys() : \n            ans.append(str(output[key]) + ' '+key)\n                \n        return ans\n
Subrectangle Queries,"###  1476\. Subrectangle Queries\n\nImplement the class `SubrectangleQueries` which receives a `rows x cols`\nrectangle as a matrix of integers in the constructor and supports two methods:\n\n1.` updateSubrectangle(int row1 int col1 int row2 int col2 int newValue)`\n\n  * Updates all values with `newValue` in the subrectangle whose upper left coordinate is `(row1col1)` and bottom right coordinate is `(row2col2)`.\n\n2.` getValue(int row int col)`\n\n  * Returns the current value of the coordinate `(rowcol)` from the rectangle.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""SubrectangleQueries""""getValue""""updateSubrectangle""""getValue""""getValue""""updateSubrectangle""""getValue""""getValue""]\n    [[[[121][434][321][111]]][02][00325][02][31][303210][31][02]]\n    **Output**\n    [null1null55null105]\n    **Explanation**\n    SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[121][434][321][111]]);  \n    // The initial rectangle (4x3) looks like:\n    // 1 2 1\n    // 4 3 4\n    // 3 2 1\n    // 1 1 1\n    subrectangleQueries.getValue(0 2); // return 1\n    subrectangleQueries.updateSubrectangle(0 0 3 2 5);\n    // After this update the rectangle looks like:\n    // 5 5 5\n    // 5 5 5\n    // 5 5 5\n    // 5 5 5 \n    subrectangleQueries.getValue(0 2); // return 5\n    subrectangleQueries.getValue(3 1); // return 5\n    subrectangleQueries.updateSubrectangle(3 0 3 2 10);\n    // After this update the rectangle looks like:\n    // 5   5   5\n    // 5   5   5\n    // 5   5   5\n    // 10  10  10 \n    subrectangleQueries.getValue(3 1); // return 10\n    subrectangleQueries.getValue(0 2); // return 5\n    \n\n**Example 2:**\n\n    \n    \n    **Input**\n    [""SubrectangleQueries""""getValue""""updateSubrectangle""""getValue""""getValue""""updateSubrectangle""""getValue""]\n    [[[[111][222][333]]][00][0022100][00][22][112220][22]]\n    **Output**\n    [null1null100100null20]\n    **Explanation**\n    SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[111][222][333]]);\n    subrectangleQueries.getValue(0 0); // return 1\n    subrectangleQueries.updateSubrectangle(0 0 2 2 100);\n    subrectangleQueries.getValue(0 0); // return 100\n    subrectangleQueries.getValue(2 2); // return 100\n    subrectangleQueries.updateSubrectangle(1 1 2 2 20);\n    subrectangleQueries.getValue(2 2); // return 20\n    \n\n\n\n**Constraints:**\n\n  * There will be at most `500` operations considering both methods: `updateSubrectangle` and `getValue`.\n  * `1 <= rows cols <= 100`\n  * `rows == rectangle.length`\n  * `cols == rectangle[i].length`\n  * `0 <= row1 <= row2 < rows`\n  * `0 <= col1 <= col2 < cols`\n  * `1 <= newValue rectangle[i][j] <= 10^9`\n  * `0 <= row < rows`\n  * `0 <= col < cols`\n\n",class SubrectangleQueries:\n\n    def __init__(self rectangle: List[List[int]]):\n        self.rectangle = rectangle\n\n    def updateSubrectangle(self row1: int col1: int row2: int col2: int newValue: int) -> None:\n        for i in range(row1row2+1):\n            for j in range(col1col2+1):\n                self.rectangle[i][j] = newValue\n                \n    def getValue(self row: int col: int) -> int:\n        return self.rectangle[row][col]\n
Subsets II,###  90\. Subsets II\n\nGiven an integer array `nums` that may contain duplicates return _all\npossible subsets (the power set)_.\n\nThe solution set **must not** contain duplicate subsets. Return the solution\nin **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [122]\n    **Output:** [[][1][12][122][2][22]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0]\n    **Output:** [[][0]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 10`\n  * `-10 <= nums[i] <= 10`\n\n,class Solution:\n    def subsetsWithDup(self nums: List[int]) -> List[List[int]]:\n        ans = []\n        nums.sort()\n        def subset(p up):\n            if len(up) == 0:\n                if p not in ans:\n                    ans.append(p)\n                return \n            ch = up[0]\n            subset(p+[ch] up[1:])\n            subset(p up[1:])\n        subset([] nums)\n        return ans
Substring with Concatenation of All Words,"###  30\. Substring with Concatenation of All Words\n\nYou are given a string `s` and an array of strings `words`. All the strings of\n`words` are of **the same length**.\n\nA **concatenated substring** in `s` is a substring that contains all the\nstrings of any permutation of `words` concatenated.\n\n  * For example if `words = [""ab""""cd""""ef""]` then `""abcdef""` `""abefcd""` `""cdabef""` `""cdefab""` `""efabcd""` and `""efcdab""` are all concatenated strings. `""acdbef""` is not a concatenated substring because it is not the concatenation of any permutation of `words`.\n\nReturn _the starting indices of all the concatenated substrings in_`s`. You\ncan return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""barfoothefoobarman"" words = [""foo""""bar""]\n    **Output:** [09]\n    **Explanation:** Since words.length == 2 and words[i].length == 3 the concatenated substring has to be of length 6.\n    The substring starting at 0 is ""barfoo"". It is the concatenation of [""bar""""foo""] which is a permutation of words.\n    The substring starting at 9 is ""foobar"". It is the concatenation of [""foo""""bar""] which is a permutation of words.\n    The output order does not matter. Returning [90] is fine too.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""wordgoodgoodgoodbestword"" words = [""word""""good""""best""""word""]\n    **Output:** []\n    **Explanation:** Since words.length == 4 and words[i].length == 4 the concatenated substring has to be of length 16.\n    There is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\n    We return an empty array.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""barfoofoobarthefoobarman"" words = [""bar""""foo""""the""]\n    **Output:** [6912]\n    **Explanation:** Since words.length == 3 and words[i].length == 3 the concatenated substring has to be of length 9.\n    The substring starting at 6 is ""foobarthe"". It is the concatenation of [""foo""""bar""""the""] which is a permutation of words.\n    The substring starting at 9 is ""barthefoo"". It is the concatenation of [""bar""""the""""foo""] which is a permutation of words.\n    The substring starting at 12 is ""thefoobar"". It is the concatenation of [""the""""foo""""bar""] which is a permutation of words.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `1 <= words.length <= 5000`\n  * `1 <= words[i].length <= 30`\n  * `s` and `words[i]` consist of lowercase English letters.\n\n",# Runtime: 1522 ms (Top 17.46%) | Memory: 14.2 MB (Top 76.15%)\nclass Solution:\n    def findSubstring(self s: str words: List[str]) -> List[int]:\n        req={}\n        for i in words:\n            req[i]=1+req.get(i0)\n        l=0\n        r=len(words)*len(words[0])\n        ans=[]\n\n        while r<len(s)+1:\n            i=0\n            curr={}\n            left right= l l+len(words[0])\n            while right<l+len(words)*len(words[0])+1:\n                x=s[left:right]\n                # print(x)\n                if x in req.keys():\n                    curr[x]= 1+ curr.get(x0)\n                left=right\n                right=right+len(words[0])\n            if req==curr:\n                ans.append(l)\n            l=l+1\n            r=r+1\n        return ans
Substring With Largest Variance,"###  2272\. Substring With Largest Variance\n\nThe **variance** of a string is defined as the largest difference between the\nnumber of occurrences of **any** `2` characters present in the string. Note\nthe two characters may or may not be the same.\n\nGiven a string `s` consisting of lowercase English letters only return\n_the**largest variance** possible among all **substrings** of_ `s`.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aababbb""\n    **Output:** 3\n    **Explanation:**\n    All possible variances along with their respective substrings are listed below:\n    - Variance 0 for substrings ""a"" ""aa"" ""ab"" ""abab"" ""aababb"" ""ba"" ""b"" ""bb"" and ""bbb"".\n    - Variance 1 for substrings ""aab"" ""aba"" ""abb"" ""aabab"" ""ababb"" ""aababbb"" and ""bab"".\n    - Variance 2 for substrings ""aaba"" ""ababbb"" ""abbb"" and ""babb"".\n    - Variance 3 for substring ""babbb"".\n    Since the largest possible variance is 3 we return it.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abcde""\n    **Output:** 0\n    **Explanation:**\n    No letter occurs more than once in s so the variance of every substring is 0.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `s` consists of lowercase English letters.\n\n",class Solution:\n    class Solution:\n    def largestVariance(self s: str) -> int:\n        \n        def maxSubArray(nums: List[int]):\n            ans=-float('inf')\n            runningSum=0\n            seen=False\n            for x in (nums):\n                if x<0:\n                    seen=True\n                runningSum+=x\n                if seen:\n                    ans=max(ansrunningSum)\n                else:\n                    ans=max(ansrunningSum-1)\n                if runningSum<0:\n                    runningSum=0\n                    seen=False\n            return ans\n        \n        f=set()\n        a=''\n        for x in s:\n            if x not in f:\n                a+=x\n                f.add(x)\n       \n        n=len(s)\n        res=0\n        for j in range(len(a)-1):\n            for k in range(j+1len(a)):\n                x=a[j]\n                y=a[k]\n                arr=[]\n                for i in range(n):\n                    if s[i]!=x and s[i]!=y:\n                        continue\n                    elif s[i]==x:\n                        arr.append(1)\n                    else:\n                        arr.append(-1)\n                \n                res=max(resmaxSubArray(arr)maxSubArray([-x for x in arr]))\n                \n        return res\n                \n                \n                \n                \n\n
Subtree of Another Tree,###  572\. Subtree of Another Tree\n\nGiven the roots of two binary trees `root` and `subRoot` return `true` if\nthere is a subtree of `root` with the same structure and node values of`\nsubRoot` and `false` otherwise.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in `tree`\nand all of this node's descendants. The tree `tree` could also be considered\nas a subtree of itself.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg)\n\n    \n    \n    **Input:** root = [34512] subRoot = [412]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/28/subtree2-tree.jpg)\n\n    \n    \n    **Input:** root = [34512nullnullnullnull0] subRoot = [412]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the `root` tree is in the range `[1 2000]`.\n  * The number of nodes in the `subRoot` tree is in the range `[1 1000]`.\n  * `-104 <= root.val <= 104`\n  * `-104 <= subRoot.val <= 104`\n\n,class Solution:\n    def isSubtree(self root: Optional[TreeNode] subRoot: Optional[TreeNode]) -> bool:\n        if subRoot == None:\n            return True\n        if root == None:\n            return False\n        \n        sameTree = self.isSameTree(root subRoot)\n        subTreeOnLeft = self.isSubtree(root.left subRoot)\n        subTreeOnRight = self.isSubtree(root.right subRoot)\n        \n        return subTreeOnLeft or subTreeOnRight or sameTree\n        \n    def isSameTree(self root: Optional[TreeNode] subRoot: Optional[TreeNode]) -> bool:\n        if (root == None and subRoot == None):\n            return True\n        \n        if (root == None or subRoot == None):\n            return False\n        \n        if (root.val != subRoot.val):\n            return False\n        \n        return self.isSameTree(root.left subRoot.left) and self.isSameTree(root.right subRoot.right)\n
Successful Pairs of Spells and Potions,###  2300\. Successful Pairs of Spells and Potions\n\nYou are given two positive integer arrays `spells` and `potions` of length\n`n` and `m` respectively where `spells[i]` represents the strength of the\n`ith` spell and `potions[j]` represents the strength of the `jth` potion.\n\nYou are also given an integer `success`. A spell and potion pair is considered\n**successful** if the **product** of their strengths is **at least**\n`success`.\n\nReturn _an integer array_`pairs` _of length_`n` _where_`pairs[i]`_is the\nnumber of**potions** that will form a successful pair with the _`ith` _spell._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** spells = [513] potions = [12345] success = 7\n    **Output:** [403]\n    **Explanation:**\n    - 0th spell: 5 * [12345] = [5_**10**_ _**15**_ _**20**_ _**25**_]. 4 pairs are successful.\n    - 1st spell: 1 * [12345] = [12345]. 0 pairs are successful.\n    - 2nd spell: 3 * [12345] = [36_**9**_ _**12**_ _**15**_]. 3 pairs are successful.\n    Thus [403] is returned.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** spells = [312] potions = [858] success = 16\n    **Output:** [202]\n    **Explanation:**\n    - 0th spell: 3 * [858] = [_**24**_ 15_**24**_]. 2 pairs are successful.\n    - 1st spell: 1 * [858] = [858]. 0 pairs are successful. \n    - 2nd spell: 2 * [858] = [**_16_** 10_**16**_]. 2 pairs are successful. \n    Thus [202] is returned.\n    \n\n\n\n**Constraints:**\n\n  * `n == spells.length`\n  * `m == potions.length`\n  * `1 <= n m <= 105`\n  * `1 <= spells[i] potions[i] <= 105`\n  * `1 <= success <= 1010`\n\n,# Runtime: 3070 ms (Top 29.46%) | Memory: 37.4 MB (Top 40.00%)\nclass Solution:\n    def successfulPairs(self spells: List[int] potions: List[int] success: int) -> List[int]:\n        result = self.function(spellspotionssuccess)\n        return result\n\n    def function(selfarr1arr2success):\n        n2 = len(arr2)\n        arr2.sort() #Sorting Enables Us To Do Binary Search\n        ans = []\n        for i in arr1:\n            val = math.ceil(success/i) #Finding the Value Of Portion With Least Strength So That It Can Be Greater Than Success\n            idx = bisect.bisect_left(arr2val) #Finding The Left Most Index So That The Value Can Be Inserted\n            res = n2-idx+1 #Calculating the remaining numbers after finding the suitable index\n            ans.append(res-1)\n        return ans
Sudoku Solver,"###  37\. Sudoku Solver\n\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy **all of the following rules** :\n\n  1. Each of the digits `1-9` must occur exactly once in each row.\n  2. Each of the digits `1-9` must occur exactly once in each column.\n  3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe `'.'` character indicates empty cells.\n\n\n\n**Example 1:**\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-\nby-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)\n\n    \n    \n    **Input:** board = [[""5""""3""""."""".""""7""""."""".""""."""".""][""6""""."""".""""1""""9""""5"""".""""."""".""]["".""""9""""8""""."""".""""."""".""""6"""".""][""8"""".""""."""".""""6"""".""""."""".""""3""][""4""""."""".""""8"""".""""3""""."""".""""1""][""7"""".""""."""".""""2"""".""""."""".""""6""]["".""""6""""."""".""""."""".""""2""""8"""".""]["".""""."""".""""4""""1""""9""""."""".""""5""][""."""".""""."""".""""8""""."""".""""7""""9""]]\n    **Output:** [[""5""""3""""4""""6""""7""""8""""9""""1""""2""][""6""""7""""2""""1""""9""""5""""3""""4""""8""][""1""""9""""8""""3""""4""""2""""5""""6""""7""][""8""""5""""9""""7""""6""""1""""4""""2""""3""][""4""""2""""6""""8""""5""""3""""7""""9""""1""][""7""""1""""3""""9""""2""""4""""8""""5""""6""][""9""""6""""1""""5""""3""""7""""2""""8""""4""][""2""""8""""7""""4""""1""""9""""6""""3""""5""][""3""""4""""5""""2""""8""""6""""1""""7""""9""]]\n    **Explanation:**  The input board is shown above and the only valid solution is shown below:\n    \n    ![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png)\n    \n\n\n\n**Constraints:**\n\n  * `board.length == 9`\n  * `board[i].length == 9`\n  * `board[i][j]` is a digit or `'.'`.\n  * It is **guaranteed** that the input board has only one solution.\n\n","class Solution:\n    def solveSudoku(self board: List[List[str]]) -> None:\n        """"""\n        Do not return anything modify board in-place instead.\n        """"""\n        full = set('123456789')\n		# lets keep rows columns and boxes sets in hashmaps\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [[set() for _ in range(3)] for _ in range(3)]\n		# and remember empty cell to fill them in\n        empty = set()\n\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    empty.add((ij))\n                    continue\n                rows[i].add(board[i][j])\n                cols[j].add(board[i][j])\n                boxes[i//3][j//3].add(board[i][j])\n                \n        def options(i j):\n			""""""returns possible options for ij intersecting options from row col and box""""""\n            return (\n                (full - rows[i]) &\n                (full - cols[j]) &\n                (full - boxes[i//3][j//3])\n            )\n\n        psingle = True # did we have single option decisions in previos traverse\n        while empty:\n            single = False # for single option decisions in this traverse\n            \n            for i j in deepcopy(empty):\n                opts = options(i j)\n                if len(opts) == 0:\n					# we've made a wrong assumption - sudoku is unsolvable\n                    return None None\n                elif len(opts) == 2 and not psingle: # we have no single-option decisions so have to take an assumption\n                    board1 = deepcopy(board)\n                    board1[i][j] = opts.pop()\n                    board1 empty1 = self.solveSudoku(board1)\n                    if board1 != None: # if solved - we're done\n                        empty = empty1\n                        for i b1 in enumerate(board1):\n                            board[i] = b1 # have to modify initial list not just replace the reference\n                        return board empty\n                if len(opts) == 1: # hey we have a predetermined choice. nice\n                    single = True\n                    board[i][j] = opts.pop()\n                    empty.remove((i j))\n                    rows[i].add(board[i][j])\n                    cols[j].add(board[i][j])\n                    boxes[i//3][j//3].add(board[i][j])\n                    \n            psingle = single\n\n        return board empty\n        ```"
Sum Game,"###  1927\. Sum Game\n\nAlice and Bob take turns playing a game with **Alice****  starting first**.\n\nYou are given a string `num` of **even length** consisting of digits and `'?'`\ncharacters. On each turn a player will do the following if there is still at\nleast one `'?'` in `num`:\n\n  1. Choose an index `i` where `num[i] == '?'`.\n  2. Replace `num[i]` with any digit between `'0'` and `'9'`.\n\nThe game ends when there are no more `'?'` characters in `num`.\n\nFor Bob to win the sum of the digits in the first half of `num` must be\n**equal** to the sum of the digits in the second half. For Alice to win the\nsums must **not be equal**.\n\n  * For example if the game ended with `num = ""243801""` then Bob wins because `2+4+3 = 8+0+1`. If the game ended with `num = ""243803""` then Alice wins because `2+4+3 != 8+0+3`.\n\nAssuming Alice and Bob play **optimally**  return `true` _if Alice will win\nand_`false` _if Bob will win_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = ""5023""\n    **Output:** false\n    **Explanation:** There are no moves to be made.\n    The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = ""25??""\n    **Output:** true\n    **Explanation:** Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** num = ""?3295???""\n    **Output:** false\n    **Explanation:** It can be proven that Bob will always win. One possible outcome is:\n    - Alice replaces the first '?' with '9'. num = ""93295???"".\n    - Bob replaces one of the '?' in the right half with '9'. num = ""932959??"".\n    - Alice replaces one of the '?' in the right half with '2'. num = ""9329592?"".\n    - Bob replaces the last '?' in the right half with '7'. num = ""93295927"".\n    Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= num.length <= 105`\n  * `num.length` is **even**.\n  * `num` consists of only digits and `'?'`.\n\n",# Runtime: 173 ms (Top 90.14%) | Memory: 14.9 MB (Top 69.01%)\nclass Solution:\n    def sumGame(self num: str) -> bool:\n        n = len(num)\n        q_cnt_1 = s1 = 0\n        for i in range(n//2): # get digit sum and question mark count for the first half of `num`\n            if num[i] == '?':\n                q_cnt_1 += 1\n            else:\n                s1 += int(num[i])\n        q_cnt_2 = s2 = 0\n        for i in range(n//2 n): # get digit sum and question mark count for the second half of `num`\n            if num[i] == '?':\n                q_cnt_2 += 1\n            else:\n                s2 += int(num[i])\n        s_diff = s1 - s2 # calculate sum difference and question mark difference\n        q_diff = q_cnt_2 - q_cnt_1\n        return not (q_diff % 2 == 0 and q_diff // 2 * 9 == s_diff) # When Bob can't win Alice wins
Sum of All Odd Length Subarrays,###  1588\. Sum of All Odd Length Subarrays\n\nGiven an array of positive integers `arr` return _the sum of all\npossible**odd-length subarrays** of _`arr`.\n\nA **subarray** is a contiguous subsequence of the array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [14253]\n    **Output:** 58\n    **Explanation:** The odd-length subarrays of arr and their sums are:\n    [1] = 1\n    [4] = 4\n    [2] = 2\n    [5] = 5\n    [3] = 3\n    [142] = 7\n    [425] = 11\n    [253] = 10\n    [14253] = 15\n    If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [12]\n    **Output:** 3\n    **Explanation:** There are only 2 subarrays of odd length [1] and [2]. Their sum is 3.\n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [101112]\n    **Output:** 66\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 100`\n  * `1 <= arr[i] <= 1000`\n\n\n\n**Follow up:**\n\nCould you solve this problem in O(n) time complexity?\n\n,// Runtime: 33 ms (Top 98.51%) | Memory: 16.50 MB (Top 56.37%)\n\nclass Solution:\n    def sumOddLengthSubarrays(self arr: List[int]) -> int:\n        \n        length = len(arr)\n        ans = 0\n        \n        for i in range(length) :\n            ans += ((i+1)*(length-i)+1)//2 * arr[i]\n        return ans;\n
Sum of All Subset XOR Totals,###  1863\. Sum of All Subset XOR Totals\n\nThe **XOR total** of an array is defined as the bitwise `XOR` of**all its\nelements**  or `0` if the array is**empty**.\n\n  * For example the **XOR total** of the array `[256]` is `2 XOR 5 XOR 6 = 1`.\n\nGiven an array `nums` return _the**sum** of all **XOR totals** for every\n**subset** of _`nums`.\n\n**Note:** Subsets with the **same** elements should be counted **multiple**\ntimes.\n\nAn array `a` is a **subset** of an array `b` if `a` can be obtained from `b`\nby deleting some (possibly zero) elements of `b`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [13]\n    **Output:** 6\n    **Explanation:** The 4 subsets of [13] are:\n    - The empty subset has an XOR total of 0.\n    - [1] has an XOR total of 1.\n    - [3] has an XOR total of 3.\n    - [13] has an XOR total of 1 XOR 3 = 2.\n    0 + 1 + 3 + 2 = 6\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [516]\n    **Output:** 28\n    **Explanation:** The 8 subsets of [516] are:\n    - The empty subset has an XOR total of 0.\n    - [5] has an XOR total of 5.\n    - [1] has an XOR total of 1.\n    - [6] has an XOR total of 6.\n    - [51] has an XOR total of 5 XOR 1 = 4.\n    - [56] has an XOR total of 5 XOR 6 = 3.\n    - [16] has an XOR total of 1 XOR 6 = 7.\n    - [516] has an XOR total of 5 XOR 1 XOR 6 = 2.\n    0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [345678]\n    **Output:** 480\n    **Explanation:** The sum of all XOR totals for every subset is 480.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 12`\n  * `1 <= nums[i] <= 20`\n\n,# Runtime: 60 ms (Top 83.44%) | Memory: 13.8 MB (Top 70.65%)\nclass Solution:\n    def subsetXORSum(self nums: List[int]) -> int:\n        def sums(term idx):\n            if idx == len(nums):\n                return term\n            return sums(term idx + 1) + sums(term ^ nums[idx] idx + 1)\n\n        return sums(0 0)
Sum of Beauty in the Array,###  2012\. Sum of Beauty in the Array\n\nYou are given a **0-indexed** integer array `nums`. For each index `i` (`1 <=\ni <= nums.length - 2`) the **beauty** of `nums[i]` equals:\n\n  * `2` if `nums[j] < nums[i] < nums[k]` for **all** `0 <= j < i` and for **all** `i < k <= nums.length - 1`.\n  * `1` if `nums[i - 1] < nums[i] < nums[i + 1]` and the previous condition is not satisfied.\n  * `0` if none of the previous conditions holds.\n\nReturn _the**sum of beauty** of all _`nums[i]`_where_`1 <= i <= nums.length -\n2`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** 2\n    **Explanation:** For each index i in the range 1 <= i <= 1:\n    - The beauty of nums[1] equals 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2464]\n    **Output:** 1\n    **Explanation:** For each index i in the range 1 <= i <= 2:\n    - The beauty of nums[1] equals 1.\n    - The beauty of nums[2] equals 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [321]\n    **Output:** 0\n    **Explanation:** For each index i in the range 1 <= i <= 1:\n    - The beauty of nums[1] equals 0.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= nums.length <= 105`\n  * `1 <= nums[i] <= 105`\n\n,class Solution:\n    def sumOfBeauties(self nums: List[int]) -> int:\n        n = len(nums)\n        max_dp = [0] * n\n        min_dp = [float(inf)] * n\n        max_dp[0] = nums[0]\n        min_dp[-1] = nums[-1]\n        \n        for i in range(1 n):\n            max_dp[i] = max(nums[i] max_dp[i-1])\n            \n        for i in range(n-2 -1 -1):\n            min_dp[i] = min(nums[i] min_dp[i+1])\n        \n        ans = 0\n        for i in range(1 n-1):\n            if max_dp[i-1] < max_dp[i] and nums[i] < min_dp[i+1]:\n                ans += 2\n            elif nums[i-1] < nums[i] < nums[i+1]:\n                ans += 1\n        return ans\n
Sum of Beauty of All Substrings,"###  1781\. Sum of Beauty of All Substrings\n\nThe **beauty** of a string is the difference in frequencies between the most\nfrequent and least frequent characters.\n\n  * For example the beauty of `""abaacc""` is `3 - 1 = 2`.\n\nGiven a string `s` return _the sum of**beauty** of all of its substrings._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aabcb""\n    **Output:** 5\n    **Explanation:** The substrings with non-zero beauty are [""aab""""aabc""""aabcb""""abcb""""bcb""] each with beauty equal to 1.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aabcbaa""\n    **Output:** 17\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 500`\n  * `s` consists of only lowercase English letters.\n\n",class Solution:\n    def beautySum(self s: str) -> int:\n        c n ans = Counter(s) len(s) 0\n        for i in range(n-2):\n            x=c.copy()\n            for j in range(n-1i+1-1):\n                ans+=max(x.values())-min(x.values())\n                if x[s[j]]==1:\n                    del x[s[j]]\n                else:\n                    x[s[j]]-=1\n            if c[s[i]]==1:\n                del c[s[i]]\n            else:\n                c[s[i]]-=1\n        return ans\n
Sum of Digits in Base K,###  1837\. Sum of Digits in Base K\n\nGiven an integer `n` (in base `10`) and a base `k` return _the**sum** of the\ndigits of _`n` _**after** converting _`n` _from base_`10` _to base_`k`.\n\nAfter converting each digit should be interpreted as a base `10` number and\nthe sum should be returned in base `10`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 34 k = 6\n    **Output:** 9\n    **Explanation:** 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 10 k = 10\n    **Output:** 1\n    **Explanation:** n is already in base 10. 1 + 0 = 1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 100`\n  * `2 <= k <= 10`\n\n,# Runtime: 40 ms (Top 73.88%) | Memory: 13.8 MB (Top 97.86%)\nclass Solution:\n    def sumBase(self n: int k: int) -> int:\n        cnt = 0\n        while n:\n            cnt += (n % k)\n            n //= k\n        print(cnt)\n        return cnt
Sum of Even Numbers After Queries,###  985\. Sum of Even Numbers After Queries\n\nYou are given an integer array `nums` and an array `queries` where `queries[i]\n= [vali indexi]`.\n\nFor each query `i` first apply `nums[indexi] = nums[indexi] + vali` then\nprint the sum of the even values of `nums`.\n\nReturn _an integer array_`answer` _where_`answer[i]`_is the answer to\nthe_`ith` _query_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234] queries = [[10][-31][-40][23]]\n    **Output:** [8624]\n    **Explanation:** At the beginning the array is [1234].\n    After adding 1 to nums[0] the array is [2234] and the sum of even values is 2 + 2 + 4 = 8.\n    After adding -3 to nums[1] the array is [2-134] and the sum of even values is 2 + 4 = 6.\n    After adding -4 to nums[0] the array is [-2-134] and the sum of even values is -2 + 4 = 2.\n    After adding 2 to nums[3] the array is [-2-136] and the sum of even values is -2 + 6 = 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1] queries = [[40]]\n    **Output:** [0]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-104 <= nums[i] <= 104`\n  * `1 <= queries.length <= 104`\n  * `-104 <= vali <= 104`\n  * `0 <= indexi < nums.length`\n\n,# Runtime: 1565 ms (Top 5.26%) | Memory: 20.6 MB (Top 46.36%)\nclass Solution:\n# O(n) || O(1)\n# Runtime: 583ms 72.40% || memory: 20.5mb 37.69%\n    def sumEvenAfterQueries(self nums: List[int] queries: List[List[int]]) -> List[int]:\n        totalEvenNumSum = sum([num for num in nums if num % 2 == 0])\n        result = []\n\n        for val idx in queries:\n            oldVal = nums[idx]\n            nums[idx] += val\n\n            if oldVal % 2 == 0:\n                totalEvenNumSum -= oldVal\n\n            if nums[idx] % 2 == 0:\n                totalEvenNumSum += nums[idx]\n\n            result.append(totalEvenNumSum)\n\n        return result\n
Sum of Floored Pairs,###  1862\. Sum of Floored Pairs\n\nGiven an integer array `nums` return the sum of `floor(nums[i] / nums[j])`\nfor all pairs of indices `0 <= i j < nums.length` in the array. Since the\nanswer may be too large return it **modulo** `109 + 7`.\n\nThe `floor()` function returns the integer part of the division.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [259]\n    **Output:** 10\n    **Explanation:**\n    floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0\n    floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1\n    floor(5 / 2) = 2\n    floor(9 / 2) = 4\n    floor(9 / 5) = 1\n    We calculate the floor of the division for every pair of indices in the array then sum them up.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [7777777]\n    **Output:** 49\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 105`\n\n,class Solution:\n    def sumOfFlooredPairs(self nums: List[int]) -> int:\n        \n        incs counter=[0]*(max(nums)+1) Counter(nums)            # To store all the quotients increases; counter\n        for num in counter:                                       # Loop over all the divisors\n            for j in range(num len(incs) num):                  # Loop over all the possible dividends where the quotient increases\n                incs[j] += counter[num]                           # Increment the increases in quotients\n        quots=list(accumulate(incs))                              # Accumulate the increases to get the sum of quotients\n        return sum([quots[num] for num in nums]) % 1_000_000_007  # Sum up all the quotients for all the numbers in the list.\n
Sum of k-Mirror Numbers,###  2081\. Sum of k-Mirror Numbers\n\nA **k-mirror number** is a **positive** integer **without leading zeros** that\nreads the same both forward and backward in base-10 **as well as** in base-k.\n\n  * For example `9` is a 2-mirror number. The representation of `9` in base-10 and base-2 are `9` and `1001` respectively which read the same both forward and backward.\n  * On the contrary `4` is not a 2-mirror number. The representation of `4` in base-2 is `100` which does not read the same both forward and backward.\n\nGiven the base `k` and the number `n` return _the**sum** of the_ `n`\n_**smallest** k-mirror numbers_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** k = 2 n = 5\n    **Output:** 25\n    **Explanation:** The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:\n      base-10    base-2\n        1          1\n        3          11\n        5          101\n        7          111\n        9          1001\n    Their sum = 1 + 3 + 5 + 7 + 9 = 25. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** k = 3 n = 7\n    **Output:** 499\n    **Explanation:** The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:\n      base-10    base-3\n        1          1\n        2          2\n        4          11\n        8          22\n        121        11111\n        151        12121\n        212        21212\n    Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** k = 7 n = 17\n    **Output:** 20379000\n    **Explanation:** The 17 smallest 7-mirror numbers are:\n    1 2 3 4 5 6 8 121 171 242 292 16561 65656 2137312 4602064 6597956 6958596\n    \n\n\n\n**Constraints:**\n\n  * `2 <= k <= 9`\n  * `1 <= n <= 30`\n\n,"class Solution:\n    def kMirror(self k: int n: int) -> int:\n\n        def numberToBase(n b):\n            if n == 0:\n                return [0]\n            digits = []\n            while n:\n                digits.append(n % b)\n                n //= b\n            return digits[::-1]\n        \n        # not used\n        def baseToNumber(arr b):\n            ans = 0\n            for x in arr:\n                ans = ans * b + int(x)\n            return ans\n        \n        def is_mirror(s):\n            l r = 0 len(s)-1\n            while l <= r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n        \n        def gen():\n            '''\n            generate for value with different length\n            when i == 0: num：[1 10)\n            size of num: 1 2 -> 1 or 11\n            when i == 1: [10 100)\n            size of num: 3 4 -> 10 or 101\n            when i == 2: [100 1000)\n            size of num: 5 6 -> 10001 or 100001\n            \n            the num will be increasing\n            '''\n            for i in range(30):\n                for num in range(10**i 10**(i+1)):\n                    s = str(num) + str(num)[::-1][1:]\n                    yield int(s)\n                for num in range(10**i 10**(i+1)):\n                    s = str(num) + str(num)[::-1]\n                    yield int(s)\n        \n        ans = 0\n        left = n\n        for num in gen():\n            base = numberToBase(num k)\n			# if is_mirror(base):\n            if base == base[::-1]:\n                ans += num\n                left -= 1\n            if left == 0:\n                break\n\n        return ans\n"
Sum of Nodes with Even-Valued Grandparent,###  1315\. Sum of Nodes with Even-Valued Grandparent\n\nGiven the `root` of a binary tree return _the sum of values of nodes with\nan**even-valued grandparent**_. If there are no nodes with an **even-valued\ngrandparent**  return `0`.\n\nA **grandparent** of a node is the parent of its parent if it exists.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/08/10/even1-tree.jpg)\n\n    \n    \n    **Input:** root = [67827139null14nullnullnull5]\n    **Output:** 18\n    **Explanation:** The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/08/10/even2-tree.jpg)\n\n    \n    \n    **Input:** root = [1]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `1 <= Node.val <= 100`\n\n,"class Solution:\n	def sumEvenGrandparent(self root: TreeNode) -> int:\n\n		def dfs(root p gp):\n			if not root: return 0\n			if gp and gp.val%2==0:\n				return root.val + dfs(root.leftrootp)+dfs(root.rightrootp)\n			return 0 + dfs(root.leftrootp)+dfs(root.rightrootp)\n\n		return dfs(rootNoneNone)"
Sum of Root To Leaf Binary Numbers,###  1022\. Sum of Root To Leaf Binary Numbers\n\nYou are given the `root` of a binary tree where each node has a value `0` or\n`1`. Each root-to-leaf path represents a binary number starting with the most\nsignificant bit.\n\n  * For example if the path is `0 -> 1 -> 1 -> 0 -> 1` then this could represent `01101` in binary which is `13`.\n\nFor all leaves in the tree consider the numbers represented by the path from\nthe root to that leaf. Return _the sum of these numbers_.\n\nThe test cases are generated so that the answer fits in a **32-bits** integer.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-\nnumbers.png)\n\n    \n    \n    **Input:** root = [1010101]\n    **Output:** 22\n    **Explanation:**(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** root = [0]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 1000]`.\n  * `Node.val` is `0` or `1`.\n\n,"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumRootToLeaf(self root: Optional[TreeNode]) -> int:\n        def path(rootpans):\n            p.append(str(root.val))\n            if root.left==None and root.right==None:\n                t = int("""".join(p)2)\n                p.pop()\n                return t+ans\n            if root.left==None:\n                t = path(root.rightpans)\n                p.pop()\n                return t\n            if root.right==None:\n                t = path(root.leftpans)\n                p.pop()\n                return t\n            t = path(root.leftpans)+path(root.rightpans)\n            p.pop()\n            return t\n        return path(root[]0)\n"
Sum of Scores of Built Strings,"###  2223\. Sum of Scores of Built Strings\n\nYou are **building** a string `s` of length `n` **one** character at a time\n**prepending** each new character to the **front** of the string. The strings\nare labeled from `1` to `n` where the string with length `i` is labeled `si`.\n\n  * For example for `s = ""abaca""` `s1 == ""a""` `s2 == ""ca""` `s3 == ""aca""` etc.\n\nThe **score** of `si` is the length of the **longest common prefix** between\n`si` and `sn` (Note that `s == sn`).\n\nGiven the final string `s` return _the**sum** of the **score** of every\n_`si`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""babab""\n    **Output:** 9\n    **Explanation:**\n    For s1 == ""b"" the longest common prefix is ""b"" which has a score of 1.\n    For s2 == ""ab"" there is no common prefix so the score is 0.\n    For s3 == ""bab"" the longest common prefix is ""bab"" which has a score of 3.\n    For s4 == ""abab"" there is no common prefix so the score is 0.\n    For s5 == ""babab"" the longest common prefix is ""babab"" which has a score of 5.\n    The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9 so we return 9.\n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""azbazbzaz""\n    **Output:** 14\n    **Explanation:** \n    For s2 == ""az"" the longest common prefix is ""az"" which has a score of 2.\n    For s6 == ""azbzaz"" the longest common prefix is ""azb"" which has a score of 3.\n    For s9 == ""azbazbzaz"" the longest common prefix is ""azbazbzaz"" which has a score of 9.\n    For all other si the score is 0.\n    The sum of the scores is 2 + 3 + 9 = 14 so we return 14.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of lowercase English letters.\n\n",// Runtime: 200 ms (Top 85.96%) | Memory: 25.20 MB (Top 24.56%)\n\nclass Solution:\n    def sumScores(self s):\n        n = len(s)\n\n        dp ans j = [1]*n [0]*n 0 \n\n        for i in range(1n):\n            while s[i] != s[j] and j > 0:\n                j = ans[j-1]\n\n            if s[i] == s[j]:\n                dp[i] += dp[j]\n                ans[i] = j+1\n                j += 1 \n\n        return sum(dp)\n\n\n\n\n\n\n\n        \n
Sum of Square Numbers,###  633\. Sum of Square Numbers\n\nGiven a non-negative integer `c` decide whether there're two integers `a` and\n`b` such that `a2 + b2 = c`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** c = 5\n    **Output:** true\n    **Explanation:** 1 * 1 + 2 * 2 = 5\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** c = 3\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `0 <= c <= 231 - 1`\n\n,# Runtime: 669 ms (Top 21.17%) | Memory: 13.8 MB (Top 63.98%)\nimport math\n\nclass Solution:\n    def judgeSquareSum(self c: int) -> bool:\n\n        a = 0\n\n        while a ** 2 <= c:\n            b = math.sqrt(c - a ** 2)\n\n            if b.is_integer():\n                return True\n\n            a += 1\n\n        return False
Sum of Subarray Ranges,###  2104\. Sum of Subarray Ranges\n\nYou are given an integer array `nums`. The **range** of a subarray of `nums`\nis the difference between the largest and smallest element in the subarray.\n\nReturn _the**sum of all** subarray ranges of _`nums` _._\n\nA subarray is a contiguous **non-empty** sequence of elements within an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [123]\n    **Output:** 4\n    **Explanation:** The 6 subarrays of nums are the following:\n    [1] range = largest - smallest = 1 - 1 = 0 \n    [2] range = 2 - 2 = 0\n    [3] range = 3 - 3 = 0\n    [12] range = 2 - 1 = 1\n    [23] range = 3 - 2 = 1\n    [123] range = 3 - 1 = 2\n    So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.\n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [133]\n    **Output:** 4\n    **Explanation:** The 6 subarrays of nums are the following:\n    [1] range = largest - smallest = 1 - 1 = 0\n    [3] range = 3 - 3 = 0\n    [3] range = 3 - 3 = 0\n    [13] range = 3 - 1 = 2\n    [33] range = 3 - 3 = 0\n    [133] range = 3 - 1 = 2\n    So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [4-2-341]\n    **Output:** 59\n    **Explanation:** The sum of all subarray ranges of nums is 59.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `-109 <= nums[i] <= 109`\n\n\n\n**Follow-up:** Could you find a solution with `O(n)` time complexity?\n\n,"\nclass Solution:\n    def subArrayRanges(self nums: List[int]) -> int:\n        n = len(nums)\n        \n        # the answer will be sum{ Max(subarray) - Min(subarray) } over all possible subarray\n        # which decomposes to sum{Max(subarray)} - sum{Min(subarray)} over all possible subarray\n        # so totalsum = maxsum - minsum\n        # we calculate minsum and maxsum in two different loops\n        minsum = maxsum = 0\n        \n        # first calculate sum{ Min(subarray) } over all subarrays\n        # sum{ Min(subarray) } = sum(f(i) * nums[i]) ; i=0..n-1\n        # where f(i) is number of subarrays where nums[i] is the minimum value\n        # f(i) = (i - index of the previous smaller value) * (index of the next smaller value - i) * nums[i]\n        # we can claculate these indices in linear time using a monotonically increasing stack.\n        stack = []\n        for next_smaller in range(n + 1):\n			# we pop from the stack in order to satisfy the monotonically increasing order property\n			# if we reach the end of the iteration and there are elements present in the stack we pop all of them\n            while stack and (next_smaller == n or nums[stack[-1]] > nums[next_smaller]):\n                i = stack.pop()\n                prev_smaller = stack[-1] if stack else -1\n                minsum += nums[i] * (next_smaller - i) * (i - prev_smaller)\n            stack.append(next_smaller)\n            \n        # then calculate sum{ Max(subarray) } over all subarrays\n        # sum{ Max(subarray) } = sum(f'(i) * nums[i]) ; i=0..n-1\n        # where f'(i) is number of subarrays where nums[i] is the maximum value\n        # f'(i) = (i - index of the previous larger value) - (index of the next larger value - i) * nums[i]\n        # this time we use a monotonically decreasing stack.\n        stack = []\n        for next_larger in range(n + 1):\n			# we pop from the stack in order to satisfy the monotonically decreasing order property\n			# if we reach the end of the iteration and there are elements present in the stack we pop all of them\n            while stack and (next_larger == n or nums[stack[-1]] < nums[next_larger]):\n                i = stack.pop()\n                prev_larger = stack[-1] if stack else -1\n                maxsum += nums[i] * (next_larger - i) * (i - prev_larger)\n            stack.append(next_larger)\n        \n        return maxsum - minsum\n"
Sum of Subsequence Widths,###  891\. Sum of Subsequence Widths\n\nThe **width** of a sequence is the difference between the maximum and minimum\nelements in the sequence.\n\nGiven an array of integers `nums` return _the sum of the**widths** of all the\nnon-empty **subsequences** of _`nums`. Since the answer may be very large\nreturn it **modulo** `109 + 7`.\n\nA **subsequence** is a sequence that can be derived from an array by deleting\nsome or no elements without changing the order of the remaining elements. For\nexample `[3627]` is a subsequence of the array `[0316227]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [213]\n    **Output:** 6\n    Explanation: The subsequences are [1] [2] [3] [21] [23] [13] [213].\n    The corresponding widths are 0 0 0 1 1 2 2.\n    The sum of these widths is 6.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [2]\n    **Output:** 0\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 105`\n\n,class Solution:\n    def sumSubseqWidths(self nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        M = 10**9+7\n        res = 0\n        le = 1\n        re = pow(2 n-1 M)\n        #by Fermat's Little Thm\n        #inverse of 2 modulo M\n        inv = pow(2 M-2 M)\n        for num in nums:\n            res = (res + num * (le - re))%M\n            le = (le * 2) % M\n            re = (re * inv) % M\n        return res
Sum of Total Strength of Wizards,###  2281\. Sum of Total Strength of Wizards\n\nAs the ruler of a kingdom you have an army of wizards at your command.\n\nYou are given a **0-indexed** integer array `strength` where `strength[i]`\ndenotes the strength of the `ith` wizard. For a **contiguous** group of\nwizards (i.e. the wizards' strengths form a **subarray** of `strength`) the\n**total strength** is defined as the **product** of the following two values:\n\n  * The strength of the **weakest** wizard in the group.\n  * The **total** of all the individual strengths of the wizards in the group.\n\nReturn _the**sum** of the total strengths of **all** contiguous groups of\nwizards_. Since the answer may be very large return it **modulo** `109 + 7`.\n\nA **subarray** is a contiguous **non-empty** sequence of elements within an\narray.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** strength = [1312]\n    **Output:** 44\n    **Explanation:** The following are all the contiguous groups of wizards:\n    - [1] from [_**1**_ 312] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n    - [3] from [1_**3**_ 12] has a total strength of min([3]) * sum([3]) = 3 * 3 = 9\n    - [1] from [13_**1**_ 2] has a total strength of min([1]) * sum([1]) = 1 * 1 = 1\n    - [2] from [131_**2**_] has a total strength of min([2]) * sum([2]) = 2 * 2 = 4\n    - [13] from [_**13**_ 12] has a total strength of min([13]) * sum([13]) = 1 * 4 = 4\n    - [31] from [1_**31**_ 2] has a total strength of min([31]) * sum([31]) = 1 * 4 = 4\n    - [12] from [13_**12**_] has a total strength of min([12]) * sum([12]) = 1 * 3 = 3\n    - [131] from [_**131**_ 2] has a total strength of min([131]) * sum([131]) = 1 * 5 = 5\n    - [312] from [1_**312**_] has a total strength of min([312]) * sum([312]) = 1 * 6 = 6\n    - [1312] from [_**1312**_] has a total strength of min([1312]) * sum([1312]) = 1 * 7 = 7\n    The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** strength = [546]\n    **Output:** 213\n    **Explanation:** The following are all the contiguous groups of wizards: \n    - [5] from [_**5**_ 46] has a total strength of min([5]) * sum([5]) = 5 * 5 = 25\n    - [4] from [5_**4**_ 6] has a total strength of min([4]) * sum([4]) = 4 * 4 = 16\n    - [6] from [54_**6**_] has a total strength of min([6]) * sum([6]) = 6 * 6 = 36\n    - [54] from [_**54**_ 6] has a total strength of min([54]) * sum([54]) = 4 * 9 = 36\n    - [46] from [5_**46**_] has a total strength of min([46]) * sum([46]) = 4 * 10 = 40\n    - [546] from [_**546**_] has a total strength of min([546]) * sum([546]) = 4 * 15 = 60\n    The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= strength.length <= 105`\n  * `1 <= strength[i] <= 109`\n\n,class Solution:\n    def totalStrength(self stp: List[int]) -> int:\n        st = []\n        n = len(stp)\n        m1 = defaultdict(lambda:-1)\n        ps = [0]\n        for i in range(n):\n            while st and stp[st[-1]] >= stp[i]:\n                st.pop()\n            if st: m1[i] = st[-1]\n            st.append(i)\n            ps.append(ps[-1] + stp[i])\n        pss = [0]\n        for i in ps:\n            pss.append(pss[-1] + i)\n        st = []\n        m2 = defaultdict(lambda:n)\n        for i in range(n-1-1-1):\n            while st and stp[st[-1]] > stp[i]:\n                st.pop()\n            if st: m2[i] = st[-1]\n            st.append(i)\n\n        ans = 0\n        mod = 10**9 + 7\n        for i in range(n):\n            left = m1[i] + 1\n            right = m2[i]\n            p1 = (i+1-left)*(pss[right+1]-pss[i+1])\n            p2 = (right-i)*(pss[i+1]- pss[left])\n            ans = (ans + stp[i]*(p1 - p2)) % mod\n        return ans\n
Sum of Two Integers,###  371\. Sum of Two Integers\n\nGiven two integers `a` and `b` return _the sum of the two integers without\nusing the operators_ `+` _and_ `-`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** a = 1 b = 2\n    **Output:** 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** a = 2 b = 3\n    **Output:** 5\n    \n\n\n\n**Constraints:**\n\n  * `-1000 <= a b <= 1000`\n\n,"class Solution(object):\n    def getSum(self a b):\n        """"""\n        :type a: int\n        :type b: int\n        :rtype: int\n        """"""\n        sol=(ab)\n        return sum(sol)\n	```"
Sum of Unique Elements,###  1748\. Sum of Unique Elements\n\nYou are given an integer array `nums`. The unique elements of an array are the\nelements that appear **exactly once** in the array.\n\nReturn _the**sum** of all the unique elements of _`nums`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1232]\n    **Output:** 4\n    **Explanation:** The unique elements are [13] and the sum is 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [11111]\n    **Output:** 0\n    **Explanation:** There are no unique elements and the sum is 0.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [12345]\n    **Output:** 15\n    **Explanation:** The unique elements are [12345] and the sum is 15.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 100`\n  * `1 <= nums[i] <= 100`\n\n,class Solution:\n    def sumOfUnique(self nums: List[int]) -> int:\n        hashmap = {}\n        for i in nums:\n            if i in hashmap.keys():\n                hashmap[i] += 1\n            else:\n                hashmap[i] = 1\n        sum = 0\n        for k v in hashmap.items():\n            if v == 1: sum += k\n        return sum\n
Sum Root to Leaf Numbers,###  129\. Sum Root to Leaf Numbers\n\nYou are given the `root` of a binary tree containing digits from `0` to `9`\nonly.\n\nEach root-to-leaf path in the tree represents a number.\n\n  * For example the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.\n\nReturn _the total sum of all root-to-leaf numbers_. Test cases are generated\nso that the answer will fit in a **32-bit** integer.\n\nA **leaf** node is a node with no children.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)\n\n    \n    \n    **Input:** root = [123]\n    **Output:** 25\n    **Explanation:**\n    The root-to-leaf path 1->2 represents the number 12.\n    The root-to-leaf path 1->3 represents the number 13.\n    Therefore sum = 12 + 13 = 25.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)\n\n    \n    \n    **Input:** root = [49051]\n    **Output:** 1026\n    **Explanation:**\n    The root-to-leaf path 4->9->5 represents the number 495.\n    The root-to-leaf path 4->9->1 represents the number 491.\n    The root-to-leaf path 4->0 represents the number 40.\n    Therefore sum = 495 + 491 + 40 = 1026.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 1000]`.\n  * `0 <= Node.val <= 9`\n  * The depth of the tree will not exceed `10`.\n\n,"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self root: Optional[TreeNode]) -> int:\n        \n        int_list = []\n        \n        def traverse(node input_string):\n            \n            nonlocal int_list\n            \n            if not node:\n                return int_list\n            \n            input_string = input_string + str(node.val)\n\n            if not (node.left or node.right):\n                int_list.append(int(input_string))\n            \n            traverse(node.left input_string)\n            traverse(node.right input_string)\n                \n        traverse(root """")\n        return sum(int_list)\n                \n"
Summary Ranges,"###  228\. Summary Ranges\n\nYou are given a **sorted unique** integer array `nums`.\n\nA **range** `[ab]` is the set of all integers from `a` to `b` (inclusive).\n\nReturn _the**smallest sorted** list of ranges that **cover all the numbers in\nthe array exactly**_. That is each element of `nums` is covered by exactly\none of the ranges and there is no integer `x` such that `x` is in one of the\nranges but not in `nums`.\n\nEach range `[ab]` in the list should be output as:\n\n  * `""a->b""` if `a != b`\n  * `""a""` if `a == b`\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [012457]\n    **Output:** [""0->2""""4->5""""7""]\n    **Explanation:** The ranges are:\n    [02] --> ""0->2""\n    [45] --> ""4->5""\n    [77] --> ""7""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [0234689]\n    **Output:** [""0""""2->4""""6""""8->9""]\n    **Explanation:** The ranges are:\n    [00] --> ""0""\n    [24] --> ""2->4""\n    [66] --> ""6""\n    [89] --> ""8->9""\n    \n\n\n\n**Constraints:**\n\n  * `0 <= nums.length <= 20`\n  * `-231 <= nums[i] <= 231 - 1`\n  * All the values of `nums` are **unique**.\n  * `nums` is sorted in ascending order.\n\n",# Runtime: 38 ms (Top 76.97%) | Memory: 13.8 MB (Top 98.42%)\n\nclass Solution(object):\n    def summaryRanges(self nums):\n\n        if len(nums) == 0:\n            return []\n\n        l r = 0 0\n        res = []\n\n        while l<=r and r <= len(nums):\n\n            if r == 0:\n                r+=1\n\n            while r < len(nums) and r>0 and nums[r-1] == nums[r]-1:\n                r+=1\n\n            if r-1 == l:\n                    res.append(str(nums[r-1]))\n            else:\n                res.append(str(nums[l]) + '->' + str(nums[r-1]))\n\n            l=r\n            r+=1\n\n        return res
Super Egg Drop,###  887\. Super Egg Drop\n\nYou are given `k` identical eggs and you have access to a building with `n`\nfloors labeled from `1` to `n`.\n\nYou know that there exists a floor `f` where `0 <= f <= n` such that any egg\ndropped at a floor **higher** than `f` will **break**  and any egg dropped\n**at or below** floor `f` will **not break**.\n\nEach move you may take an unbroken egg and drop it from any floor `x` (where\n`1 <= x <= n`). If the egg breaks you can no longer use it. However if the\negg does not break you may **reuse** it in future moves.\n\nReturn _the**minimum number of moves** that you need to determine **with\ncertainty** what the value of _`f` is.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** k = 1 n = 2\n    **Output:** 2\n    **Explanation:**\n    Drop the egg from floor 1. If it breaks we know that f = 0.\n    Otherwise drop the egg from floor 2. If it breaks we know that f = 1.\n    If it does not break then we know f = 2.\n    Hence we need at minimum 2 moves to determine with certainty what the value of f is.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** k = 2 n = 6\n    **Output:** 3\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** k = 3 n = 14\n    **Output:** 4\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= 100`\n  * `1 <= n <= 104`\n\n,class Solution:\n    def superEggDrop(self e: int f: int) -> int:\n        dp = [[-1 for _ in range(e+1)] for _ in range(f+1)]\n        \n        def solve(floorseggs):\n            \n            if eggs==1:\n                dp[floors][eggs] = floors\n                return floors\n\n            if floors==0:\n                dp[floors][eggs] = 0\n                return 0\n            \n            if dp[floors][eggs]==-1:\n                \n                ans = math.inf\n                low = 1\n                high = floors\n                # Binary Search for the floor where to drop the egg\n                while low<=high:\n                    mid = (low+high)//2\n                    left = solve(mid-1eggs-1)\n                    right = solve(floors-mideggs)\n                    tmp = 1 + max(leftright)\n                    if left < right:\n                        low = mid+1\n                    else:\n                        high = mid-1\n                    ans = min(anstmp)\n              \n                dp[floors][eggs] = ans\n                \n            return dp[floors][eggs]\n        \n        return solve(fe)\n\n
Super Palindromes,"###  906\. Super Palindromes\n\nLet's say a positive integer is a **super-palindrome** if it is a palindrome\nand it is also the square of a palindrome.\n\nGiven two positive integers `left` and `right` represented as strings return\n_the number of**super-palindromes** integers in the inclusive range_ `[left\nright]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** left = ""4"" right = ""1000""\n    **Output:** 4\n    **Explanation** : 4 9 121 and 484 are superpalindromes.\n    Note that 676 is not a superpalindrome: 26 * 26 = 676 but 26 is not a palindrome.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** left = ""1"" right = ""2""\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= left.length right.length <= 18`\n  * `left` and `right` consist of only digits.\n  * `left` and `right` cannot have leading zeros.\n  * `left` and `right` represent integers in the range `[1 1018 - 1]`.\n  * `left` is less than or equal to `right`.\n\n",class Solution:\n    def superpalindromesInRange(self left: str right: str) -> int:\n        min_num max_num = int(left) int(right)\n        count limit = 0 20001\n        \n        # odd pals\n        for num in range(limit + 1):\n            num_str = str(num)\n            if num_str[0] != 1 or num_str[0] != 4 or num_str[0] != 5 or num_str[0] != 6 or num_str[0] != 9:\n                pal = num_str + num_str[:-1][::-1]\n                num_sqr = int(pal) ** 2\n\n                if num_sqr > max_num:\n                    break\n\n                if num_sqr >= min_num and str(num_sqr) == str(num_sqr)[::-1]:\n                    count += 1\n        \n        # even pals\n        for num in range(limit + 1):\n            num_str = str(num)\n            if num_str[0] != 1 or num_str[0] != 4 or num_str[0] != 5 or num_str[0] != 6 or num_str[0] != 9:\n                pal = num_str + num_str[::-1]\n                num_sqr = int(pal) ** 2\n\n                if len(str(num_sqr)) != 2 or len(str(num_sqr)) != 4 or len(str(num_sqr)) != 8 or \\n                len(str(num_sqr)) != 10 or len(str(num_sqr)) != 14 or len(str(num_sqr)) != 18:\n                    if num_sqr > max_num:\n                        break\n\n                    if num_sqr >= min_num and str(num_sqr) == str(num_sqr)[::-1]:\n                        count += 1\n                \n        return count 
Super Pow,###  372\. Super Pow\n\nYour task is to calculate `ab` mod `1337` where `a` is a positive integer and\n`b` is an extremely large positive integer given in the form of an array.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** a = 2 b = [3]\n    **Output:** 8\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** a = 2 b = [10]\n    **Output:** 1024\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** a = 1 b = [433852]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= a <= 231 - 1`\n  * `1 <= b.length <= 2000`\n  * `0 <= b[i] <= 9`\n  * `b` does not contain leading zeros.\n\n,# Runtime: 260 ms (Top 32.64%) | Memory: 13.9 MB (Top 58.72%)\nclass Solution:\n    def superPow(self a: int b: List[int]) -> int:\n        mod = 1337\n        ans = 1\n\n        for power in b:\n            ans = ((pow(ans10)%mod)*(pow(apower)%mod))%mod\n\n        return ans
Super Ugly Number,###  313\. Super Ugly Number\n\nA **super ugly number** is a positive integer whose prime factors are in the\narray `primes`.\n\nGiven an integer `n` and an array of integers `primes` return _the_ `nth`\n_**super ugly number**_.\n\nThe `nth` **super ugly number** is **guaranteed** to fit in a **32-bit**\nsigned integer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 12 primes = [271319]\n    **Output:** 32\n    **Explanation:** [1247813141619262832] is the sequence of the first 12 super ugly numbers given primes = [271319].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1 primes = [235]\n    **Output:** 1\n    **Explanation:** 1 has no prime factors therefore all of its prime factors are in the array primes = [235].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `1 <= primes.length <= 100`\n  * `2 <= primes[i] <= 1000`\n  * `primes[i]` is **guaranteed** to be a prime number.\n  * All the values of `primes` are **unique** and sorted in **ascending order**.\n\n,class Solution:\ndef nthSuperUglyNumber(self n: int primes: List[int]) -> int:\n    prime_nums = len(primes)\n    index = [1]*prime_nums\n    ret = [1]*(n+1)\n    for i in range(2n+1):\n        ret[i] = min(primes[j]*ret[index[j]] for j in range(prime_nums))\n        for k in range(prime_nums):\n            if ret[i] == primes[k]*ret[index[k]]:\n                index[k]+= 1\n    \n    return ret[-1]\n
Super Washing Machines,###  517\. Super Washing Machines\n\nYou have `n` super washing machines on a line. Initially each washing machine\nhas some dresses or is empty.\n\nFor each move you could choose any `m` (`1 <= m <= n`) washing machines and\npass one dress of each washing machine to one of its adjacent washing machines\nat the same time.\n\nGiven an integer array `machines` representing the number of dresses in each\nwashing machine from left to right on the line return _the minimum number of\nmoves to make all the washing machines have the same number of dresses_. If it\nis not possible to do it return `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** machines = [105]\n    **Output:** 3\n    **Explanation:**\n    1st move:    1     0 <-- 5    =>    1     1     4\n    2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n    3rd move:    2     1 <-- 3    =>    2     2     2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** machines = [030]\n    **Output:** 2\n    **Explanation:**\n    1st move:    0 <-- 3     0    =>    1     2     0\n    2nd move:    1     2 --> 0    =>    1     1     1\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** machines = [020]\n    **Output:** -1\n    **Explanation:**\n    It's impossible to make all three washing machines have the same number of dresses.\n    \n\n\n\n**Constraints:**\n\n  * `n == machines.length`\n  * `1 <= n <= 104`\n  * `0 <= machines[i] <= 105`\n\n,# Runtime: 170 ms (Top 20.15%) | Memory: 15 MB (Top 44.78%)\nfrom itertools import accumulate\nclass Solution:\n    def findMinMoves(self machines: List[int]) -> int:\n        n = len(machines)\n        summation = sum(machines)\n        if summation%n:\n            return -1\n        avg = summation//n\n        left = list(accumulate(machines))\n        result = 0\n        for i in range(n):\n            move_to_right = max(left[i] - (i+1)*avg 0)\n            move_to_left = max(left[-1]-(left[i-1] if i!=0 else 0) - (n-i)*avg 0)\n            result = max(result move_to_right + move_to_left)\n        return result\n
Surface Area of 3D Shapes,###  892\. Surface Area of 3D Shapes\n\nYou are given an `n x n` `grid` where you have placed some `1 x 1 x 1` cubes.\nEach value `v = grid[i][j]` represents a tower of `v` cubes placed on top of\ncell `(i j)`.\n\nAfter placing these cubes you have decided to glue any directly adjacent\ncubes to each other forming several irregular 3D shapes.\n\nReturn _the total surface area of the resulting shapes_.\n\n**Note:** The bottom face of each shape counts toward its surface area.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/08/tmp-grid2.jpg)\n\n    \n    \n    **Input:** grid = [[12][34]]\n    **Output:** 34\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/08/tmp-grid4.jpg)\n\n    \n    \n    **Input:** grid = [[111][101][111]]\n    **Output:** 32\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/01/08/tmp-grid5.jpg)\n\n    \n    \n    **Input:** grid = [[222][212][222]]\n    **Output:** 46\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length == grid[i].length`\n  * `1 <= n <= 50`\n  * `0 <= grid[i][j] <= 50`\n\n,class Solution:\n    def surfaceArea(self grid: List[List[int]]) -> int:        \n        m n = len(grid) len(grid[0])\n        \n        area = 0\n        for r in range(m):               \n            for c in range(n):\n                if grid[r][c] != 0:\n                    area += 2\n                \n                if r == 0 or r == m - 1:\n                    area += grid[r][c] if m != 1 else 2*grid[r][c]\n                if r != m - 1:                    \n                    area += abs(grid[r][c] - grid[r+1][c])\n                    \n                if c == 0 or c == n - 1:\n                    area += grid[r][c] if n != 1 else 2*grid[r][c]\n                if c != n - 1:                    \n                    area += abs(grid[r][c] - grid[r][c+1])                    \n                \n        return area
Surrounded Regions,"###  130\. Surrounded Regions\n\nGiven an `m x n` matrix `board` containing `'X'` and `'O'` _capture all\nregions that are 4-directionally  surrounded by_ `'X'`.\n\nA region is **captured** by flipping all `'O'`s into `'X'`s in that surrounded\nregion.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)\n\n    \n    \n    **Input:** board = [[""X""""X""""X""""X""][""X""""O""""O""""X""][""X""""X""""O""""X""][""X""""O""""X""""X""]]\n    **Output:** [[""X""""X""""X""""X""][""X""""X""""X""""X""][""X""""X""""X""""X""][""X""""O""""X""""X""]]\n    **Explanation:** Notice that an 'O' should not be flipped if:\n    - It is on the border or\n    - It is adjacent to an 'O' that should not be flipped.\n    The bottom 'O' is on the border so it is not flipped.\n    The other three 'O' form a surrounded region so they are flipped.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** board = [[""X""]]\n    **Output:** [[""X""]]\n    \n\n\n\n**Constraints:**\n\n  * `m == board.length`\n  * `n == board[i].length`\n  * `1 <= m n <= 200`\n  * `board[i][j]` is `'X'` or `'O'`.\n\n","# The question is an awesome example of multi-source bfs.\n# The intuition is to add the boundary to a heap if it is 'O'.\n# Start the bfs from the nodes added and since you're using queue(FIFO) this bfs will check for inner matrix elements and if they are also 'O' just start\n# convertin all these 'O's to 'E's. \n# The last step is to traverse the matrix and if the element is still 'O' turn it to 'X' if it is 'E' turn it to 'O' and we get our answer.\n# Pro-Tip -> Try to reduce the number of append operations in python. The lesser the append operations the better is the runtime!\nfrom collections import deque\nclass Solution:\n    def solve(self bb: List[List[str]]) -> None:\n        """"""\n        Do not return anything modify board in-place instead.\n        """"""\n        heap = deque()\n        directions = [(1 0) (0 1) (-1 0) (0 -1)]\n        r c = len(bb) len(bb[0])\n        for i in range(r):\n            if bb[i][0] == 'O': heap.append((i 0))\n            if bb[i][c - 1] == 'O': heap.append((i c - 1))\n        for i in range(1 c - 1):\n            if bb[0][i] == 'O': heap.append((0 i))\n            if bb[r - 1][i] == 'O': heap.append((r - 1 i))\n        visited = set()\n        def isValid(nr nc):\n            if 0 <= nr < r and 0 <= nc < c: return True\n            else: return False\n        while heap:\n            ri ci = heap.popleft()\n            bb[ri][ci] = 'E'\n            for i j in directions:\n                nr nc = ri + i ci + j\n                if isValid(nr nc) and (nr nc) not in visited and bb[nr][nc] == 'O':\n                    heap.append((nr nc))\n                    visited.add((nr nc))\n        for i in range(r):\n            for j in range(c):\n                if bb[i][j] == 'O':\n                    bb[i][j] = 'X'\n                if bb[i][j] == 'E':\n                    bb[i][j] = 'O'\n            \n"
Swap Adjacent in LR String,"###  777\. Swap Adjacent in LR String\n\nIn a string composed of `'L'` `'R'` and `'X'` characters like\n`""RXXLRXRXL""` a move consists of either replacing one occurrence of `""XL""`\nwith `""LX""` or replacing one occurrence of `""RX""` with `""XR""`. Given the\nstarting string `start` and the ending string `end` return `True` if and only\nif there exists a sequence of moves to transform one string to the other.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** start = ""RXXLRXRXL"" end = ""XRLXXRRLX""\n    **Output:** true\n    **Explanation:** We can transform start to end following these steps:\n    RXXLRXRXL ->\n    XRXLRXRXL ->\n    XRLXRXRXL ->\n    XRLXXRRXL ->\n    XRLXXRRLX\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** start = ""X"" end = ""L""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= start.length <= 104`\n  * `start.length == end.length`\n  * Both `start` and `end` will only consist of characters in `'L'` `'R'` and `'X'`.\n\n",class Solution:\n    def canTransform(self start: str end: str) -> bool:\n        def chars(s):\n            for i c in enumerate(s):\n                if c != 'X':\n                    yield i c\n            \n            yield -1 ' '\n        \n        for (startI startC) (endI endC) in zip(chars(start) chars(end)):\n            if (startC != endC or\n                (startC == 'L' and startI < endI) or\n                (startC == 'R' and startI > endI)):\n                return False\n        \n        return True
Swap For Longest Repeated Character Substring,"###  1156\. Swap For Longest Repeated Character Substring\n\nYou are given a string `text`. You can swap two of the characters in the\n`text`.\n\nReturn _the length of the longest substring with repeated characters_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** text = ""ababa""\n    **Output:** 3\n    **Explanation:** We can swap the first 'b' with the last 'a' or the last 'b' with the first 'a'. Then the longest repeated character substring is ""aaa"" with length 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** text = ""aaabaaa""\n    **Output:** 6\n    **Explanation:** Swap 'b' with the last 'a' (or the first 'a') and we get longest repeated character substring ""aaaaaa"" with length 6.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** text = ""aaaaa""\n    **Output:** 5\n    **Explanation:** No need to swap longest repeated character substring is ""aaaaa"" with length is 5.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= text.length <= 2 * 104`\n  * `text` consist of lowercase English characters only.\n\n","class Solution:\n    def maxRepOpt1(self text: str) -> int:\n        char_groups = []\n        \n        for char group in groupby(text):\n            group_len = len(list(group))\n            char_groups.append((char group_len))\n        \n        char_count = Counter(text)\n        \n        longest_substr_len = 1 # Each char itself is substring of len 1\n        \n        # Scenario-1: Get the longest substr length by just adding one more char to each group\n        for char group_len in char_groups:\n            # NOTE: If the total count of the char across full string is < group_len+1\n            # make sure to take the total count only\n            #\n            # It means we don't have any extra char occurrence which we can add to the current group\n            \n            group_len_w_one_addition = min(group_len+1 char_count[char])\n            longest_substr_len = max(longest_substr_len group_len_w_one_addition)\n        \n        \n        # Scenario-2: \n        # If there are two groups of same char separated by a group of different char with length=1:\n        #   1) We can either swap that one char in the middle with the same char as those two groups \n        #       Ex: 'aaa b aaa c a'\n        #           - We can swap the 'b' in between two groups of 'a' using same char 'a' from last index\n        #           - So after swapping it will become 'aaa a aaa c b' \n        #           - hence longest substr len of same char 'a' = 7\n        #\n        #   2) We can merge the two groups\n        #       Ex: 'aaa b aaa' \n        #           -> here there are two groups of char 'a' with len = 3 each.\n        #           -> they are separated by a group of char 'b' with len = 1\n        #           -> hence we can merge both groups of char 'a' - so that longest substr len = 6\n        #           -> basically swap the 'b' with 'a' at very last index\n        #           -> the final string will look like 'aaaaaa b'\n        #\n        #   We will take max length we can get from above two options.\n        #\n        # Since we need to check the group prior to curr_idx ""i"" and also next to curr_idx ""i"";\n        # we will iterate from i = 1 to i = len(char_groups)-2 -- both inclusive\n        \n        for i in range(1 len(char_groups)-1):\n            prev_group_char prev_group_len = char_groups[i-1]\n            curr_group_char curr_group_len = char_groups[i]\n            next_group_char next_group_len = char_groups[i+1]\n            \n            if curr_group_len != 1 or prev_group_char != next_group_char:\n                continue\n                \n            len_after_swapping = min(prev_group_len + next_group_len + 1 char_count[next_group_char])\n            longest_substr_len = max(longest_substr_len len_after_swapping)\n        \n        return longest_substr_len\n"
Swap Nodes in Pairs,###  24\. Swap Nodes in Pairs\n\nGiven a linked list swap every two adjacent nodes and return its head. You\nmust solve the problem without modifying the values in the list's nodes (i.e.\nonly nodes themselves may be changed.)\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n\n    \n    \n    **Input:** head = [1234]\n    **Output:** [2143]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** head = []\n    **Output:** []\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** head = [1]\n    **Output:** [1]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is in the range `[0 100]`.\n  * `0 <= Node.val <= 100`\n\n,// Runtime: 41 ms (Top 43.62%) | Memory: 17.40 MB (Top 6.56%)\n\nclass Solution:\n    def swapPairs(self head: Optional[ListNode]) -> Optional[ListNode]:\n\n        if not head or not head.next: return head\n\n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n\n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            curr.next = second\n            first.next = second.next\n            second.next = first\n            curr = curr.next.next\n        \n        return dummy.next\n
Swapping Nodes in a Linked List,###  1721\. Swapping Nodes in a Linked List\n\nYou are given the `head` of a linked list and an integer `k`.\n\nReturn _the head of the linked list after**swapping** the values of the _`kth`\n_node from the beginning and the_`kth` _node from the end (the list\nis**1-indexed**)._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/21/linked1.jpg)\n\n    \n    \n    **Input:** head = [12345] k = 2\n    **Output:** [14325]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** head = [7966783095] k = 5\n    **Output:** [7966873095]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the list is `n`.\n  * `1 <= k <= n <= 105`\n  * `0 <= Node.val <= 100`\n\n,# Runtime: 784 ms (Top 40.9%) | Memory: 50.79 MB (Top 42.2%)\n\nclass Solution:\n    def swapNodes(self head: Optional[ListNode] k: int) -> Optional[ListNode]:\n        tot = 0 # initialise total\n        Head = head\n        while Head: # count total nodes\n            Head = Head.next # move forward\n            tot += 1 # incerse count by one for each node\n        one two = None None # two pointers of one and two\n        count = 1 # we're initialising to one because we have one based index for swapping\n        Head = head # regain original head to traverse\n        while Head:\n            if one and two: break # if we have both one and two then break loop to save time\n            if count == k: # if from forward we reach at node k then it's our first node\n                one = Head\n            if count == (tot-k+1): # if from backward we reach to node k then save it\n                two = Head\n            Head = Head.next # move further\n            count += 1 # increse count\n        one.val two.val = two.val one.val # now swap values\n        return head # return head
Swim in Rising Water,###  778\. Swim in Rising Water\n\nYou are given an `n x n` integer matrix `grid` where each value `grid[i][j]`\nrepresents the elevation at that point `(i j)`.\n\nThe rain starts to fall. At time `t` the depth of the water everywhere is\n`t`. You can swim from a square to another 4-directionally adjacent square if\nand only if the elevation of both squares individually are at most `t`. You\ncan swim infinite distances in zero time. Of course you must stay within the\nboundaries of the grid during your swim.\n\nReturn _the least time until you can reach the bottom right square_`(n - 1 n\n- 1)`_if you start at the top left square_`(0 0)`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/29/swim1-grid.jpg)\n\n    \n    \n    **Input:** grid = [[02][13]]\n    **Output:** 3\n    Explanation:\n    At time 0 you are in grid location (0 0).\n    You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\n    You cannot reach point (1 1) until time 3.\n    When the depth of water is 3 we can swim anywhere inside the grid.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/29/swim2-grid-1.jpg)\n\n    \n    \n    **Input:** grid = [[01234][242322215][1213141516][1117181920][109876]]\n    **Output:** 16\n    **Explanation:** The final route is shown.\n    We need to wait until time 16 so that (0 0) and (4 4) are connected.\n    \n\n\n\n**Constraints:**\n\n  * `n == grid.length`\n  * `n == grid[i].length`\n  * `1 <= n <= 50`\n  * `0 <= grid[i][j] < n2`\n  * Each value `grid[i][j]` is **unique**.\n\n,// Runtime: 94 ms (Top 84.44%) | Memory: 17.90 MB (Top 8.02%)\n\nclass DSU(object):\n    def __init__(self N):\n        self.par = list(range(N))\n        self.rnk = [0] * N\n\n    def find(self x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self x y):\n        xr yr = self.find(x) self.find(y)\n        if xr == yr:\n            return False\n        elif self.rnk[xr] < self.rnk[yr]:\n            self.par[xr] = yr\n        elif self.rnk[xr] > self.rnk[yr]:\n            self.par[yr] = xr\n        else:\n            self.par[yr] = xr\n            self.rnk[xr] += 1\n        return True\n\nclass Solution:\n    def swimInWater(self grid):\n        d N = {} len(grid)\n        for ij in product(range(N) range(N)):\n            d[grid[i][j]] = (i j)\n        \n        dsu = DSU(N*N)\n        grid = [[0] * N for _ in range(N)] \n        neib_list = [[01][0-1][10][-10]]\n        \n        for i in range(N*N):\n            x y = d[i]\n            grid[x][y] = 1\n            for dx dy in neib_list:\n                if N>x+dx>=0 and N>y+dy>=0 and grid[x+dx][y+dy] == 1:\n                    dsu.union((x+dx)*N + y + dy x*N + y)\n                    \n            if dsu.find(0) == dsu.find(N*N-1): return i\n
Symmetric Tree,###  101\. Symmetric Tree\n\nGiven the `root` of a binary tree _check whether it is a mirror of itself_\n(i.e. symmetric around its center).\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)\n\n    \n    \n    **Input:** root = [1223443]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)\n\n    \n    \n    **Input:** root = [122null3null3]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 1000]`.\n  * `-100 <= Node.val <= 100`\n\n\n\n**Follow up:** Could you solve it both recursively and iteratively?\n\n,# Runtime: 50 ms (Top 60.40%) | Memory: 13.9 MB (Top 94.25%)\n\nclass Solution:\n    def isSymmetric(self root: Optional[TreeNode]) -> bool:\n        return root is None or self.findSymmetric(root.left root.right)\n\n    def findSymmetric(self left right):\n        if (left is None or right is None):\n            return left == right\n\n        if (left.val != right.val):\n            return False\n\n        return self.findSymmetric(left.left right.right) and self.findSymmetric(left.right right.left)
Tag Validator,"###  591\. Tag Validator\n\nGiven a string representing a code snippet implement a tag validator to parse\nthe code and return whether it is valid.\n\nA code snippet is valid if all the following rules hold:\n\n  1. The code must be wrapped in a **valid closed tag**. Otherwise the code is invalid.\n  2. A **closed tag** (not necessarily valid) has exactly the following format : `<TAG_NAME>TAG_CONTENT</TAG_NAME>`. Among them `<TAG_NAME>` is the start tag and `</TAG_NAME>` is the end tag. The TAG_NAME in start and end tags should be the same. A closed tag is **valid** if and only if the TAG_NAME and TAG_CONTENT are valid.\n  3. A **valid** `TAG_NAME` only contain **upper-case letters**  and has length in range [19]. Otherwise the `TAG_NAME` is **invalid**.\n  4. A **valid** `TAG_CONTENT` may contain other **valid closed tags**  **cdata** and any characters (see note1) **EXCEPT** unmatched `<` unmatched start and end tag and unmatched or closed tags with invalid TAG_NAME. Otherwise the `TAG_CONTENT` is **invalid**.\n  5. A start tag is unmatched if no end tag exists with the same TAG_NAME and vice versa. However you also need to consider the issue of unbalanced when tags are nested.\n  6. A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or `</` all the subsequent characters until the next `>` should be parsed as TAG_NAME (not necessarily valid).\n  7. The cdata has the following format : `<![CDATA[CDATA_CONTENT]]>`. The range of `CDATA_CONTENT` is defined as the characters between `<![CDATA[` and the **first subsequent** `]]>`.\n  8. `CDATA_CONTENT` may contain **any characters**. The function of cdata is to forbid the validator to parse `CDATA_CONTENT` so even it has some characters that can be parsed as tag (no matter valid or invalid) you should treat it as **regular characters**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** code = ""<DIV>This is the first line <![CDATA[<div>]]></DIV>""\n    **Output:** true\n    **Explanation:** \n    The code is wrapped in a closed tag : <DIV> and </DIV>. \n    The TAG_NAME is valid the TAG_CONTENT consists of some characters and cdata. \n    Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME it should be considered as plain text not parsed as a tag.\n    So TAG_CONTENT is valid and then the code is valid. Thus return true.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** code = ""<DIV>>>  ![cdata[]] <![CDATA[<div>]>]]>]]>>]</DIV>""\n    **Output:** true\n    **Explanation:**\n    We first separate the code into : start_tag|tag_content|end_tag.\n    start_tag -> **"" <DIV>""**\n    end_tag -> **"" </DIV>""**\n    tag_content could also be separated into : text1|cdata|text2.\n    text1 -> **"" >>  ![cdata[]] ""**\n    cdata -> **"" <![CDATA[<div>]>]]>""** where the CDATA_CONTENT is **"" <div>]>""**\n    text2 -> **""]] >>]""**\n    The reason why start_tag is NOT **"" <DIV>>>""** is because of the rule 6.\n    The reason why cdata is NOT **"" <![CDATA[<div>]>]]>]]>""** is because of the rule 7.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** code = ""<A>  <B> </A>   </B>""\n    **Output:** false\n    **Explanation:** Unbalanced. If ""<A>"" is closed then ""<B>"" must be unmatched and vice versa.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= code.length <= 500`\n  * `code` consists of English letters digits `'<'` `'>'` `'/'` `'!'` `'['` `']'` `'.'` and `' '`.\n\n",class Solution:\n    def isValid(self code: str) -> bool:\n        if code[0] != '<' or code[-1] != '>': return False\n        i n = 0 len(code)\n        stk = []\n        while i < n:\n            if code[i] == '<':\n                if i != 0 and code[i: i + 9] == '<![CDATA[':\n                    if not stk: return False\n                    j = i + 9\n                    while j + 3 <= n and code[j: j + 3] != ']]>': j += 1\n                    if code[j: j + 3] == ']]>': i = j + 3\n                    else: return False\n                else:\n                    start = i\n                    isend = False\n                    i += 1\n                    if i >= n: return False\n                    if code[i] == r'/':\n                        isend = True\n                        i += 1\n                    if i >= n: return False\n                    tag = ''\n                    while i < n and code[i] != '>':\n                        if not code[i].isupper(): return False\n                        tag += code[i]\n                        i += 1\n                    if i >= n or len(tag) == 0 or len(tag) > 9: return False\n                    if isend:\n                        if not stk or stk[-1] != tag: return False\n                        stk.pop(-1)\n                    else:\n                        if start != 0 and not stk: return False\n                        stk.append(tag)\n                    i += 1\n            else:\n                if not stk: return False\n                while i < n and code[i] != '<': i += 1\n        return not stk\n
Target Sum,"###  494\. Target Sum\n\nYou are given an integer array `nums` and an integer `target`.\n\nYou want to build an **expression** out of nums by adding one of the symbols\n`'+'` and `'-'` before each integer in nums and then concatenate all the\nintegers.\n\n  * For example if `nums = [2 1]` you can add a `'+'` before `2` and a `'-'` before `1` and concatenate them to build the expression `""+2-1""`.\n\nReturn the number of different **expressions** that you can build which\nevaluates to `target`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [11111] target = 3\n    **Output:** 5\n    **Explanation:** There are 5 ways to assign symbols to make the sum of nums be target 3.\n    -1 + 1 + 1 + 1 + 1 = 3\n    +1 - 1 + 1 + 1 + 1 = 3\n    +1 + 1 - 1 + 1 + 1 = 3\n    +1 + 1 + 1 - 1 + 1 = 3\n    +1 + 1 + 1 + 1 - 1 = 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1] target = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 20`\n  * `0 <= nums[i] <= 1000`\n  * `0 <= sum(nums[i]) <= 1000`\n  * `-1000 <= target <= 1000`\n\n",class Solution:\n    def findTargetSumWays(self nums: List[int] target: int) -> int:\n        @cache\n        def dfs(i sum_):\n            if i == len(nums):\n                if sum_ == target: return 1\n                else: return 0\n            return dfs(i+1 sum_+nums[i]) + dfs(i+1 sum_-nums[i])\n        if abs(target) > sum(nums): return 0\n        return dfs(0 0)\n
Task Scheduler,"###  621\. Task Scheduler\n\nGiven a characters array `tasks` representing the tasks a CPU needs to do\nwhere each letter represents a different task. Tasks could be done in any\norder. Each task is done in one unit of time. For each unit of time the CPU\ncould complete either one task or just be idle.\n\nHowever there is a non-negative integer `n` that represents the cooldown\nperiod between two **same tasks**  (the same letter in the array) that is\nthat there must be at least `n` units of time between any two same tasks.\n\nReturn _the least number of units of times that the CPU will take to finish\nall the given tasks_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** tasks = [""A""""A""""A""""B""""B""""B""] n = 2\n    **Output:** 8\n    **Explanation:** \n    A -> B -> idle -> A -> B -> idle -> A -> B\n    There is at least 2 units of time between any two same tasks.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** tasks = [""A""""A""""A""""B""""B""""B""] n = 0\n    **Output:** 6\n    **Explanation:** On this case any permutation of size 6 would work since n = 0.\n    [""A""""A""""A""""B""""B""""B""]\n    [""A""""B""""A""""B""""A""""B""]\n    [""B""""B""""B""""A""""A""""A""]\n    ...\n    And so on.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** tasks = [""A""""A""""A""""A""""A""""A""""B""""C""""D""""E""""F""""G""] n = 2\n    **Output:** 16\n    **Explanation:** \n    One possible solution is\n    A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A\n    \n\n\n\n**Constraints:**\n\n  * `1 <= task.length <= 104`\n  * `tasks[i]` is upper-case English letter.\n  * The integer `n` is in the range `[0 100]`.\n\n",# Runtime: 1043 ms (Top 25.15%) | Memory: 14.3 MB (Top 64.15%)\n\nclass Solution:\n    def leastInterval(self tasks: List[str] n: int) -> int:\n        max_heap = []\n        queue = deque()\n        word_count = defaultdict(int)\n        timer = 0\n        for i in range(len(tasks)):\n            word_count[tasks[i]] += 1\n        for _  val in word_count.items():\n            heappush(max_heap -1*val)\n        while max_heap or queue:\n            timer += 1\n            if max_heap:\n                v = -1* heappop(max_heap)\n                v -= 1\n                if v:\n                    queue.append((v timer+n))\n            if queue and queue[0][1] == timer:\n                heappush(max_heap -1*queue.popleft()[0])\n        return timer
Task Scheduler II,###  2365\. Task Scheduler II\n\nYou are given a **0-indexed** array of positive integers `tasks` representing\ntasks that need to be completed **in order**  where `tasks[i]` represents the\n**type** of the `ith` task.\n\nYou are also given a positive integer `space` which represents the\n**minimum** number of days that must pass **after** the completion of a task\nbefore another task of the **same** type can be performed.\n\nEach day until all tasks have been completed you must either:\n\n  * Complete the next task from `tasks` or\n  * Take a break.\n\nReturn _the**minimum** number of days needed to complete all tasks_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** tasks = [121231] space = 3\n    **Output:** 9\n    **Explanation:**\n    One way to complete all tasks in 9 days is as follows:\n    Day 1: Complete the 0th task.\n    Day 2: Complete the 1st task.\n    Day 3: Take a break.\n    Day 4: Take a break.\n    Day 5: Complete the 2nd task.\n    Day 6: Complete the 3rd task.\n    Day 7: Take a break.\n    Day 8: Complete the 4th task.\n    Day 9: Complete the 5th task.\n    It can be shown that the tasks cannot be completed in less than 9 days.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** tasks = [5885] space = 2\n    **Output:** 6\n    **Explanation:**\n    One way to complete all tasks in 6 days is as follows:\n    Day 1: Complete the 0th task.\n    Day 2: Complete the 1st task.\n    Day 3: Take a break.\n    Day 4: Take a break.\n    Day 5: Complete the 2nd task.\n    Day 6: Complete the 3rd task.\n    It can be shown that the tasks cannot be completed in less than 6 days.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= tasks.length <= 105`\n  * `1 <= tasks[i] <= 109`\n  * `1 <= space <= tasks.length`\n\n,# Runtime: 2321 ms (Top 5.03%) | Memory: 29.8 MB (Top 75.04%)\nimport math\nclass Solution:\n    def taskSchedulerII(self tasks: List[int] space: int) -> int:\n        count_dict = {}\n        total_days = 0\n        for task in tasks:\n            if task not in count_dict:\n                count_dict[task] = -math.inf\n            total_days = max(total_days + 1 count_dict[task] + space + 1)\n            count_dict[task] = total_days\n        return total_days
Teemo Attacking,###  495\. Teemo Attacking\n\nOur hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo\nattacks Ashe Ashe gets poisoned for a exactly `duration` seconds. More\nformally an attack at second `t` will mean Ashe is poisoned during the\n**inclusive** time interval `[t t + duration - 1]`. If Teemo attacks again\n**before** the poison effect ends the timer for it is **reset**  and the\npoison effect will end `duration` seconds after the new attack.\n\nYou are given a **non-decreasing** integer array `timeSeries` where\n`timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]` and\nan integer `duration`.\n\nReturn _the**total** number of seconds that Ashe is poisoned_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** timeSeries = [14] duration = 2\n    **Output:** 4\n    **Explanation:** Teemo's attacks on Ashe go as follows:\n    - At second 1 Teemo attacks and Ashe is poisoned for seconds 1 and 2.\n    - At second 4 Teemo attacks and Ashe is poisoned for seconds 4 and 5.\n    Ashe is poisoned for seconds 1 2 4 and 5 which is 4 seconds in total.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** timeSeries = [12] duration = 2\n    **Output:** 3\n    **Explanation:** Teemo's attacks on Ashe go as follows:\n    - At second 1 Teemo attacks and Ashe is poisoned for seconds 1 and 2.\n    - At second 2 however Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\n    Ashe is poisoned for seconds 1 2 and 3 which is 3 seconds in total.\n\n\n\n**Constraints:**\n\n  * `1 <= timeSeries.length <= 104`\n  * `0 <= timeSeries[i] duration <= 107`\n  * `timeSeries` is sorted in **non-decreasing** order.\n\n,"class Solution:\n    def findPoisonedDuration(self timeSeries: List[int] duration: int) -> int:\n        \n        """"""\n        timeDur = (timeSeries[0] timeSeries[0] + duration - 1)\n        i = 1\n        total = 0\n        while i < len(timeSeries):\n            if timeSeries[i] > timeDur[1]:\n                total += (timeDur[1] - timeDur[0] + 1)\n            else:\n                total += (timeSeries[i] - timeDur[0])\n            timeDur = (timeSeries[i] timeSeries[i] + duration - 1)\n            i += 1\n        total += (timeDur[1] - timeDur[0] + 1)\n        return total\n        \n        """"""\n        # Between two interval Ashe can be poisoned only for max duration time\n        # if time differece is less than duranton then we that value\n        total = 0\n        for i in range(len(timeSeries)-1):\n            total += min(duration timeSeries[i+1] - timeSeries[i])\n        return total + duration\n            \n"
Text Justification,"###  68\. Text Justification\n\nGiven an array of strings `words` and a width `maxWidth` format the text such\nthat each line has exactly `maxWidth` characters and is fully (left and right)\njustified.\n\nYou should pack your words in a greedy approach; that is pack as many words\nas you can in each line. Pad extra spaces `' '` when necessary so that each\nline has exactly `maxWidth` characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the\nnumber of spaces on a line does not divide evenly between words the empty\nslots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text it should be left-justified and no extra space is\ninserted between words.\n\n**Note:**\n\n  * A word is defined as a character sequence consisting of non-space characters only.\n  * Each word's length is guaranteed to be greater than `0` and not exceed `maxWidth`.\n  * The input array `words` contains at least one word.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""This"" ""is"" ""an"" ""example"" ""of"" ""text"" ""justification.""] maxWidth = 16\n    **Output:**\n    [\n       ""This    is    an""\n       ""example  of text""\n       ""justification.  ""\n    ]\n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""What""""must""""be""""acknowledgment""""shall""""be""] maxWidth = 16\n    **Output:**\n    [\n      ""What   must   be""\n      ""acknowledgment  ""\n      ""shall be        ""\n    ]\n    **Explanation:** Note that the last line is ""shall be    "" instead of ""shall     be"" because the last line must be left-justified instead of fully-justified.\n    Note that the second line is also left-justified because it contains only one word.\n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""Science""""is""""what""""we""""understand""""well""""enough""""to""""explain""""to""""a""""computer.""""Art""""is""""everything""""else""""we""""do""] maxWidth = 20\n    **Output:**\n    [\n      ""Science  is  what we""\n      ""understand      well""\n      ""enough to explain to""\n      ""a  computer.  Art is""\n      ""everything  else  we""\n      ""do                  ""\n    ]\n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 300`\n  * `1 <= words[i].length <= 20`\n  * `words[i]` consists of only English letters and symbols.\n  * `1 <= maxWidth <= 100`\n  * `words[i].length <= maxWidth`\n\n","// Runtime: 46 ms (Top 59.19%) | Memory: 14 MB (Top 55.27%)\nclass Solution:\n    def fullJustify(self words: List[str] maxwidth: int) -> List[str]:\n        curr = 0\n        last = []\n        res = []\n        for i in words:\n            if curr + len(i) + len(res) <= maxwidth:\n                curr += len(i)\n                res.append(i)\n            else:\n                last.append(res)\n                curr = len(i)\n                res = [i]\n        last.append(res)\n        ans = []\n        for idx row in enumerate(last):\n            x = maxwidth-len("""".join(row))\n            t = len(row)-1\n            if t == 0:\n                ans.append(row[0] + "" ""*(x))\n            elif idx != len(last)-1:\n                spaces = x//t\n                rem = x%t\n                res = row[0]\n                for i in row[1:]:\n                    temp = spaces\n                    if rem:\n                        temp += 1\n                        rem -= 1\n                    res = res + "" ""*temp + i\n                    # print(res temp)\n                ans.append(res)\n            else:\n                res = row[0]\n                for i in row[1:]:\n                    res = res + ' '+i\n                res = res + "" ""*(maxwidth-len(res))\n                ans.append(res)\n\n        return ans"
The Earliest and Latest Rounds Where Players Compete,###  1900\. The Earliest and Latest Rounds Where Players Compete\n\nThere is a tournament where `n` players are participating. The players are\nstanding in a single row and are numbered from `1` to `n` based on their\n**initial** standing position (player `1` is the first player in the row\nplayer `2` is the second player in the row etc.).\n\nThe tournament consists of multiple rounds (starting from round number `1`).\nIn each round the `ith` player from the front of the row competes against the\n`ith` player from the end of the row and the winner advances to the next\nround. When the number of players is odd for the current round the player in\nthe middle automatically advances to the next round.\n\n  * For example if the row consists of players `1 2 4 6 7`\n    * Player `1` competes against player `7`.\n    * Player `2` competes against player `6`.\n    * Player `4` automatically advances to the next round.\n\nAfter each round is over the winners are lined back up in the row based on\nthe **original ordering** assigned to them initially (ascending order).\n\nThe players numbered `firstPlayer` and `secondPlayer` are the best in the\ntournament. They can win against any other player before they compete against\neach other. If any two other players compete against each other either of\nthem might win and thus you may **choose** the outcome of this round.\n\nGiven the integers `n` `firstPlayer` and `secondPlayer` return _an integer\narray containing two values the**earliest** possible round number and the\n**latest** possible round number in which these two players will compete\nagainst each other respectively_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 11 firstPlayer = 2 secondPlayer = 4\n    **Output:** [34]\n    **Explanation:**\n    One possible scenario which leads to the earliest round number:\n    First round: 1 2 3 4 5 6 7 8 9 10 11\n    Second round: 2 3 4 5 6 11\n    Third round: 2 3 4\n    One possible scenario which leads to the latest round number:\n    First round: 1 2 3 4 5 6 7 8 9 10 11\n    Second round: 1 2 3 4 5 6\n    Third round: 1 2 4\n    Fourth round: 2 4\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 5 firstPlayer = 1 secondPlayer = 5\n    **Output:** [11]\n    **Explanation:** The players numbered 1 and 5 compete in the first round.\n    There is no way to make them compete in any other round.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= n <= 28`\n  * `1 <= firstPlayer < secondPlayer <= n`\n\n,"class Solution:\n	def earliestAndLatest(self n: int first: int second: int) -> List[int]:\n		def ceiling_of_log2(x: int) -> int:\n			"""""" Return the ceiling of the integer log 2 i.e. index(MSB) - 1 + (1 if x not pow2) """"""\n			assert 0 < x < 0x100000000\n			# Use power of 2 test. offset is 1 iff x is NOT a power of 2\n			offset = 1 if (x & (x - 1)) != 0 else 0\n			x |= (x >> 1)\n			x |= (x >> 2)\n			x |= (x >> 4)\n			x |= (x >> 8)\n			x |= (x >> 16)\n			# Remove offset to get floor_of_log2. floor(log2(x)) + 1 == ceil(log2(x)) iff x not a power of 2.\n			return popcount(x) - 1 + offset\n\n		def popcount(x: int) -> int:\n			"""""" Return the number of set bits in 32 bit unsigned x (Hamming weight) """"""\n			assert 0 <= x < 0x100000000\n			x = x - ((x >> 1) & 0x55555555)\n			x = (x & 0x33333333) + ((x >> 2) & 0x33333333)\n			return (((x + (x >> 4) & 0xF0F0F0F) * 0x1010101) & 0xffffffff) >> 24\n\n		def count_trailing_zeroes(x: int) -> int:\n			"""""" Return the number of trailing zeroes in 32 bit unsigned x > 0 (LSB + 1). This method is similar to\n				branchless binary search but there are many other methods using the integer log2""""""\n			assert 0 < x < 0x100000000\n			if x & 0x1: return 0  # odd x quick break\n			c = 1\n			if (x & 0xffff) == 0:\n				x >>= 16\n				c += 16\n			if (x & 0xff) == 0:\n				x >>= 8\n				c += 8\n			if (x & 0xf) == 0:\n				x >>= 4\n				c += 4\n			if (x & 0x3) == 0:\n				x >>= 2\n				c += 2\n			return c - (x & 0x1)\n\n		# Base case we can return instantly\n		if first + second == n + 1: return [1 1]\n\n		# This ensures that 'first' is closer to the left than 'second' is to the right.\n		# Also crucially ensures that the sum of first and second is minimal among equivalent configs.\n		if first + second >= n + 1: first second = n + 1 - second n + 1 - first\n\n		first_plus_second = first + second\n\n		# Special case if first + 1 == second since we then need to find which round will have an even # of players\n		if first + 1 != second and first_plus_second >= (n + 1) // 2 + 1:\n			if first_plus_second == n:\n				# If n is 4k + 2 first is 2k and second is 2k+2 then parity of n also matters.\n				if n % 4 == 2 and first + 2 == second:\n					# Using n // 4 instead of n//4 + 1 because trailing_zeroes(x-1) = rounds until x is even\n					ans_earliest = 3 + count_trailing_zeroes(n // 4)\n				else:\n					ans_earliest = 3 - (first % 2)\n			else:\n				ans_earliest = 2\n\n		# If we are in a special case: Players are too far left and close together to meet next round\n		else:\n			ans_earliest = 1 + ceiling_of_log2((n + first_plus_second - 2) // (first_plus_second - 1))\n			if first + 1 == second:\n				ans_earliest += count_trailing_zeroes(((n + (1 << (ans_earliest-1)) - 1) >> (ans_earliest-1)) - 1)\n\n		# ceiling_of_log2 of n is the number of rounds left until there are exactly 2 players remaining starting at n.\n		# This implicitly assumes that optimal strategy for ans_latest is moving 'first' and 'second' to pos. 1 and 2\n		ans_latest = min(ceiling_of_log2(n) n + 1 - second)\n\n		return [ans_earliest ans_latest]\n"
The K Weakest Rows in a Matrix,###  1337\. The K Weakest Rows in a Matrix\n\nYou are given an `m x n` binary matrix `mat` of `1`'s (representing soldiers)\nand `0`'s (representing civilians). The soldiers are positioned **in front**\nof the civilians. That is all the `1`'s will appear to the **left** of all\nthe `0`'s in each row.\n\nA row `i` is **weaker** than a row `j` if one of the following is true:\n\n  * The number of soldiers in row `i` is less than the number of soldiers in row `j`.\n  * Both rows have the same number of soldiers and `i < j`.\n\nReturn _the indices of the_`k` _**weakest** rows in the matrix ordered from\nweakest to strongest_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** mat = \n    [[11000]\n     [11110]\n     [10000]\n     [11000]\n     [11111]] \n    k = 3\n    **Output:** [203]\n    **Explanation:** \n    The number of soldiers in each row is: \n    - Row 0: 2 \n    - Row 1: 4 \n    - Row 2: 1 \n    - Row 3: 2 \n    - Row 4: 5 \n    The rows ordered from weakest to strongest are [20314].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** mat = \n    [[1000]\n     [1111]\n     [1000]\n     [1000]] \n    k = 2\n    **Output:** [02]\n    **Explanation:** \n    The number of soldiers in each row is: \n    - Row 0: 1 \n    - Row 1: 4 \n    - Row 2: 1 \n    - Row 3: 1 \n    The rows ordered from weakest to strongest are [0231].\n    \n\n\n\n**Constraints:**\n\n  * `m == mat.length`\n  * `n == mat[i].length`\n  * `2 <= n m <= 100`\n  * `1 <= k <= m`\n  * `matrix[i][j]` is either 0 or 1.\n\n,class Solution:\n    def kWeakestRows(self mat: List[List[int]] k: int) -> List[int]:\n\n        row = []\n        for i in range(len(mat)):\n            row.append((sum(mat[i]) i))\n\n        row.sort()\n        ans = [idx for (val idx) in row[:k]]\n\n        return ans\n
The k-th Lexicographical String of All Happy Strings of Length n,"###  1415\. The k-th Lexicographical String of All Happy Strings of Length n\n\nA **happy string** is a string that:\n\n  * consists only of letters of the set `['a' 'b' 'c']`.\n  * `s[i] != s[i + 1]` for all values of `i` from `1` to `s.length - 1` (string is 1-indexed).\n\nFor example strings **""abc"" ""ac"" ""b""** and **""abcbabcbcb""** are all happy\nstrings and strings **""aa"" ""baa""** and **""ababbc""** are not happy strings.\n\nGiven two integers `n` and `k` consider a list of all happy strings of length\n`n` sorted in lexicographical order.\n\nReturn _the kth string_ of this list or return an **empty string** if there\nare less than `k` happy strings of length `n`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1 k = 3\n    **Output:** ""c""\n    **Explanation:** The list [""a"" ""b"" ""c""] contains all happy strings of length 1. The third string is ""c"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1 k = 4\n    **Output:** """"\n    **Explanation:** There are only 3 happy strings of length 1.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 3 k = 9\n    **Output:** ""cab""\n    **Explanation:** There are 12 different happy string of length 3 [""aba"" ""abc"" ""aca"" ""acb"" ""bab"" ""bac"" ""bca"" ""bcb"" ""cab"" ""cac"" ""cba"" ""cbc""]. You will find the 9th string = ""cab""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 10`\n  * `1 <= k <= 100`\n\n","class Solution:\n    def getHappyString(self n: int k: int) -> str:\n        ans = []\n        letters = ['a''b''c']\n        def happystr(nprevtemp):\n            if n==0:\n                ans.append("""".join(temp))\n                return \n            for l in letters: \n                if l!=prev: \n                    happystr(n-1ltemp+[l])\n        happystr(n""""[])\n        if len(ans)<k:\n            return """"\n        return ans[k-1]\n            \n            \n"
The kth Factor of n,###  1492\. The kth Factor of n\n\nYou are given two positive integers `n` and `k`. A factor of an integer `n` is\ndefined as an integer `i` where `n % i == 0`.\n\nConsider a list of all factors of `n` sorted in **ascending order**  return\n_the_`kth` _factor_ in this list or return `-1` if `n` has less than `k`\nfactors.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 12 k = 3\n    **Output:** 3\n    **Explanation:** Factors list is [1 2 3 4 6 12] the 3rd factor is 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 7 k = 2\n    **Output:** 7\n    **Explanation:** Factors list is [1 7] the 2nd factor is 7.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 4 k = 4\n    **Output:** -1\n    **Explanation:** Factors list is [1 2 4] there is only 3 factors. We should return -1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= k <= n <= 1000`\n\n\n\n**Follow up:**\n\nCould you solve this problem in less than O(n) complexity?\n\n,class Solution:\n    def kthFactor(self n: int k: int) -> int:\n        start=[1]\n        end=[n]\n        for i in range(2math.ceil(math.sqrt(n))+1):\n            if n%i==0:\n                start.append(i)\n                if i!=n//i:\n                    end.append(n//i)\n        start=sorted(set(start).union(set(end)))\n        if k<=len(start):\n            return start[k-1]\n        else:\n            return -1\n
The Number of Good Subsets,###  1994\. The Number of Good Subsets\n\nYou are given an integer array `nums`. We call a subset of `nums` **good** if\nits product can be represented as a product of one or more **distinct prime**\nnumbers.\n\n  * For example if `nums = [1 2 3 4]`: \n    * `[2 3]` `[1 2 3]` and `[1 3]` are **good** subsets with products `6 = 2*3` `6 = 2*3` and `3 = 3` respectively.\n    * `[1 4]` and `[4]` are not **good** subsets with products `4 = 2*2` and `4 = 2*2` respectively.\n\nReturn _the number of different**good** subsets in _`nums` _**modulo** _`109 +\n7`.\n\nA **subset** of `nums` is any array that can be obtained by deleting some\n(possibly none or all) elements from `nums`. Two subsets are different if and\nonly if the chosen indices to delete are different.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [1234]\n    **Output:** 6\n    **Explanation:** The good subsets are:\n    - [12]: product is 2 which is the product of distinct prime 2.\n    - [123]: product is 6 which is the product of distinct primes 2 and 3.\n    - [13]: product is 3 which is the product of distinct prime 3.\n    - [2]: product is 2 which is the product of distinct prime 2.\n    - [23]: product is 6 which is the product of distinct primes 2 and 3.\n    - [3]: product is 3 which is the product of distinct prime 3.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [42315]\n    **Output:** 5\n    **Explanation:** The good subsets are:\n    - [2]: product is 2 which is the product of distinct prime 2.\n    - [23]: product is 6 which is the product of distinct primes 2 and 3.\n    - [215]: product is 30 which is the product of distinct primes 2 3 and 5.\n    - [3]: product is 3 which is the product of distinct prime 3.\n    - [15]: product is 15 which is the product of distinct primes 3 and 5.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `1 <= nums[i] <= 30`\n\n,"from collections import Counter\nfrom functools import lru_cache\nfrom typing import List Tuple\n\nPRIMES = (2 3 5 7 11 13 17 19 23 29)\n\nBIG_NUMBER = 10 ** 9 + 7\n\n\n@lru_cache(maxsize=32)\ndef factor(n) -> Tuple[int bool]:\n    """"""\n    :param n: 1 < n <= max(PRIMES)\n    :return: (factors in bit mask has duplicate primes)\n    """"""\n    output = 0\n\n    for e in PRIMES:\n        while n > 1 and n % e == 0:\n            mask = 1 << e\n\n            if mask & output:\n                return -1 False\n\n            output |= mask\n\n            n //= e\n\n        if n == 1:\n            break\n\n    return output True\n\n\nclass Solution:\n    def numberOfGoodSubsets(self nums: List[int]) -> int:\n        masks = []\n\n        for e in nums:\n            if 1 < e and (fr := factor(e))[1]:\n                masks.append(fr[0])\n\n        cnt = Counter(masks)\n        good_nums = Counter({0: 0})\n\n        for mask in cnt:\n            for f in tuple(good_nums):\n                if f & mask:  # some prime dividing ""mask"" is also dividing the ""f""\n                    continue\n\n                new_mask = f | mask\n\n                count_for_new_mask = good_nums[new_mask] + cnt[mask] * (good_nums[f] or 1)\n\n                good_nums[new_mask] = count_for_new_mask % BIG_NUMBER\n\n        effect_of_one = pow(2 nums.count(1) BIG_NUMBER)\n        total_subsets_without_one = sum(good_nums.values()) % BIG_NUMBER\n\n        return (effect_of_one * total_subsets_without_one) % BIG_NUMBER\n"
The Number of the Smallest Unoccupied Chair,###  1942\. The Number of the Smallest Unoccupied Chair\n\nThere is a party where `n` friends numbered from `0` to `n - 1` are attending.\nThere is an **infinite** number of chairs in this party that are numbered from\n`0` to `infinity`. When a friend arrives at the party they sit on the\nunoccupied chair with the **smallest number**.\n\n  * For example if chairs `0` `1` and `5` are occupied when a friend comes they will sit on chair number `2`.\n\nWhen a friend leaves the party their chair becomes unoccupied at the moment\nthey leave. If another friend arrives at that same moment they can sit in\nthat chair.\n\nYou are given a **0-indexed** 2D integer array `times` where `times[i] =\n[arrivali leavingi]` indicating the arrival and leaving times of the `ith`\nfriend respectively and an integer `targetFriend`. All arrival times are\n**distinct**.\n\nReturn _the**chair number** that the friend numbered _`targetFriend` _will sit\non_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** times = [[14][23][46]] targetFriend = 1\n    **Output:** 1\n    **Explanation:** \n    - Friend 0 arrives at time 1 and sits on chair 0.\n    - Friend 1 arrives at time 2 and sits on chair 1.\n    - Friend 1 leaves at time 3 and chair 1 becomes empty.\n    - Friend 0 leaves at time 4 and chair 0 becomes empty.\n    - Friend 2 arrives at time 4 and sits on chair 0.\n    Since friend 1 sat on chair 1 we return 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** times = [[310][15][26]] targetFriend = 0\n    **Output:** 2\n    **Explanation:** \n    - Friend 1 arrives at time 1 and sits on chair 0.\n    - Friend 2 arrives at time 2 and sits on chair 1.\n    - Friend 0 arrives at time 3 and sits on chair 2.\n    - Friend 1 leaves at time 5 and chair 0 becomes empty.\n    - Friend 2 leaves at time 6 and chair 1 becomes empty.\n    - Friend 0 leaves at time 10 and chair 2 becomes empty.\n    Since friend 0 sat on chair 2 we return 2.\n    \n\n\n\n**Constraints:**\n\n  * `n == times.length`\n  * `2 <= n <= 104`\n  * `times[i].length == 2`\n  * `1 <= arrivali < leavingi <= 105`\n  * `0 <= targetFriend <= n - 1`\n  * Each `arrivali` time is **distinct**.\n\n,class Solution:\n    def smallestChair(self times: List[List[int]] targetFriend: int) -> int:\n        arrivals = []\n        departures = []\n        for ind (x y) in enumerate(times):\n            heappush(arrivals (x ind))\n            heappush(departures (y ind))\n        d = {}\n        occupied = [0] * len(times)\n        while True:\n            if arrivals and departures and arrivals[0][0] < departures[0][0]:\n                _ ind = heappop(arrivals)\n                d[ind] = occupied.index(0)\n                occupied[d[ind]] = 1\n                if ind == targetFriend:\n                    return d[ind]\n            elif arrivals and departures and arrivals[0][0] >= departures[0][0]:\n                _ ind = heappop(departures)\n                occupied[d[ind]] = 0\n
The Number of Weak Characters in the Game,###  1996\. The Number of Weak Characters in the Game\n\nYou are playing a game that contains multiple characters and each of the\ncharacters has **two** main properties: **attack** and **defense**. You are\ngiven a 2D integer array `properties` where `properties[i] = [attacki\ndefensei]` represents the properties of the `ith` character in the game.\n\nA character is said to be **weak** if any other character has **both** attack\nand defense levels **strictly greater** than this character's attack and\ndefense levels. More formally a character `i` is said to be **weak** if there\nexists another character `j` where `attackj > attacki` and `defensej >\ndefensei`.\n\nReturn _the number of**weak** characters_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** properties = [[55][63][36]]\n    **Output:** 0\n    **Explanation:** No character has strictly greater attack and defense than the other.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** properties = [[22][33]]\n    **Output:** 1\n    **Explanation:** The first character is weak because the second character has a strictly greater attack and defense.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** properties = [[15][104][43]]\n    **Output:** 1\n    **Explanation:** The third character is weak because the second character has a strictly greater attack and defense.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= properties.length <= 105`\n  * `properties[i].length == 2`\n  * `1 <= attacki defensei <= 105`\n\n,# Runtime: 4914 ms (Top 7.28%) | Memory: 66.6 MB (Top 91.64%)\nclass Solution:\n    def numberOfWeakCharacters(self properties: List[List[int]]) -> int:\n\n        properties.sort(key=lambda x: (-x[0]x[1]))\n\n        ans = 0\n        curr_max = 0\n\n        for _ d in properties:\n            if d < curr_max:\n                ans += 1\n            else:\n                curr_max = d\n        return ans
The Score of Students Solving Math Expression,"###  2019\. The Score of Students Solving Math Expression\n\nYou are given a string `s` that contains digits `0-9` addition symbols `'+'`\nand multiplication symbols `'*'` **only**  representing a **valid** math\nexpression of **single digit numbers** (e.g. `3+5*2`). This expression was\ngiven to `n` elementary school students. The students were instructed to get\nthe answer of the expression by following this **order of operations** :\n\n  1. Compute **multiplication**  reading from **left to right** ; Then\n  2. Compute **addition**  reading from **left to right**.\n\nYou are given an integer array `answers` of length `n` which are the\nsubmitted answers of the students in no particular order. You are asked to\ngrade the `answers` by following these **rules** :\n\n  * If an answer **equals** the correct answer of the expression this student will be rewarded `5` points;\n  * Otherwise if the answer **could be interpreted** as if the student applied the operators **in the wrong order** but had **correct arithmetic**  this student will be rewarded `2` points;\n  * Otherwise this student will be rewarded `0` points.\n\nReturn _the sum of the points of the students_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/09/17/student_solving_math.png)\n\n    \n    \n    **Input:** s = ""7+3*1*2"" answers = [201342]\n    **Output:** 7\n    **Explanation:** As illustrated above the correct answer of the expression is 13 therefore one student is rewarded 5 points: [20_**13**_ 42]\n    A student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [_**20**_ 1342]\n    The points for the students are: [250]. The sum of the points is 2+5+0=7.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""3+5*2"" answers = [1301013131616]\n    **Output:** 19\n    **Explanation:** The correct answer of the expression is 13 therefore three students are rewarded 5 points each: [**_13_** 010**_13_** **_13_** 1616]\n    A student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [130101313**_16_** **_16_**]\n    The points for the students are: [5005522]. The sum of the points is 5+0+0+5+5+2+2=19.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""6+0*1"" answers = [1296486]\n    **Output:** 10\n    **Explanation:** The correct answer of the expression is 6.\n    If a student had incorrectly done (6+0)*1 the answer would also be 6.\n    By the rules of grading the students will still be rewarded 5 points (as they got the correct answer) not 2 points.\n    The points for the students are: [005005]. The sum of the points is 10.\n    \n\n\n\n**Constraints:**\n\n  * `3 <= s.length <= 31`\n  * `s` represents a valid expression that contains only digits `0-9` `'+'` and `'*'` only.\n  * All the integer operands in the expression are in the **inclusive** range `[0 9]`.\n  * `1 <=` The count of all operators (`'+'` and `'*'`) in the math expression `<= 15`\n  * Test data are generated such that the correct answer of the expression is in the range of `[0 1000]`.\n  * `n == answers.length`\n  * `1 <= n <= 104`\n  * `0 <= answers[i] <= 1000`\n\n","class Solution:\n    def scoreOfStudents(self s: str answers: List[int]) -> int:\n        \n        @cache\n        def fn(lo hi): \n            """"""Return possible answers of s[lo:hi].""""""\n            if lo+1 == hi: return {int(s[lo])}\n            ans = set()\n            for mid in range(lo+1 hi 2): \n                for x in fn(lo mid): \n                    for y in fn(mid+1 hi): \n                        if s[mid] == ""+"" and x + y <= 1000: ans.add(x + y)\n                        elif s[mid] == ""*"" and x * y <= 1000: ans.add(x * y)\n            return ans \n                \n        target = eval(s)\n        cand = fn(0 len(s))\n        ans = 0 \n        for x in answers: \n            if x == target: ans += 5\n            elif x in cand: ans += 2\n        return ans "
The Skyline Problem,"###  218\. The Skyline Problem\n\nA city's **skyline** is the outer contour of the silhouette formed by all the\nbuildings in that city when viewed from a distance. Given the locations and\nheights of all the buildings return _the**skyline** formed by these buildings\ncollectively_.\n\nThe geometric information of each building is given in the array `buildings`\nwhere `buildings[i] = [lefti righti heighti]`:\n\n  * `lefti` is the x coordinate of the left edge of the `ith` building.\n  * `righti` is the x coordinate of the right edge of the `ith` building.\n  * `heighti` is the height of the `ith` building.\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely\nflat surface at height `0`.\n\nThe **skyline** should be represented as a list of ""key points"" **sorted by\ntheir x-coordinate** in the form `[[x1y1][x2y2]...]`. Each key point is\nthe left endpoint of some horizontal segment in the skyline except the last\npoint in the list which always has a y-coordinate `0` and is used to mark the\nskyline's termination where the rightmost building ends. Any ground between\nthe leftmost and rightmost buildings should be part of the skyline's contour.\n\n**Note:** There must be no consecutive horizontal lines of equal height in the\noutput skyline. For instance `[...[2 3][4 5][7 5][11 5][12 7]...]` is\nnot acceptable; the three lines of height 5 should be merged into one in the\nfinal output as such: `[...[2 3][4 5][12 7]...]`\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/01/merged.jpg)\n\n    \n    \n    **Input:** buildings = [[2910][3715][51212][152010][19248]]\n    **Output:** [[210][315][712][120][1510][208][240]]\n    **Explanation:**\n    Figure A shows the buildings of the input.\n    Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** buildings = [[023][253]]\n    **Output:** [[03][50]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= buildings.length <= 104`\n  * `0 <= lefti < righti <= 231 - 1`\n  * `1 <= heighti <= 231 - 1`\n  * `buildings` is sorted by `lefti` in non-decreasing order.\n\n",class Solution:\n    def getSkyline(self buildings: List[List[int]]) -> List[List[int]]:\n        d = collections.defaultdict(list)\n        \n        for i(start end height) in enumerate(buildings):\n            d[start].append(height)\n            d[end].append(-height)\n            \n        l = list(d.keys())\n        l.sort()\n        \n        result = []\n        \n        active = []\n        \n        for key in l:\n            o = d[key]\n            o.sort(reverse=True)\n            for j in o:\n                if j > 0:\n                    if not result or not active:\n                        result.append([key j])\n                        active.append(j)\n                    else:\n                        if j > active[-1]:\n                            result.append([key j])\n                            active.append(j)\n                        else:\n                            active.insert(bisect_left(active j) j)\n                else:\n                    idx = active.index(-j)\n                    if idx == len(active) - 1:\n                        active.pop()\n                        if active:\n                            result.append([key active[-1]])\n                        else:\n                            result.append([key 0])\n                    else:\n                        active.pop(idx)\n        \n        return result\n                        \n
The Time When the Network Becomes Idle,###  2039\. The Time When the Network Becomes Idle\n\nThere is a network of `n` servers labeled from `0` to `n - 1`. You are given\na 2D integer array `edges` where `edges[i] = [ui vi]` indicates there is a\nmessage channel between servers `ui` and `vi` and they can pass **any**\nnumber of messages to **each other** directly in **one** second. You are also\ngiven a **0-indexed** integer array `patience` of length `n`.\n\nAll servers are **connected**  i.e. a message can be passed from one server\nto any other server(s) directly or indirectly through the message channels.\n\nThe server labeled `0` is the **master** server. The rest are **data**\nservers. Each data server needs to send its message to the master server for\nprocessing and wait for a reply. Messages move between servers **optimally** \nso every message takes the **least amount of time** to arrive at the master\nserver. The master server will process all newly arrived messages\n**instantly** and send a reply to the originating server via the **reversed\npath** the message had gone through.\n\nAt the beginning of second `0` each data server sends its message to be\nprocessed. Starting from second `1` at the **beginning** of **every** second\neach data server will check if it has received a reply to the message it sent\n(including any newly arrived replies) from the master server:\n\n  * If it has not it will **resend** the message periodically. The data server `i` will resend the message every `patience[i]` second(s) i.e. the data server `i` will resend the message if `patience[i]` second(s) have **elapsed** since the **last** time the message was sent from this server.\n  * Otherwise **no more resending** will occur from this server.\n\nThe network becomes **idle** when there are **no** messages passing between\nservers or arriving at servers.\n\nReturn _the**earliest second** starting from which the network becomes\n**idle**_.\n\n\n\n**Example 1:**\n\n![example 1](https://assets.leetcode.com/uploads/2021/09/22/quiet-place-\nexample1.png)\n\n    \n    \n    **Input:** edges = [[01][12]] patience = [021]\n    **Output:** 8\n    **Explanation:**\n    At (the beginning of) second 0\n    - Data server 1 sends its message (denoted 1A) to the master server.\n    - Data server 2 sends its message (denoted 2A) to the master server.\n    \n    At second 1\n    - Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back.\n    - Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message therefore it does not resend the message.\n    - Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message therefore it resends the message (denoted 2B).\n    \n    At second 2\n    - The reply 1A arrives at server 1. No more resending will occur from server 1.\n    - Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back.\n    - Server 2 resends the message (denoted 2C).\n    ...\n    At second 4\n    - The reply 2A arrives at server 2. No more resending will occur from server 2.\n    ...\n    At second 7 reply 2D arrives at server 2.\n    \n    Starting from the beginning of the second 8 there are no messages passing between servers or arriving at servers.\n    This is the time when the network becomes idle.\n    \n\n**Example 2:**\n\n![example\n2](https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png)\n\n    \n    \n    **Input:** edges = [[01][02][12]] patience = [01010]\n    **Output:** 3\n    **Explanation:** Data servers 1 and 2 receive a reply back at the beginning of second 2.\n    From the beginning of the second 3 the network becomes idle.\n    \n\n\n\n**Constraints:**\n\n  * `n == patience.length`\n  * `2 <= n <= 105`\n  * `patience[0] == 0`\n  * `1 <= patience[i] <= 105` for `1 <= i < n`\n  * `1 <= edges.length <= min(105 n * (n - 1) / 2)`\n  * `edges[i].length == 2`\n  * `0 <= ui vi < n`\n  * `ui != vi`\n  * There are no duplicate edges.\n  * Each server can directly or indirectly reach another server.\n\n,# Runtime: 2578 ms (Top 92.45%) | Memory: 69.3 MB (Top 19.78%)\nclass Solution:\n    def networkBecomesIdle(self edges: List[List[int]] patience: List[int]) -> int:\n\n        #Build Adjency List\n        adjList = defaultdict(list)\n\n        for source target in edges:\n            adjList[source].append(target)\n            adjList[target].append(source)\n\n        #BFS to get the shortest route from node to master.\n        shortest = {}\n        queue = deque([(00)])\n        seen = set()\n        while queue:\n            currPos currDist = queue.popleft()\n\n            if currPos in seen:\n                continue\n            seen.add(currPos)\n            shortest[currPos] = currDist\n\n            for nei in adjList[currPos]:\n                queue.append((nei currDist+1))\n\n        #Calculate answer using shortest paths.\n        ans = 0\n        for index in range(1len(patience)):\n            resendInterval = patience[index]\n\n            #The server will stop sending requests after it's been sent to the master node and back.\n            shutOffTime = (shortest[index] * 2)\n\n            # shutOffTime-1 == Last second the server can send a re-request.\n            lastSecond = shutOffTime-1\n\n            #Calculate the last time a packet is actually resent.\n            lastResentTime = (lastSecond//resendInterval)*resendInterval\n\n            # At the last resent time the packet still must go through 2 more cycles to the master node and back.\n            lastPacketTime = lastResentTime + shutOffTime\n\n            ans = max(lastPacketTime ans)\n\n        #Add +1 the current answer is the last time the packet is recieved by the target server (still active).\n        #We must return the first second the network is idle therefore + 1\n        return ans + 1
Third Maximum Number,###  414\. Third Maximum Number\n\nGiven an integer array `nums` return _the**third distinct maximum** number in\nthis array. If the third maximum does not exist return the **maximum**\nnumber_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [321]\n    **Output:** 1\n    **Explanation:**\n    The first distinct maximum is 3.\n    The second distinct maximum is 2.\n    The third distinct maximum is 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [12]\n    **Output:** 2\n    **Explanation:**\n    The first distinct maximum is 2.\n    The second distinct maximum is 1.\n    The third distinct maximum does not exist so the maximum (2) is returned instead.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [2231]\n    **Output:** 1\n    **Explanation:**\n    The first distinct maximum is 3.\n    The second distinct maximum is 2 (both 2's are counted together since they have the same value).\n    The third distinct maximum is 1.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 104`\n  * `-231 <= nums[i] <= 231 - 1`\n\n\n\n**Follow up:** Can you find an `O(n)` solution?\n\n,class Solution:\n    def thirdMax(self nums: List[int]) -> int:\n        nums_set = set(nums)\n        sorted_set = sorted(nums_set)\n        return sorted_set[-3] if len(nums_set) >2 else sorted_set[-1]\n    \n    \n            #use set() to remove dups\n            #if len of nums after dups have been removed is at least 2 a third max val must exist\n            #if not just return the max\n        \n        \n        #you can do it in 1 line like this but then you have to call the same functions repeatedly\n        #return sorted(set(nums))[-3] if len(set(nums)) > 2  else sorted(set(nums))[-1]\n    \n \n    \n
Thousand Separator,"###  1556\. Thousand Separator\n\nGiven an integer `n` add a dot (""."") as the thousands separator and return it\nin string format.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 987\n    **Output:** ""987""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1234\n    **Output:** ""1.234""\n    \n\n\n\n**Constraints:**\n\n  * `0 <= n <= 231 - 1`\n\n","# Runtime: 17 ms (Top 24.0%) | Memory: 13.24 MB (Top 48.1%)\n\nclass Solution(object):\n    def thousandSeparator(self n):\n        """"""\n        :type n: int\n        :rtype: str\n        """"""\n        n = str(n)\n        if len(n) <= 3:\n            return str(n)\n        result = """"      \n        dot = '.'\n        index = 0\n        startPos = len(n) % 3 \n        if startPos == 0:\n            startPos += 3\n        val = -1\n        while index < len(n):\n            result += n[index]\n            if index == startPos - 1:\n                result += dot\n                val = 0\n            if val != -1:\n                val += 1\n                if val > 3 and (val - 1) % 3 == 0 and index != len(n) - 1:\n                    result += dot\n                    val = 1  \n            index += 1\n\n        return result"
Three Consecutive Odds,###  1550\. Three Consecutive Odds\n\nGiven an integer array `arr` return `true` if there are three consecutive odd\nnumbers in the array. Otherwise return `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [2641]\n    **Output:** false\n    **Explanation:** There are no three consecutive odds.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [123434572312]\n    **Output:** true\n    **Explanation:** [5723] are three consecutive odds.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 1000`\n  * `1 <= arr[i] <= 1000`\n\n,# Runtime: 106 ms (Top 5.05%) | Memory: 14 MB (Top 60.17%)\nclass Solution:\n    def threeConsecutiveOdds(self arr: List[int]) -> bool:\n        c=0\n        for i in arr:\n            if i%2==0:\n                c=0\n            else:\n                c+=1\n                if c==3:\n                    return True\n        return False
Three Divisors,###  1952\. Three Divisors\n\nGiven an integer `n` return `true` _if_`n` _has**exactly three positive\ndivisors**. Otherwise return _`false`.\n\nAn integer `m` is a **divisor** of `n` if there exists an integer `k` such\nthat `n = k * m`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 2\n    **Output:** false\n    **Explantion:** 2 has only two divisors: 1 and 2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4\n    **Output:** true\n    **Explantion:** 4 has three divisors: 1 2 and 4.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 104`\n\n,// Runtime: 34 ms (Top 88.51%) | Memory: 16.40 MB (Top 53.4%)\n\nclass Solution:\n    def isThree(self n: int) -> bool:\n        return sum(n%i == 0 for i in range(1 n+1)) == 3\n
Three Equal Parts,###  927\. Three Equal Parts\n\nYou are given an array `arr` which consists of only zeros and ones divide the\narray into **three non-empty parts** such that all of these parts represent\nthe same binary value.\n\nIf it is possible return any `[i j]` with `i + 1 < j` such that:\n\n  * `arr[0] arr[1] ... arr[i]` is the first part\n  * `arr[i + 1] arr[i + 2] ... arr[j - 1]` is the second part and\n  * `arr[j] arr[j + 1] ... arr[arr.length - 1]` is the third part.\n  * All three parts have equal binary values.\n\nIf it is not possible return `[-1 -1]`.\n\nNote that the entire part is used when considering what binary value it\nrepresents. For example `[110]` represents `6` in decimal not `3`. Also\nleading zeros **are allowed**  so `[011]` and `[11]` represent the same\nvalue.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [10101]\n    **Output:** [03]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [11011]\n    **Output:** [-1-1]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [11001]\n    **Output:** [02]\n    \n\n\n\n**Constraints:**\n\n  * `3 <= arr.length <= 3 * 104`\n  * `arr[i]` is `0` or `1`\n\n,class Solution:\n    def threeEqualParts(self arr: List[int]) -> List[int]:\n        n = len(arr)\n        count_one = arr.count(1)\n        if count_one == 0: return [0n-1]\n        if count_one % 3!= 0: return [-1-1]\n        target_ones = count_one // 3\n        breaks = []\n        one_count = 0\n        for i  bit in enumerate(arr):\n            if bit ==1 :\n                one_count +=1\n                if one_count in [1target_ones+12*target_ones+1]:breaks.append(i)   \n                if one_count in [target_ones2*target_ones3*target_ones]:breaks.append(i)\n        i1j1i2j2i3j3 = breaks\n        \n        if not arr[i1:j1+1] == arr[i2:j2+1] == arr[i3:j3+1]:return [-1-1]\n        \n        trailing_zeroes_left  = i2 - j1 - 1\n        trailing_zeroes_mid   = i3 - j2 - 1\n        trailing_zeroes_right = n -  j3 - 1\n        if trailing_zeroes_right > min(trailing_zeroes_lefttrailing_zeroes_mid):return [-1-1]\n        j1 += trailing_zeroes_right\n        j2 += trailing_zeroes_right\n        return [j1j2+1]\n    \n
Throne Inheritance,"###  1600\. Throne Inheritance\n\nA kingdom consists of a king his children his grandchildren and so on.\nEvery once in a while someone in the family dies or a child is born.\n\nThe kingdom has a well-defined order of inheritance that consists of the king\nas the first member. Let's define the recursive function `Successor(x\ncurOrder)` which given a person `x` and the inheritance order so far returns\nwho should be the next person after `x` in the order of inheritance.\n\n    \n    \n    Successor(x curOrder):\n        if x has no children or all of x's children are in curOrder:\n            if x is the king return null\n            else return Successor(x's parent curOrder)\n        else return x's oldest child who's not in curOrder\n    \n\nFor example assume we have a kingdom that consists of the king his children\nAlice and Bob (Alice is older than Bob) and finally Alice's son Jack.\n\n  1. In the beginning `curOrder` will be `[""king""]`.\n  2. Calling `Successor(king curOrder)` will return Alice so we append to `curOrder` to get `[""king"" ""Alice""]`.\n  3. Calling `Successor(Alice curOrder)` will return Jack so we append to `curOrder` to get `[""king"" ""Alice"" ""Jack""]`.\n  4. Calling `Successor(Jack curOrder)` will return Bob so we append to `curOrder` to get `[""king"" ""Alice"" ""Jack"" ""Bob""]`.\n  5. Calling `Successor(Bob curOrder)` will return `null`. Thus the order of inheritance will be `[""king"" ""Alice"" ""Jack"" ""Bob""]`.\n\nUsing the above function we can always obtain a unique order of inheritance.\n\nImplement the `ThroneInheritance` class:\n\n  * `ThroneInheritance(string kingName)` Initializes an object of the `ThroneInheritance` class. The name of the king is given as part of the constructor.\n  * `void birth(string parentName string childName)` Indicates that `parentName` gave birth to `childName`.\n  * `void death(string name)` Indicates the death of `name`. The death of the person doesn't affect the `Successor` function nor the current inheritance order. You can treat it as just marking the person as dead.\n  * `string[] getInheritanceOrder()` Returns a list representing the current order of inheritance **excluding** dead people.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""ThroneInheritance"" ""birth"" ""birth"" ""birth"" ""birth"" ""birth"" ""birth"" ""getInheritanceOrder"" ""death"" ""getInheritanceOrder""]\n    [[""king""] [""king"" ""andy""] [""king"" ""bob""] [""king"" ""catherine""] [""andy"" ""matthew""] [""bob"" ""alex""] [""bob"" ""asha""] [null] [""bob""] [null]]\n    **Output**\n    [null null null null null null null [""king"" ""andy"" ""matthew"" ""bob"" ""alex"" ""asha"" ""catherine""] null [""king"" ""andy"" ""matthew"" ""alex"" ""asha"" ""catherine""]]\n    \n    **Explanation**\n    ThroneInheritance t= new ThroneInheritance(""king""); // order: **king**\n    t.birth(""king"" ""andy""); // order: king > **andy**\n    t.birth(""king"" ""bob""); // order: king > andy > **bob**\n    t.birth(""king"" ""catherine""); // order: king > andy > bob > **catherine**\n    t.birth(""andy"" ""matthew""); // order: king > andy > **matthew** > bob > catherine\n    t.birth(""bob"" ""alex""); // order: king > andy > matthew > bob > **alex** > catherine\n    t.birth(""bob"" ""asha""); // order: king > andy > matthew > bob > alex > **asha** > catherine\n    t.getInheritanceOrder(); // return [""king"" ""andy"" ""matthew"" ""bob"" ""alex"" ""asha"" ""catherine""]\n    t.death(""bob""); // order: king > andy > matthew > **~~bob~~** > alex > asha > catherine\n    t.getInheritanceOrder(); // return [""king"" ""andy"" ""matthew"" ""alex"" ""asha"" ""catherine""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= kingName.length parentName.length childName.length name.length <= 15`\n  * `kingName` `parentName` `childName` and `name` consist of lowercase English letters only.\n  * All arguments `childName` and `kingName` are **distinct**.\n  * All `name` arguments of `death` will be passed to either the constructor or as `childName` to `birth` first.\n  * For each call to `birth(parentName childName)` it is guaranteed that `parentName` is alive.\n  * At most `105` calls will be made to `birth` and `death`.\n  * At most `10` calls will be made to `getInheritanceOrder`.\n\n",# Runtime: 1338 ms (Top 35.29%) | Memory: 68.8 MB (Top 82.35%)\n\nclass ThroneInheritance:\n\n    def __init__(self kingName: str):\n        # Taking kingName as root\n        self.root = kingName\n\n        # notDead will hold all the people who are alive and their level number\n        self.alive = {}\n        self.alive[kingName] = 0\n\n        # hold edges existing in our graph\n        self.edges = {self.root:[]}\n\n    def birth(self parentName: str childName: str) -> None:\n        # birth --> new child so update alive\n        self.alive[childName] = self.alive[parentName]+1\n\n        # add parent to child edges in the edges dictionary\n        if parentName in self.edges:\n            self.edges[parentName].append(childName)\n            if childName not in self.edges:\n                self.edges[childName] = []\n        else:\n            if childName not in self.edges:\n                self.edges[childName] = []\n            self.edges[parentName] = [childName]\n\n    def death(self name: str) -> None:\n        # removing the dead people from alive map\n        del self.alive[name]\n\n    def getInheritanceOrder(self) -> List[str]:\n\n        hierarchy = []\n        def dfs(curparent=-1):\n            nonlocal hierarchy\n\n            # current person available in alive then only add in hierarchy\n            if cur in self.alive:\n                hierarchy.append(cur)\n\n            # traverse all the children of current node\n            for i in self.edges[cur]:\n                if i!=parent:\n                    dfs(icur)\n        dfs(self.root)\n        return hierarchy
Tiling a Rectangle with the Fewest Squares,###  1240\. Tiling a Rectangle with the Fewest Squares\n\nGiven a rectangle of size `n` x `m` return _the minimum number of integer-\nsided squares that tile the rectangle_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/10/17/sample_11_1592.png)\n\n    \n    \n    **Input:** n = 2 m = 3\n    **Output:** 3\n    **Explanation:** 3 squares are necessary to cover the rectangle.\n    2 (squares of 1x1)\n    1 (square of 2x2)\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/10/17/sample_22_1592.png)\n\n    \n    \n    **Input:** n = 5 m = 8\n    **Output:** 5\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/10/17/sample_33_1592.png)\n\n    \n    \n    **Input:** n = 11 m = 13\n    **Output:** 6\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n m <= 13`\n\n,# Runtime: 197 ms (Top 21.3%) | Memory: 16.48 MB (Top 34.6%)\n\nclass Solution:\n    def tilingRectangle(self n: int m: int) -> int:\n      # try brute force backtracking?\n      board = [[0 for _ in range(n)] for _ in range(m)]\n\n      ans = math.inf\n      def bt(counts):\n        nonlocal ans\n        if counts >= ans:\n          return\n        \n        pos = None\n        found = False\n        for row in range(m):\n          for col in range(n):\n            if board[row][col] == 0:\n              pos = (row col)\n              found = True\n              break\n          if found:\n            break\n        if not found:\n          ans = min(ans counts)\n          return\n\n        # see how many difference size of squares we can place from this spot\n        r c = pos\n        offset = 0\n        while r + offset < m and c + offset < n and board[r + offset][c] == 0 and board[r][c + offset] == 0:\n          offset += 1\n        # max can place size is offset\n        for row in range(r r + offset):\n          for col in range(c c + offset):\n            board[row][col] = 1\n        # do bt and shrink\n        while offset > 0:\n          bt(counts + 1)\n          # shrink\n          for row in range(r r + offset):\n            board[row][c + offset - 1] = 0\n          for col in range(c c + offset):\n            board[r + offset - 1][col] = 0\n          offset -= 1\n\n      bt(0)\n      return ans
Time Based Key-Value Store,"###  981\. Time Based Key-Value Store\n\nDesign a time-based key-value data structure that can store multiple values\nfor the same key at different time stamps and retrieve the key's value at a\ncertain timestamp.\n\nImplement the `TimeMap` class:\n\n  * `TimeMap()` Initializes the object of the data structure.\n  * `void set(String key String value int timestamp)` Stores the key `key` with the value `value `at the given time `timestamp`.\n  * `String get(String key int timestamp)` Returns a value such that `set` was called previously with `timestamp_prev <= timestamp`. If there are multiple such values it returns the value associated with the largest `timestamp_prev`. If there are no values it returns `""""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input**\n    [""TimeMap"" ""set"" ""get"" ""get"" ""set"" ""get"" ""get""]\n    [[] [""foo"" ""bar"" 1] [""foo"" 1] [""foo"" 3] [""foo"" ""bar2"" 4] [""foo"" 4] [""foo"" 5]]\n    **Output**\n    [null null ""bar"" ""bar"" null ""bar2"" ""bar2""]\n    \n    **Explanation**\n    TimeMap timeMap = new TimeMap();\n    timeMap.set(""foo"" ""bar"" 1);  // store the key ""foo"" and value ""bar"" along with timestamp = 1.\n    timeMap.get(""foo"" 1);         // return ""bar""\n    timeMap.get(""foo"" 3);         // return ""bar"" since there is no value corresponding to foo at timestamp 3 and timestamp 2 then the only value is at timestamp 1 is ""bar"".\n    timeMap.set(""foo"" ""bar2"" 4); // store the key ""foo"" and value ""bar2"" along with timestamp = 4.\n    timeMap.get(""foo"" 4);         // return ""bar2""\n    timeMap.get(""foo"" 5);         // return ""bar2""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= key.length value.length <= 100`\n  * `key` and `value` consist of lowercase English letters and digits.\n  * `1 <= timestamp <= 107`\n  * All the timestamps `timestamp` of `set` are strictly increasing.\n  * At most `2 * 105` calls will be made to `set` and `get`.\n\n","class TimeMap:\n\n    def __init__(self):\n        self.dict = {}\n        \n\n    def set(self key: str value: str timestamp: int) -> None:\n        if key not in self.dict:\n            self.dict[key] = ([] [])\n            self.dict[key][0].append(value)\n            self.dict[key][1].append(timestamp)\n        else:\n            self.dict[key][0].append(value)\n            self.dict[key][1].append(timestamp)\n    \n    \n    def bsearch(self nums target):\n        beg = 0\n        end = len(nums)-1\n        lastIndex = len(nums)-1\n        \n        while beg<=end:\n            mid = (beg+end)//2\n            if target == nums[mid]:\n                return mid\n            elif target < nums[mid]:\n                end = mid-1\n            elif target > nums[mid]:\n                beg = mid+1\n        \n        \n        if target < nums[mid] and mid == 0:\n            return -1\n        if target > nums[mid]:\n            return mid\n        return mid-1\n            \n    def get(self key: str timestamp: int) -> str:\n        if key not in self.dict:\n            return """"\n        \n        index = self.bsearch(self.dict[key][1] timestamp)\n        return self.dict[key][0][index] if 0 <= index < len(self.dict[key][0]) else """"\n    \n\n\n# Your TimeMap object will be instantiated and called as such:\n# obj = TimeMap()\n# obj.set(keyvaluetimestamp)\n# param_2 = obj.get(keytimestamp)\n"
Time Needed to Inform All Employees,###  1376\. Time Needed to Inform All Employees\n\nA company has `n` employees with a unique ID for each employee from `0` to `n\n- 1`. The head of the company is the one with `headID`.\n\nEach employee has one direct manager given in the `manager` array where\n`manager[i]` is the direct manager of the `i-th` employee `manager[headID] =\n-1`. Also it is guaranteed that the subordination relationships have a tree\nstructure.\n\nThe head of the company wants to inform all the company employees of an urgent\npiece of news. He will inform his direct subordinates and they will inform\ntheir subordinates and so on until all employees know about the urgent news.\n\nThe `i-th` employee needs `informTime[i]` minutes to inform all of his direct\nsubordinates (i.e. After informTime[i] minutes all his direct subordinates\ncan start spreading the news).\n\nReturn _the number of minutes_ needed to inform all the employees about the\nurgent news.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 1 headID = 0 manager = [-1] informTime = [0]\n    **Output:** 0\n    **Explanation:** The head of the company is the only employee in the company.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/02/27/graph.png)\n\n    \n    \n    **Input:** n = 6 headID = 2 manager = [22-1222] informTime = [001000]\n    **Output:** 1\n    **Explanation:** The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\n    The tree structure of the employees in the company is shown.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 105`\n  * `0 <= headID < n`\n  * `manager.length == n`\n  * `0 <= manager[i] < n`\n  * `manager[headID] == -1`\n  * `informTime.length == n`\n  * `0 <= informTime[i] <= 1000`\n  * `informTime[i] == 0` if employee `i` has no subordinates.\n  * It is **guaranteed** that all the employees can be informed.\n\n,"import queue\nclass Solution:\n	def numOfMinutes(self n: int headID: int manager: List[int]time: List[int]) -> int:\n		nodes = []\n		for i in range(n): nodes.append([])\n		for i in range(n): \n			if i != headID: nodes[manager[i]].append(i)\n\n		q = queue.LifoQueue()\n		q.put([headID0])\n		ans = 0\n		while not q.empty():\n			cur = q.get()\n			for nxt in nodes[cur[0]]:\n				q.put([nxtcur[1]+time[cur[0]]])\n				ans = max(anscur[1]+time[cur[0]])\n		return ans"
Toeplitz Matrix,"###  766\. Toeplitz Matrix\n\nGiven an `m x n` `matrix` return _`true` if the matrix is Toeplitz.\nOtherwise return `false`._\n\nA matrix is **Toeplitz** if every diagonal from top-left to bottom-right has\nthe same elements.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg)\n\n    \n    \n    **Input:** matrix = [[1234][5123][9512]]\n    **Output:** true\n    **Explanation:**\n    In the above grid the diagonals are:\n    ""[9]"" ""[5 5]"" ""[1 1 1]"" ""[2 2 2]"" ""[3 3]"" ""[4]"".\n    In each diagonal all elements are the same so the answer is True.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg)\n\n    \n    \n    **Input:** matrix = [[12][22]]\n    **Output:** false\n    **Explanation:**\n    The diagonal ""[1 2]"" has different elements.\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m n <= 20`\n  * `0 <= matrix[i][j] <= 99`\n\n\n\n**Follow up:**\n\n  * What if the `matrix` is stored on disk and the memory is limited such that you can only load at most one row of the matrix into the memory at once?\n  * What if the `matrix` is so large that you can only load up a partial row into the memory at once?\n\n",###########################################################################################\n#   Runtime: O(MN)\n#       Number of rows(M) x expected numbers(N)\n#   Space: O(N)\n#       We need to store the expected numbers in list\n############################################################################################\nclass Solution:\n    def isToeplitzMatrix(self matrix: List[List[int]]) -> bool:\n        # Validate Input\n        if not matrix or not matrix[0]:\n            return False                \n        \n        # Create a deque tracking the expected values for the next row\n        expected = matrix[0]\n        # We only care about the elements before last element\n        expected.pop()\n        \n        # From the second row pop out the last element of the expected numbers and compare it with the target row[1:]\n        for row in matrix[1:]:\n            # Compare row with expected numbers invalidate it as soon as we find the numbers are not the same (O(N))\n            if row[1:] != expected:\n                return False\n            else:\n                # Pop the last element from row use it as the expected numbers for the next iteration\n                row.pop()\n                expected = row\n        # If we've reached here all diagonals aligned\n        return True\n
Top K Frequent Elements,###  347\. Top K Frequent Elements\n\nGiven an integer array `nums` and an integer `k` return _the_ `k` _most\nfrequent elements_. You may return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [111223] k = 2\n    **Output:** [12]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1] k = 1\n    **Output:** [1]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 105`\n  * `-104 <= nums[i] <= 104`\n  * `k` is in the range `[1 the number of unique elements in the array]`.\n  * It is **guaranteed** that the answer is **unique**.\n\n\n\n**Follow up:** Your algorithm's time complexity must be better than `O(n log\nn)` where n is the array's size.\n\n,class Solution:\n    def topKFrequent(self nums: List[int] k: int) -> List[int]:\n        return [i[0] for i in Counter(nums).most_common(k)]\n
Top K Frequent Words,"###  692\. Top K Frequent Words\n\nGiven an array of strings `words` and an integer `k` return _the_`k` _most\nfrequent strings_.\n\nReturn the answer **sorted** by **the frequency** from highest to lowest. Sort\nthe words with the same frequency by their **lexicographical order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""i""""love""""leetcode""""i""""love""""coding""] k = 2\n    **Output:** [""i""""love""]\n    **Explanation:** ""i"" and ""love"" are the two most frequent words.\n    Note that ""i"" comes before ""love"" due to a lower alphabetical order.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""the""""day""""is""""sunny""""the""""the""""the""""sunny""""is""""is""] k = 4\n    **Output:** [""the""""is""""sunny""""day""]\n    **Explanation:** ""the"" ""is"" ""sunny"" and ""day"" are the four most frequent words with the number of occurrence being 4 3 2 and 1 respectively.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 500`\n  * `1 <= words[i].length <= 10`\n  * `words[i]` consists of lowercase English letters.\n  * `k` is in the range `[1 The number of **unique** words[i]]`\n\n\n\n**Follow-up:** Could you solve it in `O(n log(k))` time and `O(n)` extra\nspace?\n\n",import heapq\nclass Solution:\n    def topKFrequent(self words: List[str] k: int) -> List[str]:\n        \n        li = {}\n        for i in words:\n            if i in li:\n                li[i]+=1\n            else:\n                li[i]=1\n        \n        heap = []\n        for i in li:\n            heap.append([-li[i]i])\n        \n        heapq.heapify(heap)\n        \n        ans = []\n        for i in range(k):\n            ans.append(heapq.heappop(heap)[1])\n        \n        return ans
Total Appeal of A String,"###  2262\. Total Appeal of A String\n\nThe **appeal** of a string is the number of **distinct** characters found in\nthe string.\n\n  * For example the appeal of `""abbca""` is `3` because it has `3` distinct characters: `'a'` `'b'` and `'c'`.\n\nGiven a string `s` return _the**total appeal of all of its**substrings**.**_\n\nA **substring** is a contiguous sequence of characters within a string.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""abbca""\n    **Output:** 28\n    **Explanation:** The following are the substrings of ""abbca"":\n    - Substrings of length 1: ""a"" ""b"" ""b"" ""c"" ""a"" have an appeal of 1 1 1 1 and 1 respectively. The sum is 5.\n    - Substrings of length 2: ""ab"" ""bb"" ""bc"" ""ca"" have an appeal of 2 1 2 and 2 respectively. The sum is 7.\n    - Substrings of length 3: ""abb"" ""bbc"" ""bca"" have an appeal of 2 2 and 3 respectively. The sum is 7.\n    - Substrings of length 4: ""abbc"" ""bbca"" have an appeal of 3 and 3 respectively. The sum is 6.\n    - Substrings of length 5: ""abbca"" has an appeal of 3. The sum is 3.\n    The total sum is 5 + 7 + 7 + 6 + 3 = 28.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""code""\n    **Output:** 20\n    **Explanation:** The following are the substrings of ""code"":\n    - Substrings of length 1: ""c"" ""o"" ""d"" ""e"" have an appeal of 1 1 1 and 1 respectively. The sum is 4.\n    - Substrings of length 2: ""co"" ""od"" ""de"" have an appeal of 2 2 and 2 respectively. The sum is 6.\n    - Substrings of length 3: ""cod"" ""ode"" have an appeal of 3 and 3 respectively. The sum is 6.\n    - Substrings of length 4: ""code"" has an appeal of 4. The sum is 4.\n    The total sum is 4 + 6 + 6 + 4 = 20.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of lowercase English letters.\n\n",// Runtime: 201 ms (Top 33.23%) | Memory: 18.20 MB (Top 28.53%)\n\nclass Solution:\n    def appealSum(self s: str) -> int:\n        res n prev = 0 len(s) defaultdict(lambda: -1)\n        for i ch in enumerate(s):\n            res += (i - prev[ch]) * (n - i)\n            prev[ch] = i\n        return res\n
Transform to Chessboard,###  782\. Transform to Chessboard\n\nYou are given an `n x n` binary grid `board`. In each move you can swap any\ntwo rows with each other or any two columns with each other.\n\nReturn _the minimum number of moves to transform the board into a**chessboard\nboard**_. If the task is impossible return `-1`.\n\nA **chessboard board** is a board where no `0`'s and no `1`'s are\n4-directionally adjacent.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/06/29/chessboard1-grid.jpg)\n\n    \n    \n    **Input:** board = [[0110][0110][1001][1001]]\n    **Output:** 2\n    **Explanation:** One potential sequence of moves is shown.\n    The first move swaps the first and second column.\n    The second move swaps the second and third row.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/06/29/chessboard2-grid.jpg)\n\n    \n    \n    **Input:** board = [[01][10]]\n    **Output:** 0\n    **Explanation:** Also note that the board with 0 in the top left corner is also a valid chessboard.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/06/29/chessboard3-grid.jpg)\n\n    \n    \n    **Input:** board = [[10][10]]\n    **Output:** -1\n    **Explanation:** No matter what sequence of moves you make you cannot end with a valid chessboard.\n    \n\n\n\n**Constraints:**\n\n  * `n == board.length`\n  * `n == board[i].length`\n  * `2 <= n <= 30`\n  * `board[i][j]` is either `0` or `1`.\n\n,class Solution(object):\n    def movesToChessboard(self board):\n        N = len(board)\n        ans = 0\n        # For each count of lines from {rows columns}...\n        for count in (collections.Counter(map(tuple board))  # get row\n                      collections.Counter(zip(*board))): #get column\n\n            # If there are more than 2 kinds of lines\n            # or if the number of kinds is not appropriate ...\n            if len(count) != 2 or sorted(count.values()) != [N/2 (N+1)/2]:\n                return -1\n\n            # If the lines are not opposite each other impossible\n            line1 line2 = count\n            if not all(x ^ y for x y in zip(line1 line2)):\n                return -1\n\n            # starts = what could be the starting value of line1\n            # If N is odd then we have to start with the more\n            # frequent element\n            starts = [int(line1.count(1) * 2 > N)] if N%2 else [0 1]\n\n            # To transform line1 into the ideal line [i%2 for i ...]\n            # we take the number of differences and divide by two\n            ans += min(sum((x-i) % 2 for i x in enumerate(line1 start))\n                       for start in starts) / 2            \n\n        return ans\n
Transpose Matrix,###  867\. Transpose Matrix\n\nGiven a 2D integer array `matrix` return _the**transpose** of_ `matrix`.\n\nThe **transpose** of a matrix is the matrix flipped over its main diagonal\nswitching the matrix's row and column indices.\n\n![](https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png)\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** matrix = [[123][456][789]]\n    **Output:** [[147][258][369]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** matrix = [[123][456]]\n    **Output:** [[14][25][36]]\n    \n\n\n\n**Constraints:**\n\n  * `m == matrix.length`\n  * `n == matrix[i].length`\n  * `1 <= m n <= 1000`\n  * `1 <= m * n <= 105`\n  * `-109 <= matrix[i][j] <= 109`\n\n,class Solution:\n    def transpose(self matrix: List[List[int]]) -> List[List[int]]:\n        rows=len(matrix)\n        cols=len(matrix[0])\n        ans=[[0]*rows]*cols\n        for i in range(cols):\n            for j in range(rows):\n                ans[i][j]=matrix[j][i]\n        return ans\n
Trapping Rain Water,###  42\. Trapping Rain Water\n\nGiven `n` non-negative integers representing an elevation map where the width\nof each bar is `1` compute how much water it can trap after raining.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png)\n\n    \n    \n    **Input:** height = [010210132121]\n    **Output:** 6\n    **Explanation:** The above elevation map (black section) is represented by array [010210132121]. In this case 6 units of rain water (blue section) are being trapped.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** height = [420325]\n    **Output:** 9\n    \n\n\n\n**Constraints:**\n\n  * `n == height.length`\n  * `1 <= n <= 2 * 104`\n  * `0 <= height[i] <= 105`\n\n,# Runtime: 254 ms (Top 43.79%) | Memory: 16.1 MB (Top 46.67%)\nclass Solution:\n    def trap(self a: List[int]) -> int:\n        l=0\n        r=len(a)-1\n        maxl=0\n        maxr=0\n        res=0\n\n        while (l<=r):\n            if a[l]<=a[r]:\n                if a[l]>=maxl: maxl=a[l] #update maxl if a[l] is >=\n                else: res+=maxl-a[l] #adding captured water when maxl>a[l]\n                l+=1\n            else:\n                if a[r]>=maxr: maxr=a[r]\n                else: res+=maxr-a[r]\n                r-=1\n        return res\n
Trapping Rain Water II,###  407\. Trapping Rain Water II\n\nGiven an `m x n` integer matrix `heightMap` representing the height of each\nunit cell in a 2D elevation map return _the volume of water it can trap after\nraining_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/04/08/trap1-3d.jpg)\n\n    \n    \n    **Input:** heightMap = [[143132][321324][233231]]\n    **Output:** 4\n    **Explanation:** After the rain water is trapped between the blocks.\n    We have two small ponds 1 and 3 units trapped.\n    The total volume of water trapped is 4.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/04/08/trap2-3d.jpg)\n\n    \n    \n    **Input:** heightMap = [[33333][32223][32123][32223][33333]]\n    **Output:** 10\n    \n\n\n\n**Constraints:**\n\n  * `m == heightMap.length`\n  * `n == heightMap[i].length`\n  * `1 <= m n <= 200`\n  * `0 <= heightMap[i][j] <= 2 * 104`\n\n,import heapq\nclass Solution:\n    def trapRainWater(self heightMap: List[List[int]]) -> int:\n        ROW COL = len(heightMap) len(heightMap[0])\n\n        pq = []\n        heapq.heapify(pq)\n        visited = {}\n        \n        for row in range(ROW):\n            for col in range(COL):\n                if row == 0 or row == ROW-1 or col == 0 or col == COL-1:\n                    heapq.heappush(pq (heightMap[row][col]rowcol))\n                    visited[(rowcol)] = True\n                    \n        def getnbr(rowcol):\n            res = []\n            if row-1 >=0:\n                res.append((row-1col))\n            if col-1 >=0:\n                res.append((row col-1))\n            if row+1 < ROW:\n                res.append((row+1col))\n            if col+1 < COL:\n                res.append((row col+1))\n\n            return res\n        \n        res = 0\n        \n        while pq:\n            h i j = heapq.heappop(pq)\n            \n            for dx dy in getnbr(ij):\n                if (dxdy) not in visited:  \n                    \n                    res += max(0 h-heightMap[dx][dy])\n                    \n                    heapq.heappush(pq (max(h heightMap[dx][dy])dxdy))\n                    visited[(dxdy)] = True\n\n        return res\n
Tree of Coprimes,###  1766\. Tree of Coprimes\n\nThere is a tree (i.e. a connected undirected graph that has no cycles)\nconsisting of `n` nodes numbered from `0` to `n - 1` and exactly `n - 1`\nedges. Each node has a value associated with it and the **root** of the tree\nis node `0`.\n\nTo represent this tree you are given an integer array `nums` and a 2D array\n`edges`. Each `nums[i]` represents the `ith` node's value and each `edges[j]\n= [uj vj]` represents an edge between nodes `uj` and `vj` in the tree.\n\nTwo values `x` and `y` are **coprime** if `gcd(x y) == 1` where `gcd(x y)`\nis the **greatest common divisor** of `x` and `y`.\n\nAn ancestor of a node `i` is any other node on the shortest path from node `i`\nto the **root**. A node is **not** considered an ancestor of itself.\n\nReturn _an array_`ans` _of size_`n` _where_`ans[i]`_is the closest ancestor\nto node_`i` _such that_`nums[i]` _and_`nums[ans[i]]` are **coprime**  or `-1`\n_if there is no such ancestor_.\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2021/01/06/untitled-diagram.png)**\n\n    \n    \n    **Input:** nums = [2332] edges = [[01][12][13]]\n    **Output:** [-1001]\n    **Explanation:** In the above figure each node's value is in parentheses.\n    - Node 0 has no coprime ancestors.\n    - Node 1 has only one ancestor node 0. Their values are coprime (gcd(23) == 1).\n    - Node 2 has two ancestors nodes 1 and 0. Node 1's value is not coprime (gcd(33) == 3) but node 0's\n      value is (gcd(23) == 1) so node 0 is the closest valid ancestor.\n    - Node 3 has two ancestors nodes 1 and 0. It is coprime with node 1 (gcd(32) == 1) so node 1 is its\n      closest valid ancestor.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/06/untitled-diagram1.png)\n\n    \n    \n    **Input:** nums = [561023615] edges = [[01][02][13][14][25][26]]\n    **Output:** [-10-1000-1]\n    \n\n\n\n**Constraints:**\n\n  * `nums.length == n`\n  * `1 <= nums[i] <= 50`\n  * `1 <= n <= 105`\n  * `edges.length == n - 1`\n  * `edges[j].length == 2`\n  * `0 <= uj vj < n`\n  * `uj != vj`\n\n,class Solution:\n    def getCoprimes(self nums: List[int] edges: List[List[int]]) -> List[int]:\n        \n        gcdset = [set() for i in range(51)]\n        for i in range(151):\n            for j in range(151):\n                if math.gcd(ij) == 1:\n                    gcdset[i].add(j)\n                    gcdset[j].add(i)\n        \n        graph = defaultdict(list)\n        for v1 v2 in edges:\n            graph[v1].append(v2)\n            graph[v2].append(v1)\n        \n        ans = [-1]*len(nums)\n        q = [[0 {}]]\n        seen = set([0])\n        depth = 0\n        while q:\n            temp = []\n            for node ancestors in q:\n                index_depth = (-1-1)\n                for anc in list(ancestors.keys()):\n                    if anc in gcdset[nums[node]]:\n                        index d = ancestors[anc]\n                        if d > index_depth[1]:\n                            index_depth = (indexd)\n                ans[node] = index_depth[0]\n                \n                copy = ancestors.copy()\n                copy[nums[node]] = (nodedepth)\n                \n                for child in graph[node]:\n                    if child not in seen:\n                        seen.add(child)\n                        temp.append([child copy])\n            q = temp\n            depth += 1\n        return ans
Triangle,###  120\. Triangle\n\nGiven a `triangle` array return _the minimum path sum from top to bottom_.\n\nFor each step you may move to an adjacent number of the row below. More\nformally if you are on index `i` on the current row you may move to either\nindex `i` or index `i + 1` on the next row.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** triangle = [[2][34][657][4183]]\n    **Output:** 11\n    **Explanation:** The triangle looks like:\n       _2_\n      _3_ 4\n     6 _5_ 7\n    4 _1_ 8 3\n    The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** triangle = [[-10]]\n    **Output:** -10\n    \n\n\n\n**Constraints:**\n\n  * `1 <= triangle.length <= 200`\n  * `triangle[0].length == 1`\n  * `triangle[i].length == triangle[i - 1].length + 1`\n  * `-104 <= triangle[i][j] <= 104`\n\n\n\n**Follow up:** Could you do this using only `O(n)` extra space where `n` is\nthe total number of rows in the triangle?\n\n,class Solution:\n    def minimumTotal(self t: List[List[int]]) -> int:\n        dp = []\n        dp.append(t[0])\n        \n        r = len(t)\n        answer = float('inf')\n        for i in range(1 r):\n            c = len(t[i])\n            dp.append([])\n            for j in range(0 c):\n                if j == 0:\n                    val = dp[i - 1][j] + t[i][j]\n                elif j == c - 1:\n                    val = dp[i - 1][j - 1] + t[i][j]\n                else:\n                    val = min(dp[i - 1][j] dp[i - 1][j - 1]) + t[i][j]\n                if i == r - 1:\n                    answer = min(answer val)\n                dp[i].append(val)\n        return answer if r > 1 else t[0][0]\n
Trim a Binary Search Tree,###  669\. Trim a Binary Search Tree\n\nGiven the `root` of a binary search tree and the lowest and highest boundaries\nas `low` and `high` trim the tree so that all its elements lies in `[low\nhigh]`. Trimming the tree should **not** change the relative structure of the\nelements that will remain in the tree (i.e. any node's descendant should\nremain a descendant). It can be proven that there is a **unique answer**.\n\nReturn _the root of the trimmed binary search tree_. Note that the root may\nchange depending on the given bounds.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)\n\n    \n    \n    **Input:** root = [102] low = 1 high = 2\n    **Output:** [1null2]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg)\n\n    \n    \n    **Input:** root = [304null2nullnull1] low = 1 high = 3\n    **Output:** [32null1]\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `0 <= Node.val <= 104`\n  * The value of each node in the tree is **unique**.\n  * `root` is guaranteed to be a valid binary search tree.\n  * `0 <= low <= high <= 104`\n\n,"// Runtime: 58 ms (Top 27.96%) | Memory: 20.40 MB (Top 38.8%)\n\nclass Solution:\n	def trimBST(self root: TreeNode low: int high: int) -> TreeNode:\n		if not root: return root\n		if root.val < low: return self.trimBST(root.right low high)\n		if root.val > high: return self.trimBST(root.left low high)\n		root.left = self.trimBST(root.left low high)\n		root.right = self.trimBST(root.right low high)\n		return root"
Triples with Bitwise AND Equal To Zero,###  982\. Triples with Bitwise AND Equal To Zero\n\nGiven an integer array nums return _the number of**AND triples**_.\n\nAn **AND triple** is a triple of indices `(i j k)` such that:\n\n  * `0 <= i < nums.length`\n  * `0 <= j < nums.length`\n  * `0 <= k < nums.length`\n  * `nums[i] & nums[j] & nums[k] == 0` where `&` represents the bitwise-AND operator.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [213]\n    **Output:** 12\n    **Explanation:** We could choose the following i j k triples:\n    (i=0 j=0 k=1) : 2 & 2 & 1\n    (i=0 j=1 k=0) : 2 & 1 & 2\n    (i=0 j=1 k=1) : 2 & 1 & 1\n    (i=0 j=1 k=2) : 2 & 1 & 3\n    (i=0 j=2 k=1) : 2 & 3 & 1\n    (i=1 j=0 k=0) : 1 & 2 & 2\n    (i=1 j=0 k=1) : 1 & 2 & 1\n    (i=1 j=0 k=2) : 1 & 2 & 3\n    (i=1 j=1 k=0) : 1 & 1 & 2\n    (i=1 j=2 k=0) : 1 & 3 & 2\n    (i=2 j=0 k=1) : 3 & 2 & 1\n    (i=2 j=1 k=0) : 3 & 1 & 2\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [000]\n    **Output:** 27\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `0 <= nums[i] < 216`\n\n,# Runtime: 549 ms (Top 98.6%) | Memory: 23.43 MB (Top 9.7%)\n\nclass Solution:\n    def countTriplets(self nums: List[int]) -> int:\n        freq = defaultdict(int)\n        for x in nums: \n            for y in nums: \n                freq[x&y] += 1\n        \n        ans = 0\n        for x in nums: \n            mask = x = x ^ 0xffff\n            while x: \n                ans += freq[x]\n                x = mask & (x-1)\n            ans += freq[0]\n        return ans 
Truncate Sentence,"###  1816\. Truncate Sentence\n\nA **sentence** is a list of words that are separated by a single space with no\nleading or trailing spaces. Each of the words consists of **only** uppercase\nand lowercase English letters (no punctuation).\n\n  * For example `""Hello World""` `""HELLO""` and `""hello world hello world""` are all sentences.\n\nYou are given a sentence `s`​​​​​​ and an integer\n`k`​​​​​​. You want to **truncate** `s`​​​​​​ such\nthat it contains only the **first** `k`​​​​​​ words. Return\n`s`​​​​ _​​ after**truncating** it._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""Hello how are you Contestant"" k = 4\n    **Output:** ""Hello how are you""\n    **Explanation:**\n    The words in s are [""Hello"" ""how"" ""are"" ""you"" ""Contestant""].\n    The first 4 words are [""Hello"" ""how"" ""are"" ""you""].\n    Hence you should return ""Hello how are you"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""What is the solution to this problem"" k = 4\n    **Output:** ""What is the solution""\n    **Explanation:**\n    The words in s are [""What"" ""is"" ""the"" ""solution"" ""to"" ""this"" ""problem""].\n    The first 4 words are [""What"" ""is"" ""the"" ""solution""].\n    Hence you should return ""What is the solution"".\n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""chopper is not a tanuki"" k = 5\n    **Output:** ""chopper is not a tanuki""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 500`\n  * `k` is in the range `[1 the number of words in s]`.\n  * `s` consist of only lowercase and uppercase English letters and spaces.\n  * The words in `s` are separated by a single space.\n  * There are no leading or trailing spaces.\n\n","class Solution:\n    def truncateSentence(self s: str k: int) -> str:\n        words = s.split("" "")\n        return "" "".join(words[0:k])\n"
Tuple with Same Product,###  1726\. Tuple with Same Product\n\nGiven an array `nums` of **distinct** positive integers return _the number of\ntuples_`(a b c d)`_such that_`a * b = c * d` _where_`a` __`b` __`c` _\nand_`d` _are elements of_`nums` _ and_`a != b != c != d` _._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [2346]\n    **Output:** 8\n    **Explanation:** There are 8 valid tuples:\n    (2634)  (2643)  (6234)  (6243)\n    (3426)  (4326)  (3462)  (4362)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [124510]\n    **Output:** 16\n    **Explanation:** There are 16 valid tuples:\n    (11025)  (11052)  (10125)  (10152)\n    (25110)  (25101)  (52110)  (52101)\n    (21045)  (21054)  (10245)  (10254)\n    (45210)  (45102)  (54210)  (54102)\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `1 <= nums[i] <= 104`\n  * All elements in `nums` are **distinct**.\n\n,# Runtime: 1072 ms (Top 44.44%) | Memory: 42.9 MB (Top 86.75%)\nclass Solution:\n    def tupleSameProduct(self nums: List[int]) -> int:\n\n        from itertools import combinations\n        mydict=defaultdict(int)\n        ans=0\n\n        for ab in combinations(nums2):\n            mydict[a*b]+=1\n\n        for ij in mydict.items():\n            if j>1:\n                ans+=(j*(j-1)//2)*8\n\n        return ans
Tweet Counts Per Frequency,"###  1348\. Tweet Counts Per Frequency\n\nA social media company is trying to monitor activity on their site by\nanalyzing the number of tweets that occur in select periods of time. These\nperiods can be partitioned into smaller **time chunks** based on a certain\nfrequency (every **minute**  **hour**  or **day**).\n\nFor example the period `[10 10000]` (in **seconds**) would be partitioned\ninto the following **time chunks** with these frequencies:\n\n  * Every **minute** (60-second chunks): `[1069]` `[70129]` `[130189]` `...` `[997010000]`\n  * Every **hour** (3600-second chunks): `[103609]` `[36107209]` `[721010000]`\n  * Every **day** (86400-second chunks): `[1010000]`\n\nNotice that the last chunk may be shorter than the specified frequency's chunk\nsize and will always end with the end time of the period (`10000` in the above\nexample).\n\nDesign and implement an API to help the company with their analysis.\n\nImplement the `TweetCounts` class:\n\n  * `TweetCounts()` Initializes the `TweetCounts` object.\n  * `void recordTweet(String tweetName int time)` Stores the `tweetName` at the recorded `time` (in **seconds**).\n  * `List<Integer> getTweetCountsPerFrequency(String freq String tweetName int startTime int endTime)` Returns a list of integers representing the number of tweets with `tweetName` in each **time chunk** for the given period of time `[startTime endTime]` (in **seconds**) and frequency `freq`. \n    * `freq` is one of `""minute""` `""hour""` or `""day""` representing a frequency of every **minute**  **hour**  or **day** respectively.\n\n\n\n**Example:**\n\n    \n    \n    **Input**\n    [""TweetCounts""""recordTweet""""recordTweet""""recordTweet""""getTweetCountsPerFrequency""""getTweetCountsPerFrequency""""recordTweet""""getTweetCountsPerFrequency""]\n    [[][""tweet3""0][""tweet3""60][""tweet3""10][""minute""""tweet3""059][""minute""""tweet3""060][""tweet3""120][""hour""""tweet3""0210]]\n    \n    **Output**\n    [nullnullnullnull[2][21]null[4]]\n    \n    **Explanation**\n    TweetCounts tweetCounts = new TweetCounts();\n    tweetCounts.recordTweet(""tweet3"" 0);                              // New tweet ""tweet3"" at time 0\n    tweetCounts.recordTweet(""tweet3"" 60);                             // New tweet ""tweet3"" at time 60\n    tweetCounts.recordTweet(""tweet3"" 10);                             // New tweet ""tweet3"" at time 10\n    tweetCounts.getTweetCountsPerFrequency(""minute"" ""tweet3"" 0 59); // return [2]; chunk [059] had 2 tweets\n    tweetCounts.getTweetCountsPerFrequency(""minute"" ""tweet3"" 0 60); // return [21]; chunk [059] had 2 tweets chunk [6060] had 1 tweet\n    tweetCounts.recordTweet(""tweet3"" 120);                            // New tweet ""tweet3"" at time 120\n    tweetCounts.getTweetCountsPerFrequency(""hour"" ""tweet3"" 0 210);  // return [4]; chunk [0210] had 4 tweets\n    \n\n\n\n**Constraints:**\n\n  * `0 <= time startTime endTime <= 109`\n  * `0 <= endTime - startTime <= 104`\n  * There will be at most `104` calls **in total** to `recordTweet` and `getTweetCountsPerFrequency`.\n\n","import bisect\nclass TweetCounts:\n\n    def __init__(self):\n        self.tweets = {}\n        \n\n    def recordTweet(self tweetName: str time: int) -> None:\n        if not tweetName in self.tweets:\n            self.tweets[tweetName] = []\n        index = bisect.bisect_left(self.tweets[tweetName] time)\n        self.tweets[tweetName].insert(index time)\n        \n    \n    def getTweetCountsPerFrequency(self freq: str tweetName: str startTime: int endTime: int) -> List[int]:\n        \n        def find(step):\n            nonlocal tweet\n            result = []\n            for i in range(startTime endTime+1 step):\n                result.append(bisect.bisect_right(tweet min(endTime i + step - 1)) - bisect.bisect_left(tweet i))\n            return result\n                \n                \n        tweet = self.tweets[tweetName]\n        if freq == ""minute"":\n            return find(60)\n        elif freq == ""hour"":\n            return find(3600)\n        else:\n            return find(86400)"
Two Best Non-Overlapping Events,###  2054\. Two Best Non-Overlapping Events\n\nYou are given a **0-indexed** 2D integer array of `events` where `events[i] =\n[startTimei endTimei valuei]`. The `ith` event starts at `startTimei` and\nends at `endTimei` and if you attend this event you will receive a value of\n`valuei`. You can choose **at most** **two** **non-overlapping** events to\nattend such that the sum of their values is **maximized**.\n\nReturn _this**maximum** sum._\n\nNote that the start time and end time is **inclusive** : that is you cannot\nattend two events where one of them starts and the other ends at the same\ntime. More specifically if you attend an event with end time `t` the next\nevent must start at or after `t + 1`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/09/21/picture5.png)\n\n    \n    \n    **Input:** events = [[132][452][243]]\n    **Output:** 4\n    **Explanation:** Choose the green events 0 and 1 for a sum of 2 + 2 = 4.\n    \n\n**Example 2:**\n\n![Example 1\nDiagram](https://assets.leetcode.com/uploads/2021/09/21/picture1.png)\n\n    \n    \n    **Input:** events = [[132][452][155]]\n    **Output:** 5\n    **Explanation:** Choose event 2 for a sum of 5.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/09/21/picture3.png)\n\n    \n    \n    **Input:** events = [[153][151][665]]\n    **Output:** 8\n    **Explanation:** Choose events 0 and 2 for a sum of 3 + 5 = 8.\n\n\n\n**Constraints:**\n\n  * `2 <= events.length <= 105`\n  * `events[i].length == 3`\n  * `1 <= startTimei <= endTimei <= 109`\n  * `1 <= valuei <= 106`\n\n,class Solution:\ndef maxTwoEvents(self events: List[List[int]]) -> int:\n    \n    events.sort()\n    heap = []\n    res2res1 = 00\n    for sep in events:\n        while heap and heap[0][0]<s:\n            res1 = max(res1heapq.heappop(heap)[1])\n        \n        res2 = max(res2res1+p)\n        heapq.heappush(heap(ep))\n    \n    return res2\n
Two Furthest Houses With Different Colors,###  2078\. Two Furthest Houses With Different Colors\n\nThere are `n` houses evenly lined up on the street and each house is\nbeautifully painted. You are given a **0-indexed** integer array `colors` of\nlength `n` where `colors[i]` represents the color of the `ith` house.\n\nReturn _the**maximum** distance between **two** houses with **different**\ncolors_.\n\nThe distance between the `ith` and `jth` houses is `abs(i - j)` where\n`abs(x)` is the **absolute value** of `x`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/10/31/eg1.png)\n\n    \n    \n    **Input:** colors = [_**1**_ 11**_6_** 111]\n    **Output:** 3\n    **Explanation:** In the above image color 1 is blue and color 6 is red.\n    The furthest two houses with different colors are house 0 and house 3.\n    House 0 has color 1 and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\n    Note that houses 3 and 6 can also produce the optimal answer.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/10/31/eg2.png)\n\n    \n    \n    **Input:** colors = [_**1**_ 838_**3**_]\n    **Output:** 4\n    **Explanation:** In the above image color 1 is blue color 8 is yellow and color 3 is green.\n    The furthest two houses with different colors are house 0 and house 4.\n    House 0 has color 1 and house 4 has color 3. The distance between them is abs(0 - 4) = 4.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** colors = [_**0**_ **_1_**]\n    **Output:** 1\n    **Explanation:** The furthest two houses with different colors are house 0 and house 1.\n    House 0 has color 0 and house 1 has color 1. The distance between them is abs(0 - 1) = 1.\n    \n\n\n\n**Constraints:**\n\n  * `n == colors.length`\n  * `2 <= n <= 100`\n  * `0 <= colors[i] <= 100`\n  * Test data are generated such that **at least** two houses have different colors.\n\n,"// Runtime: 33 ms (Top 98.18%) | Memory: 17.40 MB (Top 5.01%)\n\nclass Solution:\n    def maxDistance(self colors: List[int]) -> int:\n		#first pass\n        l r = 0 len(colors)-1\n        dist = 0\n        \n        while r > l:\n            if colors[r] != colors[l]:\n                dist = r-l\n				#slight performance increase break out if you find it \n				#because it can't get bigger than this\n                break \n            r -= 1\n			\n        #second pass backwards\n        l r = 0 len(colors)-1\n        while r > l:\n            if colors[r] != colors[l]:\n                dist = max(dist r-l)\n                break\n            l += 1\n        \n        return dist\n	\n"
Two Out of Three,###  2032\. Two Out of Three\n\nGiven three integer arrays `nums1` `nums2` and `nums3` return\n_a**distinct** array containing all the values that are present in **at least\ntwo** out of the three arrays. You may return the values in **any** order_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums1 = [1132] nums2 = [23] nums3 = [3]\n    **Output:** [32]\n    **Explanation:** The values that are present in at least two arrays are:\n    - 3 in all three arrays.\n    - 2 in nums1 and nums2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [31] nums2 = [23] nums3 = [12]\n    **Output:** [231]\n    **Explanation:** The values that are present in at least two arrays are:\n    - 2 in nums2 and nums3.\n    - 3 in nums1 and nums2.\n    - 1 in nums1 and nums3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [122] nums2 = [433] nums3 = [5]\n    **Output:** []\n    **Explanation:** No value is present in at least two arrays.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length nums3.length <= 100`\n  * `1 <= nums1[i] nums2[j] nums3[k] <= 100`\n\n,# Runtime: 65 ms (Top 93.8%) | Memory: 16.30 MB (Top 83.7%)\n\nclass Solution:\n    def twoOutOfThree(self nums1: List[int] nums2: List[int] nums3: List[int]) -> List[int]:\n        output = []\n        for i in nums1:\n            if i in nums2 or i in nums3:\n                if i not in output:\n                    output.append(i)\n        for j in nums2:\n            if j in nums3 or j in nums1:\n                if j not in output:\n                    output.append(j)\n        return output
Two Sum,###  1\. Two Sum\n\nGiven an array of integers `nums` and an integer `target` return _indices of\nthe two numbers such that they add up to`target`_.\n\nYou may assume that each input would have **_exactly_ one solution** and you\nmay not use the _same_ element twice.\n\nYou can return the answer in any order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [271115] target = 9\n    **Output:** [01]\n    **Explanation:** Because nums[0] + nums[1] == 9 we return [0 1].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [324] target = 6\n    **Output:** [12]\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [33] target = 6\n    **Output:** [01]\n    \n\n\n\n**Constraints:**\n\n  * `2 <= nums.length <= 104`\n  * `-109 <= nums[i] <= 109`\n  * `-109 <= target <= 109`\n  * **Only one valid answer exists.**\n\n\n\n**Follow-up:  **Can you come up with an algorithm that is less than `O(n2)\n`time complexity?\n\n,// Runtime: 2571 ms (Top 18.27%) | Memory: 17.10 MB (Top 86.21%)\n\nclass Solution:\n    def twoSum(self nums: List[int] target: int) -> List[int]:\n        n = len(nums)\n        for i in range(n - 1):\n            for j in range(i + 1 n):\n                if nums[i] + nums[j] == target:\n                    return [i j]\n        return []  # No solution found\n\n
Ugly Number,###  263\. Ugly Number\n\nAn **ugly number** is a positive integer whose prime factors are limited to\n`2` `3` and `5`.\n\nGiven an integer `n` return `true` _if_ `n` _is an**ugly number**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 6\n    **Output:** true\n    **Explanation:** 6 = 2 × 3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** true\n    **Explanation:** 1 has no prime factors therefore all of its prime factors are limited to 2 3 and 5.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 14\n    **Output:** false\n    **Explanation:** 14 is not ugly since it includes the prime factor 7.\n    \n\n\n\n**Constraints:**\n\n  * `-231 <= n <= 231 - 1`\n\n,class Solution:\n    def isUgly(self n: int) -> bool:\n        if n == 0:\n            return False\n        res=[2 3 5]\n        while n!= 1:\n            for i in res:\n               if n%i==0:\n                   n=n//i\n                   break\n            else:\n                return False\n        return True
Ugly Number II,###  264\. Ugly Number II\n\nAn **ugly number** is a positive integer whose prime factors are limited to\n`2` `3` and `5`.\n\nGiven an integer `n` return _the_ `nth` _**ugly number**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 10\n    **Output:** 12\n    **Explanation:** [1 2 3 4 5 6 8 9 10 12] is the sequence of the first 10 ugly numbers.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1\n    **Explanation:** 1 has no prime factors therefore all of its prime factors are limited to 2 3 and 5.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1690`\n\n,# Runtime: 354 ms (Top 28.01%) | Memory: 13.9 MB (Top 55.93%)\nimport heapq\nclass Solution:\n    def nthUglyNumber(self n: int) -> int:\n        h1 h2 h3 = [] [] []\n        heapq.heappush(h1 1)\n        heapq.heappush(h2 1)\n        heapq.heappush(h3 1)\n        ugly_number = 1\n        last_ugly_number = 1\n        count = 1\n        while count < n:\n            if 2 * h1[0] <= 3 * h2[0] and 2 * h1[0] <= 5 * h3[0]:\n                # pop from h1\n                x = heapq.heappop(h1)\n                ugly_number = 2 * x\n                if ugly_number == last_ugly_number:\n                    # do nothing\n                    continue\n                count+=1\n                last_ugly_number = ugly_number\n                heapq.heappush(h1 ugly_number)\n                heapq.heappush(h2 ugly_number)\n                heapq.heappush(h3 ugly_number)\n\n            elif 3 * h2[0] <= 2 * h1[0] and 3 * h2[0] <= 5 * h3[0]:\n                # pop from h2\n                x = heapq.heappop(h2)\n                ugly_number = 3 * x\n                if ugly_number == last_ugly_number:\n                    continue\n                count+=1\n                last_ugly_number = ugly_number\n                heapq.heappush(h1 ugly_number)\n                heapq.heappush(h2 ugly_number)\n                heapq.heappush(h3 ugly_number)\n            else:\n                # pop from h3\n                x = heapq.heappop(h3)\n                ugly_number = 5 * x\n                if ugly_number == last_ugly_number:\n                    continue\n                count+=1\n                last_ugly_number = ugly_number\n                heapq.heappush(h1 ugly_number)\n                heapq.heappush(h2 ugly_number)\n                heapq.heappush(h3 ugly_number)\n\n        return last_ugly_number
Ugly Number III,###  1201\. Ugly Number III\n\nAn **ugly number** is a positive integer that is divisible by `a` `b` or\n`c`.\n\nGiven four integers `n` `a` `b` and `c` return the `nth` **ugly number**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 3 a = 2 b = 3 c = 5\n    **Output:** 4\n    **Explanation:** The ugly numbers are 2 3 4 5 6 8 9 10... The 3rd is 4.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4 a = 2 b = 3 c = 4\n    **Output:** 6\n    **Explanation:** The ugly numbers are 2 3 4 6 8 9 10 12... The 4th is 6.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** n = 5 a = 2 b = 11 c = 13\n    **Output:** 10\n    **Explanation:** The ugly numbers are 2 4 6 8 10 11 12 13... The 5th is 10.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n a b c <= 109`\n  * `1 <= a * b * c <= 1018`\n  * It is guaranteed that the result will be in range `[1 2 * 109]`.\n\n,class Solution:\n    def nthUglyNumber(self n: int a: int b: int c: int) -> int:\n        times = [111]\n        smallest = inf\n        while n != 0:\n            smallest = min ( times[0]*atimes[1]*btimes[2]*c)\n            if times[0]*a == smallest: times[0] += 1\n            if times[1]*b == smallest: times[1] += 1\n            if times[2]*c == smallest: times[2] += 1\n            n -= 1\n        return smallest\n
Uncommon Words from Two Sentences,"###  884\. Uncommon Words from Two Sentences\n\nA **sentence** is a string of single-space separated words where each word\nconsists only of lowercase letters.\n\nA word is **uncommon** if it appears exactly once in one of the sentences and\n**does not appear** in the other sentence.\n\nGiven two **sentences** `s1` and `s2` return _a list of all the**uncommon\nwords**_. You may return the answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s1 = ""this apple is sweet"" s2 = ""this apple is sour""\n    **Output:** [""sweet""""sour""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s1 = ""apple apple"" s2 = ""banana""\n    **Output:** [""banana""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s1.length s2.length <= 200`\n  * `s1` and `s2` consist of lowercase English letters and spaces.\n  * `s1` and `s2` do not have leading or trailing spaces.\n  * All the words in `s1` and `s2` are separated by a single space.\n\n",from collections import Counter\nclass Solution:\n    def uncommonFromSentences(self s1: str s2: str) -> List[str]:\n        x = dict(Counter(s1.split() + s2.split()))\n        ans = []\n        for key in x:\n            if x[key] == 1:\n                ans.append(key)\n                \n        return ans
Uncrossed Lines,###  1035\. Uncrossed Lines\n\nYou are given two integer arrays `nums1` and `nums2`. We write the integers of\n`nums1` and `nums2` (in the order they are given) on two separate horizontal\nlines.\n\nWe may draw connecting lines: a straight line connecting two numbers\n`nums1[i]` and `nums2[j]` such that:\n\n  * `nums1[i] == nums2[j]` and\n  * the line we draw does not intersect any other connecting (non-horizontal) line.\n\nNote that a connecting line cannot intersect even at the endpoints (i.e. each\nnumber can only belong to one connecting line).\n\nReturn _the maximum number of connecting lines we can draw in this way_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/04/26/142.png)\n\n    \n    \n    **Input:** nums1 = [142] nums2 = [124]\n    **Output:** 2\n    **Explanation:** We can draw 2 uncrossed lines as in the diagram.\n    We cannot draw 3 uncrossed lines because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums1 = [25125] nums2 = [1052152]\n    **Output:** 3\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums1 = [137175] nums2 = [19251]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums1.length nums2.length <= 500`\n  * `1 <= nums1[i] nums2[j] <= 2000`\n\n,class Solution:\n    def maxUncrossedLines(self nums1: List[int] nums2: List[int]) -> int:\n        \n        @lru_cache(None)\n        def dp(ab):\n            if a>=len(nums1) or b>=len(nums2): return 0\n            if nums1[a]==nums2[b]: return 1+dp(a+1b+1)\n            else: return max(dp(a+1b)dp(ab+1))\n        \n        return dp(00)\n
Unique Binary Search Trees,###  96\. Unique Binary Search Trees\n\nGiven an integer `n` return _the number of structurally unique**BST'** s\n(binary search trees) which has exactly _`n` _nodes of unique values from_ `1`\n_to_ `n`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)\n\n    \n    \n    **Input:** n = 3\n    **Output:** 5\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 19`\n\n,# Runtime: 58 ms (Top 20.54%) | Memory: 13.9 MB (Top 13.32%)\nclass Solution(object):\n    def numTrees(self n):\n        if n == 0 or n == 1:\n            return 1\n        # Create 'sol' array of length n+1...\n        sol = [0] * (n+1)\n        # The value of the first index will be 1.\n        sol[0] = 1\n        # Run a loop from 1 to n+1...\n        for i in range(1 n+1):\n            # Within the above loop run a nested loop from 0 to i...\n            for j in range(i):\n                # Update the i-th position of the array by adding the multiplication of the respective index...\n                sol[i] += sol[j] * sol[i-j-1]\n        # Return the value of the nth index of the array to get the solution...\n        return sol[n]
Unique Binary Search Trees II,###  95\. Unique Binary Search Trees II\n\nGiven an integer `n` return _all the structurally unique**BST'** s (binary\nsearch trees) which has exactly _`n` _nodes of unique values from_ `1` _to_\n`n`. Return the answer in **any order**.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)\n\n    \n    \n    **Input:** n = 3\n    **Output:** [[1null2null3][1null32][213][31nullnull2][32null1]]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 1\n    **Output:** [[1]]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 8`\n\n,# Runtime: 73 ms (Top 74.11%) | Memory: 15.7 MB (Top 42.55%)\n# Definition for a binary tree node.\n# class TreeNode:\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass Solution:\n\n    def generateTrees(self n: int) -> List[Optional[TreeNode]]:\n        # define a sorted list of the numbers for each num in that list  leftvalues\n# are left tree and right val are rightree then for each number create a tree\n# assign the left and right to that root and append the root to the ans\n        nums = list(range(1n+1))\n        def dfs(nums):\n            if not nums:\n                return [None]\n            ans = []\n            for i in range(len(nums)):\n                leftTrees = dfs(nums[:i])\n                rightTrees = dfs(nums[i+1:])\n\n                for l in leftTrees:\n                    for r in rightTrees:\n                        root = TreeNode(nums[i])\n                        root.left = l\n                        root.right = r\n                        ans.append(root)\n            return ans\n\n        return dfs(nums)\n
Unique Email Addresses,"###  929\. Unique Email Addresses\n\nEvery **valid email** consists of a **local name** and a **domain name** \nseparated by the `'@'` sign. Besides lowercase letters the email may contain\none or more `'.'` or `'+'`.\n\n  * For example in `""alice@leetcode.com""` `""alice""` is the **local name**  and `""leetcode.com""` is the **domain name**.\n\nIf you add periods `'.'` between some characters in the **local name** part of\nan email address mail sent there will be forwarded to the same address\nwithout dots in the local name. Note that this rule **does not apply** to\n**domain names**.\n\n  * For example `""alice.z@leetcode.com""` and `""alicez@leetcode.com""` forward to the same email address.\n\nIf you add a plus `'+'` in the **local name**  everything after the first\nplus sign **will be ignored**. This allows certain emails to be filtered. Note\nthat this rule **does not apply** to **domain names**.\n\n  * For example `""m.y+name@email.com""` will be forwarded to `""my@email.com""`.\n\nIt is possible to use both of these rules at the same time.\n\nGiven an array of strings `emails` where we send one email to each\n`emails[i]` return _the number of different addresses that actually receive\nmails_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** emails = [""test.email+alex@leetcode.com""""test.e.mail+bob.cathy@leetcode.com""""testemail+david@lee.tcode.com""]\n    **Output:** 2\n    **Explanation:** ""testemail@leetcode.com"" and ""testemail@lee.tcode.com"" actually receive mails.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** emails = [""a@leetcode.com""""b@leetcode.com""""c@leetcode.com""]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `1 <= emails.length <= 100`\n  * `1 <= emails[i].length <= 100`\n  * `emails[i]` consist of lowercase English letters `'+'` `'.'` and `'@'`.\n  * Each `emails[i]` contains exactly one `'@'` character.\n  * All local and domain names are non-empty.\n  * Local names do not start with a `'+'` character.\n  * Domain names end with the `"".com""` suffix.\n\n","class Solution:\n    def numUniqueEmails(self emails: List[str]) -> int:\n        def ets(email):\n            s domain = email[:email.index('@')] email[email.index('@'):]\n            s = s.replace(""."" """")\n            s = s[:s.index('+')] if '+' in s else s\n            return s+domain\n        dict = {}\n        for i in emails:\n            dict[ets(i)] = 1\n        return len(dict)\n"
Unique Length-3 Palindromic Subsequences,"###  1930\. Unique Length-3 Palindromic Subsequences\n\nGiven a string `s` return _the number of**unique palindromes of length\nthree** that are a **subsequence** of _`s`.\n\nNote that even if there are multiple ways to obtain the same subsequence it\nis still only counted **once**.\n\nA **palindrome** is a string that reads the same forwards and backwards.\n\nA **subsequence** of a string is a new string generated from the original\nstring with some characters (can be none) deleted without changing the\nrelative order of the remaining characters.\n\n  * For example `""ace""` is a subsequence of `""_a_ b _c_ d _e_ ""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aabca""\n    **Output:** 3\n    **Explanation:** The 3 palindromic subsequences of length 3 are:\n    - ""aba"" (subsequence of ""_a_ a _b_ c _a_ "")\n    - ""aaa"" (subsequence of ""_aa_ bc _a_ "")\n    - ""aca"" (subsequence of ""_a_ ab _ca_ "")\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""adc""\n    **Output:** 0\n    **Explanation:** There are no palindromic subsequences of length 3 in ""adc"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""bbcbaba""\n    **Output:** 4\n    **Explanation:** The 4 palindromic subsequences of length 3 are:\n    - ""bbb"" (subsequence of ""_bb_ c _b_ aba"")\n    - ""bcb"" (subsequence of ""_b_ b _cb_ aba"")\n    - ""bab"" (subsequence of ""_b_ bcb _ab_ a"")\n    - ""aba"" (subsequence of ""bbcb _aba_ "")\n    \n\n\n\n**Constraints:**\n\n  * `3 <= s.length <= 105`\n  * `s` consists of only lowercase English letters.\n\n",class Solution(object):\n    def countPalindromicSubsequence(self s):\n        d=defaultdict(list)\n        for ic in enumerate(s):\n            d[c].append(i)\n        ans=0\n        for el in d:\n            if len(d[el])<2:\n                continue\n            a=d[el][0]\n            b=d[el][-1]\n            ans+=len(set(s[a+1:b]))\n        return(ans)\n
Unique Number of Occurrences,###  1207\. Unique Number of Occurrences\n\nGiven an array of integers `arr` return `true` if the number of occurrences\nof each value in the array is **unique**  or `false` otherwise.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [122113]\n    **Output:** true\n    **Explanation:**  The value 1 has 3 occurrences 2 has 2 and 3 has 1. No two values have the same number of occurrences.\n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [12]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [-301-3111-3100]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 1000`\n  * `-1000 <= arr[i] <= 1000`\n\n,"class Solution:\n    def uniqueOccurrences(self arr: List[int]) -> bool:\n		# defining dictionary\n        occ = dict()\n        \n		# adding elements with their counts in dictionary\n        for element in arr:\n            if element not in occ:\n                occ[element] = 0\n            else:\n                occ[element] += 1\n        \n		# list of count of elements\n        values = list(occ.values())\n		# Unique count\n        unique = set(values)\n        \n        if len(values) == len(unique):\n            return True\n        else:\n            return False\n"
Unique Paths,###  62\. Unique Paths\n\nThere is a robot on an `m x n` grid. The robot is initially located at the\n**top-left corner** (i.e. `grid[0][0]`). The robot tries to move to the\n**bottom-right corner** (i.e. `grid[m - 1][n - 1]`). The robot can only move\neither down or right at any point in time.\n\nGiven the two integers `m` and `n` return _the number of possible unique\npaths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to\n`2 * 109`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)\n\n    \n    \n    **Input:** m = 3 n = 7\n    **Output:** 28\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** m = 3 n = 2\n    **Output:** 3\n    **Explanation:** From the top-left corner there are a total of 3 ways to reach the bottom-right corner:\n    1. Right -> Down -> Down\n    2. Down -> Down -> Right\n    3. Down -> Right -> Down\n    \n\n\n\n**Constraints:**\n\n  * `1 <= m n <= 100`\n\n,// Runtime: 39 ms (Top 53.95%) | Memory: 17.30 MB (Top 9.72%)\n\nclass Solution:\n    def uniquePaths(self m n):\n        dp = [[1]*n for i in range(m)]\n        for i j in product(range(1 m) range(1 n)):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[-1][-1]\n
Unique Paths II,###  63\. Unique Paths II\n\nYou are given an `m x n` integer array `grid`. There is a robot initially\nlocated at the **top-left corner** (i.e. `grid[0][0]`). The robot tries to\nmove to the **bottom-right corner** (i.e. `grid[m-1][n-1]`). The robot can\nonly move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path\nthat the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach\nthe bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to\n`2 * 109`.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)\n\n    \n    \n    **Input:** obstacleGrid = [[000][010][000]]\n    **Output:** 2\n    **Explanation:** There is one obstacle in the middle of the 3x3 grid above.\n    There are two ways to reach the bottom-right corner:\n    1. Right -> Right -> Down -> Down\n    2. Down -> Down -> Right -> Right\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)\n\n    \n    \n    **Input:** obstacleGrid = [[01][00]]\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `m == obstacleGrid.length`\n  * `n == obstacleGrid[i].length`\n  * `1 <= m n <= 100`\n  * `obstacleGrid[i][j]` is `0` or `1`.\n\n,# Runtime: 75 ms (Top 36.49%) | Memory: 14 MB (Top 43.32%)\nclass Solution:\n    def uniquePathsWithObstacles(self obstacleGrid: List[List[int]]) -> int:\n        def valid(rcmatrix):\n            return r >= 0 and c >= 0 and r < len(matrix) and c < len(matrix[0])\n\n        dp = [[0] * len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]\n        dp[0][0] = 1 ^ obstacleGrid[0][0]\n\n        for r in range(len(obstacleGrid)):\n            for c in range(len(obstacleGrid[0])):\n                if obstacleGrid[r][c] != 1:\n                    if valid(r-1 c dp) and obstacleGrid[r-1][c] != 1:\n                        dp[r][c] += dp[r-1][c]\n                    if valid(r c-1 dp) and obstacleGrid[r][c-1] != 1:\n                        dp[r][c] += dp[r][c-1]\n\n        return dp[-1][-1]
Unique Paths III,###  980\. Unique Paths III\n\nYou are given an `m x n` integer array `grid` where `grid[i][j]` could be:\n\n  * `1` representing the starting square. There is exactly one starting square.\n  * `2` representing the ending square. There is exactly one ending square.\n  * `0` representing empty squares we can walk over.\n  * `-1` representing obstacles that we cannot walk over.\n\nReturn _the number of 4-directional walks from the starting square to the\nending square that walk over every non-obstacle square exactly once_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/08/02/lc-unique1.jpg)\n\n    \n    \n    **Input:** grid = [[1000][0000][002-1]]\n    **Output:** 2\n    **Explanation:** We have the following two paths: \n    1. (00)(01)(02)(03)(13)(12)(11)(10)(20)(21)(22)\n    2. (00)(10)(20)(21)(11)(01)(02)(03)(13)(12)(22)\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/08/02/lc-unique2.jpg)\n\n    \n    \n    **Input:** grid = [[1000][0000][0002]]\n    **Output:** 4\n    **Explanation:** We have the following four paths: \n    1. (00)(01)(02)(03)(13)(12)(11)(10)(20)(21)(22)(23)\n    2. (00)(01)(11)(10)(20)(21)(22)(12)(02)(03)(13)(23)\n    3. (00)(10)(20)(21)(22)(12)(11)(01)(02)(03)(13)(23)\n    4. (00)(10)(20)(21)(11)(01)(02)(03)(13)(12)(22)(23)\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/08/02/lc-unique3-.jpg)\n\n    \n    \n    **Input:** grid = [[01][20]]\n    **Output:** 0\n    **Explanation:** There is no path that walks over every empty square exactly once.\n    Note that the starting and ending square can be anywhere in the grid.\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 20`\n  * `1 <= m * n <= 20`\n  * `-1 <= grid[i][j] <= 2`\n  * There is exactly one starting cell and one ending cell.\n\n,class Solution:\n    def uniquePathsIII(self grid: List[List[int]]) -> int:\n        ans empty = 0 1\n        \n        def dfs(grid: List[List[int]] row: int col: int count: int visited) -> None:\n            if row >= len(grid) or col >= len(grid[0]) or row < 0 or col < 0 or grid[row][col] == -1:\n                return\n            nonlocal ans\n            if grid[row][col] == 2:\n                if empty == count:\n                    ans += 1\n                return\n            if (row col) not in visited:\n                visited.add((row col))\n                dfs(grid row + 1 col count + 1 visited)\n                dfs(grid row - 1 col count + 1 visited)\n                dfs(grid row col + 1 count + 1 visited)\n                dfs(grid row col - 1 count + 1 visited)\n                visited.remove((row col))\n        \n        row col = 0 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    row col = i j\n                elif grid[i][j] == 0:\n                    empty += 1\n        dfs(grid row col 0 set())\n        return ans\n
Unique Substrings in Wraparound String,"###  467\. Unique Substrings in Wraparound String\n\nWe define the string `s` to be the infinite wraparound string of\n`""abcdefghijklmnopqrstuvwxyz""` so `s` will look like this:\n\n  * `""...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....""`.\n\nGiven a string `p` return _the number of**unique non-empty substrings** of\n_`p` _are present in_`s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** p = ""a""\n    **Output:** 1\n    Explanation: Only the substring ""a"" of p is in s.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** p = ""cac""\n    **Output:** 2\n    **Explanation:** There are two substrings (""a"" ""c"") of p in s.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** p = ""zab""\n    **Output:** 6\n    **Explanation:** There are six substrings (""z"" ""a"" ""b"" ""za"" ""ab"" and ""zab"") of p in s.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= p.length <= 105`\n  * `p` consists of lowercase English letters.\n\n",def get_next(char):\n    x = ord(char)-ord('a')\n    x = (x+1)%26\n    return chr(ord('a') + x)\nclass Solution:\n    def findSubstringInWraproundString(self p: str) -> int:\n        i = 0\n        n = len(p)\n        map_ = collections.defaultdict(int)\n        while i<n:\n            start = i\n            prev_val = p[i]\n            while i+1<n and get_next(prev_val) == p[i+1]:\n                prev_val = p[i+1]\n                i+=1\n            while start <= i:\n                curr_val = i-start+1\n                map_[p[start]] = max(map_[p[start]] curr_val)\n                start += 1\n            i+=1\n        return sum(map_.values())\n\n
Univalued Binary Tree,###  965\. Univalued Binary Tree\n\nA binary tree is **uni-valued** if every node in the tree has the same value.\n\nGiven the `root` of a binary tree return `true` _if the given tree is**uni-\nvalued**  or _`false` _otherwise._\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png)\n\n    \n    \n    **Input:** root = [11111null1]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png)\n\n    \n    \n    **Input:** root = [22252]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 100]`.\n  * `0 <= Node.val < 100`\n\n,# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self val=0 left=None right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isUnivalTree(self root: Optional[TreeNode]) -> bool:\n        val1 = root.val\n        self.tracker = False\n        def dfs(rootval1):\n            if not root:\n                return \n            if root.val!=val1:\n                self.tracker=True\n            dfs(root.leftval1)\n            dfs(root.rightval1)\n            return \n        dfs(rootval1)\n        \n        if self.tracker == False:\n            return True\n        return False\n
Valid Arrangement of Pairs,###  2097\. Valid Arrangement of Pairs\n\nYou are given a **0-indexed** 2D integer array `pairs` where `pairs[i] =\n[starti endi]`. An arrangement of `pairs` is **valid** if for every index `i`\nwhere `1 <= i < pairs.length` we have `endi-1 == starti`.\n\nReturn _**any** valid arrangement of _`pairs`.\n\n**Note:** The inputs will be generated such that there exists a valid\narrangement of `pairs`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** pairs = [[51][45][119][94]]\n    **Output:** [[119][94][45][51]]\n    **Explanation:** This is a valid arrangement since endi-1 always equals starti.\n    end0 = 9 == 9 = start1 \n    end1 = 4 == 4 = start2\n    end2 = 5 == 5 = start3\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** pairs = [[13][32][21]]\n    **Output:** [[13][32][21]]\n    **Explanation:**\n    This is a valid arrangement since endi-1 always equals starti.\n    end0 = 3 == 3 = start1\n    end1 = 2 == 2 = start2\n    The arrangements [[21][13][32]] and [[32][21][13]] are also valid.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** pairs = [[12][13][21]]\n    **Output:** [[12][21][13]]\n    **Explanation:**\n    This is a valid arrangement since endi-1 always equals starti.\n    end0 = 2 == 2 = start1\n    end1 = 1 == 1 = start2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= pairs.length <= 105`\n  * `pairs[i].length == 2`\n  * `0 <= starti endi <= 109`\n  * `starti != endi`\n  * No two pairs are exactly the same.\n  * There **exists** a valid arrangement of `pairs`.\n\n,#Hierholzer Algorithm\nfrom collections import defaultdict\nclass Solution:\n    def validArrangement(self pairs: List[List[int]]) -> List[List[int]]:\n        G = defaultdict(list)\n        din = defaultdict(int)\n        dout = defaultdict(int)\n        for v w in pairs:\n            G[v].append(w)\n            dout[v] += 1\n            din[w] += 1\n        start = pairs[0][0]\n        for v in G:\n            if din[v]+1 == dout[v]:\n                start = v\n        route = []\n        def dfs(v):\n            while G[v]:\n                w = G[v].pop()\n                dfs(w)\n            route.append(v)\n        dfs(start)\n        route.reverse()\n        return [[route[i]route[i+1]] for i in range(len(route)-1)]\n
Valid Boomerang,###  1037\. Valid Boomerang\n\nGiven an array `points` where `points[i] = [xi yi]` represents a point on the\n**X-Y** plane return `true` _if these points are a**boomerang**_.\n\nA **boomerang** is a set of three points that are **all distinct** and **not\nin a straight line**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** points = [[11][23][32]]\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** points = [[11][22][33]]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `points.length == 3`\n  * `points[i].length == 2`\n  * `0 <= xi yi <= 100`\n\n,class Solution:\n    def isBoomerang(self points: List[List[int]]) -> bool:\n        abc=points\n        return (b[1]-a[1])*(c[0]-b[0]) != (c[1]-b[1])*(b[0]-a[0])\n
Valid Mountain Array,###  941\. Valid Mountain Array\n\nGiven an array of integers `arr` return _`true` if and only if it is a valid\nmountain array_.\n\nRecall that arr is a mountain array if and only if:\n\n  * `arr.length >= 3`\n  * There exists some `i` with `0 < i < arr.length - 1` such that: \n    * `arr[0] < arr[1] < ... < arr[i - 1] < arr[i] `\n    * `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\n![](https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png)\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [21]\n    **Output:** false\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [355]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** arr = [0321]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length <= 104`\n  * `0 <= arr[i] <= 104`\n\n,// Runtime: 153 ms (Top 95.7%) | Memory: 18.70 MB (Top 43.81%)\n\nclass Solution:\n    def validMountainArray(self arr: List[int]) -> bool:\n        if len(arr)<=2 or max(arr)==arr[0] or max(arr)==arr[len(arr)-1]:\n            return False\n        f=True\n        for i in range(len(arr)-1):\n            if f and arr[i]>=arr[i+1]:\n                f=False\n            if not f and arr[i]<=arr[i+1]:\n                return False\n        return True\n
Valid Number,"###  65\. Valid Number\n\nA **valid number** can be split up into these components (in order):\n\n  1. A **decimal number** or an **integer**.\n  2. (Optional) An `'e'` or `'E'` followed by an **integer**.\n\nA **decimal number** can be split up into these components (in order):\n\n  1. (Optional) A sign character (either `'+'` or `'-'`).\n  2. One of the following formats: \n    1. One or more digits followed by a dot `'.'`.\n    2. One or more digits followed by a dot `'.'` followed by one or more digits.\n    3. A dot `'.'` followed by one or more digits.\n\nAn **integer** can be split up into these components (in order):\n\n  1. (Optional) A sign character (either `'+'` or `'-'`).\n  2. One or more digits.\n\nFor example all the following are valid numbers: `[""2"" ""0089"" ""-0.1""\n""+3.14"" ""4."" ""-.9"" ""2e10"" ""-90E3"" ""3e+7"" ""+6e-1"" ""53.5e93""\n""-123.456e789""]` while the following are not valid numbers: `[""abc"" ""1a""\n""1e"" ""e3"" ""99e2.5"" ""--6"" ""-+3"" ""95a54e53""]`.\n\nGiven a string `s` return `true` _if_`s` _is a**valid number**_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""0""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""e""\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = "".""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 20`\n  * `s` consists of only English letters (both uppercase and lowercase) digits (`0-9`) plus `'+'` minus `'-'` or dot `'.'`.\n\n","class Solution:\n    def isNumber(self s: str) -> bool:\n        if s == ""inf"" or s == ""-inf"" or s == ""+inf"" or s == ""Infinity"" or s == ""-Infinity"" or s == ""+Infinity"":\n            return False\n        try:\n            float(s)\n        except (Exception):\n            return False\n        return True\n"
Valid Palindrome,"###  125\. Valid Palindrome\n\nA phrase is a **palindrome** if after converting all uppercase letters into\nlowercase letters and removing all non-alphanumeric characters it reads the\nsame forward and backward. Alphanumeric characters include letters and\nnumbers.\n\nGiven a string `s` return `true` _if it is a**palindrome**  or _`false`\n_otherwise_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""A man a plan a canal: Panama""\n    **Output:** true\n    **Explanation:** ""amanaplanacanalpanama"" is a palindrome.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""race a car""\n    **Output:** false\n    **Explanation:** ""raceacar"" is not a palindrome.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = "" ""\n    **Output:** true\n    **Explanation:** s is an empty string """" after removing non-alphanumeric characters.\n    Since an empty string reads the same forward and backward it is a palindrome.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 2 * 105`\n  * `s` consists only of printable ASCII characters.\n\n","class Solution:\n    def isPalindrome(self s: str) -> bool:\n        cleaned = """"\n        for c in s:\n            if c.isalnum():\n                cleaned += c.lower()\n        return (cleaned == cleaned[::-1])\n\n            \n"
Valid Palindrome II,"###  680\. Valid Palindrome II\n\nGiven a string `s` return `true` _if the_`s` _can be palindrome after\ndeleting**at most one** character from it_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aba""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""abca""\n    **Output:** true\n    **Explanation:** You could delete the character 'c'.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""abc""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 105`\n  * `s` consists of lowercase English letters.\n\n",# Runtime: 9164 ms (Top 5.04%) | Memory: 645.8 MB (Top 5.21%)\nclass Solution:\n    def validPalindrome(self s: str) -> bool:\n        has_deleted = False\n\n        def compare(s has_deleted):\n\n            if len(s) <= 1:\n                return True\n\n            if s[0] == s[-1]:\n                return compare(s[1:-1] has_deleted)\n            else:\n                if not has_deleted:\n                    return compare(s[1:] True) or compare(s[:-1] True)\n                else:\n                    return False\n\n        return compare(s has_deleted)
Valid Parentheses,"###  20\. Valid Parentheses\n\nGiven a string `s` containing just the characters `'('` `')'` `'{'` `'}'`\n`'['` and `']'` determine if the input string is valid.\n\nAn input string is valid if:\n\n  1. Open brackets must be closed by the same type of brackets.\n  2. Open brackets must be closed in the correct order.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""()""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""()[]{}""\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""(]""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 104`\n  * `s` consists of parentheses only `'()[]{}'`.\n\n",class Solution:\n    def isValid(self string: str) -> bool:\n         while True:\n            if '()' in string:\n                string = string.replace('()' '')\n            elif '{}' in string:\n                string = string.replace('{}' '')\n            elif '[]' in string:\n                string = string.replace('[]' '')\n\n            else:\n                return not string\n
Valid Parenthesis String,"###  678\. Valid Parenthesis String\n\nGiven a string `s` containing only three types of characters: `'('` `')'` and\n`'*'` return `true` _if_ `s` _is**valid**_.\n\nThe following rules define a **valid** string:\n\n  * Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.\n  * Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.\n  * Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.\n  * `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `""""`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""()""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""(*)""\n    **Output:** true\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""(*))""\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 100`\n  * `s[i]` is `'('` `')'` or `'*'`.\n\n",class Solution:\n    def checkValidString(self s: str) -> bool:\n        leftrightstar = deque() deque() deque() #indexes of all unmatched left right parens and all '*'\n        # O(n) where n=len(s)\n        for ic in enumerate(s):\n            if c == '(': # we just append left paren's index\n                left.append(i)\n            elif c == ')': # we check if we can find a match of left paren\n                if left and left[-1] < i:\n                    left.pop()\n                else:\n                    right.append(i)\n            else: #'*' case we just add the postion\n                star.append(i)\n        if not left and not right: return True\n        elif not star: return False #no star to save the string return False\n        lr = 0 len(star)-1\n        #O(n) since star will be length less than n\n        # Note: left rightand star are always kept in ascending order! And for any i in left j in right i > j or they would have been matched in the previous for loop.\n        while l<=r:\n            if left:\n                if left[-1]< star[r]: # we keep using right most star to match with right most '('\n                    left.pop()\n                    r -= 1\n                else: return False # even the right most '*' can not match a '(' we can not fix the string.\n            if right:\n                if right[0] > star[l]:\n                    right.popleft()\n                    l += 1\n                else: return False\n            if not left and not right: return True #if after some fix all matched we return True\n
Valid Perfect Square,###  367\. Valid Perfect Square\n\nGiven a **positive** integer _num_  write a function which returns True if\n_num_ is a perfect square else False.\n\n**Follow up:** **Do not** use any built-in library function such as `sqrt`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** num = 16\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** num = 14\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= num <= 2^31 - 1`\n\n,# Runtime: 45 ms (Top 36.3%) | Memory: 16.20 MB (Top 88.7%)\n\nclass Solution:\n    def isPerfectSquare(self num: int) -> bool:\n        if num == 1:\n            return True\n        lo = 2\n        hi = num // 2\n        while lo <= hi:\n            mid = lo + (hi - lo) //2\n            print(mid)\n            if mid * mid == num:\n                return True\n            if mid * mid > num:\n                hi = mid - 1\n            else:\n                lo = mid + 1\n        return False\n
Valid Permutations for DI Sequence,"###  903\. Valid Permutations for DI Sequence\n\nYou are given a string `s` of length `n` where `s[i]` is either:\n\n  * `'D'` means decreasing or\n  * `'I'` means increasing.\n\nA permutation `perm` of `n + 1` integers of all the integers in the range `[0\nn]` is called a **valid permutation** if for all valid `i`:\n\n  * If `s[i] == 'D'` then `perm[i] > perm[i + 1]` and\n  * If `s[i] == 'I'` then `perm[i] < perm[i + 1]`.\n\nReturn _the number of**valid permutations** _`perm`. Since the answer may be\nlarge return it **modulo** `109 + 7`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""DID""\n    **Output:** 5\n    **Explanation:** The 5 valid permutations of (0 1 2 3) are:\n    (1 0 3 2)\n    (2 0 3 1)\n    (2 1 3 0)\n    (3 0 2 1)\n    (3 1 2 0)\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""D""\n    **Output:** 1\n    \n\n\n\n**Constraints:**\n\n  * `n == s.length`\n  * `1 <= n <= 200`\n  * `s[i]` is either `'I'` or `'D'`.\n\n","// Runtime: 46 ms (Top 80.0%) | Memory: 18.80 MB (Top 54.55%)\n\nclass Solution:\n    def numPermsDISequence(self s: str) -> int:\n        n = len(s)\n        dp = [[None for j in range(n-i+1)] for i in range(n)]\n        for j in range(n-1 0-1 -1):\n            if s[j] == ""I"":\n                if j == n-1:\n                    dp[j][0] = 1\n                    dp[j][1] = 0\n                else:\n                    dp[j][n-j] = 0\n                    for i in range((n-j)-1 0-1 -1):\n                        dp[j][i] = dp[j+1][i]+dp[j][i+1]\n            else:\n                if j == n-1:\n                    dp[j][0] = 0\n                    dp[j][1] = 1\n                else:\n                    dp[j][0] = 0\n                    for i in range(1 n-j+1):\n                        dp[j][i] = dp[j+1][i-1]+dp[j][i-1]\n        return sum([dp[0][i] for i in range(n+1)])%(10**9+7)\n"
Valid Square,###  593\. Valid Square\n\nGiven the coordinates of four points in 2D space `p1` `p2` `p3` and `p4`\nreturn `true` _if the four points construct a square_.\n\nThe coordinate of a point `pi` is represented as `[xi yi]`. The input is\n**not** given in any order.\n\nA **valid square** has four equal sides with positive length and four equal\nangles (90-degree angles).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** p1 = [00] p2 = [11] p3 = [10] p4 = [01]\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** p1 = [00] p2 = [11] p3 = [10] p4 = [012]\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** p1 = [10] p2 = [-10] p3 = [01] p4 = [0-1]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `p1.length == p2.length == p3.length == p4.length == 2`\n  * `-104 <= xi yi <= 104`\n\n,# Runtime: 65 ms (Top 24.05%) | Memory: 13.9 MB (Top 50.57%)\nclass Solution:\n    def validSquare(self p1 p2 p3 p4):\n\n        def cal(A B):\n            return abs(A[0] - B[0]) + abs(A[1] - B[1])\n\n        d = [cal(p1 p2) cal(p1 p3) cal(p1 p4) cal(p2 p3) cal(p2 p4) cal(p3 p4)]\n        d.sort()\n\n        return 0 < d[0] == d[1] == d[2] == d[3] and d[4] == d[5]\n
Valid Sudoku,"###  36\. Valid Sudoku\n\nDetermine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be\nvalidated **according to the following rules** :\n\n  1. Each row must contain the digits `1-9` without repetition.\n  2. Each column must contain the digits `1-9` without repetition.\n  3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.\n\n**Note:**\n\n  * A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n  * Only the filled cells need to be validated according to the mentioned rules.\n\n\n\n**Example 1:**\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-\nby-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)\n\n    \n    \n    **Input:** board = \n    [[""5""""3""""."""".""""7""""."""".""""."""".""]\n    [""6""""."""".""""1""""9""""5"""".""""."""".""]\n    ["".""""9""""8""""."""".""""."""".""""6"""".""]\n    [""8"""".""""."""".""""6"""".""""."""".""""3""]\n    [""4""""."""".""""8"""".""""3""""."""".""""1""]\n    [""7"""".""""."""".""""2"""".""""."""".""""6""]\n    ["".""""6""""."""".""""."""".""""2""""8"""".""]\n    ["".""""."""".""""4""""1""""9""""."""".""""5""]\n    [""."""".""""."""".""""8""""."""".""""7""""9""]]\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** board = \n    [[""8""""3""""."""".""""7""""."""".""""."""".""]\n    [""6""""."""".""""1""""9""""5"""".""""."""".""]\n    ["".""""9""""8""""."""".""""."""".""""6"""".""]\n    [""8"""".""""."""".""""6"""".""""."""".""""3""]\n    [""4""""."""".""""8"""".""""3""""."""".""""1""]\n    [""7"""".""""."""".""""2"""".""""."""".""""6""]\n    ["".""""6""""."""".""""."""".""""2""""8"""".""]\n    ["".""""."""".""""4""""1""""9""""."""".""""5""]\n    [""."""".""""."""".""""8""""."""".""""7""""9""]]\n    **Output:** false\n    **Explanation:** Same as Example 1 except with the **5** in the top left corner being modified to **8**. Since there are two 8's in the top left 3x3 sub-box it is invalid.\n    \n\n\n\n**Constraints:**\n\n  * `board.length == 9`\n  * `board[i].length == 9`\n  * `board[i][j]` is a digit `1-9` or `'.'`.\n\n","# Runtime: 104 ms (Top 89.12%) | Memory: 14 MB (Top 35.48%)\nclass Solution:\n    def isValidSudoku(self board: List[List[str]]) -> bool:\n\n        hrow = {}\n        hcol = {}\n        hbox = defaultdict(list)\n\n        #CHECK FOR DUPLICATES ROWWISE\n        for i in range(9):\n            for j in range(9):\n\n                #JUST THAT THE DUPLICATE SHOULDNT BE """"\n                if board[i][j] != '.':\n\n                    if board[i][j] not in hrow:\n                        hrow[board[i][j]] = 1\n\n                    else:\n                        return False\n\n            #CLEAR HASHMAP FOR THIS ROW\n            hrow.clear()\n        print(""TRUE1"")\n        #CHECK FOR DUPLICATES COLUMNWISE\n\n        for i in range(9):\n            for j in range(9):\n\n                #JUST THAT THE DUPLICATE SHOULDNT BE """"\n                if board[j][i] != '.':\n\n                    if board[j][i] not in hcol:\n                        hcol[board[j][i]] = 1\n\n                    else:\n                        return False\n\n        #CLEAR HASHMAP FOR THIS COL\n\n            hcol.clear()\n\n        print('TRUE2')\n\n        #CHECK DUPLICATE IN BOX THIS IS WHERE KEY DESIGN SKILLS COME INTO PLAY FOR SUDOKU YOU COMBINE ROW INDICES AND COL INDICES\n\n        for i in range(9):\n            for j in range(9):\n\n                i_3 = i //3\n                j_3 = j//3\n\n                # print(hbox)\n                if board[i][j] != '.':\n\n                #CHECK ELEMENT OF ORIGINAL INDICE present in key i_3  j_3\n                    if board[i][j] not in hbox[i_3  j_3]:\n# #CHECKED IN NEW KEY\n                        hbox[i_3 j_3 ]= hbox[i_3 j_3 ] + [board[i][j]]\n\n                    else:\n                        return False\n\n        return True\n"
Valid Tic-Tac-Toe State,"###  794\. Valid Tic-Tac-Toe State\n\nGiven a Tic-Tac-Toe board as a string array `board` return `true` if and only\nif it is possible to reach this board position during the course of a valid\ntic-tac-toe game.\n\nThe board is a `3 x 3` array that consists of characters `' '` `'X'` and\n`'O'`. The `' '` character represents an empty square.\n\nHere are the rules of Tic-Tac-Toe:\n\n  * Players take turns placing characters into empty squares `' '`.\n  * The first player always places `'X'` characters while the second player always places `'O'` characters.\n  * `'X'` and `'O'` characters are always placed into empty squares never filled ones.\n  * The game ends when there are three of the same (non-empty) character filling any row column or diagonal.\n  * The game also ends if all squares are non-empty.\n  * No more moves can be played if the game is over.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/05/15/tictactoe1-grid.jpg)\n\n    \n    \n    **Input:** board = [""O  """"   """"   ""]\n    **Output:** false\n    **Explanation:** The first player always plays ""X"".\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/05/15/tictactoe2-grid.jpg)\n\n    \n    \n    **Input:** board = [""XOX"""" X """"   ""]\n    **Output:** false\n    **Explanation:** Players take turns making moves.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/05/15/tictactoe4-grid.jpg)\n\n    \n    \n    **Input:** board = [""XOX""""O O""""XOX""]\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `board.length == 3`\n  * `board[i].length == 3`\n  * `board[i][j]` is either `'X'` `'O'` or `' '`.\n\n","class Solution:\n    def validTicTacToe(self board: List[str]) -> bool:\n                                            # The two criteria for a valid board are:\n                                            #   1) num of Xs - num of Os is 0 or 1\n                                            #   2) X is not a winner if the # of moves is even and\n                                            #      O is not a winner if the # of moves is odd.\n\n        d = {'X': 1 'O': -1 ' ': 0}               # transform the 1x3 str array to a 1x9 int array\n        s = [d[ch] for ch in ''.join(board)]        # Ex: [""XOX"""" X """"   ""] --> [1-11010000]\n        sm = sum(s)\n\n        if sm>>1: return False                                      # <-- criterion 1\n        \n        n = -3 if sm == 1 else 3                                    # <-- criterion 2.\n        if n in {s[0]+s[1]+s[2] s[3]+s[4]+s[5] s[6]+s[7]+s[8] \n                 s[0]+s[3]+s[6] s[1]+s[4]+s[7] s[2]+s[5]+s[8]         # the elements of the set are \n                 s[0]+s[4]+s[8] s[2]+s[4]+s[6]}: return False           # the rows cols and diags\n        \n        return True                                                 # <-- both criteria are true"
Validate Binary Search Tree,###  98\. Validate Binary Search Tree\n\nGiven the `root` of a binary tree _determine if it is a valid binary search\ntree (BST)_.\n\nA **valid BST** is defined as follows:\n\n  * The left subtree of a node contains only nodes with keys **less than** the node's key.\n  * The right subtree of a node contains only nodes with keys **greater than** the node's key.\n  * Both the left and right subtrees must also be binary search trees.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\n\n    \n    \n    **Input:** root = [213]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)\n\n    \n    \n    **Input:** root = [514nullnull36]\n    **Output:** false\n    **Explanation:** The root node's value is 5 but its right child's value is 4.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 104]`.\n  * `-231 <= Node.val <= 231 - 1`\n\n,"# Runtime: 89 ms (Top 18.35%) | Memory: 16.5 MB (Top 80.77%)\n# Definition for a binary tree node.\n# class TreeNode:\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass Solution:\n    def isValidBST(self root: Optional[TreeNode]) -> bool:\n\n        def valid(nodeleftright):\n            if not node: # checking node is none\n                return True\n            if not (node.val>left and node.val<right): # checking the left value is less than node and right value is greater than node\n                return False\n            return (valid(node.leftleftnode.val) and valid(node.rightnode.valright)) # recursively calling left child and right child and returing the result True if both are true else False\n\n        return valid(rootfloat(""-inf"")float(""inf"")) #calling recursive function to check"
Validate Binary Tree Nodes,###  1361\. Validate Binary Tree Nodes\n\nYou have `n` binary tree nodes numbered from `0` to `n - 1` where node `i` has\ntwo children `leftChild[i]` and `rightChild[i]` return `true` if and only if\n**all** the given nodes form **exactly one** valid binary tree.\n\nIf node `i` has no left child then `leftChild[i]` will equal `-1` similarly\nfor the right child.\n\nNote that the nodes have no values and that we only use the node numbers in\nthis problem.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2019/08/23/1503_ex1.png)\n\n    \n    \n    **Input:** n = 4 leftChild = [1-13-1] rightChild = [2-1-1-1]\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2019/08/23/1503_ex2.png)\n\n    \n    \n    **Input:** n = 4 leftChild = [1-13-1] rightChild = [23-1-1]\n    **Output:** false\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2019/08/23/1503_ex3.png)\n\n    \n    \n    **Input:** n = 2 leftChild = [10] rightChild = [-1-1]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `n == leftChild.length == rightChild.length`\n  * `1 <= n <= 104`\n  * `-1 <= leftChild[i] rightChild[i] <= n - 1`\n\n, class Solution:\n    def validateBinaryTreeNodes(self n: int leftChild: List[int] rightChild: List[int]) -> bool:\n        \n        left_set=set(leftChild)\n        right_set=set(rightChild) \n\n        que=[]\n\n        for i in range(n):\n            if i not in left_set and i not in right_set:\n                que.append(i)\n        \n        if len(que)>1 or len(que)==0:\n            return False\n        \n        \n        graph=defaultdict(list)\n\n        for i in range(n):\n            graph[i]=[]\n\n            if leftChild[i]!=-1:\n                graph[i].append(leftChild[i])\n\n            if rightChild[i]!=-1:\n                graph[i].append(rightChild[i])\n        \n        visited=set()\n        visited.add(que[0])\n        \n        \n        while len(que)>0:\n            item=que.pop(0)\n            \n\n            children=graph[item]\n\n            for child in children:\n                if child not in visited:\n                    que.append(child)\n                    visited.add(child)\n                else:\n                    return False\n\n\n        for i in range(n):\n            if i not in visited:\n                return False\n\n        return True\n
Validate IP Address,"###  468\. Validate IP Address\n\nGiven a string `queryIP` return `""IPv4""` if IP is a valid IPv4 address\n`""IPv6""` if IP is a valid IPv6 address or `""Neither""` if IP is not a correct\nIP of any type.\n\n**A valid IPv4** address is an IP in the form `""x1.x2.x3.x4""` where `0 <= xi\n<= 255` and `xi` **cannot contain** leading zeros. For example\n`""192.168.1.1""` and `""192.168.1.0""` are valid IPv4 addresses while\n`""192.168.01.1""` `""192.168.1.00""` and `""192.168@1.1""` are invalid IPv4\naddresses.\n\n**A valid IPv6** address is an IP in the form `""x1:x2:x3:x4:x5:x6:x7:x8""`\nwhere:\n\n  * `1 <= xi.length <= 4`\n  * `xi` is a **hexadecimal string** which may contain digits lowercase English letter (`'a'` to `'f'`) and upper-case English letters (`'A'` to `'F'`).\n  * Leading zeros are allowed in `xi`.\n\nFor example ""`2001:0db8:85a3:0000:0000:8a2e:0370:7334""` and\n""`2001:db8:85a3:0:0:8A2E:0370:7334""` are valid IPv6 addresses while\n""`2001:0db8:85a3::8A2E:037j:7334""` and\n""`02001:0db8:85a3:0000:0000:8a2e:0370:7334""` are invalid IPv6 addresses.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** queryIP = ""172.16.254.1""\n    **Output:** ""IPv4""\n    **Explanation:** This is a valid IPv4 address return ""IPv4"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** queryIP = ""2001:0db8:85a3:0:0:8A2E:0370:7334""\n    **Output:** ""IPv6""\n    **Explanation:** This is a valid IPv6 address return ""IPv6"".\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** queryIP = ""256.256.256.256""\n    **Output:** ""Neither""\n    **Explanation:** This is neither a IPv4 address nor a IPv6 address.\n    \n\n\n\n**Constraints:**\n\n  * `queryIP` consists only of English letters digits and the characters `'.'` and `':'`.\n\n","class Solution:\n    def validIPAddress(self queryIP: str) -> str:\n        queryIP = queryIP.replace(""."""":"")\n        ct = 0\n        for i in queryIP.split("":""):\n            if i != """":\n                ct += 1\n        if ct == 4:\n            for i in queryIP.split("":""):\n                if i == """":\n                    return ""Neither""\n                if i.isnumeric():\n                    if len(i) > 1:\n                        if i.count('0') == len(i) or int(i) > 255 or i[0] == '0':\n                            return ""Neither""\n                else:\n                    return ""Neither""\n            return ""IPv4""\n        elif ct == 8:\n            a = ['a''b''c''d''e''f''A''B''C''D''E''F']\n            for i in queryIP.split("":""):\n                if i == """":\n                    return ""Neither""\n                if len(i) < 5:\n                    for j in i:\n                        if j not in a and j.isdigit() == False:\n                            return ""Neither""\n                else:\n                    return ""Neither""\n            return ""IPv6""\n        else:\n            return ""Neither""\n                   \n\n\n        "
Validate Stack Sequences,###  946\. Validate Stack Sequences\n\nGiven two integer arrays `pushed` and `popped` each with distinct values\nreturn `true` _if this could have been the result of a sequence of push and\npop operations on an initially empty stack or_`false` _otherwise._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** pushed = [12345] popped = [45321]\n    **Output:** true\n    **Explanation:** We might do the following sequence:\n    push(1) push(2) push(3) push(4)\n    pop() -> 4\n    push(5)\n    pop() -> 5 pop() -> 3 pop() -> 2 pop() -> 1\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** pushed = [12345] popped = [43512]\n    **Output:** false\n    **Explanation:** 1 cannot be popped before 2.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= pushed.length <= 1000`\n  * `0 <= pushed[i] <= 1000`\n  * All the elements of `pushed` are **unique**.\n  * `popped.length == pushed.length`\n  * `popped` is a permutation of `pushed`.\n\n,"class Solution:\n    def validateStackSequences(self pushed: List[int] popped: List[int]) -> bool:\n        stack=[]\n        i=0\n        for num in pushed:\n            stack.append(num) #we are pushing the number to the stack\n            while  len(stack) >0 and stack[len(stack)-1] == popped[i] :\n                #if the last element of the stack is equal to the popped element\n                stack.pop()\n                i+=1 #we are incrementing i\n        return True if len(stack) ==0 else False\n		\n"
Verbal Arithmetic Puzzle,"###  1307\. Verbal Arithmetic Puzzle\n\nGiven an equation represented by `words` on the left side and the `result` on\nthe right side.\n\nYou need to check if the equation is solvable under the following rules:\n\n  * Each character is decoded as one digit (0 - 9).\n  * No two characters can map to the same digit.\n  * Each `words[i]` and `result` are decoded as one number **without** leading zeros.\n  * Sum of numbers on the left side (`words`) will equal to the number on the right side (`result`).\n\nReturn `true` _if the equation is solvable otherwise return_ `false`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""SEND""""MORE""] result = ""MONEY""\n    **Output:** true\n    **Explanation:** Map 'S'-> 9 'E'->5 'N'->6 'D'->7 'M'->1 'O'->0 'R'->8 'Y'->'2'\n    Such that: ""SEND"" + ""MORE"" = ""MONEY""   9567 + 1085 = 10652\n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""SIX""""SEVEN""""SEVEN""] result = ""TWENTY""\n    **Output:** true\n    **Explanation:** Map 'S'-> 6 'I'->5 'X'->0 'E'->8 'V'->7 'N'->2 'T'->1 'W'->'3' 'Y'->4\n    Such that: ""SIX"" + ""SEVEN"" + ""SEVEN"" = ""TWENTY""   650 + 68782 + 68782 = 138214\n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""LEET""""CODE""] result = ""POINT""\n    **Output:** false\n    **Explanation:** There is no possible mapping to satisfy the equation so we return false.\n    Note that two different characters cannot map to the same digit.\n    \n\n\n\n**Constraints:**\n\n  * `2 <= words.length <= 5`\n  * `1 <= words[i].length result.length <= 7`\n  * `words[i] result` contain only uppercase English letters.\n  * The number of different characters used in the expression is at most `10`.\n\n",class Solution:\n    def isSolvable(self words: List[str] result: str) -> bool:\n        \n        # reverse words\n        words = [i[::-1] for i in words]\n        result = result[::-1]\n        allWords = words + [result]\n        \n        # chars that can not be 0\n        nonZero = set()\n        for word in allWords:\n            if len(word) > 1:\n                nonZero.add(word[-1])\n        \n        # numbers selected in backtracking\n        selected = set()\n        # char to Int map\n        charToInt = dict()\n        mxLen = max([len(i) for i in allWords])\n        \n        def res(i = 0 c = 0 sm = 0):\n            if c == mxLen:\n                return 1 if sm == 0 else 0\n            elif i == len(words):\n                num = sm % 10\n                carry = sm // 10\n                if c >= len(result):\n                    if num == 0:\n                        return res(0 c+1 carry)\n                    else:\n                        return 0\n                # result[c] should be mapped to num if a mapping exists\n                if result[c] in charToInt:\n                    if charToInt[result[c]] != num:\n                        return 0\n                    else:\n                        return res(0 c+1 carry)\n                elif num in selected:\n                    return 0\n                # if mapping does not exist create a mapping\n                elif (num == 0 and result[c] not in nonZero) or num > 0:\n                    selected.add(num)\n                    charToInt[result[c]] = num\n                    ret = res(0 c + 1 carry)\n                    del charToInt[result[c]]\n                    selected.remove(num)\n                    return ret\n                else:\n                    return 0\n            else:\n                word = words[i]\n                if c >= len(word):\n                    return res(i+1 c sm)\n                elif word[c] in charToInt:\n                    return res(i+1 c sm + charToInt[word[c]])\n                else:\n                    ret = 0\n                    # possibilities for word[c]\n                    for j in range(10):\n                        if (j == 0 and word[c] not in nonZero) or j > 0:\n                            if j not in selected:\n                                selected.add(j)\n                                charToInt[word[c]] = j\n                                ret += res(i + 1 c sm + j)\n                                del charToInt[word[c]]\n                                selected.remove(j)\n                    return ret\n        \n        return res() > 0
Verify Preorder Serialization of a Binary Tree,"###  331\. Verify Preorder Serialization of a Binary Tree\n\nOne way to serialize a binary tree is to use **preorder traversal**. When we\nencounter a non-null node we record the node's value. If it is a null node\nwe record using a sentinel value such as `'#'`.\n\n![](https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg)\n\nFor example the above binary tree can be serialized to the string\n`""934##1##2#6##""` where `'#'` represents a null node.\n\nGiven a string of comma-separated values `preorder` return `true` if it is a\ncorrect preorder traversal serialization of a binary tree.\n\nIt is **guaranteed** that each comma-separated value in the string must be\neither an integer or a character `'#'` representing null pointer.\n\nYou may assume that the input format is always valid.\n\n  * For example it could never contain two consecutive commas such as `""13""`.\n\n**Note:  **You are not allowed to reconstruct the tree.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** preorder = ""934##1##2#6##""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** preorder = ""1#""\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** preorder = ""9##1""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= preorder.length <= 104`\n  * `preorder` consist of integers in the range `[0 100]` and `'#'` separated by commas `''`.\n\n",# Runtime: 77 ms (Top 11.09%) | Memory: 13.8 MB (Top 99.05%)\nclass Solution:\n    def isValidSerialization(self preorder: str) -> bool:\n        nodes = preorder.split('')\n        counter=1\n        for i node in enumerate(nodes):\n            if node != '#':\n                counter+=1\n            else:\n                if counter <= 1 and i != len(nodes) - 1:\n                    return False\n                counter-=1\n        return counter == 0
Verifying an Alien Dictionary,"###  953\. Verifying an Alien Dictionary\n\nIn an alien language surprisingly they also use English lowercase letters\nbut possibly in a different `order`. The `order` of the alphabet is some\npermutation of lowercase letters.\n\nGiven a sequence of `words` written in the alien language and the `order` of\nthe alphabet return `true` if and only if the given `words` are sorted\nlexicographically in this alien language.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words = [""hello""""leetcode""] order = ""hlabcdefgijkmnopqrstuvwxyz""\n    **Output:** true\n    **Explanation:** As 'h' comes before 'l' in this language then the sequence is sorted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words = [""word""""world""""row""] order = ""worldabcefghijkmnpqstuvxyz""\n    **Output:** false\n    **Explanation:** As 'd' comes after 'l' in this language then words[0] > words[1] hence the sequence is unsorted.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** words = [""apple""""app""] order = ""abcdefghijklmnopqrstuvwxyz""\n    **Output:** false\n    **Explanation:** The first three characters ""app"" match and the second string is shorter (in size.) According to lexicographical rules ""apple"" > ""app"" because 'l' > '∅' where '∅' is defined as the blank character which is less than any other character ([More info](https://en.wikipedia.org/wiki/Lexicographical_order)).\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words.length <= 100`\n  * `1 <= words[i].length <= 20`\n  * `order.length == 26`\n  * All characters in `words[i]` and `order` are English lowercase letters.\n\n",# Runtime: 74 ms (Top 17.14%) | Memory: 13.7 MB (Top 99.39%)\nclass Solution:\n    def isAlienSorted(self words: List[str] order: str) -> bool:\n        order_index = {key:index for index key in enumerate(order)}\n\n        for i in range(len(words)-1):\n           w1w2 = words[i]  words[i + 1]\n           for j in range(len(w1)):\n                if j == len(w2):\n                    return False\n                if w1[j] != w2[j]:\n                    if order_index.get(w2[j]) < order_index.get(w1[j]):\n                        return False\n                    break\n        return True
Vertical Order Traversal of a Binary Tree,###  987\. Vertical Order Traversal of a Binary Tree\n\nGiven the `root` of a binary tree calculate the **vertical order traversal**\nof the binary tree.\n\nFor each node at position `(row col)` its left and right children will be at\npositions `(row + 1 col - 1)` and `(row + 1 col + 1)` respectively. The root\nof the tree is at `(0 0)`.\n\nThe **vertical order traversal** of a binary tree is a list of top-to-bottom\norderings for each column index starting from the leftmost column and ending\non the rightmost column. There may be multiple nodes in the same row and same\ncolumn. In such a case sort these nodes by their values.\n\nReturn _the**vertical order traversal** of the binary tree_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)\n\n    \n    \n    **Input:** root = [3920nullnull157]\n    **Output:** [[9][315][20][7]]\n    **Explanation:**\n    Column -1: Only node 9 is in this column.\n    Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.\n    Column 1: Only node 20 is in this column.\n    Column 2: Only node 7 is in this column.\n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg)\n\n    \n    \n    **Input:** root = [1234567]\n    **Output:** [[4][2][156][3][7]]\n    **Explanation:**\n    Column -2: Only node 4 is in this column.\n    Column -1: Only node 2 is in this column.\n    Column 0: Nodes 1 5 and 6 are in this column.\n              1 is at the top so it comes first.\n              5 and 6 are at the same position (2 0) so we order them by their value 5 before 6.\n    Column 1: Only node 3 is in this column.\n    Column 2: Only node 7 is in this column.\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg)\n\n    \n    \n    **Input:** root = [1234657]\n    **Output:** [[4][2][156][3][7]]\n    **Explanation:**\n    This case is the exact same as example 2 but with nodes 5 and 6 swapped.\n    Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n    \n\n\n\n**Constraints:**\n\n  * The number of nodes in the tree is in the range `[1 1000]`.\n  * `0 <= Node.val <= 1000`\n\n,"# Runtime: 69 ms (Top 15.25%) | Memory: 14.3 MB (Top 28.85%)\n# Definition for a binary tree node.\n# class TreeNode(object):\n# def __init__(self val=0 left=None right=None):\n# self.val = val\n# self.left = left\n# self.right = right\nclass Solution(object):\n    def verticalTraversal(self root):\n        """"""\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        """"""\n        q = [(0 0 root)]\n        l = []\n        while q:\n            col row node = q.pop()\n            l.append((col row node.val))\n            if node.left:\n                q.append((col-1 row+1 node.left))\n            if node.right:\n                q.append((col+1 row+1 node.right))\n        l.sort()\n        print(l)\n        ans = []\n        ans.append([l[0][-1]])\n        for i in range(1 len(l)):\n            if l[i][0] > l[i-1][0]:\n                ans.append([l[i][-1]])\n            else:\n                ans[-1].append(l[i][-1])\n        return ans\n"
Video Stitching,###  1024\. Video Stitching\n\nYou are given a series of video clips from a sporting event that lasted `time`\nseconds. These video clips can be overlapping with each other and have varying\nlengths.\n\nEach video clip is described by an array `clips` where `clips[i] = [starti\nendi]` indicates that the ith clip started at `starti` and ended at `endi`.\n\nWe can cut these clips into segments freely.\n\n  * For example a clip `[0 7]` can be cut into segments `[0 1] + [1 3] + [3 7]`.\n\nReturn _the minimum number of clips needed so that we can cut the clips into\nsegments that cover the entire sporting event_ `[0 time]`. If the task is\nimpossible return `-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** clips = [[02][46][810][19][15][59]] time = 10\n    **Output:** 3\n    **Explanation:** We take the clips [02] [810] [19]; a total of 3 clips.\n    Then we can reconstruct the sporting event as follows:\n    We cut [19] into segments [12] + [28] + [89].\n    Now we have segments [02] + [28] + [810] which cover the sporting event [0 10].\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** clips = [[01][12]] time = 5\n    **Output:** -1\n    **Explanation:** We cannot cover [05] with only [01] and [12].\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** clips = [[01][68][02][56][04][03][67][13][47][14][25][26][34][45][57][69]] time = 9\n    **Output:** 3\n    **Explanation:** We can take clips [04] [47] and [69].\n    \n\n\n\n**Constraints:**\n\n  * `1 <= clips.length <= 100`\n  * `0 <= starti <= endi <= 100`\n  * `1 <= time <= 100`\n\n,# Runtime: 46 ms (Top 41.2%) | Memory: 16.25 MB (Top 82.7%)\n\nclass Solution:\n    def videoStitching(self clips: List[List[int]] T: int) -> int:\n        dp = [float('inf')] * (T + 1)\n        dp[0] = 0\n        for i in range(1 T + 1):\n            for start end in clips:\n                if start <= i <= end:\n                    dp[i] = min(dp[start] + 1 dp[i])\n        if dp[T] == float('inf'):\n            return -1\n        return dp[T]
Vowel Spellchecker,"###  966\. Vowel Spellchecker\n\nGiven a `wordlist` we want to implement a spellchecker that converts a query\nword into a correct word.\n\nFor a given `query` word the spell checker handles two categories of spelling\nmistakes:\n\n  * Capitalization: If the query matches a word in the wordlist (**case-insensitive**) then the query word is returned with the same case as the case in the wordlist. \n    * Example: `wordlist = [""yellow""]` `query = ""YellOw""`: `correct = ""yellow""`\n    * Example: `wordlist = [""Yellow""]` `query = ""yellow""`: `correct = ""Yellow""`\n    * Example: `wordlist = [""yellow""]` `query = ""yellow""`: `correct = ""yellow""`\n  * Vowel Errors: If after replacing the vowels `('a' 'e' 'i' 'o' 'u')` of the query word with any vowel individually it matches a word in the wordlist (**case-insensitive**) then the query word is returned with the same case as the match in the wordlist. \n    * Example: `wordlist = [""YellOw""]` `query = ""yollow""`: `correct = ""YellOw""`\n    * Example: `wordlist = [""YellOw""]` `query = ""yeellow""`: `correct = """"` (no match)\n    * Example: `wordlist = [""YellOw""]` `query = ""yllw""`: `correct = """"` (no match)\n\nIn addition the spell checker operates under the following precedence rules:\n\n  * When the query exactly matches a word in the wordlist (**case-sensitive**) you should return the same word back.\n  * When the query matches a word up to capitlization you should return the first such match in the wordlist.\n  * When the query matches a word up to vowel errors you should return the first such match in the wordlist.\n  * If the query has no matches in the wordlist you should return the empty string.\n\nGiven some `queries` return a list of words `answer` where `answer[i]` is\nthe correct word for `query = queries[i]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** wordlist = [""KiTe""""kite""""hare""""Hare""] queries = [""kite""""Kite""""KiTe""""Hare""""HARE""""Hear""""hear""""keti""""keet""""keto""]\n    **Output:** [""kite""""KiTe""""KiTe""""Hare""""hare""""""""""""KiTe""""""""KiTe""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** wordlist = [""yellow""] queries = [""YellOw""]\n    **Output:** [""yellow""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= wordlist.length queries.length <= 5000`\n  * `1 <= wordlist[i].length queries[i].length <= 7`\n  * `wordlist[i]` and `queries[i]` consist only of only English letters.\n\n","// Runtime: 166 ms (Top 89.12%) | Memory: 19.20 MB (Top 76.17%)\n\nclass Solution:\n    def spellchecker(self wordlist: List[str] queries: List[str]) -> List[str]:\n        capital={i.lower():i for i in wordlist[::-1]}\n        vovel={''.join([j if j not in ""aeiou"" else '.' for j in i.lower()]):i for i in wordlist[::-1]}\n        wordlist=set(wordlist)\n        res=[]\n        for i in queries:\n            if i in wordlist:\n                res.append(i)\n            elif i.lower() in capital:\n                res.append(capital[i.lower()])\n            elif ''.join([j if j not in ""aeiou"" else '.' for j in i.lower()]) in vovel:\n                res.append(vovel[''.join([j if j not in ""aeiou"" else '.' for j in i.lower()])])\n            else:\n                res.append("""")\n        return res\n"
Vowels of All Substrings,"###  2063\. Vowels of All Substrings\n\nGiven a string `word` return _the**sum of the number of vowels** (_`'a'`\n`'e'`__ `'i'`__ `'o'`_ and_ `'u'`_)_ _in every substring of_`word`.\n\nA **substring** is a contiguous (non-empty) sequence of characters within a\nstring.\n\n**Note:** Due to the large constraints the answer may not fit in a signed\n32-bit integer. Please be careful during the calculations.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** word = ""aba""\n    **Output:** 6\n    **Explanation:** \n    All possible substrings are: ""a"" ""ab"" ""aba"" ""b"" ""ba"" and ""a"".\n    - ""b"" has 0 vowels in it\n    - ""a"" ""ab"" ""ba"" and ""a"" have 1 vowel each\n    - ""aba"" has 2 vowels in it\n    Hence the total sum of vowels = 0 + 1 + 1 + 1 + 1 + 2 = 6. \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** word = ""abc""\n    **Output:** 3\n    **Explanation:** \n    All possible substrings are: ""a"" ""ab"" ""abc"" ""b"" ""bc"" and ""c"".\n    - ""a"" ""ab"" and ""abc"" have 1 vowel each\n    - ""b"" ""bc"" and ""c"" have 0 vowels each\n    Hence the total sum of vowels = 1 + 1 + 1 + 0 + 0 + 0 = 3.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** word = ""ltcd""\n    **Output:** 0\n    **Explanation:** There are no vowels in any substring of ""ltcd"".\n    \n\n\n\n**Constraints:**\n\n  * `1 <= word.length <= 105`\n  * `word` consists of lowercase English letters.\n\n",class Solution:\n    def countVowels(self word: str) -> int:\n        count = vowelIndexSum = 0\n        vowels = {'a' 'e' 'i' 'o' 'u'}\n\n        for i c in enumerate(word start=1):\n            if c in vowels:\n                vowelIndexSum += i\n            count += vowelIndexSum\n        \n        return count
Walking Robot Simulation,###  874\. Walking Robot Simulation\n\nA robot on an infinite XY-plane starts at point `(0 0)` facing north. The\nrobot can receive a sequence of these three possible types of `commands`:\n\n  * `-2`: Turn left `90` degrees.\n  * `-1`: Turn right `90` degrees.\n  * `1 <= k <= 9`: Move forward `k` units one unit at a time.\n\nSome of the grid squares are `obstacles`. The `ith` obstacle is at grid point\n`obstacles[i] = (xi yi)`. If the robot runs into an obstacle then it will\ninstead stay in its current location and move on to the next command.\n\nReturn _the**maximum Euclidean distance** that the robot ever gets from the\norigin **squared** (i.e. if the distance is _`5` _ return_`25` _)_.\n\n**Note:**\n\n  * North means +Y direction.\n  * East means +X direction.\n  * South means -Y direction.\n  * West means -X direction.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** commands = [4-13] obstacles = []\n    **Output:** 25\n    **Explanation:** The robot starts at (0 0):\n    1. Move north 4 units to (0 4).\n    2. Turn right.\n    3. Move east 3 units to (3 4).\n    The furthest point the robot ever gets from the origin is (3 4) which squared is 32 + 42 = 25 units away.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** commands = [4-14-24] obstacles = [[24]]\n    **Output:** 65\n    **Explanation:** The robot starts at (0 0):\n    1. Move north 4 units to (0 4).\n    2. Turn right.\n    3. Move east 1 unit and get blocked by the obstacle at (2 4) robot is at (1 4).\n    4. Turn left.\n    5. Move north 4 units to (1 8).\n    The furthest point the robot ever gets from the origin is (1 8) which squared is 12 + 82 = 65 units away.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** commands = [6-1-16] obstacles = []\n    **Output:** 36\n    **Explanation:** The robot starts at (0 0):\n    1. Move north 6 units to (0 6).\n    2. Turn right.\n    3. Turn right.\n    4. Move south 6 units to (0 0).\n    The furthest point the robot ever gets from the origin is (0 6) which squared is 62 = 36 units away.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= commands.length <= 104`\n  * `commands[i]` is either `-2` `-1` or an integer in the range `[1 9]`.\n  * `0 <= obstacles.length <= 104`\n  * `-3 * 104 <= xi yi <= 3 * 104`\n  * The answer is guaranteed to be less than `231`.\n\n,# Runtime: 970 ms (Top 9.86%) | Memory: 20.6 MB (Top 59.47%)\nclass Solution:\n    def robotSim(self commands: List[int] obstacles: List[List[int]]) -> int:\n        obs = set(tuple(o) for o in obstacles)\n        x = y = a = out = 0\n        move = {0:(01) 90:(10) 180:(0-1) 270:(-10)}\n        for c in commands:\n            if c == -1:\n                a += 90\n            elif c == -2:\n                a -= 90\n            else:\n                direction = a % 360\n                dx dy = move[direction]\n                for _ in range(c):\n                    if (x + dx y + dy) in obs:\n                        break\n                    x += dx\n                    y += dy\n                out = max(out x**2 + y**2)\n        return out
Walking Robot Simulation II,"###  2069\. Walking Robot Simulation II\n\nA `width x height` grid is on an XY-plane with the **bottom-left** cell at\n`(0 0)` and the **top-right** cell at `(width - 1 height - 1)`. The grid is\naligned with the four cardinal directions (`""North""` `""East""` `""South""` and\n`""West""`). A robot is **initially** at cell `(0 0)` facing direction\n`""East""`.\n\nThe robot can be instructed to move for a specific number of **steps**. For\neach step it does the following.\n\n  1. Attempts to move **forward one** cell in the direction it is facing.\n  2. If the cell the robot is **moving to** is **out of bounds**  the robot instead **turns** 90 degrees **counterclockwise** and retries the step.\n\nAfter the robot finishes moving the number of steps required it stops and\nawaits the next instruction.\n\nImplement the `Robot` class:\n\n  * `Robot(int width int height)` Initializes the `width x height` grid with the robot at `(0 0)` facing `""East""`.\n  * `void step(int num)` Instructs the robot to move forward `num` steps.\n  * `int[] getPos()` Returns the current cell the robot is at as an array of length 2 `[x y]`.\n  * `String getDir()` Returns the current direction of the robot `""North""` `""East""` `""South""` or `""West""`.\n\n\n\n**Example 1:**\n\n![example-1](https://assets.leetcode.com/uploads/2021/10/09/example-1.png)\n\n    \n    \n    **Input**\n    [""Robot"" ""step"" ""step"" ""getPos"" ""getDir"" ""step"" ""step"" ""step"" ""getPos"" ""getDir""]\n    [[6 3] [2] [2] [] [] [2] [1] [4] [] []]\n    **Output**\n    [null null null [4 0] ""East"" null null null [1 2] ""West""]\n    \n    **Explanation**\n    Robot robot = new Robot(6 3); // Initialize the grid and the robot at (0 0) facing East.\n    robot.step(2);  // It moves two steps East to (2 0) and faces East.\n    robot.step(2);  // It moves two steps East to (4 0) and faces East.\n    robot.getPos(); // return [4 0]\n    robot.getDir(); // return ""East""\n    robot.step(2);  // It moves one step East to (5 0) and faces East.\n                    // Moving the next step East would be out of bounds so it turns and faces North.\n                    // Then it moves one step North to (5 1) and faces North.\n    robot.step(1);  // It moves one step North to (5 2) and faces **North** (not West).\n    robot.step(4);  // Moving the next step North would be out of bounds so it turns and faces West.\n                    // Then it moves four steps West to (1 2) and faces West.\n    robot.getPos(); // return [1 2]\n    robot.getDir(); // return ""West""\n    \n    \n\n\n\n**Constraints:**\n\n  * `2 <= width height <= 100`\n  * `1 <= num <= 105`\n  * At most `104` calls **in total** will be made to `step` `getPos` and `getDir`.\n\n",class Robot:\n\n    def __init__(self width: int height: int):\n        self.perimeter = 2*width + 2*(height - 2)\n        self.pos = 0\n        self.atStart = True\n\n        self.bottomRight = width - 1\n        self.topRight = self.bottomRight + (height - 1)\n        self.topLeft = self.topRight + (width - 1)\n\n    def step(self num: int) -> None:\n        self.atStart = False\n        self.pos = (self.pos + num) % self.perimeter\n\n    def getPos(self) -> List[int]:\n        if 0 <= self.pos <= self.bottomRight:\n            return [self.pos 0]\n\n        if self.bottomRight < self.pos <= self.topRight:\n            return [self.bottomRight self.pos - self.bottomRight]\n\n        if self.topRight < self.pos <= self.topLeft:\n            return [self.bottomRight - (self.pos - self.topRight) self.topRight - self.bottomRight]\n        \n        return [0 self.topRight - self.bottomRight - (self.pos - self.topLeft)]\n\n    def getDir(self) -> str:\n        if self.atStart or 0 < self.pos <= self.bottomRight:\n            return 'East'\n\n        if self.bottomRight < self.pos <= self.topRight:\n            return 'North'\n\n        if self.topRight < self.pos <= self.topLeft:\n            return 'West'\n        \n        return 'Sout
Water and Jug Problem,###  365\. Water and Jug Problem\n\nYou are given two jugs with capacities `jug1Capacity` and `jug2Capacity`\nliters. There is an infinite amount of water supply available. Determine\nwhether it is possible to measure exactly `targetCapacity` liters using these\ntwo jugs.\n\nIf `targetCapacity` liters of water are measurable you must have\n`targetCapacity` liters of water contained **within one or both buckets** by\nthe end.\n\nOperations allowed:\n\n  * Fill any of the jugs with water.\n  * Empty any of the jugs.\n  * Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** jug1Capacity = 3 jug2Capacity = 5 targetCapacity = 4\n    **Output:** true\n    **Explanation:** The famous [Die Hard](https://www.youtube.com/watch?v=BVtQNK_ZUJg&ab_channel=notnek01) example \n    \n\n**Example 2:**\n\n    \n    \n    **Input:** jug1Capacity = 2 jug2Capacity = 6 targetCapacity = 5\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** jug1Capacity = 1 jug2Capacity = 2 targetCapacity = 3\n    **Output:** true\n    \n\n\n\n**Constraints:**\n\n  * `1 <= jug1Capacity jug2Capacity targetCapacity <= 106`\n\n,class Solution:\n    def canMeasureWater(self jug1Capacity: int jug2Capacity: int targetCapacity: int) -> bool:\n        n1 n2 t = jug1Capacity jug2Capacity targetCapacity\n        if n1 == t or n2 == t or n1 + n2 == t:\n            return True\n        if n1 + n2 < t:\n            return False\n        if n1 < n2:\n            n1 n2 = n2 n1\n        stack = []\n        visited = set()\n        d = n1 - n2\n        if d == t:\n            return True\n        while d > n2:\n            d -= n2\n            if d == t:\n                return True\n        stack.append(d)\n        while stack:\n            #print(stack)\n            d = stack.pop()\n            visited.add(d)\n            n = n1 + d\n            if n == t:\n                return True\n            n = n1 - d\n            if n == t:\n                return True\n            while n > n2:\n                n -= n2\n                if n == t:\n                    return True\n            if n < n2 and n not in visited:\n                stack.append(n)\n            n = n2 - d\n            if n == t:\n                return True\n            if n not in visited:\n                stack.append(n)\n        return False\n
Water Bottles,###  1518\. Water Bottles\n\nThere are `numBottles` water bottles that are initially full of water. You can\nexchange `numExchange` empty water bottles from the market with one full water\nbottle.\n\nThe operation of drinking a full water bottle turns it into an empty bottle.\n\nGiven the two integers `numBottles` and `numExchange` return _the**maximum**\nnumber of water bottles you can drink_.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/07/01/sample_1_1875.png)\n\n    \n    \n    **Input:** numBottles = 9 numExchange = 3\n    **Output:** 13\n    **Explanation:** You can exchange 3 empty bottles to get 1 full water bottle.\n    Number of water bottles you can drink: 9 + 3 + 1 = 13.\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/07/01/sample_2_1875.png)\n\n    \n    \n    **Input:** numBottles = 15 numExchange = 4\n    **Output:** 19\n    **Explanation:** You can exchange 4 empty bottles to get 1 full water bottle. \n    Number of water bottles you can drink: 15 + 3 + 1 = 19.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= numBottles <= 100`\n  * `2 <= numExchange <= 100`\n\n,class Solution:\n    def numWaterBottles(self a: int b: int) -> int:\n        \n        def sol(aberes):\n            if a!=0: res += a\n            if (a+e)<b: return res \n            a += e\n            new=a//b\n            e = a-(new*b)\n            a=new\n            return sol(aberes)\n        \n        return sol(ab00)\n
Watering Plants,###  2079\. Watering Plants\n\nYou want to water `n` plants in your garden with a watering can. The plants\nare arranged in a row and are labeled from `0` to `n - 1` from left to right\nwhere the `ith` plant is located at `x = i`. There is a river at `x = -1` that\nyou can refill your watering can at.\n\nEach plant needs a specific amount of water. You will water the plants in the\nfollowing way:\n\n  * Water the plants in order from left to right.\n  * After watering the current plant if you do not have enough water to **completely** water the next plant return to the river to fully refill the watering can.\n  * You **cannot** refill the watering can early.\n\nYou are initially at the river (i.e. `x = -1`). It takes **one step** to move\n**one unit** on the x-axis.\n\nGiven a **0-indexed** integer array `plants` of `n` integers where\n`plants[i]` is the amount of water the `ith` plant needs and an integer\n`capacity` representing the watering can capacity return _the**number of\nsteps** needed to water all the plants_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** plants = [2233] capacity = 5\n    **Output:** 14\n    **Explanation:** Start at the river with a full watering can:\n    - Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.\n    - Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.\n    - Since you cannot completely water plant 2 walk back to the river to refill (2 steps).\n    - Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.\n    - Since you cannot completely water plant 3 walk back to the river to refill (3 steps).\n    - Walk to plant 3 (4 steps) and water it.\n    Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** plants = [111423] capacity = 4\n    **Output:** 30\n    **Explanation:** Start at the river with a full watering can:\n    - Water plants 0 1 and 2 (3 steps). Return to river (3 steps).\n    - Water plant 3 (4 steps). Return to river (4 steps).\n    - Water plant 4 (5 steps). Return to river (5 steps).\n    - Water plant 5 (6 steps).\n    Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** plants = [7777777] capacity = 8\n    **Output:** 49\n    **Explanation:** You have to refill before watering each plant.\n    Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.\n    \n\n\n\n**Constraints:**\n\n  * `n == plants.length`\n  * `1 <= n <= 1000`\n  * `1 <= plants[i] <= 106`\n  * `max(plants[i]) <= capacity <= 109`\n\n,# Runtime: 93 ms (Top 33.43%) | Memory: 14.1 MB (Top 44.38%)\nclass Solution:\n    def wateringPlants(self plants: List[int] capacity: int) -> int:\n        result = 0\n        curCap = capacity\n\n        for i in range(len(plants)):\n            if curCap >= plants[i]:\n                curCap -= plants[i]\n                result += 1\n\n            else:\n                result += i * 2 + 1\n                curCap = capacity - plants[i]\n\n        return result
Watering Plants II,###  2105\. Watering Plants II\n\nAlice and Bob want to water `n` plants in their garden. The plants are\narranged in a row and are labeled from `0` to `n - 1` from left to right where\nthe `ith` plant is located at `x = i`.\n\nEach plant needs a specific amount of water. Alice and Bob have a watering can\neach **initially full**. They water the plants in the following way:\n\n  * Alice waters the plants in order from **left to right**  starting from the `0th` plant. Bob waters the plants in order from **right to left**  starting from the `(n - 1)th` plant. They begin watering the plants **simultaneously**.\n  * It takes the same amount of time to water each plant regardless of how much water it needs.\n  * Alice/Bob **must** water the plant if they have enough in their can to **fully** water it. Otherwise they **first** refill their can (instantaneously) then water the plant.\n  * In case both Alice and Bob reach the same plant the one with **more** water currently in his/her watering can should water this plant. If they have the same amount of water then Alice should water this plant.\n\nGiven a **0-indexed** integer array `plants` of `n` integers where\n`plants[i]` is the amount of water the `ith` plant needs and two integers\n`capacityA` and `capacityB` representing the capacities of Alice's and Bob's\nwatering cans respectively return _the**number of times** they have to refill\nto water all the plants_.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** plants = [2233] capacityA = 5 capacityB = 5\n    **Output:** 1\n    **Explanation:**\n    - Initially Alice and Bob have 5 units of water each in their watering cans.\n    - Alice waters plant 0 Bob waters plant 3.\n    - Alice and Bob now have 3 units and 2 units of water respectively.\n    - Alice has enough water for plant 1 so she waters it. Bob does not have enough water for plant 2 so he refills his can then waters it.\n    So the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** plants = [2233] capacityA = 3 capacityB = 4\n    **Output:** 2\n    **Explanation:**\n    - Initially Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n    - Alice waters plant 0 Bob waters plant 3.\n    - Alice and Bob now have 1 unit of water each and need to water plants 1 and 2 respectively.\n    - Since neither of them have enough water for their current plants they refill their cans and then water the plants.\n    So the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** plants = [5] capacityA = 10 capacityB = 8\n    **Output:** 0\n    **Explanation:**\n    - There is only one plant.\n    - Alice's watering can has 10 units of water whereas Bob's can has 8 units. Since Alice has more water in her can she waters this plant.\n    So the total number of times they have to refill is 0.\n    \n\n\n\n**Constraints:**\n\n  * `n == plants.length`\n  * `1 <= n <= 105`\n  * `1 <= plants[i] <= 106`\n  * `max(plants[i]) <= capacityA capacityB <= 109`\n\n,// Runtime: 591 ms (Top 95.38%) | Memory: 31.60 MB (Top 92.31%)\n\nclass Solution:\n    def minimumRefill(self plants: List[int] capacityA: int capacityB: int) -> int:\n        ans = 0 \n        lo hi = 0 len(plants)-1\n        canA canB = capacityA capacityB\n        while lo < hi: \n            if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi]: ans += 1; canB = capacityB\n            canB -= plants[hi]\n            lo hi = lo+1 hi-1\n        if lo == hi and max(canA canB) < plants[lo]: ans += 1\n        return ans \n
Where Will the Ball Fall,"###  1706\. Where Will the Ball Fall\n\nYou have a 2-D `grid` of size `m x n` representing a box and you have `n`\nballs. The box is open on the top and bottom sides.\n\nEach cell in the box has a diagonal board spanning two corners of the cell\nthat can redirect a ball to the right or to the left.\n\n  * A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as `1`.\n  * A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as `-1`.\n\nWe drop one ball at the top of each column of the box. Each ball can get stuck\nin the box or fall out of the bottom. A ball gets stuck if it hits a ""V""\nshaped pattern between two boards or if a board redirects the ball into either\nwall of the box.\n\nReturn _an array_`answer` _of size_`n` _where_`answer[i]`_is the column that\nthe ball falls out of at the bottom after dropping the ball from the_`ith`\n_column at the top or`-1` _if the ball gets stuck in the box_._\n\n\n\n**Example 1:**\n\n**![](https://assets.leetcode.com/uploads/2019/09/26/ball.jpg)**\n\n    \n    \n    **Input:** grid = [[111-1-1][111-1-1][-1-1-111][1111-1][-1-1-1-1-1]]\n    **Output:** [1-1-1-1-1]\n    **Explanation:** This example is shown in the photo.\n    Ball b0 is dropped at column 0 and falls out of the box at column 1.\n    Ball b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\n    Ball b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\n    Ball b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\n    Ball b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** grid = [[-1]]\n    **Output:** [-1]\n    **Explanation:** The ball gets stuck against the left wall.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** grid = [[111111][-1-1-1-1-1-1][111111][-1-1-1-1-1-1]]\n    **Output:** [01234-1]\n    \n\n\n\n**Constraints:**\n\n  * `m == grid.length`\n  * `n == grid[i].length`\n  * `1 <= m n <= 100`\n  * `grid[i][j]` is `1` or `-1`.\n\n",# Runtime: 205 ms (Top 93.96%) | Memory: 14.3 MB (Top 84.02%)\n\nclass Solution:\n    def findBall(self grid: List[List[int]]) -> List[int]:\n\n        mn=len(grid)len(grid[0])\n        for i in range(m):\n            grid[i].insert(01)\n            grid[i].append(-1)\n        res=[]\n\n        for k in range(1n+1):\n            i  j = 0  k\n            struck = False\n            while i<m:\n                if grid[i][j]==1:\n                    if grid[i][j+1]==1:\n                        j+=1\n                    else:\n                        struck=True\n                        break\n                else:\n                    if grid[i][j-1]==-1:\n                        j-=1\n                    else:\n                        struck=True\n                        break\n                i+=1\n            if struck:\n                res.append(-1)\n            else:\n                res.append(j-1)\n\n        return res
Widest Vertical Area Between Two Points Containing No Points,###  1637\. Widest Vertical Area Between Two Points Containing No Points\n\nGiven `n` `points` on a 2D plane where `points[i] = [xi yi]` Return _  the\n**widest vertical area** between two points such that no points are inside the\narea._\n\nA **vertical area** is an area of fixed-width extending infinitely along the\ny-axis (i.e. infinite height). The **widest vertical area** is the one with\nthe maximum width.\n\nNote that points **on the edge** of a vertical area **are not** considered\nincluded in the area.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/09/19/points3.png)​\n\n    \n    \n    **Input:** points = [[87][99][74][97]]\n    **Output:** 1\n    **Explanation:** Both the red and the blue area are optimal.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** points = [[31][90][10][14][53][88]]\n    **Output:** 3\n    \n\n\n\n**Constraints:**\n\n  * `n == points.length`\n  * `2 <= n <= 105`\n  * `points[i].length == 2`\n  * `0 <= xi yi <= 109`\n\n,class Solution:\n    def maxWidthOfVerticalArea(self points: List[List[int]]) -> int:\n        # only taking x-axis point as it's relevant\n        arr = [i[0] for i in points]\n        \n        arr.sort()\n        \n        diff = -1\n        for i in range(1 len(arr)):\n            diff = max(diff arr[i] - arr[i - 1])\n        \n        return diff\n
Wiggle Sort II,###  324\. Wiggle Sort II\n\nGiven an integer array `nums` reorder it such that `nums[0] < nums[1] >\nnums[2] < nums[3]...`.\n\nYou may assume the input array always has a valid answer.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [151164]\n    **Output:** [161514]\n    **Explanation:** [141516] is also accepted.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [132231]\n    **Output:** [231312]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 5 * 104`\n  * `0 <= nums[i] <= 5000`\n  * It is guaranteed that there will be an answer for the given input `nums`.\n\n\n\n**Follow Up:** Can you do it in `O(n)` time and/or **in-place** with `O(1)`\nextra space?\n\n,"class Heap:\n	def __init__(self):\n		self.q = []\n	def push(selfdata):\n		i = len(self.q)\n		self.q.append(data)\n		while i>0:\n			if self.q[i] > self.q[(i-1)//2]:\n				self.q[i] self.q[(i-1)//2] = self.q[(i-1)//2] self.q[i]\n				i = (i-1)//2\n			else: return \n	def pop(self):\n		if len(self.q)==0:return\n		self.q[0] = self.q[-1]\n		self.q.pop()\n		def heapify(i):\n			ind = i\n			l = 2*i+1\n			r = 2*i+2\n			if r<len(self.q) and self.q[ind] < self.q[r]: ind = r\n			if l<len(self.q) and self.q[ind] < self.q[l]: ind = l            \n			if ind != i:\n				self.q[i] self.q[ind] = self.q[ind] self.q[i]\n				heapify(ind)\n		heapify(0)\n	def top(self):  \n		return self.q[0] \n\n\nclass Solution:\n	def wiggleSort(self nums: List[int]) -> None:\n		n = len(nums)\n		h = Heap()\n		for i in nums: h.push(i)\n		for i in range(1n2):\n			nums[i] = h.top()\n			h.pop()\n		for i in range(0n2):\n			nums[i] = h.top()\n			h.pop()"
Wiggle Subsequence,###  376\. Wiggle Subsequence\n\nA **wiggle sequence** is a sequence where the differences between successive\nnumbers strictly alternate between positive and negative. The first difference\n(if one exists) may be either positive or negative. A sequence with one\nelement and a sequence with two non-equal elements are trivially wiggle\nsequences.\n\n  * For example `[1 7 4 9 2 5]` is a **wiggle sequence** because the differences `(6 -3 5 -7 3)` alternate between positive and negative.\n  * In contrast `[1 4 7 2 5]` and `[1 7 4 5 5]` are not wiggle sequences. The first is not because its first two differences are positive and the second is not because its last difference is zero.\n\nA **subsequence** is obtained by deleting some elements (possibly zero) from\nthe original sequence leaving the remaining elements in their original order.\n\nGiven an integer array `nums` return _the length of the longest**wiggle\nsubsequence** of _`nums`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** nums = [174925]\n    **Output:** 6\n    **Explanation:** The entire sequence is a wiggle sequence with differences (6 -3 5 -7 3).\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** nums = [1175101315105168]\n    **Output:** 7\n    **Explanation:** There are several subsequences that achieve this length.\n    One is [1 17 10 13 10 16 8] with differences (16 -7 3 -3 6 -8).\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** nums = [123456789]\n    **Output:** 2\n    \n\n\n\n**Constraints:**\n\n  * `1 <= nums.length <= 1000`\n  * `0 <= nums[i] <= 1000`\n\n\n\n**Follow up:** Could you solve this in `O(n)` time?\n\n,# Runtime: 47 ms (Top 48.8%) | Memory: 16.22 MB (Top 87.1%)\n\n#####################################################################################################################\n# Problem:  Wiggle Subsequence\n# Solution : Dynamic Programming\n# Time Complexity : O(n) \n# Space Complexity : O(1)\n#####################################################################################################################\n\nclass Solution:\n    def wiggleMaxLength(self nums: List[int]) -> int:\n        \n        positive negative = 1 1\n        \n        if len(nums) < 2:\n            return len(nums)\n        \n        for i in range(1 len(nums)):\n            if nums[i] > nums[i - 1]:\n                positive = negative + 1\n            elif nums[i] < nums[i - 1]:\n                negative = positive + 1\n                \n        return max(positive negative)
Wildcard Matching,"###  44\. Wildcard Matching\n\nGiven an input string (`s`) and a pattern (`p`) implement wildcard pattern\nmatching with support for `'?'` and `'*'` where:\n\n  * `'?'` Matches any single character.\n  * `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""aa"" p = ""a""\n    **Output:** false\n    **Explanation:** ""a"" does not match the entire string ""aa"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""aa"" p = ""*""\n    **Output:** true\n    **Explanation:**  '*' matches any sequence.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""cb"" p = ""?a""\n    **Output:** false\n    **Explanation:**  '?' matches 'c' but the second letter is 'a' which does not match 'b'.\n    \n\n\n\n**Constraints:**\n\n  * `0 <= s.length p.length <= 2000`\n  * `s` contains only lowercase English letters.\n  * `p` contains only lowercase English letters `'?'` or `'*'`.\n\n","# Runtime: 1580 ms (Top 22.92%) | Memory: 22.4 MB (Top 66.92%)\nclass Solution:\n    def isMatch(self s: str p: str) -> bool:\n        m= len(s)\n        n= len(p)\n\n        dp = [[False]*(n+1) for i in range(m+1)]\n\n        dp[0][0] = True\n\n        for j in range(len(p)):\n            if p[j] == ""*"":\n                dp[0][j+1] = dp[0][j]\n\n        for i in range(1m+1):\n            for j in range(1n+1):\n                if p[j-1] == ""*"":\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\n\n                elif s[i-1] == p[j-1] or p[j-1] == ""?"":\n                    dp[i][j] = dp[i-1][j-1]\n\n        return dp[-1][-1]"
Word Break,"###  139\. Word Break\n\nGiven a string `s` and a dictionary of strings `wordDict` return `true` if\n`s` can be segmented into a space-separated sequence of one or more dictionary\nwords.\n\n**Note** that the same word in the dictionary may be reused multiple times in\nthe segmentation.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""leetcode"" wordDict = [""leet""""code""]\n    **Output:** true\n    **Explanation:** Return true because ""leetcode"" can be segmented as ""leet code"".\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""applepenapple"" wordDict = [""apple""""pen""]\n    **Output:** true\n    **Explanation:** Return true because ""applepenapple"" can be segmented as ""apple pen apple"".\n    Note that you are allowed to reuse a dictionary word.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""catsandog"" wordDict = [""cats""""dog""""sand""""and""""cat""]\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 300`\n  * `1 <= wordDict.length <= 1000`\n  * `1 <= wordDict[i].length <= 20`\n  * `s` and `wordDict[i]` consist of only lowercase English letters.\n  * All the strings of `wordDict` are **unique**.\n\n","class Solution:\n    def wordBreak(self s: str wordDict: List[str]) -> bool:\n        memo = {}\n\n\n        def can_construct(target strings_bank memo):    \n            if target in memo:\n                return memo[target]\n            if target == """":\n                return True\n            for element in strings_bank: # for every element in our dict we check if we can start constructing the string ""s""\n                if element == target[0:len(element)]: # the remaining of the string ""s"" (which is the suffix) is the new target \n                    suffix = target[len(element):]\n                    if can_construct(suffix strings_bank memo):\n                        memo[target] = True\n                        return True\n            memo[target] = False\n            return False\n\n\n        return can_construct(s wordDict memo)"
Word Break II,"###  140\. Word Break II\n\nGiven a string `s` and a dictionary of strings `wordDict` add spaces in `s`\nto construct a sentence where each word is a valid dictionary word. Return all\nsuch possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in\nthe segmentation.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""catsanddog"" wordDict = [""cat""""cats""""and""""sand""""dog""]\n    **Output:** [""cats and dog""""cat sand dog""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""pineapplepenapple"" wordDict = [""apple""""pen""""applepen""""pine""""pineapple""]\n    **Output:** [""pine apple pen apple""""pineapple pen apple""""pine applepen apple""]\n    **Explanation:** Note that you are allowed to reuse a dictionary word.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""catsandog"" wordDict = [""cats""""dog""""sand""""and""""cat""]\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 20`\n  * `1 <= wordDict.length <= 1000`\n  * `1 <= wordDict[i].length <= 10`\n  * `s` and `wordDict[i]` consist of only lowercase English letters.\n  * All the strings of `wordDict` are **unique**.\n\n","# Runtime: 56 ms (Top 49.21%) | Memory: 14 MB (Top 33.37%)\nclass Solution(object):\n    def wordBreak(self s wordDict):\n        """"""\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        """"""\n\n        dic = defaultdict(list)\n        for w in wordDict:\n            dic[w[0]].append(w)\n        result = []\n        def recursion(idx  ans):\n            if idx >= len(s):\n                result.append("" "".join(ans))\n                return\n\n            for w in dic[s[idx]]:\n                if s[idx : idx+len(w)] == w:\n                    ans.append(w)\n                    recursion(idx+len(w) ans)\n                    ans.pop()\n\n            return\n        recursion(0 [])\n        return result\n"
Word Ladder,"###  127\. Word Ladder\n\nA **transformation sequence** from word `beginWord` to word `endWord` using a\ndictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... ->\nsk` such that:\n\n  * Every adjacent pair of words differs by a single letter.\n  * Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n  * `sk == endWord`\n\nGiven two words `beginWord` and `endWord` and a dictionary `wordList`\nreturn _the**number of words** in the **shortest transformation sequence**\nfrom_ `beginWord` _to_ `endWord` _ or_`0` _if no such sequence exists._\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** beginWord = ""hit"" endWord = ""cog"" wordList = [""hot""""dot""""dog""""lot""""log""""cog""]\n    **Output:** 5\n    **Explanation:** One shortest transformation sequence is ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> cog"" which is 5 words long.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** beginWord = ""hit"" endWord = ""cog"" wordList = [""hot""""dot""""dog""""lot""""log""]\n    **Output:** 0\n    **Explanation:** The endWord ""cog"" is not in wordList therefore there is no valid transformation sequence.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= beginWord.length <= 10`\n  * `endWord.length == beginWord.length`\n  * `1 <= wordList.length <= 5000`\n  * `wordList[i].length == beginWord.length`\n  * `beginWord` `endWord` and `wordList[i]` consist of lowercase English letters.\n  * `beginWord != endWord`\n  * All the words in `wordList` are **unique**.\n\n","class Solution:\n    def ladderLength(self beginWord: str endWord: str wordList: List[str]) -> int:\n        e = defaultdict(list)\n        m = len(beginWord)\n        for word in wordList + [beginWord]:\n            for i in range(m):\n                w = word[:i] + ""*"" + word[i + 1:]\n                e[w].append(word)\n        q = deque([beginWord])\n        used = set([beginWord])\n        d = 0\n        while q:\n            d += 1\n            for _ in range(len(q)):\n                word = q.popleft()\n                for i in range(m):\n                    w = word[:i] + ""*"" + word[i + 1:]\n                    if w in e:\n                        for v in e[w]:\n                            if v == endWord:\n                                return d + 1\n                            if v not in used:\n                                q.append(v)\n                                used.add(v)\n                        e.pop(w)\n        return 0\n"
Word Ladder II,"###  126\. Word Ladder II\n\nA **transformation sequence** from word `beginWord` to word `endWord` using a\ndictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... ->\nsk` such that:\n\n  * Every adjacent pair of words differs by a single letter.\n  * Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n  * `sk == endWord`\n\nGiven two words `beginWord` and `endWord` and a dictionary `wordList`\nreturn _all the**shortest transformation sequences** from_ `beginWord` _to_\n`endWord` _ or an empty list if no such sequence exists. Each sequence should\nbe returned as a list of the words_`[beginWord s1 s2 ... sk]`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** beginWord = ""hit"" endWord = ""cog"" wordList = [""hot""""dot""""dog""""lot""""log""""cog""]\n    **Output:** [[""hit""""hot""""dot""""dog""""cog""][""hit""""hot""""lot""""log""""cog""]]\n    **Explanation:**  There are 2 shortest transformation sequences:\n    ""hit"" -> ""hot"" -> ""dot"" -> ""dog"" -> ""cog""\n    ""hit"" -> ""hot"" -> ""lot"" -> ""log"" -> ""cog""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** beginWord = ""hit"" endWord = ""cog"" wordList = [""hot""""dot""""dog""""lot""""log""]\n    **Output:** []\n    **Explanation:** The endWord ""cog"" is not in wordList therefore there is no valid transformation sequence.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= beginWord.length <= 5`\n  * `endWord.length == beginWord.length`\n  * `1 <= wordList.length <= 500`\n  * `wordList[i].length == beginWord.length`\n  * `beginWord` `endWord` and `wordList[i]` consist of lowercase English letters.\n  * `beginWord != endWord`\n  * All the words in `wordList` are **unique**.\n\n","# Runtime: 80 ms (Top 72.71%) | Memory: 14.5 MB (Top 54.17%)\nclass Solution:\n\n    WILDCARD = "".""\n\n    def findLadders(self beginWord: str endWord: str wordList: List[str]) -> List[List[str]]:\n        """"""\n        Given a wordlist we perform BFS traversal to generate a word tree where\n        every node points to its parent node.\n\n        Then we perform a DFS traversal on this tree starting at the endWord.\n        """"""\n        if endWord not in wordList:\n            # end word is unreachable\n            return []\n\n        # first generate a word tree from the wordlist\n        word_tree = self.getWordTree(beginWord endWord wordList)\n\n        # then generate a word ladder from the word tree\n        return self.getLadders(beginWord endWord word_tree)\n\n    def getWordTree(self\n                    beginWord: str\n                    endWord: str\n                    wordList: List[str]) -> Dict[str List[str]]:\n        """"""\n        BFS traversal from begin word until end word is encountered.\n\n        This functions constructs a tree in reverse starting at the endWord.\n        """"""\n        # Build an adjacency list using patterns as keys\n        # For example: "".it"" -> (""hit"") ""h.t"" -> (""hit"") ""hi."" -> (""hit"")\n        adjacency_list = defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + Solution.WILDCARD + word[i+1:]\n                adjacency_list[pattern].append(word)\n\n        # Holds the tree of words in reverse order\n        # The key is an encountered word.\n        # The value is a list of preceding words.\n        # For example we got to beginWord from no other nodes.\n        # {a: [bc]} means we got to ""a"" from ""b"" and ""c""\n        visited_tree = {beginWord: []}\n\n        # start off the traversal without finding the word\n        found = False\n\n        q = deque([beginWord])\n        while q and not found:\n            n = len(q)\n\n            # keep track of words visited at this level of BFS\n            visited_this_level = {}\n\n            for i in range(n):\n                word = q.popleft()\n\n                for i in range(len(word)):\n                    # for each pattern of the current word\n                    pattern = word[:i] + Solution.WILDCARD + word[i+1:]\n\n                    for next_word in adjacency_list[pattern]:\n                        if next_word == endWord:\n                            # we don't return immediately because other\n                            # sequences might reach the endWord in the same\n                            # BFS level\n                            found = True\n                        if next_word not in visited_tree:\n                            if next_word not in visited_this_level:\n                                visited_this_level[next_word] = [word]\n                                # queue up next word iff we haven't visited it yet\n                                # or already are planning to visit it\n                                q.append(next_word)\n                            else:\n                                visited_this_level[next_word].append(word)\n\n            # add all seen words at this level to the global visited tree\n            visited_tree.update(visited_this_level)\n\n        return visited_tree\n\n    def getLadders(self\n                   beginWord: str\n                   endWord: str\n                   wordTree: Dict[str List[str]]) -> List[List[str]]:\n        """"""\n        DFS traversal from endWord to beginWord in a given tree.\n        """"""\n        def dfs(node: str) -> List[List[str]]:\n            if node == beginWord:\n                return [[beginWord]]\n            if node not in wordTree:\n                return []\n\n            res = []\n            parents = wordTree[node]\n            for parent in parents:\n                res += dfs(parent)\n            for r in res:\n                r.append(node)\n            return res\n\n        return dfs(endWord)"
Word Pattern,"###  290\. Word Pattern\n\nGiven a `pattern` and a string `s` find if `s` follows the same pattern.\n\nHere **follow** means a full match such that there is a bijection between a\nletter in `pattern` and a **non-empty** word in `s`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** pattern = ""abba"" s = ""dog cat cat dog""\n    **Output:** true\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** pattern = ""abba"" s = ""dog cat cat fish""\n    **Output:** false\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** pattern = ""aaaa"" s = ""dog cat cat dog""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `1 <= pattern.length <= 300`\n  * `pattern` contains only lower-case English letters.\n  * `1 <= s.length <= 3000`\n  * `s` contains only lowercase English letters and spaces `' '`.\n  * `s` **does not contain** any leading or trailing spaces.\n  * All the words in `s` are separated by a **single space**.\n\n","class Solution(object):\n    def wordPattern(self pattern s):\n        """"""\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        """"""\n        p s = list(pattern) list(s.split("" ""))\n\n        return len(s) == len(p) and len(set(zip(p s))) == len(set(s)) == len(set(p))\n\n"
Word Search,"###  79\. Word Search\n\nGiven an `m x n` grid of characters `board` and a string `word` return `true`\n_if_ `word` _exists in the grid_.\n\nThe word can be constructed from letters of sequentially adjacent cells where\nadjacent cells are horizontally or vertically neighboring. The same letter\ncell may not be used more than once.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)\n\n    \n    \n    **Input:** board = [[""A""""B""""C""""E""][""S""""F""""C""""S""][""A""""D""""E""""E""]] word = ""ABCCED""\n    **Output:** true\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)\n\n    \n    \n    **Input:** board = [[""A""""B""""C""""E""][""S""""F""""C""""S""][""A""""D""""E""""E""]] word = ""SEE""\n    **Output:** true\n    \n\n**Example 3:**\n\n![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)\n\n    \n    \n    **Input:** board = [[""A""""B""""C""""E""][""S""""F""""C""""S""][""A""""D""""E""""E""]] word = ""ABCB""\n    **Output:** false\n    \n\n\n\n**Constraints:**\n\n  * `m == board.length`\n  * `n = board[i].length`\n  * `1 <= m n <= 6`\n  * `1 <= word.length <= 15`\n  * `board` and `word` consists of only lowercase and uppercase English letters.\n\n\n\n**Follow up:** Could you use search pruning to make your solution faster with\na larger `board`?\n\n",class Solution:\n    def exist(self board: List[List[str]] word: str) -> bool:\n        m = len(board)\n        n = len(board[0])\n        \n        marked = set() # visited by the dfs\n        def dfs(cell: Tuple[int int] wp: int) -> bool:\n            i = cell[0]\n            j = cell[1]\n            \n            if wp == len(word):\n                return True\n            \n            # Get appropriate neighbours and perform dfs on them\n            # When going on dfs we mark certain cells we should remove # \n            #them from the marked list after we return from the dfs\n            marked.add((ij))\n            neibs = [(i - 1 j) (i j - 1) (i + 1 j) (i j + 1)]\n            for x y in neibs:\n                if (\n                        x < 0 or y < 0 or\n                        x >= m or y >= n or\n                        (x y) in marked or\n                        board[x][y] != word[wp]\n                ):\n                    continue\n                \n                if dfs((xy) wp + 1):\n                    return True\n                \n            marked.remove((ij))\n            return False\n                \n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0]:\n                    if dfs((ij) 1):\n                        return True\n        \n        return False\n
Word Search II,"###  212\. Word Search II\n\nGiven an `m x n` `board` of characters and a list of strings `words` return\n_all words on the board_.\n\nEach word must be constructed from letters of sequentially adjacent cells\nwhere **adjacent cells** are horizontally or vertically neighboring. The same\nletter cell may not be used more than once in a word.\n\n\n\n**Example 1:**\n\n![](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)\n\n    \n    \n    **Input:** board = [[""o""""a""""a""""n""][""e""""t""""a""""e""][""i""""h""""k""""r""][""i""""f""""l""""v""]] words = [""oath""""pea""""eat""""rain""]\n    **Output:** [""eat""""oath""]\n    \n\n**Example 2:**\n\n![](https://assets.leetcode.com/uploads/2020/11/07/search2.jpg)\n\n    \n    \n    **Input:** board = [[""a""""b""][""c""""d""]] words = [""abcb""]\n    **Output:** []\n    \n\n\n\n**Constraints:**\n\n  * `m == board.length`\n  * `n == board[i].length`\n  * `1 <= m n <= 12`\n  * `board[i][j]` is a lowercase English letter.\n  * `1 <= words.length <= 3 * 104`\n  * `1 <= words[i].length <= 10`\n  * `words[i]` consists of lowercase English letters.\n  * All the strings of `words` are unique.\n\n","class Solution:\n    def findWords(self board: List[List[str]] words: List[str]) -> List[str]:\n        solution = set()\n        trie = self.make_trie(words)\n        visited = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                self.dfs(ijboardtrievisited""""solution)\n        return solution\n    \n    def dfs(selfijboardtrievisitedwordsolution):\n        if ""*"" in trie:\n            if len(trie.keys()) == 0:\n                return\n            else:\n                solution.add(word)\n                del trie[""*""]\n        if (ij) in visited:\n            return\n        if (i < 0 or i == len(board) or j < 0 or j == len(board[0])):\n            return\n        if board[i][j] not in trie:\n            return\n        if len(trie[board[i][j]]) == 0:\n            del trie[board[i][j]]\n            return\n        visited.add((ij))\n        neighbours = [(ij-1)(i-1j)(ij+1)(i+1j)]\n        for n_xn_y in neighbours:\n            self.dfs(n_xn_yboardtrie[board[i][j]]visitedword+board[i][j]solution)    \n        visited.remove((ij))\n        \n    def make_trie(selfwords):\n        trie = {}\n        for word in words:\n            current = trie\n            for char in word:\n                if char not in current:\n                    current[char] = {}\n                current = current[char]\n            current[""*""] = ""*""\n        return trie\n\n"
Word Subsets,"###  916\. Word Subsets\n\nYou are given two string arrays `words1` and `words2`.\n\nA string `b` is a **subset** of string `a` if every letter in `b` occurs in\n`a` including multiplicity.\n\n  * For example `""wrr""` is a subset of `""warrior""` but is not a subset of `""world""`.\n\nA string `a` from `words1` is **universal** if for every string `b` in\n`words2` `b` is a subset of `a`.\n\nReturn an array of all the **universal** strings in `words1`. You may return\nthe answer in **any order**.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** words1 = [""amazon""""apple""""facebook""""google""""leetcode""] words2 = [""e""""o""]\n    **Output:** [""facebook""""google""""leetcode""]\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** words1 = [""amazon""""apple""""facebook""""google""""leetcode""] words2 = [""l""""e""]\n    **Output:** [""apple""""google""""leetcode""]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= words1.length words2.length <= 104`\n  * `1 <= words1[i].length words2[i].length <= 10`\n  * `words1[i]` and `words2[i]` consist only of lowercase English letters.\n  * All the strings of `words1` are **unique**.\n\n",class Solution:\n    def wordSubsets(self A: List[str] B: List[str]) -> List[str]:\n        freq = [0]*26 \n        \n        for w in B: \n            temp = [0]*26\n            for c in w: temp[ord(c)-97] += 1\n            for i in range(26): freq[i] = max(freq[i] temp[i])\n                \n        ans = []\n        for w in A: \n            temp = [0]*26\n            for c in w: temp[ord(c)-97] += 1\n            if all(freq[i] <= temp[i] for i in range(26)): ans.append(w)\n        return ans 
XOR Operation in an Array,"###  1486\. XOR Operation in an Array\n\nYou are given an integer `n` and an integer `start`.\n\nDefine an array `nums` where `nums[i] = start + 2 * i` (**0-indexed**) and `n\n== nums.length`.\n\nReturn _the bitwise XOR of all elements of_ `nums`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** n = 5 start = 0\n    **Output:** 8\n    **Explanation:** Array nums is equal to [0 2 4 6 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\n    Where ""^"" corresponds to bitwise XOR operator.\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** n = 4 start = 3\n    **Output:** 8\n    **Explanation:** Array nums is equal to [3 5 7 9] where (3 ^ 5 ^ 7 ^ 9) = 8.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= n <= 1000`\n  * `0 <= start <= 1000`\n  * `n == nums.length`\n\n",class Solution:\n    def xorOperation(self n: int start: int) -> int:\n        nums = [start + 2*i for i in range(n)] #generate list of numbers\n        ans = nums[0]\n        for i in range(1n):\n            ans = ans^nums[i] # XOR operation\n        return ans\n        \n        \n
XOR Queries of a Subarray,###  1310\. XOR Queries of a Subarray\n\nYou are given an array `arr` of positive integers. You are also given the\narray `queries` where `queries[i] = [lefti righti]`.\n\nFor each query `i` compute the **XOR** of elements from `lefti` to `righti`\n(that is `arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti]` ).\n\nReturn an array `answer` where `answer[i]` is the answer to the `ith` query.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** arr = [1348] queries = [[01][12][03][33]]\n    **Output:** [27148] \n    **Explanation:** \n    The binary representation of the elements in the array are:\n    1 = 0001 \n    3 = 0011 \n    4 = 0100 \n    8 = 1000 \n    The XOR values for queries are:\n    [01] = 1 xor 3 = 2 \n    [12] = 3 xor 4 = 7 \n    [03] = 1 xor 3 xor 4 xor 8 = 14 \n    [33] = 8\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** arr = [48210] queries = [[23][13][00][03]]\n    **Output:** [8044]\n    \n\n\n\n**Constraints:**\n\n  * `1 <= arr.length queries.length <= 3 * 104`\n  * `1 <= arr[i] <= 109`\n  * `queries[i].length == 2`\n  * `0 <= lefti <= righti < arr.length`\n\n,"class Solution:\n    def xorQueries(self arr: List[int] queries: List[List[int]]) -> List[int]:\n\n\n       """"""\n\n       arr = [1348] queries = [[01][12][03][33]]\n\n       find pref xor of arr\n\n       pref = [xxxx]\n\n       for each query find the left and right indices\n       the xor for range (l r) would be pref[r] xor pref[l-1]\n       \n       """"""     \n       n m = len(queries) len(arr)\n\n       answer = [1]*n\n\n       pref = [1]*m\n       pref[0] = arr[0]\n       if m > 1:\n           for i in range(1m):\n               pref[i] = pref[i-1] ^ arr[i]\n\n       for (i (lr)) in enumerate(queries):\n           if l == 0: answer[i] = pref[r]          \n           else: answer[i] = pref[r] ^ pref[l-1]\n\n       return answer"
Zigzag Conversion,"###  6\. Zigzag Conversion\n\nThe string `""PAYPALISHIRING""` is written in a zigzag pattern on a given number\nof rows like this: (you may want to display this pattern in a fixed font for\nbetter legibility)\n\n    \n    \n    P   A   H   N\n    A P L S I I G\n    Y   I   R\n    \n\nAnd then read line by line: `""PAHNAPLSIIGYIR""`\n\nWrite the code that will take a string and make this conversion given a number\nof rows:\n\n    \n    \n    string convert(string s int numRows);\n    \n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** s = ""PAYPALISHIRING"" numRows = 3\n    **Output:** ""PAHNAPLSIIGYIR""\n    \n\n**Example 2:**\n\n    \n    \n    **Input:** s = ""PAYPALISHIRING"" numRows = 4\n    **Output:** ""PINALSIGYAHRPI""\n    **Explanation:**\n    P     I    N\n    A   L S  I G\n    Y A   H R\n    P     I\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** s = ""A"" numRows = 1\n    **Output:** ""A""\n    \n\n\n\n**Constraints:**\n\n  * `1 <= s.length <= 1000`\n  * `s` consists of English letters (lower-case and upper-case) `''` and `'.'`.\n  * `1 <= numRows <= 1000`\n\n","# Runtime: 96 ms (Top 61.23%) | Memory: 14 MB (Top 75.15%)\nclass Solution:\n    def convert(self s: str numRows: int) -> str:\n\n        # safety check to not process single row\n        if numRows == 1:\n            return s\n\n        # safety check to not process strings shorter/equal than numRows\n        if len(s) <= numRows:\n            return s\n\n        # safety check to not process double rows\n        if numRows == 2:\n            # slice every other character\n            return s[0::2] + s[1::2]\n\n        # list that stores the lines\n        # add lines with initial letters\n        lines: list[str] = [letter for letter in s[:numRows]]\n\n        # positive direction goes down\n        # lines are created so it's going up\n        direction: int = -1\n\n        # track the position at which the letter will be added\n        # position after bouncing off after adding initial lines\n        line_index: int = numRows - 2\n\n        # edge indexes\n        # 0 can only be reached by going up\n        # numRows only by going down\n        edges: set[int] = {0 numRows}\n\n        for letter in s[numRows:]:\n            # add letter at tracked index position\n            lines[line_index] += letter\n\n            # prepare index before next loop iteration\n            line_index += direction\n\n            # reaching one of the edges\n            if line_index in edges:\n                # change direction\n                direction = -direction\n                # bounce off if bottom edge\n                if line_index == numRows:\n                    line_index += direction * 2\n\n        return """".join(lines)"
Zuma Game,"###  488\. Zuma Game\n\nYou are playing a variation of the game Zuma.\n\nIn this variation of Zuma there is a **single row** of colored balls on a\nboard where each ball can be colored red `'R'` yellow `'Y'` blue `'B'`\ngreen `'G'` or white `'W'`. You also have several colored balls in your hand.\n\nYour goal is to **clear all** of the balls from the board. On each turn:\n\n  * Pick **any** ball from your hand and insert it in between two balls in the row or on either end of the row.\n  * If there is a group of **three or more consecutive balls** of the **same color**  remove the group of balls from the board. \n    * If this removal causes more groups of three or more of the same color to form then continue removing each group until there are none left.\n  * If there are no more balls on the board then you win the game.\n  * Repeat this process until you either win or do not have any more balls in your hand.\n\nGiven a string `board` representing the row of balls on the board and a\nstring `hand` representing the balls in your hand return _the**minimum**\nnumber of balls you have to insert to clear all the balls from the board. If\nyou cannot clear all the balls from the board using the balls in your hand\nreturn _`-1`.\n\n\n\n**Example 1:**\n\n    \n    \n    **Input:** board = ""WRRBBW"" hand = ""RB""\n    **Output:** -1\n    **Explanation:** It is impossible to clear all the balls. The best you can do is:\n    - Insert 'R' so the board becomes WRR _R_ BBW. W _RRR_ BBW -> WBBW.\n    - Insert 'B' so the board becomes WBB _B_ W. W _BBB_ W -> WW.\n    There are still balls remaining on the board and you are out of balls to insert.\n\n**Example 2:**\n\n    \n    \n    **Input:** board = ""WWRRBBWW"" hand = ""WRBRW""\n    **Output:** 2\n    **Explanation:** To make the board empty:\n    - Insert 'R' so the board becomes WWRR _R_ BBWW. WW _RRR_ BBWW -> WWBBWW.\n    - Insert 'B' so the board becomes WWBB _B_ WW. WW _BBB_ WW -> _WWWW_ -> empty.\n    2 balls from your hand were needed to clear the board.\n    \n\n**Example 3:**\n\n    \n    \n    **Input:** board = ""G"" hand = ""GGGGG""\n    **Output:** 2\n    **Explanation:** To make the board empty:\n    - Insert 'G' so the board becomes G _G_.\n    - Insert 'G' so the board becomes GG _G_. _GGG_ -> empty.\n    2 balls from your hand were needed to clear the board.\n    \n\n\n\n**Constraints:**\n\n  * `1 <= board.length <= 16`\n  * `1 <= hand.length <= 5`\n  * `board` and `hand` consist of the characters `'R'` `'Y'` `'B'` `'G'` and `'W'`.\n  * The initial row of balls on the board will **not** have any groups of three or more consecutive balls of the same color.\n\n","class Solution:\n    def findMinStep(self board: str hand: str) -> int:\n        \n        # start from i and remove continues ball\n        def remove_same(s i):\n            if i < 0:\n                return s\n            \n            left = right = i\n            while left > 0 and s[left-1] == s[i]:\n                left -= 1\n            while right+1 < len(s) and s[right+1] == s[i]:\n                right += 1\n            \n            length = right - left + 1\n            if length >= 3:\n                new_s = s[:left] + s[right+1:]\n                return remove_same(new_s left-1)\n            else:\n                return s\n\n\n\n        hand = """".join(sorted(hand))\n\n        # board hand and step\n        q = collections.deque([(board hand 0)])\n        visited = set([(board hand)])\n\n        while q:\n            curr_board curr_hand step = q.popleft()\n            for i in range(len(curr_board)+1):\n                for j in range(len(curr_hand)):\n                    # skip the continue balls in hand\n                    if j > 0 and curr_hand[j] == curr_hand[j-1]:\n                        continue\n                    \n                    # only insert at the begin of continue balls in board\n                    if i > 0 and curr_board[i-1] == curr_hand[j]: # left side same color\n                        continue\n                    \n                    pick = False\n                    # 1. same color with right\n                    # 2. left and right are same but pick is different\n                    if i < len(curr_board) and curr_board[i] == curr_hand[j]:\n                        pick = True\n                    if 0<i<len(curr_board) and curr_board[i-1] == curr_board[i] and curr_board[i] != curr_hand[j]:\n                        pick = True\n                    \n                    if pick:\n                        new_board = remove_same(curr_board[:i] + curr_hand[j] + curr_board[i:] i)\n                        new_hand = curr_hand[:j] + curr_hand[j+1:]\n                        if not new_board:\n                            return step + 1\n                        if (new_board new_hand) not in visited:\n                            q.append((new_board new_hand step+1))\n                            visited.add((new_board new_hand))\n\n        return -1\n"
